import { vec2, vec3 } from 'gl-matrix';
import { getEnabledElement, utilities as csUtils, getRenderingEngine, } from '@cornerstonejs/core';
import { drawCircle as drawCircleSvg } from '../../drawingSvg';
import { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';
import { Events } from '../../enums';
import triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';
import { growCut } from '../../utilities/segmentation';
import GrowCutBaseTool from '../base/GrowCutBaseTool';
class RegionSegmentTool extends GrowCutBaseTool {
    static { this.toolName = 'RegionSegment'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            isPartialVolume: true,
            positiveSeedVariance: 0.5,
            negativeSeedVariance: 0.9,
        },
    }) {
        super(toolProps, defaultToolProps);
        this._dragCallback = (evt) => {
            const eventData = evt.detail;
            const { element, currentPoints } = eventData;
            const { world: currentWorldPoint } = currentPoints;
            const enabledElement = getEnabledElement(element);
            const { viewport } = enabledElement;
            this.growCutData.circleBorderPoint = currentWorldPoint;
            triggerAnnotationRenderForViewportUIDs([viewport.id]);
        };
        this._endCallback = async (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const enabledElement = getEnabledElement(element);
            const { viewport } = enabledElement;
            this.runGrowCut();
            this._deactivateDraw(element);
            this.growCutData = null;
            resetElementCursor(element);
            triggerAnnotationRenderForViewportUIDs([viewport.id]);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);
        };
    }
    async preMouseDownCallback(evt) {
        const eventData = evt.detail;
        const { element, currentPoints } = eventData;
        const { world: worldPoint } = currentPoints;
        const enabledElement = getEnabledElement(element);
        const { viewport, renderingEngine } = enabledElement;
        await super.preMouseDownCallback(evt);
        Object.assign(this.growCutData, {
            circleCenterPoint: worldPoint,
            circleBorderPoint: worldPoint,
        });
        this._activateDraw(element);
        hideElementCursor(element);
        triggerAnnotationRenderForViewportUIDs([viewport.id]);
        return true;
    }
    async getGrowCutLabelmap(growCutData) {
        const { segmentation: { referencedVolumeId }, renderingEngineId, viewportId, circleCenterPoint, circleBorderPoint, options, } = growCutData;
        const renderingEngine = getRenderingEngine(renderingEngineId);
        const viewport = renderingEngine.getViewport(viewportId);
        const worldCircleRadius = vec3.len(vec3.sub(vec3.create(), circleCenterPoint, circleBorderPoint));
        const sphereInfo = {
            center: circleCenterPoint,
            radius: worldCircleRadius,
        };
        return growCut.runGrowCutForSphere(referencedVolumeId, sphereInfo, viewport, options);
    }
    _activateDraw(element) {
        element.addEventListener(Events.MOUSE_UP, this._endCallback);
        element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);
        element.addEventListener(Events.MOUSE_CLICK, this._endCallback);
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        if (!this.growCutData) {
            return;
        }
        const { viewport } = enabledElement;
        const { segmentation: segmentationData, circleCenterPoint, circleBorderPoint, } = this.growCutData;
        const canvasCenterPoint = viewport.worldToCanvas(circleCenterPoint);
        const canvasBorderPoint = viewport.worldToCanvas(circleBorderPoint);
        const vecCenterToBorder = vec2.sub(vec2.create(), canvasBorderPoint, canvasCenterPoint);
        const circleRadius = vec2.len(vecCenterToBorder);
        if (csUtils.isEqual(circleRadius, 0)) {
            return;
        }
        const annotationUID = 'growcut';
        const circleUID = '0';
        const { color } = this.getSegmentStyle({
            segmentationId: segmentationData.segmentationId,
            segmentIndex: segmentationData.segmentIndex,
            viewportId: viewport.id,
        });
        drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, canvasCenterPoint, circleRadius, {
            color,
        });
    }
}
export default RegionSegmentTool;
