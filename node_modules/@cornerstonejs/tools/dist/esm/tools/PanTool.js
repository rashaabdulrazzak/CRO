import { BaseTool } from './base';
import { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';
class PanTool extends BaseTool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            limitToViewport: false,
        },
    }) {
        super(toolProps, defaultToolProps);
    }
    touchDragCallback(evt) {
        this._dragCallback(evt);
    }
    mouseDragCallback(evt) {
        this._dragCallback(evt);
    }
    _checkImageInViewport(viewport, deltaPointsCanvas) {
        const { canvas } = viewport;
        const ratio = window.devicePixelRatio;
        const viewportLeft = 0;
        const viewportRight = canvas.width / ratio;
        const viewportTop = 0;
        const viewportBottom = canvas.height / ratio;
        const defaultActor = viewport.getDefaultActor();
        const renderer = viewport.getRenderer();
        let bounds;
        if (defaultActor && csUtils.isImageActor(defaultActor)) {
            const imageData = defaultActor.actor.getMapper().getInputData();
            bounds = imageData.getBounds();
        }
        else {
            bounds = renderer.computeVisiblePropBounds();
        }
        const [imageLeft, imageTop] = viewport.worldToCanvas([
            bounds[0],
            bounds[2],
            bounds[4],
        ]);
        const [imageRight, imageBottom] = viewport.worldToCanvas([
            bounds[1],
            bounds[3],
            bounds[5],
        ]);
        const zoom = viewport.getZoom();
        if (zoom <= 1) {
            if ((imageLeft + deltaPointsCanvas[0] < viewportLeft &&
                deltaPointsCanvas[0] < 0) ||
                (imageRight + deltaPointsCanvas[0] > viewportRight &&
                    deltaPointsCanvas[0] > 0) ||
                (imageTop + deltaPointsCanvas[1] < viewportTop &&
                    deltaPointsCanvas[1] < 0) ||
                (imageBottom + deltaPointsCanvas[1] > viewportBottom &&
                    deltaPointsCanvas[1] > 0)) {
                return false;
            }
        }
        else {
            if ((imageLeft + deltaPointsCanvas[0] > viewportLeft &&
                deltaPointsCanvas[0] > 0) ||
                (imageRight + deltaPointsCanvas[0] < viewportRight &&
                    deltaPointsCanvas[0] < 0) ||
                (imageTop + deltaPointsCanvas[1] > viewportTop &&
                    deltaPointsCanvas[1] > 0) ||
                (imageBottom + deltaPointsCanvas[1] < viewportBottom &&
                    deltaPointsCanvas[1] < 0)) {
                return false;
            }
        }
        return true;
    }
    _dragCallback(evt) {
        const { element, deltaPoints } = evt.detail;
        const enabledElement = getEnabledElement(element);
        const deltaPointsWorld = deltaPoints.world;
        const deltaPointsCanvas = deltaPoints.canvas;
        if (deltaPointsWorld[0] === 0 &&
            deltaPointsWorld[1] === 0 &&
            deltaPointsWorld[2] === 0) {
            return;
        }
        const viewport = enabledElement.viewport;
        const camera = viewport.getCamera();
        const { focalPoint, position } = camera;
        if (this.configuration.limitToViewport &&
            !this._checkImageInViewport(viewport, deltaPointsCanvas)) {
            return;
        }
        const updatedPosition = [
            position[0] - deltaPointsWorld[0],
            position[1] - deltaPointsWorld[1],
            position[2] - deltaPointsWorld[2],
        ];
        const updatedFocalPoint = [
            focalPoint[0] - deltaPointsWorld[0],
            focalPoint[1] - deltaPointsWorld[1],
            focalPoint[2] - deltaPointsWorld[2],
        ];
        viewport.setCamera({
            focalPoint: updatedFocalPoint,
            position: updatedPosition,
        });
        viewport.render();
    }
}
PanTool.toolName = 'Pan';
export default PanTool;
