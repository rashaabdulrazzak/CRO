import { vec3 } from 'gl-matrix';
import StrategyCallbacks from '../../../../enums/StrategyCallbacks';
export default {
    [StrategyCallbacks.Initialize]: (operationData) => {
        const { operationName, centerIJK, segmentationVoxelManager, imageVoxelManager, configuration, segmentIndex, viewport, } = operationData;
        if (!configuration?.threshold?.isDynamic || !centerIJK || !segmentIndex) {
            return;
        }
        if (operationName === StrategyCallbacks.RejectPreview ||
            operationName === StrategyCallbacks.OnInteractionEnd) {
            return;
        }
        const boundsIJK = segmentationVoxelManager.getBoundsIJK();
        const { range: oldThreshold, dynamicRadius = 0 } = configuration.threshold;
        const useDelta = oldThreshold ? 0 : dynamicRadius;
        const { viewPlaneNormal } = viewport.getCamera();
        const nestedBounds = boundsIJK.map((ijk, idx) => {
            const [min, max] = ijk;
            return [
                Math.max(min, centerIJK[idx] - useDelta),
                Math.min(max, centerIJK[idx] + useDelta),
            ];
        });
        if (Math.abs(viewPlaneNormal[0]) > 0.8) {
            nestedBounds[0] = [centerIJK[0], centerIJK[0]];
        }
        else if (Math.abs(viewPlaneNormal[1]) > 0.8) {
            nestedBounds[1] = [centerIJK[1], centerIJK[1]];
        }
        else if (Math.abs(viewPlaneNormal[2]) > 0.8) {
            nestedBounds[2] = [centerIJK[2], centerIJK[2]];
        }
        const threshold = oldThreshold || [Infinity, -Infinity];
        const useDeltaSqr = useDelta * useDelta;
        const callback = ({ value, pointIJK }) => {
            const distance = vec3.sqrDist(centerIJK, pointIJK);
            if (distance > useDeltaSqr) {
                return;
            }
            const gray = Array.isArray(value) ? vec3.len(value) : value;
            threshold[0] = Math.min(gray, threshold[0]);
            threshold[1] = Math.max(gray, threshold[1]);
        };
        imageVoxelManager.forEach(callback, { boundsIJK: nestedBounds });
        configuration.threshold.range = threshold;
    },
    [StrategyCallbacks.OnInteractionStart]: (operationData) => {
        const { configuration } = operationData;
        if (!configuration?.threshold?.isDynamic) {
            return;
        }
        configuration.threshold.range = null;
    },
    [StrategyCallbacks.ComputeInnerCircleRadius]: (operationData) => {
        const { configuration, viewport } = operationData;
        const { dynamicRadius = 0, isDynamic } = configuration.threshold;
        if (!isDynamic) {
            configuration.threshold.dynamicRadiusInCanvas = 0;
            return;
        }
        if (dynamicRadius === 0) {
            return;
        }
        const imageData = viewport.getImageData();
        if (!imageData) {
            return;
        }
        const { spacing } = imageData;
        const centerCanvas = [
            viewport.element.clientWidth / 2,
            viewport.element.clientHeight / 2,
        ];
        const radiusInWorld = dynamicRadius * spacing[0];
        const centerCursorInWorld = viewport.canvasToWorld(centerCanvas);
        const offSetCenterInWorld = centerCursorInWorld.map((coord) => coord + radiusInWorld);
        const offSetCenterCanvas = viewport.worldToCanvas(offSetCenterInWorld);
        const dynamicRadiusInCanvas = Math.abs(centerCanvas[0] - offSetCenterCanvas[0]);
        if (!configuration.threshold.dynamicRadiusInCanvas) {
            configuration.threshold.dynamicRadiusInCanvas = 0;
        }
        configuration.threshold.dynamicRadiusInCanvas = 3 + dynamicRadiusInCanvas;
    },
};
