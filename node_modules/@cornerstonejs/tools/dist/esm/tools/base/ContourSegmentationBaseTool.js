import { getEnabledElement, utilities } from '@cornerstonejs/core';
import { SegmentationRepresentations } from '../../enums';
import ContourBaseTool from './ContourBaseTool';
import { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';
import InterpolationManager from '../../utilities/segmentation/InterpolationManager/InterpolationManager';
import { addContourSegmentationAnnotation, removeContourSegmentationAnnotation, } from '../../utilities/contourSegmentation';
import { triggerAnnotationRenderForToolGroupIds } from '../../utilities/triggerAnnotationRenderForToolGroupIds';
import { getToolGroupForViewport } from '../../store/ToolGroupManager';
import { getSegmentationRepresentations } from '../../stateManagement/segmentation/getSegmentationRepresentation';
import { getActiveSegmentation } from '../../stateManagement/segmentation/getActiveSegmentation';
import { getViewportIdsWithSegmentation } from '../../stateManagement/segmentation/getViewportIdsWithSegmentation';
import { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';
import { getLockedSegmentIndices } from '../../stateManagement/segmentation/segmentLocking';
import { getSVGStyleForSegment } from '../../utilities/segmentation/getSVGStyleForSegment';
class ContourSegmentationBaseTool extends ContourBaseTool {
    static { this.PreviewSegmentIndex = 255; }
    constructor(toolProps, defaultToolProps) {
        super(toolProps, defaultToolProps);
        if (this.configuration.interpolation?.enabled) {
            InterpolationManager.addTool(this.getToolName());
        }
    }
    onSetToolConfiguration() {
        if (this.configuration.interpolation?.enabled) {
            InterpolationManager.addTool(this.getToolName());
        }
        else {
            InterpolationManager.removeTool(this.getToolName());
        }
    }
    isContourSegmentationTool() {
        return true;
    }
    createAnnotation(evt) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const enabledElement = getEnabledElement(element);
        if (!enabledElement) {
            return;
        }
        const { viewport } = enabledElement;
        const contourAnnotation = super.createAnnotation(evt);
        if (!this.isContourSegmentationTool()) {
            return contourAnnotation;
        }
        const activeSeg = getActiveSegmentation(viewport.id);
        if (!activeSeg) {
            throw new Error('No active segmentation detected, create one before using scissors tool');
        }
        if (!activeSeg.representationData.Contour) {
            throw new Error(`A contour segmentation must be active`);
        }
        const { segmentationId } = activeSeg;
        const segmentIndex = getActiveSegmentIndex(segmentationId);
        return utilities.deepMerge(contourAnnotation, {
            data: {
                segmentation: {
                    segmentationId,
                    segmentIndex,
                },
            },
        });
    }
    addAnnotation(annotation, element) {
        const annotationUID = super.addAnnotation(annotation, element);
        if (this.isContourSegmentationTool()) {
            const contourSegAnnotation = annotation;
            addContourSegmentationAnnotation(contourSegAnnotation);
        }
        return annotationUID;
    }
    cancelAnnotation(annotation) {
        if (this.isContourSegmentationTool()) {
            removeContourSegmentationAnnotation(annotation);
        }
        super.cancelAnnotation(annotation);
    }
    getAnnotationStyle(context) {
        const annotationStyle = super.getAnnotationStyle(context);
        if (!this.isContourSegmentationTool()) {
            return annotationStyle;
        }
        const contourSegmentationStyle = this._getContourSegmentationStyle(context);
        return utilities.deepMerge(annotationStyle, contourSegmentationStyle);
    }
    renderAnnotationInstance(renderContext) {
        const { annotation } = renderContext;
        const { invalidated } = annotation;
        const renderResult = super.renderAnnotationInstance(renderContext);
        if (invalidated && this.isContourSegmentationTool()) {
            const { segmentationId } = (annotation).data.segmentation;
            triggerSegmentationDataModified(segmentationId);
            const viewportIds = getViewportIdsWithSegmentation(segmentationId);
            const toolGroupIds = viewportIds.map((viewportId) => {
                const toolGroup = getToolGroupForViewport(viewportId);
                return toolGroup.id;
            });
            triggerAnnotationRenderForToolGroupIds(toolGroupIds);
        }
        return renderResult;
    }
    _getContourSegmentationStyle(context) {
        const annotation = context.annotation;
        const { segmentationId, segmentIndex } = annotation.data.segmentation;
        const { viewportId } = context.styleSpecifier;
        const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });
        if (!segmentationRepresentations?.length) {
            return {};
        }
        let segmentationRepresentation;
        if (segmentationRepresentations.length > 1) {
            segmentationRepresentation = segmentationRepresentations.find((rep) => rep.segmentationId === segmentationId &&
                rep.type === SegmentationRepresentations.Contour);
        }
        else {
            segmentationRepresentation = segmentationRepresentations[0];
        }
        const { autoGenerated } = annotation;
        const segmentsLocked = getLockedSegmentIndices(segmentationId);
        const annotationLocked = segmentsLocked.includes(segmentIndex);
        const { color, fillColor, lineWidth, fillOpacity, lineDash, visibility } = getSVGStyleForSegment({
            segmentationId,
            segmentIndex,
            viewportId,
            autoGenerated,
        });
        return {
            color,
            fillColor,
            lineWidth,
            fillOpacity,
            lineDash,
            textbox: {
                color,
            },
            visibility,
            locked: annotationLocked,
        };
    }
}
export { ContourSegmentationBaseTool as default, ContourSegmentationBaseTool };
