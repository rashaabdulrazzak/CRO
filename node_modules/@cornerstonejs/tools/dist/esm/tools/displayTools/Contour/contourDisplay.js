import { cache, getEnabledElementByViewportId, Enums, utilities, } from '@cornerstonejs/core';
import Representations from '../../../enums/SegmentationRepresentations';
import { handleContourSegmentation } from './contourHandler/handleContourSegmentation';
import { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';
import removeContourFromElement from './removeContourFromElement';
import { getPolySeg } from '../../../config';
import { computeAndAddRepresentation } from '../../../utilities/segmentation/computeAndAddRepresentation';
import { getUniqueSegmentIndices } from '../../../utilities/segmentation/getUniqueSegmentIndices';
import { getAnnotation } from '../../../stateManagement/annotation/annotationState';
import { vec3 } from 'gl-matrix';
const polySegConversionInProgressForViewportId = new Map();
const processedViewportSegmentations = new Map();
function removeRepresentation(viewportId, segmentationId, renderImmediate = false) {
    const enabledElement = getEnabledElementByViewportId(viewportId);
    if (!enabledElement) {
        return;
    }
    const { viewport } = enabledElement;
    removeContourFromElement(viewportId, segmentationId);
    if (!renderImmediate) {
        return;
    }
    viewport.render();
}
async function render(viewport, contourRepresentation) {
    const { segmentationId } = contourRepresentation;
    const segmentation = getSegmentation(segmentationId);
    if (!segmentation) {
        return;
    }
    let contourData = segmentation.representationData[Representations.Contour];
    const polySeg = getPolySeg();
    if (!contourData &&
        getPolySeg()?.canComputeRequestedRepresentation(segmentationId, Representations.Contour) &&
        !polySegConversionInProgressForViewportId.get(viewport.id)) {
        polySegConversionInProgressForViewportId.set(viewport.id, true);
        contourData = await computeAndAddRepresentation(segmentationId, Representations.Contour, () => polySeg.computeContourData(segmentationId, { viewport }), () => undefined);
        polySegConversionInProgressForViewportId.set(viewport.id, false);
    }
    else if (!contourData && !getPolySeg()) {
        console.debug(`No contour data found for segmentationId ${segmentationId} and PolySeg add-on is not configured. Unable to convert from other representations to contour. Please register PolySeg using cornerstoneTools.init({ addons: { polySeg } }) to enable automatic conversion.`);
    }
    if (!contourData) {
        return;
    }
    if (!contourData.geometryIds?.length) {
        return;
    }
    let hasContourDataButNotMatchingViewport = false;
    const viewportNormal = viewport.getCamera().viewPlaneNormal;
    if (contourData.annotationUIDsMap) {
        hasContourDataButNotMatchingViewport = !_checkContourNormalsMatchViewport(contourData.annotationUIDsMap, viewportNormal);
    }
    if (contourData.geometryIds.length > 0) {
        hasContourDataButNotMatchingViewport = !_checkContourGeometryMatchViewport(contourData.geometryIds, viewportNormal);
    }
    const viewportProcessed = processedViewportSegmentations.get(viewport.id) || new Set();
    if (hasContourDataButNotMatchingViewport &&
        !polySegConversionInProgressForViewportId.get(viewport.id) &&
        !viewportProcessed.has(segmentationId) &&
        viewport.viewportStatus === Enums.ViewportStatus.RENDERED) {
        polySegConversionInProgressForViewportId.set(viewport.id, true);
        const segmentIndices = getUniqueSegmentIndices(segmentationId);
        const surfacesInfo = await polySeg.computeSurfaceData(segmentationId, {
            segmentIndices,
            viewport,
        });
        const geometryIds = surfacesInfo.geometryIds;
        const pointsAndPolys = [];
        for (const geometryId of geometryIds.values()) {
            const geometry = cache.getGeometry(geometryId);
            const data = geometry.data;
            pointsAndPolys.push({
                points: data.points,
                polys: data.polys,
                segmentIndex: data.segmentIndex,
                id: data.segmentIndex,
            });
        }
        const polyDataCache = await polySeg.clipAndCacheSurfacesForViewport(pointsAndPolys, viewport);
        const rawResults = polySeg.extractContourData(polyDataCache);
        const annotationUIDsMap = polySeg.createAndAddContourSegmentationsFromClippedSurfaces(rawResults, viewport, segmentationId);
        contourData.annotationUIDsMap = new Map([
            ...contourData.annotationUIDsMap,
            ...annotationUIDsMap,
        ]);
        viewportProcessed.add(segmentationId);
        processedViewportSegmentations.set(viewport.id, viewportProcessed);
        polySegConversionInProgressForViewportId.set(viewport.id, false);
    }
    handleContourSegmentation(viewport, contourData.geometryIds, contourData.annotationUIDsMap, contourRepresentation);
}
function _checkContourGeometryMatchViewport(geometryIds, viewportNormal) {
    let validGeometry = null;
    let geometryData = null;
    for (const geometryId of geometryIds) {
        const geometry = cache.getGeometry(geometryId);
        if (!geometry) {
            continue;
        }
        const data = geometry.data;
        if (data.contours?.[0]?.points?.length >= 3) {
            validGeometry = geometry;
            geometryData = data;
            break;
        }
    }
    if (!validGeometry || !geometryData) {
        return false;
    }
    const contours = geometryData.contours;
    const points = contours[0].points;
    const point1 = points[0];
    const point2 = points[1];
    const point3 = points[2];
    let normal = vec3.cross(vec3.create(), vec3.sub(vec3.create(), point2, point1), vec3.sub(vec3.create(), point3, point1));
    normal = vec3.normalize(vec3.create(), normal);
    const dotProduct = vec3.dot(normal, viewportNormal);
    return Math.abs(dotProduct) > 0.9;
}
function _checkContourNormalsMatchViewport(annotationUIDsMap, viewportNormal) {
    const annotationUIDs = Array.from(annotationUIDsMap.values())
        .flat()
        .map((uidSet) => Array.from(uidSet))
        .flat();
    const randomAnnotationUIDs = utilities.getRandomSampleFromArray(annotationUIDs, 3);
    for (const annotationUID of randomAnnotationUIDs) {
        const annotation = getAnnotation(annotationUID);
        if (annotation?.metadata) {
            if (!annotation.metadata.viewPlaneNormal) {
                continue;
            }
            const annotationNormal = annotation.metadata.viewPlaneNormal;
            const dotProduct = Math.abs(viewportNormal[0] * annotationNormal[0] +
                viewportNormal[1] * annotationNormal[1] +
                viewportNormal[2] * annotationNormal[2]);
            if (Math.abs(dotProduct - 1) > 0.01) {
                return false;
            }
        }
    }
    return true;
}
export default {
    render,
    removeRepresentation,
};
