import { SegmentationRepresentations } from '../../enums';
import { getSegmentIndexColor } from '../../stateManagement/segmentation/config/segmentationColor';
import { getActiveSegmentation } from '../../stateManagement/segmentation/getActiveSegmentation';
import { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';
import { getSegmentationRepresentationVisibility } from '../../stateManagement/segmentation/getSegmentationRepresentationVisibility';
import { internalGetHiddenSegmentIndices } from '../../stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices';
import { segmentationStyle } from '../../stateManagement/segmentation/SegmentationStyle';
export function getSVGStyleForSegment({ segmentationId, segmentIndex, viewportId, autoGenerated = false, }) {
    const segmentColor = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);
    const segmentationVisible = getSegmentationRepresentationVisibility(viewportId, {
        segmentationId,
        type: SegmentationRepresentations.Contour,
    });
    const activeSegmentation = getActiveSegmentation(viewportId);
    const isActive = activeSegmentation?.segmentationId === segmentationId;
    const style = segmentationStyle.getStyle({
        viewportId,
        segmentationId,
        type: SegmentationRepresentations.Contour,
        segmentIndex,
    });
    const mergedConfig = style;
    let lineWidth = 1;
    let lineDash = undefined;
    let lineOpacity = 1;
    let fillOpacity = 0;
    if (autoGenerated) {
        lineWidth = mergedConfig.outlineWidthAutoGenerated ?? lineWidth;
        lineDash = mergedConfig.outlineDashAutoGenerated ?? lineDash;
        lineOpacity = mergedConfig.outlineOpacity ?? lineOpacity;
        fillOpacity = mergedConfig.fillAlphaAutoGenerated ?? fillOpacity;
    }
    else if (isActive) {
        lineWidth = mergedConfig.outlineWidth ?? lineWidth;
        lineDash = mergedConfig.outlineDash ?? lineDash;
        lineOpacity = mergedConfig.outlineOpacity ?? lineOpacity;
        fillOpacity = mergedConfig.fillAlpha ?? fillOpacity;
    }
    else {
        lineWidth = mergedConfig.outlineWidthInactive ?? lineWidth;
        lineDash = mergedConfig.outlineDashInactive ?? lineDash;
        lineOpacity = mergedConfig.outlineOpacityInactive ?? lineOpacity;
        fillOpacity = mergedConfig.fillAlphaInactive ?? fillOpacity;
    }
    if (getActiveSegmentIndex(segmentationId) === segmentIndex) {
        lineWidth += mergedConfig.activeSegmentOutlineWidthDelta;
    }
    lineWidth = mergedConfig.renderOutline ? lineWidth : 0;
    fillOpacity = mergedConfig.renderFill ? fillOpacity : 0;
    const color = `rgba(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]}, ${lineOpacity})`;
    const fillColor = `rgb(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]})`;
    const hiddenSegments = internalGetHiddenSegmentIndices(viewportId, {
        segmentationId,
        type: SegmentationRepresentations.Contour,
    });
    const isVisible = !hiddenSegments.has(segmentIndex);
    return {
        color,
        fillColor,
        lineWidth,
        fillOpacity,
        lineDash,
        textbox: {
            color,
        },
        visibility: segmentationVisible && isVisible,
    };
}
