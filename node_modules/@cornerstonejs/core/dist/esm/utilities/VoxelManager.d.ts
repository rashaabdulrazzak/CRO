import type { BoundsIJK, Point3, PixelDataTypedArray, IImage, RGB, CPUImageData, IVoxelManager, IRLEVoxelMap, Point2 } from '../types';
import type vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';
export default class VoxelManager<T> {
    modifiedSlices: Set<number>;
    private boundsIJK;
    map: Map<number, T> | IRLEVoxelMap<T>;
    sourceVoxelManager: IVoxelManager<T>;
    isInObject: (pointLPS: any, pointIJK: any) => boolean;
    readonly dimensions: Point3;
    readonly numberOfComponents: any;
    getCompleteScalarDataArray?: () => ArrayLike<number>;
    setCompleteScalarDataArray?: (scalarData: ArrayLike<number>) => void;
    getRange: () => [number, number];
    private scalarData;
    private _sliceDataCache;
    readonly _id: string;
    points: Set<number>;
    width: number;
    frameSize: number;
    readonly _get: (index: number) => T;
    readonly _set: (index: number, v: T) => boolean;
    readonly _getConstructor?: () => new (length: number) => PixelDataTypedArray;
    _getScalarDataLength?: () => number;
    _getScalarData?: () => ArrayLike<number>;
    _updateScalarData?: (scalarData: ArrayLike<number>) => PixelDataTypedArray;
    _getSliceData: (args: {
        sliceIndex: number;
        slicePlane: number;
    }) => PixelDataTypedArray;
    get id(): string;
    constructor(dimensions: any, options: {
        _get: (index: number) => T;
        _set?: (index: number, v: T) => boolean;
        _getScalarData?: () => ArrayLike<number>;
        _id?: string;
        _updateScalarData?: (scalarData: ArrayLike<number>) => PixelDataTypedArray;
        numberOfComponents?: number;
        scalarData?: ArrayLike<number>;
        _getConstructor?: () => new (length: number) => PixelDataTypedArray;
    });
    getAtIJK: (i: any, j: any, k: any) => T;
    setAtIJK: (i: number, j: number, k: number, v: any) => boolean;
    getAtIJKPoint: ([i, j, k]: [any, any, any]) => T;
    setAtIJKPoint: ([i, j, k]: Point3, v: any) => void;
    getAtIndex: (index: any) => T;
    getMinMax(): {
        min: any;
        max: any;
    };
    setAtIndex: (index: any, v: any) => boolean;
    toIJK(index: number): Point3;
    getMiddleSliceData: () => PixelDataTypedArray;
    toIndex(ijk: Point3): number;
    getDefaultBounds(): BoundsIJK;
    getBoundsIJK(): BoundsIJK;
    forEach: (callback: (args: {
        value: unknown;
        index: number;
        pointIJK: Point3;
        pointLPS: Point3;
    }) => void, options?: {
        boundsIJK?: BoundsIJK;
        isInObject?: (pointLPS: any, pointIJK: any) => boolean;
        returnPoints?: boolean;
        imageData?: vtkImageData | CPUImageData;
    }) => void | any[];
    rleForEach(callback: any, options?: any): void;
    getScalarData(storeScalarData?: boolean): PixelDataTypedArray;
    setScalarData(newScalarData: PixelDataTypedArray): void;
    getScalarDataLength(): number;
    get sizeInBytes(): number;
    get bytePerVoxel(): number;
    clearBounds(): void;
    clear(): void;
    getConstructor(): new (length: number) => PixelDataTypedArray;
    getArrayOfModifiedSlices(): number[];
    resetModifiedSlices(): void;
    setBounds(bounds: BoundsIJK): void;
    static addBounds(bounds: BoundsIJK, point: Point3): void;
    addPoint(point: Point3 | number): void;
    getPoints(): Point3[];
    getSliceData: ({ sliceIndex, slicePlane, }: {
        sliceIndex: number;
        slicePlane: number;
    }) => PixelDataTypedArray;
    private setSliceDataValue;
    private toNumber;
    private static _createRGBScalarVolumeVoxelManager;
    static createImageVolumeVoxelManager({ dimensions, imageIds, numberOfComponents, id, }: {
        dimensions: Point3;
        imageIds: string[];
        numberOfComponents: number;
        id?: string;
    }): IVoxelManager<number> | IVoxelManager<RGB>;
    static createScalarVolumeVoxelManager({ dimensions, scalarData, numberOfComponents, id, }: {
        dimensions: Point3;
        scalarData: any;
        numberOfComponents?: number;
        id?: string;
    }): IVoxelManager<number> | IVoxelManager<RGB>;
    static createScalarDynamicVolumeVoxelManager({ imageIdGroups, dimensions, dimensionGroupNumber, timePoint, numberOfComponents, id, }: {
        imageIdGroups: string[][];
        dimensions: Point3;
        dimensionGroupNumber?: number;
        timePoint?: number;
        numberOfComponents?: number;
        id?: string;
    }): IVoxelManager<number> | IVoxelManager<RGB>;
    static createImageVoxelManager({ width, height, scalarData, numberOfComponents, id, }: {
        width: number;
        height: number;
        scalarData: PixelDataTypedArray;
        numberOfComponents?: number;
        id?: string;
    }): IVoxelManager<number> | IVoxelManager<RGB>;
    private static _createNumberVolumeVoxelManager;
    static createMapVoxelManager<T>({ dimension, id, }: {
        dimension: Point3;
        id?: string;
    }): IVoxelManager<T>;
    static createHistoryVoxelManager<T>(sourceVoxelManager: VoxelManager<T>, id?: string): VoxelManager<T>;
    static createRLEHistoryVoxelManager<T>(sourceVoxelManager: VoxelManager<T>, id?: string): VoxelManager<T>;
    static createLazyVoxelManager<T>({ dimensions, planeFactory, id, }: {
        dimensions: Point3;
        planeFactory: (width: number, height: number) => T;
        id?: string;
    }): VoxelManager<T>;
    static createRLEVolumeVoxelManager<T>({ dimensions, id, }: {
        dimensions: Point3;
        id?: string;
    }): VoxelManager<T>;
    static createRLEImageVoxelManager<T>({ dimensions, id, }: {
        dimensions: Point2;
        id?: string;
    }): VoxelManager<T>;
    static addInstanceToImage(image: IImage): void;
    static: any;
}
export type { VoxelManager };
