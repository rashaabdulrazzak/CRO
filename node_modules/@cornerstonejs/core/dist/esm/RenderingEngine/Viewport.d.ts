import type { vtkCamera } from '@kitware/vtk.js/Rendering/Core/Camera';
import vtkPlane from '@kitware/vtk.js/Common/DataModel/Plane';
import type { mat4 } from 'gl-matrix';
import ViewportStatus from '../enums/ViewportStatus';
import ViewportType from '../enums/ViewportType';
import type { ICamera, ActorEntry, IRenderingEngine, ViewportInputOptions, Point2, Point3, FlipDirection, DisplayArea, ViewPresentation, ViewReference, ViewportProperties, ImageActor } from '../types';
import type { ViewportInput, ViewReferenceSpecifier, ReferenceCompatibleOptions, ViewPresentationSelector, DataSetOptions, PlaneRestriction } from '../types/IViewport';
import type { vtkSlabCamera } from './vtkClasses/vtkSlabCamera';
import type IImageCalibration from '../types/IImageCalibration';
import { InterpolationType } from '../enums';
import type vtkRenderer from '@kitware/vtk.js/Rendering/Core/Renderer';
declare class Viewport {
    static readonly CameraViewPresentation: ViewPresentationSelector;
    static readonly TransferViewPresentation: ViewPresentationSelector;
    readonly id: string;
    readonly element: HTMLDivElement;
    readonly canvas: HTMLCanvasElement;
    readonly renderingEngineId: string;
    readonly type: ViewportType;
    protected insetImageMultiplier: number;
    protected flipHorizontal: boolean;
    protected flipVertical: boolean;
    isDisabled: boolean;
    viewportStatus: ViewportStatus;
    sx: number;
    sy: number;
    sWidth: number;
    sHeight: number;
    _actors: Map<string, ActorEntry>;
    readonly defaultOptions: ViewportInputOptions;
    options: ViewportInputOptions;
    _suppressCameraModifiedEvents: boolean;
    readonly suppressEvents: boolean;
    protected hasPixelSpacing: boolean;
    protected calibration: IImageCalibration;
    protected initialCamera: ICamera;
    protected fitToCanvasCamera: ICamera;
    constructor(props: ViewportInput);
    getRotation: () => number;
    getFrameOfReferenceUID: () => string;
    canvasToWorld: (canvasPos: Point2) => Point3;
    worldToCanvas: (worldPos: Point3) => Point2;
    customRenderViewportToCanvas: () => unknown;
    resize: () => void;
    getProperties: () => ViewportProperties;
    updateRenderingPipeline: () => void;
    getNumberOfSlices: () => number;
    protected setRotation: (_rotation: number) => void;
    static get useCustomRenderingPipeline(): boolean;
    private viewportWidgets;
    addWidget: (widgetId: any, widget: any) => void;
    getWidget: (id: any) => any;
    getWidgets: () => any[];
    getRenderPasses: () => any;
    removeWidgets: () => void;
    setRendered(): void;
    protected setColorTransform(voiRange: any, averageWhite: any): any;
    getRenderingEngine(): IRenderingEngine;
    getRenderer(): vtkRenderer;
    render(): void;
    setOptions(options: ViewportInputOptions, immediate?: boolean): void;
    reset(immediate?: boolean): void;
    getSliceViewInfo(): {
        width: number;
        height: number;
        sliceIndex: number;
        slicePlane: number;
        sliceToIndexMatrix: mat4;
        indexToSliceMatrix: mat4;
    };
    protected flip({ flipHorizontal, flipVertical }: FlipDirection): void;
    private getDefaultImageData;
    getDefaultActor(): ActorEntry;
    getActors(): ActorEntry[];
    getActorUIDs(): string[];
    getActor(actorUID: string): ActorEntry;
    getImageActor(volumeId?: string): ImageActor | null;
    getActorUIDByIndex(index: number): string;
    getActorByIndex(index: number): ActorEntry;
    setActors(actors: ActorEntry[]): void;
    _removeActor(actorUID: string): ActorEntry | undefined;
    removeActors(actorUIDs: string[]): void;
    addActors(actors: ActorEntry[], options?: {
        resetCamera?: boolean;
    }): void;
    addActor(actorEntry: ActorEntry): void;
    removeAllActors(): void;
    protected resetCameraNoEvent(): void;
    protected setCameraNoEvent(camera: ICamera): void;
    private _getViewImageDataIntersections;
    protected setInterpolationType(_interpolationType: InterpolationType, _arg?: any): void;
    setDisplayArea(displayArea: DisplayArea, suppressEvents?: boolean): void;
    protected setDisplayAreaScale(displayArea: DisplayArea): void;
    protected setDisplayAreaFit(displayArea: DisplayArea): void;
    getDisplayArea(): DisplayArea | undefined;
    resetCamera(options?: {
        resetPan?: boolean;
        resetZoom?: boolean;
        resetToCenter?: boolean;
        storeAsInitialCamera?: boolean;
    }): boolean;
    protected setInitialCamera(camera: ICamera): void;
    protected setFitToCanvasCamera(camera: ICamera): void;
    getPan(initialCamera?: ICamera): Point2;
    getCurrentImageIdIndex(): number;
    getSliceIndex(): number;
    getImageData(): any;
    getViewReferenceId(_specifier?: ViewReferenceSpecifier): string;
    setPan(pan: Point2, storeAsInitialCamera?: boolean): void;
    getZoom(compareCamera?: ICamera): number;
    setZoom(value: number, storeAsInitialCamera?: boolean): void;
    private _getFocalPointForViewPlaneReset;
    getCanvas(): HTMLCanvasElement;
    protected getVtkActiveCamera(): vtkCamera | vtkSlabCamera;
    protected getCameraNoRotation(): ICamera;
    getCamera(): ICamera;
    setCamera(cameraInterface: ICamera, storeAsInitialCamera?: boolean): void;
    triggerCameraModifiedEventIfNecessary(previousCamera: ICamera, updatedCamera: ICamera): void;
    updateCameraClippingPlanesAndRange(): void;
    protected updateClippingPlanesForActors(updatedCamera: ICamera): Promise<void>;
    setOrientationOfClippingPlanes(vtkPlanes: vtkPlane[], slabThickness: number, viewPlaneNormal: Point3, focalPoint: Point3): void;
    getClippingPlanesForActor(actorEntry?: ActorEntry): vtkPlane[];
    private _getWorldDistanceViewUpAndViewRight;
    getViewReference(viewRefSpecifier?: ViewReferenceSpecifier): ViewReference;
    isPlaneViewable(planeRestriction: PlaneRestriction, options?: ReferenceCompatibleOptions): boolean;
    isReferenceViewable(viewRef: ViewReference, options?: ReferenceCompatibleOptions): boolean;
    getViewPresentation(viewPresSel?: ViewPresentationSelector): ViewPresentation;
    setViewReference(viewRef: ViewReference): void;
    setViewPresentation(viewPres: ViewPresentation): void;
    _getCorners(bounds: number[]): number[][];
    _getFocalPointForResetCamera(centeredFocalPoint: Point3, previousCamera: ICamera, { resetPan, resetToCenter }: {
        resetPan?: boolean;
        resetToCenter?: boolean;
    }): Point3;
    _isInBounds(point: Point3, bounds: number[]): boolean;
    _getEdges(bounds: number[]): [number[], number[]][];
    static boundsRadius(bounds: number[]): number;
    setDataIds(_imageIds: string[], _options?: DataSetOptions): void;
}
export default Viewport;
