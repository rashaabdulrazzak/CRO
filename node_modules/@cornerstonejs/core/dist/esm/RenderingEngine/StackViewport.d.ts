import type { vtkImageData as vtkImageDataType } from '@kitware/vtk.js/Common/DataModel/ImageData';
import { mat4 } from 'gl-matrix';
import type { ActorEntry, CPUIImageData, ICamera, IImage, IImageData, IImagesLoader, IStackInput, ImageLoadListener, Mat3, Point2, Point3, Scaling, StackViewportProperties, ViewReference, ViewReferenceSpecifier, ReferenceCompatibleOptions, ViewportInput, ImagePixelModule, ImagePlaneModule } from '../types';
import Viewport from './Viewport';
import { InterpolationType, RequestType, ViewportStatus } from '../enums';
import type vtkRenderer from '@kitware/vtk.js/Rendering/Core/Renderer';
export interface ImageDataMetaData {
    bitsAllocated: number;
    numberOfComponents: number;
    origin: Point3;
    direction: Mat3;
    dimensions: Point3;
    spacing: Point3;
    numVoxels: number;
    imagePlaneModule: ImagePlaneModule;
    imagePixelModule: ImagePixelModule;
}
declare class StackViewport extends Viewport {
    private imageIds;
    private imageKeyToIndexMap;
    private currentImageIdIndex;
    private targetImageIdIndex;
    private debouncedTimeout;
    protected imagesLoader: IImagesLoader;
    private globalDefaultProperties;
    private perImageIdDefaultProperties;
    private colormap;
    private voiRange;
    private voiUpdatedWithSetProperties;
    private sharpening;
    private VOILUTFunction;
    private invert;
    private initialInvert;
    private initialTransferFunctionNodes;
    private interpolationType;
    private _imageData;
    private stackInvalidated;
    private _publishCalibratedEvent;
    private _calibrationEvent;
    private _cpuFallbackEnabledElement?;
    private useCPURendering;
    private cpuImagePixelData;
    private cpuRenderingInvalidated;
    private csImage;
    modality: string;
    scaling: Scaling;
    private initialViewUp;
    stackActorReInitialized: boolean;
    constructor(props: ViewportInput);
    setUseCPURendering(value: boolean): void;
    static get useCustomRenderingPipeline(): boolean;
    updateRenderingPipeline: () => void;
    private _configureRenderingPipeline;
    private _resetCPUFallbackElement;
    private _resetGPUViewport;
    getImageData: () => IImageData | CPUIImageData;
    getCamera: () => ICamera;
    setCamera: (cameraInterface: ICamera, storeAsInitialCamera?: boolean) => void;
    getRotation: () => number;
    unsetColormap: () => void;
    resetCamera: (options?: {
        resetPan?: boolean;
        resetZoom?: boolean;
        resetToCenter?: boolean;
        suppressEvents?: boolean;
    }) => boolean;
    canvasToWorld: (canvasPos: Point2) => Point3;
    worldToCanvas: (worldPos: Point3) => Point2;
    getDefaultActor: () => ActorEntry;
    getActors: () => ActorEntry[];
    getActor: (actorUID: string) => ActorEntry;
    setActors: (actors: ActorEntry[]) => void;
    addActors: (actors: ActorEntry[]) => void;
    addActor: (actorEntry: ActorEntry) => void;
    removeAllActors: () => void;
    private setVOI;
    protected setInterpolationType: (interpolationType: InterpolationType) => void;
    private setInvertColor;
    private setColormap;
    private setSharpening;
    protected shouldUseCustomRenderPass(): boolean;
    getRenderPasses: () => any[];
    private initializeElementDisabledHandler;
    resize: () => void;
    private _resizeCPU;
    private getImageDataGPU;
    private getImageDataCPU;
    getFrameOfReferenceUID: (sliceIndex?: number) => string;
    getCornerstoneImage: () => IImage;
    private createActorMapper;
    getNumberOfSlices: () => number;
    private calibrateIfNecessary;
    setDefaultProperties(ViewportProperties: StackViewportProperties, imageId?: string): void;
    clearDefaultProperties(imageId?: string): void;
    setProperties({ colormap, voiRange, VOILUTFunction, invert, interpolationType, sharpening, }?: StackViewportProperties, suppressEvents?: boolean): void;
    getDefaultProperties: (imageId?: string) => StackViewportProperties;
    getProperties: () => StackViewportProperties;
    resetCameraForResize: () => boolean;
    resetProperties(): void;
    private _resetProperties;
    resetToDefaultProperties(): void;
    private _getVOIFromCache;
    private _setPropertiesFromCache;
    private getCameraCPU;
    private setCameraCPU;
    private getPanCPU;
    private setPanCPU;
    private getZoomCPU;
    private setZoomCPU;
    private setFlipCPU;
    private getRotationCPU;
    private getRotationGPU;
    protected setRotation: (rotation: number) => void;
    private setVOILUTFunction;
    private setRotationCPU;
    private setRotationGPU;
    private setInterpolationTypeGPU;
    private setInterpolationTypeCPU;
    private setInvertColorCPU;
    private setInvertColorGPU;
    private setVOICPU;
    private getTransferFunction;
    private setVOIGPU;
    private _addScalingToViewport;
    getImageDataMetadata(image: IImage): ImageDataMetaData;
    private matchImagesForOverlay;
    getImagePlaneReferenceData(sliceIndex?: number): ViewReference;
    private _getCameraOrientation;
    createVTKImageData({ origin, direction, dimensions, spacing, numberOfComponents, pixelArray, }: {
        origin: any;
        direction: any;
        dimensions: any;
        spacing: any;
        numberOfComponents: any;
        pixelArray: any;
    }): vtkImageDataType;
    private _createVTKImageData;
    setStack(imageIds: string[], currentImageIdIndex?: number): Promise<string>;
    private _throwIfDestroyed;
    private _checkVTKImageDataMatchesCornerstoneImage;
    private _updateVTKImageDataFromCornerstoneImage;
    private _loadAndDisplayImage;
    private _loadAndDisplayImageCPU;
    successCallback(imageId: any, image: any): void;
    errorCallback(imageId: any, permanent: any, error: any): void;
    getLoaderImageOptions(imageId: string): {
        useRGBA: boolean;
        transferSyntaxUID: any;
        priority: number;
        requestType: RequestType;
        additionalDetails: {
            imageId: string;
            imageIdIndex: number;
        };
    };
    loadImages(imageIds: string[], listener: ImageLoadListener): Promise<unknown>;
    private _loadAndDisplayImageGPU;
    renderImageObject: (image: any) => void;
    private _setCSImage;
    private _updateToDisplayImageCPU;
    getSliceViewInfo(): {
        width: number;
        height: number;
        sliceIndex: number;
        slicePlane: number;
        sliceToIndexMatrix: mat4;
        indexToSliceMatrix: mat4;
    };
    addImages(stackInputs: IStackInput[]): void;
    private _updateActorToDisplayImageId;
    private _getInitialVOIRange;
    private _getPTPreScaledRange;
    private _isCurrentImagePTPrescaled;
    private _getDefaultPTPrescaledVOIRange;
    private _getVOIRangeFromWindowLevel;
    private _setImageIdIndex;
    private resetCameraCPU;
    private resetCameraGPU;
    scroll(delta: number, debounce?: boolean, loop?: boolean): void;
    setImageIdIndex(imageIdIndex: number): Promise<string>;
    calibrateSpacing(imageId: string): void;
    private triggerCameraEvent;
    private triggerCalibrationEvent;
    jumpToWorld(worldPos: Point3): boolean;
    private canvasToWorldCPU;
    private worldToCanvasCPU;
    private canvasToWorldGPUContextPool;
    private canvasToWorldGPUTiled;
    private worldToCanvasGPUContextPool;
    private worldToCanvasGPUTiled;
    getRendererContextPool(): vtkRenderer;
    getRendererTiled(): vtkRenderer;
    private _getVOIRangeForCurrentImage;
    private _getValidVOILUTFunction;
    getCurrentImageIdIndex: () => number;
    getSliceIndex: () => number;
    getSliceInfo(): {
        sliceIndex: number;
        slicePlane: number;
        width: number;
        height: number;
    };
    isReferenceViewable(viewRef: ViewReference, options?: ReferenceCompatibleOptions): boolean;
    getViewReference(viewRefSpecifier?: ViewReferenceSpecifier): ViewReference;
    setViewReference(viewRef: ViewReference): void;
    getViewReferenceId(specifier?: ViewReferenceSpecifier): string;
    getTargetImageIdIndex: () => number;
    getSliceIndexForImage(reference: string | ViewReference): number;
    getImageIds: () => string[];
    getCurrentImageId: (index?: number) => string;
    hasImageId: (imageId: string) => boolean;
    hasImageURI: (imageURI: string) => boolean;
    private getCPUFallbackError;
    private fillWithBackgroundColor;
    customRenderViewportToCanvas: () => {
        canvas: HTMLCanvasElement;
        element: HTMLDivElement;
        viewportId: string;
        renderingEngineId: string;
        viewportStatus: ViewportStatus;
    };
    private unsetColormapCPU;
    private setColormapCPU;
    private setColormapGPU;
    private unsetColormapGPU;
    private _getImagePlaneModule;
    isInAcquisitionPlane(): boolean;
    private renderingPipelineFunctions;
}
export default StackViewport;
