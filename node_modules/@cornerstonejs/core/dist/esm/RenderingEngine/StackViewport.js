import vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';
import vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';
import vtkCamera from '@kitware/vtk.js/Rendering/Core/Camera';
import vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';
import vtkColorMaps from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';
import vtkImageMapper from '@kitware/vtk.js/Rendering/Core/ImageMapper';
import vtkImageSlice from '@kitware/vtk.js/Rendering/Core/ImageSlice';
import { mat4, vec2, vec3 } from 'gl-matrix';
import eventTarget from '../eventTarget';
import * as metaData from '../metaData';
import { getImageDataMetadata as getImageDataMetadataUtil } from '../utilities/getImageDataMetadata';
import { coreLog } from '../utilities/logger';
import { actorIsA, isImageActor } from '../utilities/actorCheck';
import * as colormapUtils from '../utilities/colormap';
import { getTransferFunctionNodes, setTransferFunctionNodes, } from '../utilities/transferFunctionUtils';
import * as windowLevelUtil from '../utilities/windowLevel';
import createLinearRGBTransferFunction from '../utilities/createLinearRGBTransferFunction';
import createSigmoidRGBTransferFunction from '../utilities/createSigmoidRGBTransferFunction';
import { updateVTKImageDataWithCornerstoneImage } from '../utilities/updateVTKImageDataWithCornerstoneImage';
import triggerEvent from '../utilities/triggerEvent';
import { isEqual } from '../utilities/isEqual';
import invertRgbTransferFunction from '../utilities/invertRgbTransferFunction';
import imageRetrieveMetadataProvider from '../utilities/imageRetrieveMetadataProvider';
import imageIdToURI from '../utilities/imageIdToURI';
import Viewport from './Viewport';
import drawImageSync from './helpers/cpuFallback/drawImageSync';
import { getImagePlaneModule } from '../utilities/buildMetadata';
import { Events, InterpolationType, MetadataModules, RequestType, VOILUTFunctionType, ViewportStatus, } from '../enums';
import { loadAndCacheImage } from '../loaders/imageLoader';
import imageLoadPoolManager from '../requestPool/imageLoadPoolManager';
import calculateTransform from './helpers/cpuFallback/rendering/calculateTransform';
import canvasToPixel from './helpers/cpuFallback/rendering/canvasToPixel';
import getDefaultViewport from './helpers/cpuFallback/rendering/getDefaultViewport';
import pixelToCanvas from './helpers/cpuFallback/rendering/pixelToCanvas';
import resize from './helpers/cpuFallback/rendering/resize';
import cache from '../cache/cache';
import { getConfiguration, getShouldUseCPURendering } from '../init';
import { createProgressive } from '../loaders/ProgressiveRetrieveImages';
import correctShift from './helpers/cpuFallback/rendering/correctShift';
import resetCamera from './helpers/cpuFallback/rendering/resetCamera';
import { Transform } from './helpers/cpuFallback/rendering/transform';
import uuidv4 from '../utilities/uuidv4';
import getSpacingInNormalDirection from '../utilities/getSpacingInNormalDirection';
import getClosestImageId from '../utilities/getClosestImageId';
import { adjustInitialViewUp } from '../utilities/adjustInitialViewUp';
import { isContextPoolRenderingEngine } from './helpers/isContextPoolRenderingEngine';
import { createSharpeningRenderPass } from './renderPasses';
const log = coreLog.getLogger('RenderingEngine', 'StackViewport');
class StackViewport extends Viewport {
    constructor(props) {
        super(props);
        this.imageIds = [];
        this.imageKeyToIndexMap = new Map();
        this.currentImageIdIndex = 0;
        this.targetImageIdIndex = 0;
        this.imagesLoader = this;
        this.globalDefaultProperties = {};
        this.perImageIdDefaultProperties = new Map();
        this.voiUpdatedWithSetProperties = false;
        this.sharpening = 0;
        this.invert = false;
        this.initialInvert = false;
        this.initialTransferFunctionNodes = null;
        this.stackInvalidated = false;
        this._publishCalibratedEvent = false;
        this.updateRenderingPipeline = () => {
            this._configureRenderingPipeline();
        };
        this.setSharpening = (sharpening) => {
            this.sharpening = sharpening;
            this.render();
        };
        this.getRenderPasses = () => {
            if (!this.shouldUseCustomRenderPass()) {
                return null;
            }
            try {
                return [createSharpeningRenderPass(this.sharpening)];
            }
            catch (e) {
                console.warn('Failed to create sharpening render passes:', e);
                return null;
            }
        };
        this.resize = () => {
            if (this.useCPURendering) {
                this._resizeCPU();
            }
        };
        this._resizeCPU = () => {
            if (this._cpuFallbackEnabledElement.viewport) {
                resize(this._cpuFallbackEnabledElement);
            }
        };
        this.getFrameOfReferenceUID = (sliceIndex) => this.getImagePlaneReferenceData(sliceIndex)?.FrameOfReferenceUID;
        this.getCornerstoneImage = () => this.csImage;
        this.createActorMapper = (imageData) => {
            const mapper = vtkImageMapper.newInstance();
            mapper.setInputData(imageData);
            const actor = vtkImageSlice.newInstance();
            actor.setMapper(mapper);
            const { preferSizeOverAccuracy } = getConfiguration().rendering;
            if (preferSizeOverAccuracy) {
                mapper.setPreferSizeOverAccuracy(true);
            }
            if (imageData.getPointData().getScalars().getNumberOfComponents() > 1) {
                actor.getProperty().setIndependentComponents(false);
            }
            return actor;
        };
        this.getNumberOfSlices = () => {
            return this.imageIds.length;
        };
        this.getDefaultProperties = (imageId) => {
            let imageProperties;
            if (imageId !== undefined) {
                imageProperties = this.perImageIdDefaultProperties.get(imageId);
            }
            if (imageProperties !== undefined) {
                return imageProperties;
            }
            return {
                ...this.globalDefaultProperties,
            };
        };
        this.getProperties = () => {
            const { colormap, voiRange, VOILUTFunction, interpolationType, invert, voiUpdatedWithSetProperties, } = this;
            return {
                colormap,
                voiRange,
                VOILUTFunction,
                interpolationType,
                invert,
                isComputedVOI: !voiUpdatedWithSetProperties,
                sharpening: this.sharpening,
            };
        };
        this.resetCameraForResize = () => {
            return this.resetCamera({
                resetPan: true,
                resetZoom: true,
                resetToCenter: true,
                suppressEvents: true,
            });
        };
        this.getRotationCPU = () => {
            const { viewport } = this._cpuFallbackEnabledElement;
            return viewport.rotation;
        };
        this.getRotationGPU = () => {
            const { viewUp: currentViewUp, viewPlaneNormal, flipVertical, flipHorizontal, } = this.getCameraNoRotation();
            const adjustedViewUp = adjustInitialViewUp(this.initialViewUp, flipHorizontal, flipVertical, viewPlaneNormal);
            const angleRad = vec3.angle(adjustedViewUp, currentViewUp);
            const initialToCurrentViewUpAngle = (angleRad * 180) / Math.PI;
            const initialToCurrentViewUpCross = vec3.cross(vec3.create(), adjustedViewUp, currentViewUp);
            const normalDot = vec3.dot(initialToCurrentViewUpCross, viewPlaneNormal);
            return normalDot >= 0
                ? initialToCurrentViewUpAngle
                : (360 - initialToCurrentViewUpAngle) % 360;
        };
        this.setRotation = (rotation) => {
            const previousCamera = this.getCamera();
            if (this.useCPURendering) {
                this.setRotationCPU(rotation);
            }
            else {
                this.setRotationGPU(rotation);
            }
            if (this._suppressCameraModifiedEvents) {
                return;
            }
            const camera = this.getCamera();
            const eventDetail = {
                previousCamera,
                camera,
                element: this.element,
                viewportId: this.id,
                renderingEngineId: this.renderingEngineId,
            };
            triggerEvent(this.element, Events.CAMERA_MODIFIED, eventDetail);
        };
        this.renderImageObject = (image) => {
            this._setCSImage(image);
            const renderFn = this.useCPURendering
                ? this._updateToDisplayImageCPU
                : this._updateActorToDisplayImageId;
            renderFn.call(this, image);
        };
        this._setCSImage = (image) => {
            image.isPreScaled = image.preScale?.scaled;
            this.csImage = image;
        };
        this.canvasToWorldCPU = (canvasPos, worldPos = [0, 0, 0]) => {
            if (!this._cpuFallbackEnabledElement.image) {
                return;
            }
            const [px, py] = canvasToPixel(this._cpuFallbackEnabledElement, canvasPos);
            const { origin, spacing, direction } = this.getImageData();
            const iVector = direction.slice(0, 3);
            const jVector = direction.slice(3, 6);
            vec3.scaleAndAdd(worldPos, origin, iVector, px * spacing[0]);
            vec3.scaleAndAdd(worldPos, worldPos, jVector, py * spacing[1]);
            return worldPos;
        };
        this.worldToCanvasCPU = (worldPos) => {
            const { spacing, direction, origin } = this.getImageData();
            const iVector = direction.slice(0, 3);
            const jVector = direction.slice(3, 6);
            const diff = vec3.subtract(vec3.create(), worldPos, origin);
            const indexPoint = [
                vec3.dot(diff, iVector) / spacing[0],
                vec3.dot(diff, jVector) / spacing[1],
            ];
            const canvasPoint = pixelToCanvas(this._cpuFallbackEnabledElement, indexPoint);
            return canvasPoint;
        };
        this.canvasToWorldGPUContextPool = (canvasPos) => {
            const renderer = this.getRenderer();
            const vtkCamera = this.getVtkActiveCamera();
            const crange = vtkCamera.getClippingRange();
            const distance = vtkCamera.getDistance();
            vtkCamera.setClippingRange(distance, distance + 0.1);
            const devicePixelRatio = window.devicePixelRatio || 1;
            const { width, height } = this.canvas;
            const aspectRatio = width / height;
            const canvasPosWithDPR = [
                canvasPos[0] * devicePixelRatio,
                canvasPos[1] * devicePixelRatio,
            ];
            const viewport = renderer.getViewport();
            const [xStart, yStart, xEnd, yEnd] = viewport;
            const viewportWidth = xEnd - xStart;
            const viewportHeight = yEnd - yStart;
            const normalizedDisplay = [
                xStart + (canvasPosWithDPR[0] / width) * viewportWidth,
                yStart + (1 - canvasPosWithDPR[1] / height) * viewportHeight,
                0,
            ];
            const projCoords = renderer.normalizedDisplayToProjection(normalizedDisplay[0], normalizedDisplay[1], normalizedDisplay[2]);
            const viewCoords = renderer.projectionToView(projCoords[0], projCoords[1], projCoords[2], aspectRatio);
            const worldCoord = renderer.viewToWorld(viewCoords[0], viewCoords[1], viewCoords[2]);
            vtkCamera.setClippingRange(crange[0], crange[1]);
            return [worldCoord[0], worldCoord[1], worldCoord[2]];
        };
        this.canvasToWorldGPUTiled = (canvasPos) => {
            const renderer = this.getRenderer();
            const vtkCamera = this.getVtkActiveCamera();
            const crange = vtkCamera.getClippingRange();
            const distance = vtkCamera.getDistance();
            vtkCamera.setClippingRange(distance, distance + 0.1);
            const offscreenMultiRenderWindow = this.getRenderingEngine().offscreenMultiRenderWindow;
            const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
            const size = openGLRenderWindow.getSize();
            const devicePixelRatio = window.devicePixelRatio || 1;
            const canvasPosWithDPR = [
                canvasPos[0] * devicePixelRatio,
                canvasPos[1] * devicePixelRatio,
            ];
            const displayCoord = [
                canvasPosWithDPR[0] + this.sx,
                canvasPosWithDPR[1] + this.sy,
            ];
            displayCoord[1] = size[1] - displayCoord[1];
            const worldCoord = openGLRenderWindow.displayToWorld(displayCoord[0], displayCoord[1], 0, renderer);
            vtkCamera.setClippingRange(crange[0], crange[1]);
            return [worldCoord[0], worldCoord[1], worldCoord[2]];
        };
        this.worldToCanvasGPUContextPool = (worldPos) => {
            const renderer = this.getRenderer();
            const vtkCamera = this.getVtkActiveCamera();
            const crange = vtkCamera.getClippingRange();
            const distance = vtkCamera.getDistance();
            vtkCamera.setClippingRange(distance, distance + 0.1);
            const devicePixelRatio = window.devicePixelRatio || 1;
            const { width, height } = this.canvas;
            const aspectRatio = width / height;
            const viewCoords = renderer.worldToView(worldPos[0], worldPos[1], worldPos[2]);
            const projCoords = renderer.viewToProjection(viewCoords[0], viewCoords[1], viewCoords[2], aspectRatio);
            const normalizedDisplay = renderer.projectionToNormalizedDisplay(projCoords[0], projCoords[1], projCoords[2]);
            const viewport = renderer.getViewport();
            const [xStart, yStart, xEnd, yEnd] = viewport;
            const viewportWidth = xEnd - xStart;
            const viewportHeight = yEnd - yStart;
            const canvasX = ((normalizedDisplay[0] - xStart) / viewportWidth) * width;
            const canvasY = (1 - (normalizedDisplay[1] - yStart) / viewportHeight) * height;
            vtkCamera.setClippingRange(crange[0], crange[1]);
            const canvasCoordWithDPR = [
                canvasX / devicePixelRatio,
                canvasY / devicePixelRatio,
            ];
            return canvasCoordWithDPR;
        };
        this.worldToCanvasGPUTiled = (worldPos) => {
            const renderer = this.getRenderer();
            const vtkCamera = this.getVtkActiveCamera();
            const crange = vtkCamera.getClippingRange();
            const distance = vtkCamera.getDistance();
            vtkCamera.setClippingRange(distance, distance + 0.1);
            const offscreenMultiRenderWindow = this.getRenderingEngine().offscreenMultiRenderWindow;
            const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
            const size = openGLRenderWindow.getSize();
            const displayCoord = openGLRenderWindow.worldToDisplay(...worldPos, renderer);
            displayCoord[1] = size[1] - displayCoord[1];
            const canvasCoord = [
                displayCoord[0] - this.sx,
                displayCoord[1] - this.sy,
            ];
            vtkCamera.setClippingRange(crange[0], crange[1]);
            const devicePixelRatio = window.devicePixelRatio || 1;
            const canvasCoordWithDPR = [
                canvasCoord[0] / devicePixelRatio,
                canvasCoord[1] / devicePixelRatio,
            ];
            return canvasCoordWithDPR;
        };
        this.getCurrentImageIdIndex = () => {
            return this.currentImageIdIndex;
        };
        this.getSliceIndex = () => {
            return this.currentImageIdIndex;
        };
        this.getTargetImageIdIndex = () => {
            return this.targetImageIdIndex;
        };
        this.getImageIds = () => {
            return this.imageIds;
        };
        this.getCurrentImageId = (index = this.getCurrentImageIdIndex()) => {
            return this.imageIds[index];
        };
        this.hasImageId = (imageId) => {
            return this.imageKeyToIndexMap.has(imageId);
        };
        this.hasImageURI = (imageURI) => {
            return this.imageKeyToIndexMap.has(imageURI);
        };
        this.customRenderViewportToCanvas = () => {
            if (!this.useCPURendering) {
                throw new Error('Custom cpu rendering pipeline should only be hit in CPU rendering mode');
            }
            if (this._cpuFallbackEnabledElement.image) {
                drawImageSync(this._cpuFallbackEnabledElement, this.cpuRenderingInvalidated);
                this.cpuRenderingInvalidated = false;
            }
            else {
                this.fillWithBackgroundColor();
            }
            return {
                canvas: this.canvas,
                element: this.element,
                viewportId: this.id,
                renderingEngineId: this.renderingEngineId,
                viewportStatus: this.viewportStatus,
            };
        };
        this.renderingPipelineFunctions = {
            getImageData: {
                cpu: this.getImageDataCPU,
                gpu: this.getImageDataGPU,
            },
            setColormap: {
                cpu: this.setColormapCPU,
                gpu: this.setColormapGPU,
            },
            getCamera: {
                cpu: this.getCameraCPU,
                gpu: super.getCamera,
            },
            setCamera: {
                cpu: this.setCameraCPU,
                gpu: super.setCamera,
            },
            getPan: {
                cpu: this.getPanCPU,
                gpu: super.getPan,
            },
            setPan: {
                cpu: this.setPanCPU,
                gpu: super.setPan,
            },
            getZoom: {
                cpu: this.getZoomCPU,
                gpu: super.getZoom,
            },
            setZoom: {
                cpu: this.setZoomCPU,
                gpu: super.setZoom,
            },
            setVOI: {
                cpu: this.setVOICPU,
                gpu: this.setVOIGPU,
            },
            getRotation: {
                cpu: this.getRotationCPU,
                gpu: this.getRotationGPU,
            },
            setInterpolationType: {
                cpu: this.setInterpolationTypeCPU,
                gpu: this.setInterpolationTypeGPU,
            },
            setInvertColor: {
                cpu: this.setInvertColorCPU,
                gpu: this.setInvertColorGPU,
            },
            resetCamera: {
                cpu: (options = {}) => {
                    const { resetPan = true, resetZoom = true } = options;
                    this.resetCameraCPU({ resetPan, resetZoom });
                    return true;
                },
                gpu: (options = {}) => {
                    const { resetPan = true, resetZoom = true } = options;
                    this.resetCameraGPU({ resetPan, resetZoom });
                    return true;
                },
            },
            canvasToWorld: {
                cpu: this.canvasToWorldCPU,
                gpu: {
                    tiled: this.canvasToWorldGPUTiled,
                    contextPool: this.canvasToWorldGPUContextPool,
                },
            },
            worldToCanvas: {
                cpu: this.worldToCanvasCPU,
                gpu: {
                    tiled: this.worldToCanvasGPUTiled,
                    contextPool: this.worldToCanvasGPUContextPool,
                },
            },
            getRenderer: {
                cpu: () => this.getCPUFallbackError('getRenderer'),
                gpu: {
                    tiled: this.getRendererTiled,
                    contextPool: this.getRendererContextPool,
                },
            },
            getDefaultActor: {
                cpu: () => this.getCPUFallbackError('getDefaultActor'),
                gpu: super.getDefaultActor,
            },
            getActors: {
                cpu: () => this.getCPUFallbackError('getActors'),
                gpu: super.getActors,
            },
            getActor: {
                cpu: () => this.getCPUFallbackError('getActor'),
                gpu: super.getActor,
            },
            setActors: {
                cpu: () => this.getCPUFallbackError('setActors'),
                gpu: super.setActors,
            },
            addActors: {
                cpu: () => this.getCPUFallbackError('addActors'),
                gpu: super.addActors,
            },
            addActor: {
                cpu: () => this.getCPUFallbackError('addActor'),
                gpu: super.addActor,
            },
            removeAllActors: {
                cpu: () => this.getCPUFallbackError('removeAllActors'),
                gpu: super.removeAllActors,
            },
            unsetColormap: {
                cpu: this.unsetColormapCPU,
                gpu: this.unsetColormapGPU,
            },
        };
        this.scaling = {};
        this.modality = null;
        this.useCPURendering = getShouldUseCPURendering();
        this._configureRenderingPipeline();
        const result = this.useCPURendering
            ? this._resetCPUFallbackElement()
            : this._resetGPUViewport();
        this.currentImageIdIndex = 0;
        this.targetImageIdIndex = 0;
        this.resetCamera();
        this.initializeElementDisabledHandler();
    }
    setUseCPURendering(value) {
        this.useCPURendering = value;
        this._configureRenderingPipeline(value);
    }
    static get useCustomRenderingPipeline() {
        return getShouldUseCPURendering();
    }
    _configureRenderingPipeline(value) {
        const isContextPool = isContextPoolRenderingEngine();
        this.useCPURendering = value ?? getShouldUseCPURendering();
        for (const key in this.renderingPipelineFunctions) {
            if (Object.prototype.hasOwnProperty.call(this.renderingPipelineFunctions, key)) {
                const functions = this.renderingPipelineFunctions[key];
                if (this.useCPURendering) {
                    this[key] = functions.cpu;
                }
                else {
                    if (typeof functions.gpu === 'object' &&
                        functions.gpu.tiled &&
                        functions.gpu.contextPool) {
                        this[key] = isContextPool
                            ? functions.gpu.contextPool
                            : functions.gpu.tiled;
                    }
                    else {
                        this[key] = functions.gpu;
                    }
                }
            }
        }
        const result = this.useCPURendering
            ? this._resetCPUFallbackElement()
            : this._resetGPUViewport();
    }
    _resetCPUFallbackElement() {
        this._cpuFallbackEnabledElement = {
            canvas: this.canvas,
            renderingTools: {},
            transform: new Transform(),
            viewport: { rotation: 0 },
        };
    }
    _resetGPUViewport() {
        const renderer = this.getRenderer();
        const camera = vtkCamera.newInstance();
        renderer.setActiveCamera(camera);
        const viewPlaneNormal = [0, 0, -1];
        this.initialViewUp = [0, -1, 0];
        camera.setDirectionOfProjection(-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]);
        camera.setViewUp(...this.initialViewUp);
        camera.setParallelProjection(true);
        camera.setThicknessFromFocalPoint(0.1);
        camera.setFreezeFocalPoint(true);
    }
    shouldUseCustomRenderPass() {
        return this.sharpening > 0 && !this.useCPURendering;
    }
    initializeElementDisabledHandler() {
        eventTarget.addEventListener(Events.ELEMENT_DISABLED, function elementDisabledHandler() {
            clearTimeout(this.debouncedTimeout);
            eventTarget.removeEventListener(Events.ELEMENT_DISABLED, elementDisabledHandler);
        });
    }
    getImageDataGPU() {
        const defaultActor = this.getDefaultActor();
        if (!defaultActor) {
            return;
        }
        if (!isImageActor(defaultActor)) {
            return;
        }
        const { actor } = defaultActor;
        const vtkImageData = actor.getMapper().getInputData();
        const csImage = this.csImage;
        return {
            dimensions: vtkImageData.getDimensions(),
            spacing: vtkImageData.getSpacing(),
            origin: vtkImageData.getOrigin(),
            direction: vtkImageData.getDirection(),
            get scalarData() {
                return csImage?.voxelManager.getScalarData();
            },
            imageData: actor.getMapper().getInputData(),
            metadata: {
                Modality: this.modality,
                FrameOfReferenceUID: this.getFrameOfReferenceUID(),
            },
            scaling: this.scaling,
            hasPixelSpacing: this.hasPixelSpacing,
            calibration: { ...csImage?.calibration, ...this.calibration },
            preScale: {
                ...csImage?.preScale,
            },
            voxelManager: csImage?.voxelManager,
        };
    }
    getImageDataCPU() {
        const { metadata } = this._cpuFallbackEnabledElement;
        if (!metadata) {
            return;
        }
        const spacing = metadata.spacing;
        const csImage = this.csImage;
        return {
            dimensions: metadata.dimensions,
            spacing,
            origin: metadata.origin,
            direction: metadata.direction,
            metadata: {
                Modality: this.modality,
                FrameOfReferenceUID: this.getFrameOfReferenceUID(),
            },
            scaling: this.scaling,
            imageData: {
                getDirection: () => metadata.direction,
                getDimensions: () => metadata.dimensions,
                getScalarData: () => this.cpuImagePixelData,
                getSpacing: () => spacing,
                worldToIndex: (point) => {
                    const canvasPoint = this.worldToCanvasCPU(point);
                    const pixelCoord = canvasToPixel(this._cpuFallbackEnabledElement, canvasPoint);
                    return [pixelCoord[0], pixelCoord[1], 0];
                },
                indexToWorld: (point, destPoint) => {
                    const canvasPoint = pixelToCanvas(this._cpuFallbackEnabledElement, [
                        point[0],
                        point[1],
                    ]);
                    return this.canvasToWorldCPU(canvasPoint, destPoint);
                },
            },
            scalarData: this.cpuImagePixelData,
            hasPixelSpacing: this.hasPixelSpacing,
            calibration: { ...csImage?.calibration, ...this.calibration },
            preScale: {
                ...csImage?.preScale,
            },
            voxelManager: csImage?.voxelManager,
        };
    }
    calibrateIfNecessary(imageId, imagePlaneModule) {
        const calibration = metaData.get('calibratedPixelSpacing', imageId);
        const isUpdated = this.calibration !== calibration;
        const { scale } = calibration || {};
        this.hasPixelSpacing = scale > 0 || imagePlaneModule.rowPixelSpacing > 0;
        imagePlaneModule.calibration = calibration;
        if (!isUpdated) {
            return imagePlaneModule;
        }
        this.calibration = calibration;
        this._publishCalibratedEvent = true;
        this._calibrationEvent = {
            scale,
            calibration,
        };
        return imagePlaneModule;
    }
    setDefaultProperties(ViewportProperties, imageId) {
        if (imageId == null) {
            this.globalDefaultProperties = ViewportProperties;
        }
        else {
            this.perImageIdDefaultProperties.set(imageId, ViewportProperties);
            if (this.getCurrentImageId() === imageId) {
                this.setProperties(ViewportProperties);
            }
        }
    }
    clearDefaultProperties(imageId) {
        if (imageId == null) {
            this.globalDefaultProperties = {};
            this.resetProperties();
        }
        else {
            this.perImageIdDefaultProperties.delete(imageId);
            this.resetToDefaultProperties();
        }
    }
    setProperties({ colormap, voiRange, VOILUTFunction, invert, interpolationType, sharpening, } = {}, suppressEvents = false) {
        this.viewportStatus = this.csImage
            ? ViewportStatus.PRE_RENDER
            : ViewportStatus.LOADING;
        this.globalDefaultProperties = {
            colormap: this.globalDefaultProperties.colormap ?? colormap,
            voiRange: this.globalDefaultProperties.voiRange ?? voiRange,
            VOILUTFunction: this.globalDefaultProperties.VOILUTFunction ?? VOILUTFunction,
            invert: this.globalDefaultProperties.invert ?? invert,
            interpolationType: this.globalDefaultProperties.interpolationType ?? interpolationType,
            sharpening: this.globalDefaultProperties.sharpening ?? sharpening,
        };
        if (typeof colormap !== 'undefined') {
            this.setColormap(colormap);
        }
        if (typeof voiRange !== 'undefined') {
            const voiUpdatedWithSetProperties = true;
            this.setVOI(voiRange, { suppressEvents, voiUpdatedWithSetProperties });
        }
        if (typeof VOILUTFunction !== 'undefined') {
            this.setVOILUTFunction(VOILUTFunction, suppressEvents);
        }
        if (typeof invert !== 'undefined') {
            this.setInvertColor(invert);
        }
        if (typeof interpolationType !== 'undefined') {
            this.setInterpolationType(interpolationType);
        }
        if (typeof sharpening !== 'undefined') {
            this.setSharpening(sharpening);
        }
    }
    resetProperties() {
        this.cpuRenderingInvalidated = true;
        this.voiUpdatedWithSetProperties = false;
        this.viewportStatus = ViewportStatus.PRE_RENDER;
        this.fillWithBackgroundColor();
        if (this.useCPURendering) {
            this._cpuFallbackEnabledElement.renderingTools = {};
        }
        this._resetProperties();
        this.render();
    }
    _resetProperties() {
        let voiRange;
        if (this._isCurrentImagePTPrescaled()) {
            voiRange = this._getDefaultPTPrescaledVOIRange();
        }
        else {
            voiRange = this._getVOIRangeForCurrentImage();
        }
        this.setVOI(voiRange);
        this.setInvertColor(this.initialInvert);
        this.setInterpolationType(InterpolationType.LINEAR);
        if (!this.useCPURendering) {
            const transferFunction = this.getTransferFunction();
            setTransferFunctionNodes(transferFunction, this.initialTransferFunctionNodes);
            const nodes = getTransferFunctionNodes(transferFunction);
            const RGBPoints = nodes.reduce((acc, node) => {
                acc.push(node[0], node[1], node[2], node[3]);
                return acc;
            }, []);
            const defaultActor = this.getDefaultActor();
            const matchedColormap = colormapUtils.findMatchingColormap(RGBPoints, defaultActor.actor);
            this.setColormap(matchedColormap);
        }
    }
    resetToDefaultProperties() {
        this.cpuRenderingInvalidated = true;
        this.viewportStatus = ViewportStatus.PRE_RENDER;
        this.fillWithBackgroundColor();
        if (this.useCPURendering) {
            this._cpuFallbackEnabledElement.renderingTools = {};
        }
        const currentImageId = this.getCurrentImageId();
        const properties = this.perImageIdDefaultProperties.get(currentImageId) ||
            this.globalDefaultProperties;
        if (properties.colormap?.name) {
            this.setColormap(properties.colormap);
        }
        let voiRange;
        if (properties.voiRange == undefined) {
            voiRange = this._getVOIRangeForCurrentImage();
        }
        else {
            voiRange = properties.voiRange;
        }
        this.setVOI(voiRange);
        this.setInterpolationType(InterpolationType.LINEAR);
        this.setInvertColor(false);
        this.render();
    }
    _getVOIFromCache() {
        let voiRange;
        if (this.voiUpdatedWithSetProperties) {
            voiRange = this.voiRange;
        }
        else if (this._isCurrentImagePTPrescaled()) {
            voiRange = this._getDefaultPTPrescaledVOIRange();
        }
        else {
            voiRange = this._getVOIRangeForCurrentImage() ?? this.voiRange;
        }
        return voiRange;
    }
    _setPropertiesFromCache() {
        const voiRange = this._getVOIFromCache();
        const { interpolationType, invert } = this;
        this.setVOI(voiRange);
        this.setInterpolationType(interpolationType);
        this.setInvertColor(invert);
    }
    getCameraCPU() {
        const { metadata, viewport } = this._cpuFallbackEnabledElement;
        if (!metadata) {
            return {};
        }
        const { direction } = metadata;
        const viewPlaneNormal = direction.slice(6, 9).map((x) => -x);
        let viewUp = direction.slice(3, 6).map((x) => -x);
        if (viewport.rotation) {
            const rotationMatrix = mat4.fromRotation(mat4.create(), (viewport.rotation * Math.PI) / 180, viewPlaneNormal);
            viewUp = vec3.transformMat4(vec3.create(), viewUp, rotationMatrix);
        }
        const canvasCenter = [
            this.element.clientWidth / 2,
            this.element.clientHeight / 2,
        ];
        const canvasCenterWorld = this.canvasToWorld(canvasCenter);
        const topLeftWorld = this.canvasToWorld([0, 0]);
        const bottomLeftWorld = this.canvasToWorld([0, this.element.clientHeight]);
        const parallelScale = vec3.distance(topLeftWorld, bottomLeftWorld) / 2;
        return {
            parallelProjection: true,
            focalPoint: canvasCenterWorld,
            position: [0, 0, 0],
            parallelScale,
            scale: viewport.scale,
            viewPlaneNormal: [
                viewPlaneNormal[0],
                viewPlaneNormal[1],
                viewPlaneNormal[2],
            ],
            viewUp: [viewUp[0], viewUp[1], viewUp[2]],
            flipHorizontal: this.flipHorizontal,
            flipVertical: this.flipVertical,
        };
    }
    setCameraCPU(cameraInterface) {
        const { viewport, image } = this._cpuFallbackEnabledElement;
        const previousCamera = this.getCameraCPU();
        const { focalPoint, parallelScale, scale, flipHorizontal, flipVertical } = cameraInterface;
        const { clientHeight } = this.element;
        if (focalPoint) {
            const focalPointCanvas = this.worldToCanvasCPU(focalPoint);
            const focalPointPixel = canvasToPixel(this._cpuFallbackEnabledElement, focalPointCanvas);
            const prevFocalPointCanvas = this.worldToCanvasCPU(previousCamera.focalPoint);
            const prevFocalPointPixel = canvasToPixel(this._cpuFallbackEnabledElement, prevFocalPointCanvas);
            const deltaPixel = vec2.create();
            vec2.subtract(deltaPixel, vec2.fromValues(focalPointPixel[0], focalPointPixel[1]), vec2.fromValues(prevFocalPointPixel[0], prevFocalPointPixel[1]));
            const shift = correctShift({ x: deltaPixel[0], y: deltaPixel[1] }, viewport);
            viewport.translation.x -= shift.x;
            viewport.translation.y -= shift.y;
        }
        if (parallelScale) {
            const { rowPixelSpacing } = image;
            const scale = (clientHeight * rowPixelSpacing * 0.5) / parallelScale;
            viewport.scale = scale;
            viewport.parallelScale = parallelScale;
        }
        if (scale) {
            const { rowPixelSpacing } = image;
            viewport.scale = scale;
            viewport.parallelScale = (clientHeight * rowPixelSpacing * 0.5) / scale;
        }
        if (flipHorizontal !== undefined || flipVertical !== undefined) {
            this.setFlipCPU({ flipHorizontal, flipVertical });
        }
        this._cpuFallbackEnabledElement.transform = calculateTransform(this._cpuFallbackEnabledElement);
        const eventDetail = {
            previousCamera,
            camera: this.getCamera(),
            element: this.element,
            viewportId: this.id,
            renderingEngineId: this.renderingEngineId,
        };
        triggerEvent(this.element, Events.CAMERA_MODIFIED, eventDetail);
    }
    getPanCPU() {
        const { viewport } = this._cpuFallbackEnabledElement;
        return [viewport.translation?.x ?? 0, viewport.translation?.y ?? 0];
    }
    setPanCPU(pan) {
        const camera = this.getCameraCPU();
        this.setCameraCPU({
            ...camera,
            focalPoint: [...pan.map((p) => -p), 0],
        });
    }
    getZoomCPU() {
        const { viewport } = this._cpuFallbackEnabledElement;
        return viewport.scale;
    }
    setZoomCPU(zoom) {
        const camera = this.getCameraCPU();
        this.setCameraCPU({ ...camera, scale: zoom });
    }
    setFlipCPU({ flipHorizontal, flipVertical }) {
        const { viewport } = this._cpuFallbackEnabledElement;
        if (flipHorizontal !== undefined) {
            viewport.hflip = flipHorizontal;
            this.flipHorizontal = viewport.hflip;
        }
        if (flipVertical !== undefined) {
            viewport.vflip = flipVertical;
            this.flipVertical = viewport.vflip;
        }
    }
    setVOILUTFunction(voiLUTFunction, suppressEvents) {
        if (this.useCPURendering) {
            throw new Error('VOI LUT function is not supported in CPU rendering');
        }
        const newVOILUTFunction = this._getValidVOILUTFunction(voiLUTFunction);
        let forceRecreateLUTFunction = false;
        if (this.VOILUTFunction !== newVOILUTFunction) {
            forceRecreateLUTFunction = true;
        }
        this.VOILUTFunction = newVOILUTFunction;
        const { voiRange } = this.getProperties();
        this.setVOI(voiRange, { suppressEvents, forceRecreateLUTFunction });
    }
    setRotationCPU(rotation) {
        const { viewport } = this._cpuFallbackEnabledElement;
        viewport.rotation = rotation;
    }
    setRotationGPU(rotation) {
        const panFit = this.getPan(this.fitToCanvasCamera);
        const pan = this.getPan();
        const panSub = vec2.sub([0, 0], panFit, pan);
        this.setPan(panSub, false);
        const { flipVertical, flipHorizontal, viewPlaneNormal } = this.getCamera();
        const adjustedViewUp = adjustInitialViewUp(this.initialViewUp, flipHorizontal, flipVertical, viewPlaneNormal);
        this.setCameraNoEvent({
            viewUp: adjustedViewUp,
        });
        this.getVtkActiveCamera().roll(-rotation);
        const afterPan = this.getPan();
        const afterPanFit = this.getPan(this.fitToCanvasCamera);
        const newCenter = vec2.sub([0, 0], afterPan, afterPanFit);
        const newOffset = vec2.add([0, 0], panFit, newCenter);
        this.setPan(newOffset, false);
    }
    setInterpolationTypeGPU(interpolationType) {
        const defaultActor = this.getDefaultActor();
        if (!defaultActor) {
            return;
        }
        if (!isImageActor(defaultActor)) {
            return;
        }
        const { actor } = defaultActor;
        const volumeProperty = actor.getProperty();
        volumeProperty.setInterpolationType(interpolationType);
        this.interpolationType = interpolationType;
    }
    setInterpolationTypeCPU(interpolationType) {
        const { viewport } = this._cpuFallbackEnabledElement;
        viewport.pixelReplication =
            interpolationType === InterpolationType.LINEAR ? false : true;
        this.interpolationType = interpolationType;
    }
    setInvertColorCPU(invert) {
        const { viewport } = this._cpuFallbackEnabledElement;
        if (!viewport) {
            return;
        }
        viewport.invert = invert;
        this.invert = invert;
    }
    setInvertColorGPU(invert) {
        const defaultActor = this.getDefaultActor();
        if (!defaultActor) {
            return;
        }
        if (!isImageActor(defaultActor)) {
            return;
        }
        if (actorIsA(defaultActor, 'vtkVolume')) {
            const volumeActor = defaultActor.actor;
            const tfunc = volumeActor.getProperty().getRGBTransferFunction(0);
            if ((!this.invert && invert) || (this.invert && !invert)) {
                invertRgbTransferFunction(tfunc);
            }
            this.invert = invert;
        }
        else if (actorIsA(defaultActor, 'vtkImageSlice')) {
            const imageSliceActor = defaultActor.actor;
            const tfunc = imageSliceActor.getProperty().getRGBTransferFunction(0);
            if ((!this.invert && invert) || (this.invert && !invert)) {
                invertRgbTransferFunction(tfunc);
            }
            this.invert = invert;
        }
    }
    setVOICPU(voiRange, options = {}) {
        const { suppressEvents = false } = options;
        const { viewport, image } = this._cpuFallbackEnabledElement;
        if (!viewport || !image) {
            return;
        }
        if (typeof voiRange === 'undefined') {
            const { windowWidth: ww, windowCenter: wc } = image;
            const wwToUse = Array.isArray(ww) ? ww[0] : ww;
            const wcToUse = Array.isArray(wc) ? wc[0] : wc;
            viewport.voi = {
                windowWidth: wwToUse,
                windowCenter: wcToUse,
                voiLUTFunction: image.voiLUTFunction,
            };
            const { lower, upper } = windowLevelUtil.toLowHighRange(wwToUse, wcToUse, image.voiLUTFunction);
            voiRange = { lower, upper };
        }
        else {
            const { lower, upper } = voiRange;
            const { windowCenter, windowWidth } = windowLevelUtil.toWindowLevel(lower, upper);
            if (!viewport.voi) {
                viewport.voi = {
                    windowWidth: 0,
                    windowCenter: 0,
                    voiLUTFunction: image.voiLUTFunction,
                };
            }
            viewport.voi.windowWidth = windowWidth;
            viewport.voi.windowCenter = windowCenter;
        }
        this.voiRange = voiRange;
        const eventDetail = {
            viewportId: this.id,
            range: voiRange,
        };
        if (!suppressEvents) {
            triggerEvent(this.element, Events.VOI_MODIFIED, eventDetail);
        }
    }
    getTransferFunction() {
        const defaultActor = this.getDefaultActor();
        if (!defaultActor) {
            return;
        }
        if (!isImageActor(defaultActor)) {
            return;
        }
        const imageActor = defaultActor.actor;
        return imageActor.getProperty().getRGBTransferFunction(0);
    }
    setVOIGPU(voiRange, options = {}) {
        const { suppressEvents = false, forceRecreateLUTFunction = false, voiUpdatedWithSetProperties = false, } = options;
        if (voiRange &&
            this.voiRange &&
            this.voiRange.lower === voiRange.lower &&
            this.voiRange.upper === voiRange.upper &&
            !forceRecreateLUTFunction &&
            !this.stackInvalidated) {
            return;
        }
        const defaultActor = this.getDefaultActor();
        if (!defaultActor) {
            return;
        }
        if (!isImageActor(defaultActor)) {
            return;
        }
        const imageActor = defaultActor.actor;
        let voiRangeToUse = voiRange;
        if (typeof voiRangeToUse === 'undefined') {
            const imageData = imageActor.getMapper().getInputData();
            const range = imageData.getPointData().getScalars().getRange();
            const maxVoiRange = { lower: range[0], upper: range[1] };
            voiRangeToUse = maxVoiRange;
        }
        imageActor.getProperty().setUseLookupTableScalarRange(true);
        let transferFunction = imageActor.getProperty().getRGBTransferFunction(0);
        const isSigmoidTFun = this.VOILUTFunction === VOILUTFunctionType.SAMPLED_SIGMOID;
        if (isSigmoidTFun || !transferFunction || forceRecreateLUTFunction) {
            const transferFunctionCreator = isSigmoidTFun
                ? createSigmoidRGBTransferFunction
                : createLinearRGBTransferFunction;
            transferFunction = transferFunctionCreator(voiRangeToUse);
            if (this.invert) {
                invertRgbTransferFunction(transferFunction);
            }
            imageActor.getProperty().setRGBTransferFunction(0, transferFunction);
            this.initialTransferFunctionNodes =
                getTransferFunctionNodes(transferFunction);
        }
        if (!isSigmoidTFun) {
            transferFunction.setRange(voiRangeToUse.lower, voiRangeToUse.upper);
        }
        this.voiRange = voiRangeToUse;
        if (!this.voiUpdatedWithSetProperties) {
            this.voiUpdatedWithSetProperties = voiUpdatedWithSetProperties;
        }
        if (suppressEvents) {
            return;
        }
        const eventDetail = {
            viewportId: this.id,
            range: voiRangeToUse,
            VOILUTFunction: this.VOILUTFunction,
        };
        triggerEvent(this.element, Events.VOI_MODIFIED, eventDetail);
    }
    _addScalingToViewport(imageIdScalingFactor) {
        if (this.scaling.PT) {
            return;
        }
        const { suvbw, suvlbm, suvbsa } = imageIdScalingFactor;
        const ptScaling = {};
        if (suvlbm) {
            ptScaling.suvbwToSuvlbm = suvlbm / suvbw;
        }
        if (suvbsa) {
            ptScaling.suvbwToSuvbsa = suvbsa / suvbw;
        }
        this.scaling.PT = ptScaling;
    }
    getImageDataMetadata(image) {
        const imageId = image.imageId;
        const props = getImageDataMetadataUtil(image);
        const { numberOfComponents, origin, direction, dimensions, spacing, numVoxels, imagePixelModule, voiLUTFunction, modality, scalingFactor, calibration, } = props;
        if (modality === 'PT' && scalingFactor) {
            this._addScalingToViewport(scalingFactor);
        }
        this.modality = modality;
        const voiLUTFunctionEnum = this._getValidVOILUTFunction(voiLUTFunction);
        this.VOILUTFunction = voiLUTFunctionEnum;
        this.calibration = calibration;
        let imagePlaneModule = this._getImagePlaneModule(imageId);
        if (!this.useCPURendering) {
            imagePlaneModule = this.calibrateIfNecessary(imageId, imagePlaneModule);
        }
        return {
            bitsAllocated: imagePixelModule.bitsAllocated,
            numberOfComponents,
            origin,
            direction,
            dimensions,
            spacing,
            numVoxels,
            imagePlaneModule,
            imagePixelModule,
        };
    }
    matchImagesForOverlay(currentImageId, targetOverlayImageId) {
        const matchImagesForOverlay = (targetImageId) => {
            const overlayImagePlaneModule = metaData.get(MetadataModules.IMAGE_PLANE, targetOverlayImageId);
            const currentImagePlaneModule = metaData.get(MetadataModules.IMAGE_PLANE, targetImageId);
            const overlayOrientation = overlayImagePlaneModule.imageOrientationPatient;
            const currentOrientation = currentImagePlaneModule.imageOrientationPatient;
            if (overlayOrientation && currentOrientation) {
                const closeEnough = isEqual(overlayImagePlaneModule.imageOrientationPatient, currentImagePlaneModule.imageOrientationPatient);
                if (closeEnough) {
                    const referencePosition = overlayImagePlaneModule.imagePositionPatient;
                    const currentPosition = currentImagePlaneModule.imagePositionPatient;
                    if (referencePosition && currentPosition) {
                        const closeEnough = isEqual(referencePosition, currentPosition);
                        if (closeEnough) {
                            const referenceRows = overlayImagePlaneModule.rows;
                            const referenceColumns = overlayImagePlaneModule.columns;
                            const currentRows = currentImagePlaneModule.rows;
                            const currentColumns = currentImagePlaneModule.columns;
                            if (referenceRows === currentRows &&
                                referenceColumns === currentColumns) {
                                return targetImageId;
                            }
                        }
                    }
                }
            }
            else {
                const referenceRows = overlayImagePlaneModule.rows;
                const referenceColumns = overlayImagePlaneModule.columns;
                const currentRows = currentImagePlaneModule.rows;
                const currentColumns = currentImagePlaneModule.columns;
                if (referenceRows === currentRows &&
                    referenceColumns === currentColumns) {
                    return targetImageId;
                }
            }
        };
        return matchImagesForOverlay(currentImageId);
    }
    getImagePlaneReferenceData(sliceIndex = this.getCurrentImageIdIndex()) {
        const imageId = this.imageIds[sliceIndex];
        if (!imageId) {
            return;
        }
        const imagePlaneModule = metaData.get(MetadataModules.IMAGE_PLANE, imageId);
        if (!imagePlaneModule) {
            return;
        }
        const { imagePositionPatient, frameOfReferenceUID: FrameOfReferenceUID } = imagePlaneModule;
        let { rowCosines, columnCosines } = imagePlaneModule;
        rowCosines ||= [1, 0, 0];
        columnCosines ||= [0, 1, 0];
        const viewPlaneNormal = vec3.cross([0, 0, 0], columnCosines, rowCosines);
        return {
            FrameOfReferenceUID,
            viewPlaneNormal,
            cameraFocalPoint: imagePositionPatient,
            referencedImageId: imageId,
            sliceIndex,
        };
    }
    _getCameraOrientation(imageDataDirection) {
        const viewPlaneNormal = imageDataDirection.slice(6, 9).map((x) => -x);
        const viewUp = imageDataDirection.slice(3, 6).map((x) => -x);
        return {
            viewPlaneNormal: [
                viewPlaneNormal[0],
                viewPlaneNormal[1],
                viewPlaneNormal[2],
            ],
            viewUp: [viewUp[0], viewUp[1], viewUp[2]],
        };
    }
    createVTKImageData({ origin, direction, dimensions, spacing, numberOfComponents, pixelArray, }) {
        const values = new pixelArray.constructor(pixelArray.length);
        const scalarArray = vtkDataArray.newInstance({
            name: 'Pixels',
            numberOfComponents: numberOfComponents,
            values: values,
        });
        const imageData = vtkImageData.newInstance();
        imageData.setDimensions(dimensions);
        imageData.setSpacing(spacing);
        imageData.setDirection(direction);
        imageData.setOrigin(origin);
        imageData.getPointData().setScalars(scalarArray);
        return imageData;
    }
    _createVTKImageData({ origin, direction, dimensions, spacing, numberOfComponents, pixelArray, }) {
        try {
            this._imageData = this.createVTKImageData({
                origin,
                direction,
                dimensions,
                spacing,
                numberOfComponents,
                pixelArray,
            });
        }
        catch (e) {
            log.error(e);
        }
    }
    async setStack(imageIds, currentImageIdIndex = 0) {
        this._throwIfDestroyed();
        this.imageIds = imageIds;
        if (currentImageIdIndex > imageIds.length) {
            throw new Error('Current image index is greater than the number of images in the stack');
        }
        this.imageKeyToIndexMap.clear();
        imageIds.forEach((imageId, index) => {
            this.imageKeyToIndexMap.set(imageId, index);
            this.imageKeyToIndexMap.set(imageIdToURI(imageId), index);
        });
        this.currentImageIdIndex = currentImageIdIndex;
        this.targetImageIdIndex = currentImageIdIndex;
        const imageRetrieveConfiguration = metaData.get(imageRetrieveMetadataProvider.IMAGE_RETRIEVE_CONFIGURATION, imageIds[currentImageIdIndex], 'stack');
        this.imagesLoader = imageRetrieveConfiguration
            ? (imageRetrieveConfiguration.create || createProgressive)(imageRetrieveConfiguration)
            : this;
        this.stackInvalidated = true;
        this.flipVertical = false;
        this.flipHorizontal = false;
        this.voiRange = null;
        this.interpolationType = InterpolationType.LINEAR;
        this.invert = false;
        this.viewportStatus = ViewportStatus.LOADING;
        this.fillWithBackgroundColor();
        if (this.useCPURendering) {
            this._cpuFallbackEnabledElement.renderingTools = {};
            delete this._cpuFallbackEnabledElement.viewport.colormap;
        }
        const imageId = await this._setImageIdIndex(currentImageIdIndex);
        const eventDetail = {
            imageIds,
            viewportId: this.id,
            element: this.element,
            currentImageIdIndex: currentImageIdIndex,
        };
        triggerEvent(this.element, Events.VIEWPORT_NEW_IMAGE_SET, eventDetail);
        return imageId;
    }
    _throwIfDestroyed() {
        if (this.isDisabled) {
            throw new Error('The stack viewport has been destroyed and is no longer usable. Renderings will not be performed. If you ' +
                'are using the same viewportId and have re-enabled the viewport, you need to grab the new viewport instance ' +
                'using renderingEngine.getViewport(viewportId), instead of using your lexical scoped reference to the viewport instance.');
        }
    }
    _checkVTKImageDataMatchesCornerstoneImage(image, imageData) {
        if (!imageData) {
            return false;
        }
        const [xSpacing, ySpacing] = imageData.getSpacing();
        const [xVoxels, yVoxels] = imageData.getDimensions();
        const imagePlaneModule = this._getImagePlaneModule(image.imageId);
        const direction = imageData.getDirection();
        const rowCosines = direction.slice(0, 3);
        const columnCosines = direction.slice(3, 6);
        const dataType = imageData.getPointData().getScalars().getDataType();
        const isSameXSpacing = isEqual(xSpacing, image.columnPixelSpacing);
        const isSameYSpacing = isEqual(ySpacing, image.rowPixelSpacing);
        const isXSpacingValid = isSameXSpacing || (image.columnPixelSpacing === null && xSpacing === 1.0);
        const isYSpacingValid = isSameYSpacing || (image.rowPixelSpacing === null && ySpacing === 1.0);
        const isXVoxelsMatching = xVoxels === image.columns;
        const isYVoxelsMatching = yVoxels === image.rows;
        const isRowCosinesMatching = isEqual(imagePlaneModule.rowCosines, rowCosines);
        const isColumnCosinesMatching = isEqual(imagePlaneModule.columnCosines, columnCosines);
        const isDataTypeMatching = dataType === image.voxelManager.getScalarData().constructor.name;
        const result = isXSpacingValid &&
            isYSpacingValid &&
            isXVoxelsMatching &&
            isYVoxelsMatching &&
            isRowCosinesMatching &&
            isColumnCosinesMatching &&
            isDataTypeMatching;
        return result;
    }
    _updateVTKImageDataFromCornerstoneImage(image) {
        const imagePlaneModule = this._getImagePlaneModule(image.imageId);
        let origin = imagePlaneModule.imagePositionPatient;
        if (origin == null) {
            origin = [0, 0, 0];
        }
        this._imageData.setOrigin(origin);
        const actor = this.getActor(this.id);
        if (actor) {
            actor.referencedId = image.imageId;
        }
        updateVTKImageDataWithCornerstoneImage(this._imageData, image);
    }
    _loadAndDisplayImage(imageId, imageIdIndex) {
        return this.useCPURendering
            ? this._loadAndDisplayImageCPU(imageId, imageIdIndex)
            : this._loadAndDisplayImageGPU(imageId, imageIdIndex);
    }
    _loadAndDisplayImageCPU(imageId, imageIdIndex) {
        return new Promise((resolve, reject) => {
            function successCallback(image, imageIdIndex, imageId) {
                if (this.currentImageIdIndex !== imageIdIndex) {
                    return;
                }
                const pixelData = image.voxelManager.getScalarData();
                const preScale = image.preScale;
                const scalingParams = preScale?.scalingParameters;
                const scaledWithNonIntegers = (preScale?.scaled && scalingParams?.rescaleIntercept % 1 !== 0) ||
                    scalingParams?.rescaleSlope % 1 !== 0;
                if (pixelData instanceof Float32Array && scaledWithNonIntegers) {
                    const floatMinMax = {
                        min: image.minPixelValue,
                        max: image.maxPixelValue,
                    };
                    const floatRange = Math.abs(floatMinMax.max - floatMinMax.min);
                    const intRange = 65535;
                    const slope = floatRange / intRange;
                    const intercept = floatMinMax.min;
                    const numPixels = pixelData.length;
                    const intPixelData = new Uint16Array(numPixels);
                    let min = 65535;
                    let max = 0;
                    for (let i = 0; i < numPixels; i++) {
                        const rescaledPixel = Math.floor((pixelData[i] - intercept) / slope);
                        intPixelData[i] = rescaledPixel;
                        min = Math.min(min, rescaledPixel);
                        max = Math.max(max, rescaledPixel);
                    }
                    image.minPixelValue = min;
                    image.maxPixelValue = max;
                    image.slope = slope;
                    image.intercept = intercept;
                    if (image.voxelManager) {
                        image.voxelManager.getScalarData = () => intPixelData;
                    }
                    else {
                        image.getPixelData = () => intPixelData;
                    }
                    image.preScale = {
                        ...image.preScale,
                        scaled: false,
                    };
                }
                this._setCSImage(image);
                this.viewportStatus = ViewportStatus.PRE_RENDER;
                const eventDetail = {
                    image,
                    imageId,
                    imageIdIndex,
                    viewportId: this.id,
                    renderingEngineId: this.renderingEngineId,
                };
                triggerEvent(this.element, Events.STACK_NEW_IMAGE, eventDetail);
                this._updateToDisplayImageCPU(image);
                this.render();
                this.currentImageIdIndex = imageIdIndex;
                resolve(imageId);
            }
            function errorCallback(error, imageIdIndex, imageId) {
                const eventDetail = {
                    error,
                    imageIdIndex,
                    imageId,
                };
                if (!this.suppressEvents) {
                    triggerEvent(eventTarget, Events.IMAGE_LOAD_ERROR, eventDetail);
                }
                reject(error);
            }
            function sendRequest(imageId, imageIdIndex, options) {
                return loadAndCacheImage(imageId, options).then((image) => {
                    successCallback.call(this, image, imageIdIndex, imageId);
                }, (error) => {
                    errorCallback.call(this, error, imageIdIndex, imageId);
                });
            }
            const priority = -5;
            const requestType = RequestType.Interaction;
            const additionalDetails = { imageId, imageIdIndex };
            const options = {
                useRGBA: true,
                requestType,
            };
            const eventDetail = {
                imageId,
                imageIdIndex,
                viewportId: this.id,
                renderingEngineId: this.renderingEngineId,
            };
            triggerEvent(this.element, Events.PRE_STACK_NEW_IMAGE, eventDetail);
            imageLoadPoolManager.addRequest(sendRequest.bind(this, imageId, imageIdIndex, options), requestType, additionalDetails, priority);
        });
    }
    successCallback(imageId, image) {
        const imageIdIndex = this.imageIds.indexOf(imageId);
        if (this.currentImageIdIndex !== imageIdIndex) {
            return;
        }
        const csImgFrame = this.csImage?.imageFrame;
        const imgFrame = image?.imageFrame;
        const photometricInterpretation = csImgFrame?.photometricInterpretation ||
            this.csImage?.photometricInterpretation;
        const newPhotometricInterpretation = imgFrame?.photometricInterpretation || image?.photometricInterpretation;
        if (photometricInterpretation !== newPhotometricInterpretation) {
            this.stackInvalidated = true;
        }
        this._setCSImage(image);
        const eventDetail = {
            image,
            imageId,
            imageIdIndex,
            viewportId: this.id,
            renderingEngineId: this.renderingEngineId,
        };
        this._updateActorToDisplayImageId(image);
        triggerEvent(this.element, Events.STACK_NEW_IMAGE, eventDetail);
        this.render();
        this.currentImageIdIndex = imageIdIndex;
    }
    errorCallback(imageId, permanent, error) {
        if (!permanent) {
            return;
        }
        const imageIdIndex = this.imageIds.indexOf(imageId);
        const eventDetail = {
            error,
            imageIdIndex,
            imageId,
        };
        triggerEvent(eventTarget, Events.IMAGE_LOAD_ERROR, eventDetail);
    }
    getLoaderImageOptions(imageId) {
        const imageIdIndex = this.imageIds.indexOf(imageId);
        const { transferSyntaxUID } = metaData.get('transferSyntax', imageId) || {};
        const options = {
            useRGBA: false,
            transferSyntaxUID,
            priority: 5,
            requestType: RequestType.Interaction,
            additionalDetails: { imageId, imageIdIndex },
        };
        return options;
    }
    async loadImages(imageIds, listener) {
        const resultList = await Promise.allSettled(imageIds.map((imageId) => {
            const options = this.getLoaderImageOptions(imageId);
            return loadAndCacheImage(imageId, options).then((image) => {
                listener.successCallback(imageId, image);
                return imageId;
            }, (error) => {
                listener.errorCallback(imageId, true, error);
                return imageId;
            });
        }));
        const errorList = resultList.filter((item) => item.status === 'rejected');
        if (errorList && errorList.length) {
            const event = new CustomEvent(Events.IMAGE_LOAD_ERROR, {
                detail: errorList,
                cancelable: true,
            });
            eventTarget.dispatchEvent(event);
        }
        return resultList;
    }
    _loadAndDisplayImageGPU(imageId, imageIdIndex) {
        if (!imageId) {
            console.warn('No image id set yet to load');
            return;
        }
        const eventDetail = {
            imageId,
            imageIdIndex,
            viewportId: this.id,
            renderingEngineId: this.renderingEngineId,
        };
        triggerEvent(this.element, Events.PRE_STACK_NEW_IMAGE, eventDetail);
        return this.imagesLoader.loadImages([imageId], this).then(() => {
            return imageId;
        });
    }
    _updateToDisplayImageCPU(image) {
        const metadata = this.getImageDataMetadata(image);
        const viewport = getDefaultViewport(this.canvas, image, this.modality, this._cpuFallbackEnabledElement.viewport.colormap);
        const { windowCenter, windowWidth, voiLUTFunction } = viewport.voi;
        this.voiRange = windowLevelUtil.toLowHighRange(windowWidth, windowCenter, voiLUTFunction);
        this._cpuFallbackEnabledElement.image = image;
        this._cpuFallbackEnabledElement.metadata = {
            ...metadata,
        };
        this.cpuImagePixelData = image.voxelManager.getScalarData();
        const viewportSettingToUse = Object.assign({}, viewport, this._cpuFallbackEnabledElement.viewport);
        this._cpuFallbackEnabledElement.viewport = this.stackInvalidated
            ? viewport
            : viewportSettingToUse;
        this.stackInvalidated = false;
        this.cpuRenderingInvalidated = true;
        this._cpuFallbackEnabledElement.transform = calculateTransform(this._cpuFallbackEnabledElement);
    }
    getSliceViewInfo() {
        throw new Error('Method not implemented.');
    }
    addImages(stackInputs) {
        const actors = [];
        stackInputs.forEach((stackInput) => {
            const { imageId, ...rest } = stackInput;
            const image = cache.getImage(imageId);
            const { origin, dimensions, direction, spacing, numberOfComponents } = this.getImageDataMetadata(image);
            const imagedata = this.createVTKImageData({
                origin,
                dimensions,
                direction,
                spacing,
                numberOfComponents,
                pixelArray: image.voxelManager.getScalarData(),
            });
            const imageActor = this.createActorMapper(imagedata);
            if (imageActor) {
                actors.push({
                    uid: stackInput.actorUID ?? uuidv4(),
                    actor: imageActor,
                    referencedId: imageId,
                    ...rest,
                });
                if (stackInput.callback) {
                    stackInput.callback({ imageActor, imageId: stackInput.imageId });
                }
            }
        });
        this.addActors(actors);
    }
    _updateActorToDisplayImageId(image) {
        const sameImageData = this._checkVTKImageDataMatchesCornerstoneImage(image, this._imageData);
        const viewPresentation = this.getViewPresentation();
        if (sameImageData && !this.stackInvalidated) {
            this._updateVTKImageDataFromCornerstoneImage(image);
            this.resetCameraNoEvent();
            this.setViewPresentation(viewPresentation);
            this._setPropertiesFromCache();
            this.stackActorReInitialized = false;
            return;
        }
        const { origin, direction, dimensions, spacing, numberOfComponents, imagePixelModule, } = this.getImageDataMetadata(image);
        const pixelArray = image.voxelManager.getScalarData();
        this._createVTKImageData({
            origin,
            direction,
            dimensions,
            spacing,
            numberOfComponents,
            pixelArray,
        });
        this._updateVTKImageDataFromCornerstoneImage(image);
        const actor = this.createActorMapper(this._imageData);
        const oldActors = this.getActors();
        if (oldActors.length && oldActors[0].uid === this.id) {
            oldActors[0].actor = actor;
        }
        else {
            oldActors.unshift({ uid: this.id, actor, referencedId: image.imageId });
        }
        this.setActors(oldActors);
        const { viewPlaneNormal, viewUp } = this._getCameraOrientation(direction);
        const previousCamera = this.getCamera();
        this.setCameraNoEvent({ viewUp, viewPlaneNormal });
        this.initialViewUp = viewUp;
        this.resetCameraNoEvent();
        this.setViewPresentation(viewPresentation);
        this.triggerCameraEvent(this.getCamera(), previousCamera);
        const monochrome1 = imagePixelModule.photometricInterpretation === 'MONOCHROME1';
        this.stackInvalidated = true;
        const voiRange = this._getInitialVOIRange(image);
        this.setVOI(voiRange, {
            forceRecreateLUTFunction: !!monochrome1,
        });
        this.initialInvert = !!monochrome1;
        this.setInvertColor(this.invert || this.initialInvert);
        this.stackInvalidated = false;
        this.stackActorReInitialized = true;
        if (this._publishCalibratedEvent) {
            this.triggerCalibrationEvent();
        }
    }
    _getInitialVOIRange(image) {
        if (this.voiRange && this.voiUpdatedWithSetProperties) {
            return this.voiRange;
        }
        const { windowCenter, windowWidth, voiLUTFunction } = image;
        let voiRange = this._getVOIRangeFromWindowLevel(windowWidth, windowCenter, voiLUTFunction);
        voiRange = this._getPTPreScaledRange() || voiRange;
        return voiRange;
    }
    _getPTPreScaledRange() {
        if (!this._isCurrentImagePTPrescaled()) {
            return undefined;
        }
        return this._getDefaultPTPrescaledVOIRange();
    }
    _isCurrentImagePTPrescaled() {
        if (this.modality !== 'PT' || !this.csImage.isPreScaled) {
            return false;
        }
        if (!this.csImage.preScale?.scalingParameters.suvbw) {
            return false;
        }
        return true;
    }
    _getDefaultPTPrescaledVOIRange() {
        return { lower: 0, upper: 5 };
    }
    _getVOIRangeFromWindowLevel(windowWidth, windowCenter, voiLUTFunction = VOILUTFunctionType.LINEAR) {
        let center, width;
        if (typeof windowCenter === 'number' && typeof windowWidth === 'number') {
            center = windowCenter;
            width = windowWidth;
        }
        else if (Array.isArray(windowCenter) && Array.isArray(windowWidth)) {
            center = windowCenter[0];
            width = windowWidth[0];
        }
        if (center !== undefined && width !== undefined) {
            return windowLevelUtil.toLowHighRange(width, center, voiLUTFunction);
        }
    }
    async _setImageIdIndex(imageIdIndex) {
        if (imageIdIndex >= this.imageIds.length) {
            throw new Error(`ImageIdIndex provided ${imageIdIndex} is invalid, the stack only has ${this.imageIds.length} elements`);
        }
        this.currentImageIdIndex = imageIdIndex;
        this.hasPixelSpacing = true;
        this.viewportStatus = ViewportStatus.PRE_RENDER;
        const imageId = await this._loadAndDisplayImage(this.imageIds[imageIdIndex], imageIdIndex);
        if (this.perImageIdDefaultProperties.size >= 1) {
            const defaultProperties = this.perImageIdDefaultProperties.get(imageId);
            if (defaultProperties !== undefined) {
                this.setProperties(defaultProperties);
            }
            else if (this.globalDefaultProperties !== undefined) {
                this.setProperties(this.globalDefaultProperties);
            }
        }
        return imageId;
    }
    resetCameraCPU({ resetPan = true, resetZoom = true, }) {
        const { image } = this._cpuFallbackEnabledElement;
        if (!image) {
            return;
        }
        resetCamera(this._cpuFallbackEnabledElement, resetPan, resetZoom);
        const { scale } = this._cpuFallbackEnabledElement.viewport;
        const { clientWidth, clientHeight } = this.element;
        const center = [clientWidth / 2, clientHeight / 2];
        const centerWorld = this.canvasToWorldCPU(center);
        this.setCameraCPU({
            focalPoint: centerWorld,
            scale,
        });
    }
    resetCameraGPU({ resetPan, resetZoom }) {
        this.setCamera({
            flipHorizontal: false,
            flipVertical: false,
            viewUp: this.initialViewUp,
        });
        const resetToCenter = true;
        return super.resetCamera({ resetPan, resetZoom, resetToCenter });
    }
    scroll(delta, debounce = true, loop = false) {
        const imageIds = this.imageIds;
        if (isNaN(this.targetImageIdIndex)) {
            return;
        }
        const currentTargetImageIdIndex = this.targetImageIdIndex;
        const numberOfFrames = imageIds.length;
        let newTargetImageIdIndex = currentTargetImageIdIndex + delta;
        if (loop) {
            newTargetImageIdIndex =
                (newTargetImageIdIndex + numberOfFrames) % numberOfFrames;
        }
        else {
            newTargetImageIdIndex = Math.max(0, Math.min(numberOfFrames - 1, newTargetImageIdIndex));
        }
        this.targetImageIdIndex = newTargetImageIdIndex;
        const targetImageId = imageIds[newTargetImageIdIndex];
        const imageAlreadyLoaded = cache.isLoaded(targetImageId);
        if (imageAlreadyLoaded || !debounce) {
            this.setImageIdIndex(newTargetImageIdIndex);
        }
        else {
            clearTimeout(this.debouncedTimeout);
            this.debouncedTimeout = window.setTimeout(() => {
                this.setImageIdIndex(newTargetImageIdIndex);
            }, 40);
        }
        const eventData = {
            newImageIdIndex: newTargetImageIdIndex,
            imageId: targetImageId,
            direction: delta,
        };
        if (newTargetImageIdIndex !== currentTargetImageIdIndex) {
            triggerEvent(this.element, Events.STACK_VIEWPORT_SCROLL, eventData);
        }
    }
    setImageIdIndex(imageIdIndex) {
        this._throwIfDestroyed();
        if (this.currentImageIdIndex === imageIdIndex) {
            return Promise.resolve(this.getCurrentImageId());
        }
        const imageIdPromise = this._setImageIdIndex(imageIdIndex);
        this.targetImageIdIndex = imageIdIndex;
        return imageIdPromise;
    }
    calibrateSpacing(imageId) {
        const imageIdIndex = this.getImageIds().indexOf(imageId);
        this.stackInvalidated = true;
        this._loadAndDisplayImage(imageId, imageIdIndex);
    }
    triggerCameraEvent(camera, previousCamera) {
        const eventDetail = {
            previousCamera,
            camera,
            element: this.element,
            viewportId: this.id,
            renderingEngineId: this.renderingEngineId,
        };
        if (!this.suppressEvents) {
            triggerEvent(this.element, Events.CAMERA_MODIFIED, eventDetail);
        }
    }
    triggerCalibrationEvent() {
        const { imageData } = this.getImageData();
        const eventDetail = {
            element: this.element,
            viewportId: this.id,
            renderingEngineId: this.renderingEngineId,
            imageId: this.getCurrentImageId(),
            imageData: imageData,
            worldToIndex: imageData.getWorldToIndex(),
            ...this._calibrationEvent,
        };
        if (!this.suppressEvents) {
            triggerEvent(this.element, Events.IMAGE_SPACING_CALIBRATED, eventDetail);
        }
        this._publishCalibratedEvent = false;
    }
    jumpToWorld(worldPos) {
        const imageIds = this.getImageIds();
        const imageData = this.getImageData();
        const { direction, spacing } = imageData;
        const imageId = getClosestImageId({ direction, spacing, imageIds }, worldPos, this.getCamera().viewPlaneNormal, { ignoreSpacing: true });
        const index = imageIds.indexOf(imageId);
        if (index === -1) {
            return false;
        }
        this.setImageIdIndex(index);
        this.render();
        return true;
    }
    getRendererContextPool() {
        const renderingEngine = this.getRenderingEngine();
        return renderingEngine.getRenderer(this.id);
    }
    getRendererTiled() {
        const renderingEngine = this.getRenderingEngine();
        if (!renderingEngine || renderingEngine.hasBeenDestroyed) {
            throw new Error('Rendering engine has been destroyed');
        }
        return renderingEngine.offscreenMultiRenderWindow?.getRenderer(this.id);
    }
    _getVOIRangeForCurrentImage() {
        const { windowCenter, windowWidth, voiLUTFunction } = this.csImage;
        return this._getVOIRangeFromWindowLevel(windowWidth, windowCenter, voiLUTFunction);
    }
    _getValidVOILUTFunction(voiLUTFunction) {
        if (!Object.values(VOILUTFunctionType).includes(voiLUTFunction)) {
            return VOILUTFunctionType.LINEAR;
        }
        return voiLUTFunction;
    }
    getSliceInfo() {
        const sliceIndex = this.getSliceIndex();
        const { dimensions } = this.getImageData();
        return {
            width: dimensions[0],
            height: dimensions[1],
            sliceIndex,
            slicePlane: 2,
        };
    }
    isReferenceViewable(viewRef, options = {}) {
        const testIndex = this.getCurrentImageIdIndex();
        const currentImageId = this.imageIds[testIndex];
        if (!currentImageId || !viewRef) {
            return false;
        }
        const { referencedImageId, multiSliceReference } = viewRef;
        if (referencedImageId) {
            if (referencedImageId === currentImageId) {
                return true;
            }
            viewRef.referencedImageURI ||= imageIdToURI(referencedImageId);
            const { referencedImageURI } = viewRef;
            const foundSliceIndex = this.imageKeyToIndexMap.get(referencedImageURI);
            if (options.asOverlay) {
                const matchedImageId = this.matchImagesForOverlay(currentImageId, referencedImageId);
                if (matchedImageId) {
                    return true;
                }
            }
            if (foundSliceIndex === undefined) {
                return false;
            }
            if (options.withNavigation) {
                return true;
            }
            const rangeEndSliceIndex = multiSliceReference &&
                this.imageKeyToIndexMap.get(multiSliceReference.referencedImageId);
            return testIndex <= rangeEndSliceIndex && testIndex >= foundSliceIndex;
        }
        if (!super.isReferenceViewable(viewRef, {
            ...options,
            withOrientation: options?.asVolume,
        })) {
            return false;
        }
        if (viewRef.volumeId || viewRef.FrameOfReferenceUID) {
            return options.asVolume;
        }
        const { cameraFocalPoint } = viewRef;
        if (options.asNearbyProjection && cameraFocalPoint) {
            const { spacing, direction, origin } = this.getImageData();
            const viewPlaneNormal = direction.slice(6, 9);
            const sliceThickness = getSpacingInNormalDirection({ direction, spacing }, viewPlaneNormal);
            const diff = vec3.subtract(vec3.create(), cameraFocalPoint, origin);
            const distanceToPlane = vec3.dot(diff, viewPlaneNormal);
            const threshold = sliceThickness / 2;
            if (Math.abs(distanceToPlane) <= threshold) {
                return true;
            }
        }
        return false;
    }
    getViewReference(viewRefSpecifier = {}) {
        const { sliceIndex = this.getCurrentImageIdIndex() } = viewRefSpecifier;
        const reference = super.getViewReference(viewRefSpecifier);
        const referencedImageId = this.getCurrentImageId(sliceIndex);
        if (!referencedImageId) {
            return;
        }
        reference.referencedImageId = referencedImageId;
        if (this.getCurrentImageIdIndex() !== sliceIndex) {
            const referenceData = this.getImagePlaneReferenceData(sliceIndex);
            if (!referenceData) {
                return;
            }
            Object.assign(reference, referenceData);
        }
        return reference;
    }
    setViewReference(viewRef) {
        if (!viewRef?.referencedImageId) {
            if (viewRef?.sliceIndex !== undefined) {
                this.scroll(viewRef.sliceIndex - this.targetImageIdIndex);
            }
            return;
        }
        const { referencedImageId } = viewRef;
        viewRef.referencedImageURI ||= imageIdToURI(referencedImageId);
        const { referencedImageURI } = viewRef;
        const sliceIndex = this.imageKeyToIndexMap.get(referencedImageURI);
        if (sliceIndex === undefined) {
            log.error(`No image URI found for ${referencedImageURI}`);
            return;
        }
        this.scroll(sliceIndex - this.targetImageIdIndex);
    }
    getViewReferenceId(specifier = {}) {
        const { sliceIndex = this.currentImageIdIndex } = specifier;
        return `imageId:${this.imageIds[sliceIndex]}`;
    }
    getSliceIndexForImage(reference) {
        if (!reference) {
            return;
        }
        if (typeof reference === 'string') {
            return this.imageKeyToIndexMap.get(reference);
        }
        if (reference.referencedImageId) {
            return this.imageKeyToIndexMap.get(reference.referencedImageId);
        }
        return;
    }
    getCPUFallbackError(method) {
        return new Error(`method ${method} cannot be used during CPU Fallback mode`);
    }
    fillWithBackgroundColor() {
        const renderingEngine = this.getRenderingEngine();
        if (renderingEngine) {
            renderingEngine.fillCanvasWithBackgroundColor(this.canvas, this.options.background);
        }
    }
    unsetColormapCPU() {
        delete this._cpuFallbackEnabledElement.viewport.colormap;
        this._cpuFallbackEnabledElement.renderingTools = {};
        this.cpuRenderingInvalidated = true;
        this.fillWithBackgroundColor();
        this.render();
    }
    setColormapCPU(colormapData) {
        this.colormap = colormapData;
        const colormap = colormapUtils.getColormap(colormapData.name);
        this._cpuFallbackEnabledElement.viewport.colormap = colormap;
        this._cpuFallbackEnabledElement.renderingTools = {};
        this.fillWithBackgroundColor();
        this.cpuRenderingInvalidated = true;
        this.render();
        const eventDetail = {
            viewportId: this.id,
            colormap: colormapData,
        };
        triggerEvent(this.element, Events.COLORMAP_MODIFIED, eventDetail);
    }
    setColormapGPU(colormap) {
        const ActorEntry = this.getDefaultActor();
        const actor = ActorEntry.actor;
        const actorProp = actor.getProperty();
        const rgbTransferFunction = actorProp.getRGBTransferFunction();
        const colormapObj = colormapUtils.getColormap(colormap.name) ||
            vtkColorMaps.getPresetByName(colormap.name);
        if (!rgbTransferFunction) {
            const cfun = vtkColorTransferFunction.newInstance();
            cfun.applyColorMap(colormapObj);
            cfun.setMappingRange(this.voiRange.lower, this.voiRange.upper);
            actorProp.setRGBTransferFunction(0, cfun);
        }
        else {
            rgbTransferFunction.applyColorMap(colormapObj);
            rgbTransferFunction.setMappingRange(this.voiRange.lower, this.voiRange.upper);
            actorProp.setRGBTransferFunction(0, rgbTransferFunction);
        }
        this.colormap = colormap;
        this.render();
        const eventDetail = {
            viewportId: this.id,
            colormap,
        };
        triggerEvent(this.element, Events.COLORMAP_MODIFIED, eventDetail);
    }
    unsetColormapGPU() {
        throw new Error('unsetColormapGPU not implemented.');
    }
    _getImagePlaneModule(imageId) {
        const imagePlaneModule = getImagePlaneModule(imageId);
        this.hasPixelSpacing =
            !imagePlaneModule.usingDefaultValues ||
                this.calibration?.scale > 0 ||
                this.calibration?.rowPixelSpacing > 0;
        this.calibration ||= imagePlaneModule.calibration;
        return imagePlaneModule;
    }
    isInAcquisitionPlane() {
        return true;
    }
}
export default StackViewport;
