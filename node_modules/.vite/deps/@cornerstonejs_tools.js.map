{
  "version": 3,
  "sources": ["../../lodash.get/index.js", "../../@cornerstonejs/tools/dist/esm/types/index.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js", "../../@cornerstonejs/tools/dist/esm/enums/index.js", "../../@cornerstonejs/tools/dist/esm/enums/ToolBindings.js", "../../@cornerstonejs/tools/dist/esm/enums/ToolModes.js", "../../@cornerstonejs/tools/dist/esm/enums/AnnotationStyleStates.js", "../../@cornerstonejs/tools/dist/esm/enums/Events.js", "../../@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js", "../../@cornerstonejs/tools/dist/esm/enums/Touch.js", "../../@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js", "../../@cornerstonejs/tools/dist/esm/enums/ChangeTypes.js", "../../@cornerstonejs/tools/dist/esm/enums/WorkerTypes.js", "../../@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js", "../../@cornerstonejs/tools/dist/esm/store/svgNodeCache.js", "../../@cornerstonejs/tools/dist/esm/store/state.js", "../../@cornerstonejs/tools/dist/esm/store/ToolGroupManager/ToolGroup.js", "../../@cornerstonejs/tools/dist/esm/cursors/index.js", "../../@cornerstonejs/tools/dist/esm/cursors/MouseCursor.js", "../../@cornerstonejs/tools/dist/esm/cursors/ImageMouseCursor.js", "../../@cornerstonejs/tools/dist/esm/cursors/SVGCursorDescriptor.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/ToolStyle.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/helpers.js", "../../@cornerstonejs/tools/dist/esm/cursors/SVGMouseCursor.js", "../../@cornerstonejs/tools/dist/esm/cursors/elementCursor.js", "../../@cornerstonejs/tools/dist/esm/cursors/setCursorForElement.js", "../../@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroup.js", "../../@cornerstonejs/tools/dist/esm/store/ToolGroupManager/createToolGroup.js", "../../@cornerstonejs/tools/dist/esm/store/ToolGroupManager/destroyToolGroup.js", "../../@cornerstonejs/tools/dist/esm/store/ToolGroupManager/destroy.js", "../../@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupForViewport.js", "../../@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getAllToolGroups.js", "../../@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupsWithToolName.js", "../../@cornerstonejs/tools/dist/esm/store/index.js", "../../@cornerstonejs/tools/dist/esm/store/addTool.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/mouse/getMouseEventPoints.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseDoubleClickListener.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseMoveListener.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseDownListener.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/mouse/index.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/touch/preventGhostClick.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/touch/getTouchEventPoints.js", "../../@cornerstonejs/tools/dist/esm/utilities/touch/index.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/touch/touchStartListener.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/touch/index.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/wheel/normalizeWheel.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/wheel/wheelListener.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/wheel/index.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/keyboard/keyDownListener.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/keyboard/index.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js", "../../@cornerstonejs/tools/dist/esm/utilities/boundingBox/getBoundingBoxAroundShape.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/utilities.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationDataModified.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationModified.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRemoved.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRepresentationModified.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRepresentationRemoved.js", "../../@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourConfig.js", "../../@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapConfig.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStyle.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationAdded.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js", "../../@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/removeSurfaceFromElement.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/getSegmentationActor.js", "../../@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/addOrUpdateSurfaceToElement.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getColorLUT.js", "../../@cornerstonejs/tools/dist/esm/config.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddRepresentationData.js", "../../@cornerstonejs/tools/dist/esm/utilities/isObject.js", "../../@cornerstonejs/tools/dist/esm/utilities/debounce.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/computeAndAddRepresentation.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices.js", "../../@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/surfaceDisplay.js", "../../@cornerstonejs/tools/dist/esm/utilities/annotationHydration.js", "../../@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/areSameSegment.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/annotation/FrameOfReferenceSpecificAnnotationManager.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/annotation/utilities/defineProperties.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/annotation/resetAnnotationManager.js", "../../@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/removeContourSegmentationAnnotation.js", "../../@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/addContourSegmentationAnnotation.js", "../../@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/convertContourSegmentation.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportIdsWithSegmentation.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/getViewportAssociatedToSegmentation.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/getAnnotationsUIDMapFromSegmentation.js", "../../@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/copyAnnotation.js", "../../@cornerstonejs/tools/dist/esm/types/ContourAnnotation.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/aabb/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/aabb/intersectAABB.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/aabb/distanceToPointSquared.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/aabb/distanceToPoint.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/basic/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/basic/Calculator.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/basic/BasicStatsCalculator.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/circle/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/point/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/point/distanceToPointSquared.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/point/distanceToPoint.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/point/mirror.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/circle/getCanvasCircleRadius.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/circle/getCanvasCircleCorners.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/ellipse/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/ellipse/pointInEllipse.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/ellipse/getCanvasEllipseCorners.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/line/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPointSquaredInfo.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPointSquared.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPoint.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/line/intersectLine.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/line/isPointOnLineSegment.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/isClosed.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/containsPoint.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/containsPoints.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/getAABB.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/getArea.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/getSignedArea.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/getWindingDirection.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/getNormal3.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/getNormal2.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/robustSegmentIntersection.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/arePolylinesIdentical.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/subtractPolylines.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/intersectPolylines.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/areLineSegmentsIntersecting.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/getLineSegmentIntersectionsIndexes.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/getFirstLineSegmentIntersectionIndexes.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/intersectPolyline.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/getLinesIntersection.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/combinePolyline.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/decimate.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/getLineSegmentIntersectionsCoordinates.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/getClosestLineSegmentIntersection.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/getSubPixelSpacingAndXYDirections.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/pointsAreWithinCloseContourProximity.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/addCanvasPointsToArray.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/pointCanProjectOnLine.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/projectTo2D.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/isPointInsidePolyline3D.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/polyline/convexHull.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/rectangle/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/rectangle/distanceToPoint.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/vec2/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/vec2/findClosestPoint.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/vec2/liangBarksyClip.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/angle/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/angle/angleBetweenLines.js", "../../@cornerstonejs/tools/dist/esm/utilities/contours/updateContourPolyline.js", "../../@cornerstonejs/tools/dist/esm/drawingSvg/index.js", "../../@cornerstonejs/tools/dist/esm/drawingSvg/getSvgDrawingHelper.js", "../../@cornerstonejs/tools/dist/esm/drawingSvg/draw.js", "../../@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js", "../../@cornerstonejs/tools/dist/esm/drawingSvg/setAttributesIfNecessary.js", "../../@cornerstonejs/tools/dist/esm/drawingSvg/setNewAttributesIfValid.js", "../../@cornerstonejs/tools/dist/esm/drawingSvg/drawCircle.js", "../../@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipseByCoordinates.js", "../../@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipse.js", "../../@cornerstonejs/tools/dist/esm/drawingSvg/drawHandle.js", "../../@cornerstonejs/tools/dist/esm/drawingSvg/drawHandles.js", "../../@cornerstonejs/tools/dist/esm/drawingSvg/drawLine.js", "../../@cornerstonejs/tools/dist/esm/drawingSvg/drawHeight.js", "../../@cornerstonejs/tools/dist/esm/drawingSvg/drawPolyline.js", "../../@cornerstonejs/tools/dist/esm/drawingSvg/drawPath.js", "../../@cornerstonejs/tools/dist/esm/drawingSvg/drawFan.js", "../../@cornerstonejs/tools/dist/esm/drawingSvg/drawTextBox.js", "../../@cornerstonejs/tools/dist/esm/drawingSvg/drawLink.js", "../../@cornerstonejs/tools/dist/esm/drawingSvg/drawLinkedTextBox.js", "../../@cornerstonejs/tools/dist/esm/drawingSvg/drawRectByCoordinates.js", "../../@cornerstonejs/tools/dist/esm/drawingSvg/drawRect.js", "../../@cornerstonejs/tools/dist/esm/drawingSvg/drawArrow.js", "../../@cornerstonejs/tools/dist/esm/drawingSvg/drawRedactionRect.js", "../../@cornerstonejs/tools/dist/esm/utilities/getToolsWithModesForElement.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/annotation/AnnotationRenderingEngine.js", "../../@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRender.js", "../../@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js", "../../@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithFrameOfReferenceUID.js", "../../@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithToolEnabled.js", "../../@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithParallelNormals.js", "../../@cornerstonejs/tools/dist/esm/utilities/viewportFilters/getViewportIdsWithToolToRender.js", "../../@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/sharedOperations.js", "../../@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/addPolylinesToSegmentation.js", "../../@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/getViewReferenceFromAnnotation.js", "../../@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/areViewReferencesEqual.js", "../../@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/polylineUnify.js", "../../@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/polylineSubtract.js", "../../@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/polylineIntersect.js", "../../@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/polylineXor.js", "../../@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/logicalOperators.js", "../../@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/isContourSegmentationAnnotation.js", "../../@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/getIntersectingAnnotations.js", "../../@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/mergeMultipleAnnotations.js", "../../@cornerstonejs/tools/dist/esm/utilities/getViewportsForAnnotation.js", "../../@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/contourSegmentationOperation.js", "../../@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourHandler/utils.js", "../../@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourHandler/handleContourSegmentation.js", "../../@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/removeContourFromElement.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/getUniqueSegmentIndices.js", "../../@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourDisplay.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getCurrentLabelmapImageIdForViewport.js", "../../@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/addVolumesAsIndependentComponents.js", "../../@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/addLabelmapToElement.js", "../../@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/removeLabelmapFromElement.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentation.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/setActiveSegmentation.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentIndex.js", "../../@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapDisplay.js", "../../@cornerstonejs/tools/dist/esm/tools/base/BaseTool.js", "../../@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsWithinSlice.js", "../../@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsForDisplay.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/index.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/getState.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/getFont.js", "../../@cornerstonejs/tools/dist/esm/tools/base/AnnotationDisplayTool.js", "../../@cornerstonejs/tools/dist/esm/tools/base/AnnotationTool.js", "../../@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js", "../../@cornerstonejs/tools/dist/esm/utilities/planar/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromCorners.js", "../../@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromTwoPoints.js", "../../@cornerstonejs/tools/dist/esm/utilities/planar/getPointInLineOfSightWithCriteria.js", "../../@cornerstonejs/tools/dist/esm/utilities/planar/isPlaneIntersectingAABB.js", "../../@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsWithinPlane.js", "../../@cornerstonejs/tools/dist/esm/utilities/throttle.js", "../../@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/algorithms/bspline.js", "../../@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/interpolateSegmentPoints.js", "../../@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/smoothPoints.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getMouseModifier.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/findOpenUShapedContourVectorToPeak.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/drawLoop.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/editLoopCommon.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/closedContourEditLoop.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEditLoop.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEndEditLoop.js", "../../@cornerstonejs/tools/dist/esm/utilities/contours/getContourHolesDataWorld.js", "../../@cornerstonejs/tools/dist/esm/utilities/contours/getContourHolesDataCanvas.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/renderMethods.js", "../../@cornerstonejs/tools/dist/esm/utilities/drawing/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/drawing/getTextBoxCoordsCanvas.js", "../../@cornerstonejs/tools/dist/esm/utilities/viewport/isViewportPreScaled.js", "../../@cornerstonejs/tools/dist/esm/utilities/contours/calculatePerimeter.js", "../../@cornerstonejs/tools/dist/esm/tools/base/ContourBaseTool.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/annotation/index.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/annotation/AnnotationGroup.js", "../../@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/getInterpolationData.js", "../../@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/getInterpolationDataCollection.js", "../../@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/createPolylineToolData.js", "../../@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/findAnnotationForInterpolation.js", "../../@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/selectHandles.js", "../../@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/updateChildInterpolationUID.js", "../../@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/interpolate.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/InterpolationManager/deleteRelatedAnnotations.js", "../../@cornerstonejs/tools/dist/esm/utilities/getViewportForAnnotation.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/InterpolationManager/InterpolationManager.js", "../../@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForToolGroupIds.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentLocking.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationColor.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getNextColorLUTIndex.js", "../../@cornerstonejs/tools/dist/esm/constants/COLOR_LUT.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addColorLUT.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentationVisibility.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/getSVGStyleForSegment.js", "../../@cornerstonejs/tools/dist/esm/tools/base/ContourSegmentationBaseTool.js", "../../@cornerstonejs/tools/dist/esm/utilities/getPixelValueUnits.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandROITool.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandContourSegmentationTool.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/performVolumeLabelmapUpdate.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/performStackLabelmapUpdate.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/onLabelmapSegmentationDataModified.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationDataModifiedEventListener.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationModifiedEventListener.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateLabelmapSegmentationImageReferences.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/segmentation/imageChangeEventListener.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/contourSegmentationCompleted.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/contourSegmentationRemoved.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationCompletedListener.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationSelectionListener.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationModifiedListener.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationRemovedListener.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/imageRenderedEventDispatcher.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/shared/customCallbackHandler.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseClick.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDoubleClick.js", "../../@cornerstonejs/tools/dist/esm/store/filterToolsWithMoveableHandles.js", "../../@cornerstonejs/tools/dist/esm/store/filterToolsWithAnnotationsForElement.js", "../../@cornerstonejs/tools/dist/esm/store/filterMoveableAnnotationTools.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForMouseEvent.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithModesForMouseEvent.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithActionsForMouseEvent.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDownAnnotationAction.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDown.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDownActivate.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDrag.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseMove.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseUp.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseWheel.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/mouseToolEventDispatcher.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForKeyboardEvent.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithActionsForKeyboardEvents.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardEventHandlers/keyDown.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardEventHandlers/keyUp.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardToolEventDispatcher.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/cameraModifiedEventDispatcher.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/imageSpacingCalibratedEventDispatcher.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForTouchEvent.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithModesForTouchEvent.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchStart.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchStartActivate.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchDrag.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchEnd.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchTap.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchPress.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/touchToolEventDispatcher.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/annotationInterpolationEventDispatcher.js", "../../@cornerstonejs/tools/dist/esm/eventDispatchers/cameraResetEventDispatcher.js", "../../@cornerstonejs/tools/dist/esm/store/addEnabledElement.js", "../../@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getSynchronizersForViewport.js", "../../@cornerstonejs/tools/dist/esm/store/removeEnabledElement.js", "../../@cornerstonejs/tools/dist/esm/store/cancelActiveManipulations.js", "../../@cornerstonejs/tools/dist/esm/store/SynchronizerManager/Synchronizer.js", "../../@cornerstonejs/tools/dist/esm/store/SynchronizerManager/index.js", "../../@cornerstonejs/tools/dist/esm/store/SynchronizerManager/createSynchronizer.js", "../../@cornerstonejs/tools/dist/esm/store/SynchronizerManager/destroy.js", "../../@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getSynchronizer.js", "../../@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getAllSynchronizers.js", "../../@cornerstonejs/tools/dist/esm/store/SynchronizerManager/destroySynchronizer.js", "../../@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationRepresentationModifiedListener.js", "../../@cornerstonejs/tools/dist/esm/init.js", "../../@cornerstonejs/tools/dist/esm/constants/index.js", "../../@cornerstonejs/tools/dist/esm/version.js", "../../@cornerstonejs/tools/dist/esm/synchronizers/index.js", "../../@cornerstonejs/tools/dist/esm/synchronizers/callbacks/cameraSyncCallback.js", "../../@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createCameraPositionSynchronizer.js", "../../@cornerstonejs/tools/dist/esm/synchronizers/callbacks/presentationViewSyncCallback.js", "../../@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createPresentationViewSynchronizer.js", "../../@cornerstonejs/tools/dist/esm/synchronizers/callbacks/voiSyncCallback.js", "../../@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createVOISynchronizer.js", "../../@cornerstonejs/tools/dist/esm/synchronizers/callbacks/zoomPanSyncCallback.js", "../../@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createZoomPanSynchronizer.js", "../../@cornerstonejs/tools/dist/esm/synchronizers/callbacks/areViewportsCoplanar.js", "../../@cornerstonejs/tools/dist/esm/synchronizers/callbacks/imageSliceSyncCallback.js", "../../@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createImageSliceSynchronizer.js", "../../@cornerstonejs/tools/dist/esm/synchronizers/callbacks/slabThicknessSyncCallback.js", "../../@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createSlabThicknessSynchronizer.js", "../../@cornerstonejs/tools/dist/esm/utilities/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/getAnnotationNearPoint.js", "../../@cornerstonejs/tools/dist/esm/utilities/calibrateImageSpacing.js", "../../@cornerstonejs/tools/dist/esm/utilities/boundingBox/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/boundingBox/extend2DBoundingBoxInViewAxis.js", "../../@cornerstonejs/tools/dist/esm/utilities/getSphereBoundsInfo.js", "../../@cornerstonejs/tools/dist/esm/utilities/pointToString.js", "../../@cornerstonejs/tools/dist/esm/utilities/AnnotationMultiSlice.js", "../../@cornerstonejs/tools/dist/esm/utilities/contours/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/contours/areCoplanarContours.js", "../../@cornerstonejs/tools/dist/esm/utilities/contours/contourFinder.js", "../../@cornerstonejs/tools/dist/esm/utilities/contours/getDeduplicatedVTKPolyDataPoints.js", "../../@cornerstonejs/tools/dist/esm/utilities/contours/detectContourHoles.js", "../../@cornerstonejs/tools/dist/esm/utilities/contours/findContourHoles.js", "../../@cornerstonejs/tools/dist/esm/utilities/registerComputeWorker.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentations.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/normalizeSegmentationInput.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentations.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentationRepresentations.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentation.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeColorLUT.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportSegmentations.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getStackSegmentationImageIdsForViewport.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/validateLabelmap.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/getReferenceVolumeForSegmentationVolume.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/utils/getStrategyData.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateSegmentationVolume.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/ensureSegmentationVolume.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateImageVolume.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/ensureImageVolume.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/utilsForWorker.js", "../../@cornerstonejs/tools/dist/esm/utilities/contours/generateContourSetsFromLabelmap.js", "../../@cornerstonejs/tools/dist/esm/utilities/contours/RectangleROIStartEndThreshold.js", "../../@cornerstonejs/tools/dist/esm/utilities/contours/AnnotationToPointData.js", "../../@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/acceptAutogeneratedInterpolations.js", "../../@cornerstonejs/tools/dist/esm/utilities/contours/findHandlePolylineIndex.js", "../../@cornerstonejs/tools/dist/esm/utilities/contours/findIslands.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/thresholdVolumeByRange.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/RectangleROITool.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIStartEndThresholdTool.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIThresholdTool.js", "../../@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/getBoundsIJKFromRectangleAnnotations.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/rectangleROIThresholdVolumeByRange.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/createMergedLabelmapForIndex.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/createLabelmapVolumeForViewport.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/floodFill.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/determineSegmentIndex.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/dynamicThreshold.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/erase.js", "../../@cornerstonejs/tools/dist/esm/utilities/normalizeViewportPlane.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/islandRemoval.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/islandRemovalComposition.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/preview.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/regionFill.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/utils/handleUseSegmentCenterIndex.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/setValue.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/threshold.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/VolumetricCalculator.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/getStatistics.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/labelmapStatistics.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/index.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/BrushStrategy.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/sphere/pointInSphere.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillCircle.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillSphere.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseSphere.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseCircle.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/createLabelmapMemo.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/index.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillRectangle.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/LabelmapBaseTool.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/BrushTool.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/getBrushToolInstances.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/brushSizeForToolGroup.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/brushThresholdForToolGroup.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/SegmentStatsCalculator.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/thresholdSegmentationByRange.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/isLineInSegment.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/findLargestBidirectional.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/contourAndFindLargestBidirectional.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/createBidirectionalToolData.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/BidirectionalTool.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/segmentContourAction.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/invalidateBrushCursor.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentIndexAtWorldPoint.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentIndexAtLabelmapBorder.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/getHoveredContourSegmentationAnnotation.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/growCutShader.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCut.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCutForSphere.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCutForBoundingBox.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/constants.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runOneClickGrowCut.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentIndex.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddSegmentationRepresentation.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentationRepresentationsToViewport.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/updateStackSegmentationState.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeStackLabelmapFromVolume.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeVolumeLabelmapFromStack.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentLargestBidirectional.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/getReferenceVolumeForSegmentation.js", "../../@cornerstonejs/tools/dist/esm/utilities/segmentation/computeMetabolicStats.js", "../../@cornerstonejs/tools/dist/esm/utilities/orientation/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/orientation/getOrientationStringLPS.js", "../../@cornerstonejs/tools/dist/esm/utilities/orientation/invertOrientationStringLPS.js", "../../@cornerstonejs/tools/dist/esm/utilities/cine/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/cine/events.js", "../../@cornerstonejs/tools/dist/esm/utilities/cine/state.js", "../../@cornerstonejs/tools/dist/esm/utilities/cine/playClip.js", "../../@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/smoothAnnotation.js", "../../@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/isAxisAlignedRectangle.js", "../../@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/state.js", "../../@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackPrefetchUtils.js", "../../@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackPrefetch.js", "../../@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackContextPrefetch.js", "../../@cornerstonejs/tools/dist/esm/utilities/viewport/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/getDataInTime.js", "../../@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/generateImageFromTimeData.js", "../../@cornerstonejs/tools/dist/esm/utilities/polyData/utils.js", "../../@cornerstonejs/tools/dist/esm/utilities/voi/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/enums/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/enums/ColorbarRangeTextPosition.js", "../../@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/isRangeValid.js", "../../@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/isColorbarSizeValid.js", "../../@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/areColorbarRangesEqual.js", "../../@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/areColorbarSizesEqual.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/vec3/interpolateVec3.js", "../../@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/ColorbarCanvas.js", "../../@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/ColorbarTicks.js", "../../@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/isRangeTextPositionValid.js", "../../@cornerstonejs/tools/dist/esm/widgets/Widget.js", "../../@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/Colorbar.js", "../../@cornerstonejs/tools/dist/esm/utilities/getVOIMultipliers.js", "../../@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/ViewportColorbar.js", "../../@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/index.js", "../../@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/getLuminanceFromRegion.js", "../../@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/calculateMinMaxMean.js", "../../@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/extractWindowLevelRegionToolData.js", "../../@cornerstonejs/tools/dist/esm/utilities/pointInSurroundingSphereCallback.js", "../../@cornerstonejs/tools/dist/esm/utilities/geometricSurfaceUtils.js", "../../@cornerstonejs/tools/dist/esm/utilities/setAnnotationLabel.js", "../../@cornerstonejs/tools/dist/esm/utilities/moveAnnotationToViewPlane.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/fanExtraction.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/segmentLargestUSOutlineFromBuffer.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/generateConvexHullFromContour.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/calculateFanShapeCorners.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/deriveFanGeometry.js", "../../@cornerstonejs/tools/dist/esm/index.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/index.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateSegmentations.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/index.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationVisibility.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/setSegmentationRepresentationVisibility.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/styleHelpers.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/index.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/getAnnotationMapFromSegmentation.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/getPolylineMap.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/extractSegmentPolylines.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/decimateContours.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/removeCompleteContourAnnotation.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/removeContourHoles.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/removeContourIslands.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/smoothContours.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/convertContourHoles.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/convertStackToVolumeLabelmap.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/clearSegmentValue.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/removeSegmentAnnotations.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegment.js", "../../@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getLabelmapImageIds.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/splines/index.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/splines/Spline.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/splines/CubicSpline.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/splines/BSpline.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/splines/CardinalSpline.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/splines/CatmullRomSpline.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/splines/LinearSpline.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/splines/QuadraticSpline.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/splines/QuadraticBezier.js", "../../@cornerstonejs/tools/dist/esm/tools/PanTool.js", "../../@cornerstonejs/tools/dist/esm/tools/TrackballRotateTool.js", "../../@kitware/vtk.js/Filters/Sources/SphereSource.js", "../../@cornerstonejs/tools/dist/esm/tools/VolumeCroppingTool.js", "../../@cornerstonejs/tools/dist/esm/tools/VolumeCroppingControlTool.js", "../../@cornerstonejs/tools/dist/esm/tools/WindowLevelTool.js", "../../@cornerstonejs/tools/dist/esm/tools/WindowLevelRegionTool.js", "../../@cornerstonejs/tools/dist/esm/tools/StackScrollTool.js", "../../@cornerstonejs/tools/dist/esm/tools/PlanarRotateTool.js", "../../@cornerstonejs/tools/dist/esm/tools/ZoomTool.js", "../../@cornerstonejs/tools/dist/esm/tools/MIPJumpToClickTool.js", "../../@cornerstonejs/tools/dist/esm/tools/CrosshairsTool.js", "../../@cornerstonejs/tools/dist/esm/tools/MagnifyTool.js", "../../@cornerstonejs/tools/dist/esm/tools/AdvancedMagnifyTool.js", "../../@cornerstonejs/tools/dist/esm/tools/ReferenceLinesTool.js", "../../@cornerstonejs/tools/dist/esm/tools/OverlayGridTool.js", "../../@cornerstonejs/tools/dist/esm/tools/SegmentationIntersectionTool.js", "../../@cornerstonejs/tools/dist/esm/tools/ReferenceCursors.js", "../../@cornerstonejs/tools/dist/esm/tools/ScaleOverlayTool.js", "../../@cornerstonejs/tools/dist/esm/tools/distancePointToContour.js", "../../@cornerstonejs/tools/dist/esm/tools/SculptorTool/CircleSculptCursor.js", "../../@cornerstonejs/tools/dist/esm/tools/SculptorTool.js", "../../@cornerstonejs/tools/dist/esm/tools/VolumeRotateTool.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/LabelTool.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/LengthTool.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/HeightTool.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/ProbeTool.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/DragProbeTool.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/EllipticalROITool.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/CircleROITool.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/ETDRSGridTool.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/SplineROITool.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/SplineContourSegmentationTool.js", "../../@cornerstonejs/tools/dist/esm/utilities/BucketQueue.js", "../../@cornerstonejs/tools/dist/esm/utilities/livewire/LivewireScissors.js", "../../@cornerstonejs/tools/dist/esm/utilities/livewire/LiveWirePath.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourTool.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourSegmentationTool.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/ArrowAnnotateTool.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/AngleTool.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/midPoint.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/CobbAngleTool.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundDirectionalTool.js", "../../@cornerstonejs/tools/dist/esm/utilities/math/fan/fanUtils.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/UltrasoundPleuraBLineTool.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/KeyImageTool.js", "../../@cornerstonejs/tools/dist/esm/tools/AnnotationEraserTool.js", "../../@cornerstonejs/tools/dist/esm/tools/base/GrowCutBaseTool.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/RegionSegmentTool.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/RegionSegmentPlusTool.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/WholeBodySegmentTool.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseRectangle.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleScissorsTool.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/CircleScissorsTool.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/SphereScissorsTool.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/CircleROIStartEndThresholdTool.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/PaintFillTool.js", "../../@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget/Constants.js", "../../@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget.js", "../../@kitware/vtk.js/Common/Core/ImageHelper.js", "../../@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor/Presets.js", "../../@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor.js", "../../@kitware/vtk.js/Filters/General/AppendPolyData.js", "../../@kitware/vtk.js/Filters/Sources/ConeSource.js", "../../@kitware/vtk.js/Filters/Sources/CylinderSource.js", "../../@kitware/vtk.js/Filters/Sources/ArrowSource.js", "../../@kitware/vtk.js/Rendering/Core/AxesActor.js", "../../@cornerstonejs/tools/dist/esm/tools/OrientationMarkerTool.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentSelectTool.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentBidirectionalTool.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentLabelTool.js", "../../@cornerstonejs/tools/dist/esm/tools/segmentation/LabelmapEditWithContour.js", "../../@cornerstonejs/tools/dist/esm/tools/annotation/VideoRedactionTool.js"],
  "sourcesContent": ["/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n", "", "import { utilities as csUtils } from '@cornerstonejs/core';\nimport { triggerAnnotationAddedForElement, triggerAnnotationAddedForFOR, triggerAnnotationRemoved, } from './helpers/state';\nlet defaultManager;\nfunction getAnnotationManager() {\n    return defaultManager;\n}\nfunction setAnnotationManager(annotationManager) {\n    defaultManager = annotationManager;\n}\nfunction getAnnotations(toolName, annotationGroupSelector) {\n    const manager = getAnnotationManager();\n    const groupKey = manager.getGroupKey(annotationGroupSelector);\n    return manager.getAnnotations(groupKey, toolName);\n}\nfunction getAnnotation(annotationUID) {\n    const manager = getAnnotationManager();\n    return manager.getAnnotation(annotationUID);\n}\nfunction getAllAnnotations() {\n    const manager = getAnnotationManager();\n    return manager.getAllAnnotations();\n}\nfunction clearParentAnnotation(annotation) {\n    const { annotationUID: childUID, parentAnnotationUID } = annotation;\n    if (!parentAnnotationUID) {\n        return;\n    }\n    const parentAnnotation = getAnnotation(parentAnnotationUID);\n    const childUIDIndex = parentAnnotation.childAnnotationUIDs.indexOf(childUID);\n    parentAnnotation.childAnnotationUIDs.splice(childUIDIndex, 1);\n    annotation.parentAnnotationUID = undefined;\n}\nfunction addChildAnnotation(parentAnnotation, childAnnotation) {\n    const { annotationUID: parentUID } = parentAnnotation;\n    const { annotationUID: childUID } = childAnnotation;\n    clearParentAnnotation(childAnnotation);\n    if (!parentAnnotation.childAnnotationUIDs) {\n        parentAnnotation.childAnnotationUIDs = [];\n    }\n    if (parentAnnotation.childAnnotationUIDs.includes(childUID)) {\n        return;\n    }\n    parentAnnotation.childAnnotationUIDs.push(childUID);\n    childAnnotation.parentAnnotationUID = parentUID;\n}\nfunction getParentAnnotation(annotation) {\n    return annotation.parentAnnotationUID\n        ? getAnnotation(annotation.parentAnnotationUID)\n        : undefined;\n}\nfunction getChildAnnotations(annotation) {\n    return (annotation.childAnnotationUIDs?.map((childAnnotationUID) => getAnnotation(childAnnotationUID)) ?? []);\n}\nfunction addAnnotation(annotation, annotationGroupSelector) {\n    if (!annotation.annotationUID) {\n        annotation.annotationUID = csUtils.uuidv4();\n    }\n    const manager = getAnnotationManager();\n    if (annotationGroupSelector instanceof HTMLDivElement) {\n        const groupKey = manager.getGroupKey(annotationGroupSelector);\n        manager.addAnnotation(annotation, groupKey);\n        triggerAnnotationAddedForElement(annotation, annotationGroupSelector);\n    }\n    else {\n        manager.addAnnotation(annotation, undefined);\n        triggerAnnotationAddedForFOR(annotation);\n    }\n    return annotation.annotationUID;\n}\nfunction getNumberOfAnnotations(toolName, annotationGroupSelector) {\n    const manager = getAnnotationManager();\n    const groupKey = manager.getGroupKey(annotationGroupSelector);\n    return manager.getNumberOfAnnotations(groupKey, toolName);\n}\nfunction removeAnnotation(annotationUID) {\n    if (!annotationUID) {\n        return;\n    }\n    const manager = getAnnotationManager();\n    const annotation = manager.getAnnotation(annotationUID);\n    if (!annotation) {\n        return;\n    }\n    annotation.childAnnotationUIDs?.forEach((childAnnotationUID) => removeAnnotation(childAnnotationUID));\n    manager.removeAnnotation(annotationUID);\n    triggerAnnotationRemoved({ annotation, annotationManagerUID: manager.uid });\n}\nfunction removeAllAnnotations() {\n    const manager = getAnnotationManager();\n    const removedAnnotations = manager.removeAllAnnotations();\n    for (const annotation of removedAnnotations) {\n        triggerAnnotationRemoved({\n            annotation,\n            annotationManagerUID: manager.uid,\n        });\n    }\n}\nfunction removeAnnotations(toolName, annotationGroupSelector) {\n    const manager = getAnnotationManager();\n    const groupKey = manager.getGroupKey(annotationGroupSelector);\n    const removedAnnotations = manager.removeAnnotations(groupKey, toolName);\n    for (const annotation of removedAnnotations) {\n        triggerAnnotationRemoved({\n            annotation,\n            annotationManagerUID: manager.uid,\n        });\n    }\n}\nfunction invalidateAnnotation(annotation) {\n    let currAnnotation = annotation;\n    while (currAnnotation) {\n        currAnnotation.invalidated = true;\n        currAnnotation = currAnnotation.parentAnnotationUID\n            ? getAnnotation(currAnnotation.parentAnnotationUID)\n            : undefined;\n    }\n}\nexport { getAllAnnotations, getAnnotations, getParentAnnotation, getChildAnnotations, clearParentAnnotation, addChildAnnotation, getNumberOfAnnotations, addAnnotation, removeAnnotation, removeAnnotations, removeAllAnnotations, setAnnotationManager, getAnnotationManager, invalidateAnnotation, getAnnotation, };\n", "import { getEnabledElement, triggerEvent, eventTarget, getEnabledElementByIds, } from '@cornerstonejs/core';\nimport { Events, ChangeTypes } from '../../../enums';\nimport { getToolGroupsWithToolName } from '../../../store/ToolGroupManager';\nfunction triggerAnnotationAddedForElement(annotation, element) {\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewportId } = enabledElement;\n    const eventType = Events.ANNOTATION_ADDED;\n    const eventDetail = {\n        annotation,\n        viewportId,\n        renderingEngineId: renderingEngine.id,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n}\nfunction triggerAnnotationAddedForFOR(annotation) {\n    const { toolName } = annotation.metadata;\n    const toolGroups = getToolGroupsWithToolName(toolName);\n    if (!toolGroups.length) {\n        return;\n    }\n    const viewportsToRender = [];\n    toolGroups.forEach((toolGroup) => {\n        toolGroup.viewportsInfo.forEach((viewportInfo) => {\n            const { renderingEngineId, viewportId } = viewportInfo;\n            const { FrameOfReferenceUID } = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (annotation.metadata.FrameOfReferenceUID === FrameOfReferenceUID) {\n                viewportsToRender.push(viewportInfo);\n            }\n        });\n    });\n    const eventType = Events.ANNOTATION_ADDED;\n    const eventDetail = { annotation };\n    if (!viewportsToRender.length) {\n        triggerEvent(eventTarget, eventType, eventDetail);\n        return;\n    }\n    viewportsToRender.forEach(({ renderingEngineId, viewportId }) => {\n        eventDetail.viewportId = viewportId;\n        eventDetail.renderingEngineId = renderingEngineId;\n        triggerEvent(eventTarget, eventType, eventDetail);\n    });\n}\nfunction triggerAnnotationRemoved(eventDetail) {\n    const eventType = Events.ANNOTATION_REMOVED;\n    triggerEvent(eventTarget, eventType, eventDetail);\n}\nfunction triggerAnnotationModified(annotation, element, changeType = ChangeTypes.HandlesUpdated) {\n    const enabledElement = element && getEnabledElement(element);\n    const { viewportId, renderingEngineId } = enabledElement || {};\n    const eventType = Events.ANNOTATION_MODIFIED;\n    const eventDetail = {\n        annotation,\n        viewportId,\n        renderingEngineId,\n        changeType,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n}\nfunction triggerAnnotationCompleted(annotation) {\n    const eventDetail = {\n        annotation,\n    };\n    _triggerAnnotationCompleted(eventDetail);\n}\nfunction triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled = false) {\n    const eventDetail = {\n        annotation,\n        contourHoleProcessingEnabled,\n    };\n    _triggerAnnotationCompleted(eventDetail);\n}\nfunction _triggerAnnotationCompleted(eventDetail) {\n    const eventType = Events.ANNOTATION_COMPLETED;\n    triggerEvent(eventTarget, eventType, eventDetail);\n}\nexport { triggerAnnotationAddedForElement, triggerAnnotationAddedForFOR, triggerAnnotationRemoved, triggerAnnotationModified, triggerAnnotationCompleted, triggerContourAnnotationCompleted, };\n", "import { MouseBindings, KeyboardBindings } from './ToolBindings';\nimport ToolModes from './ToolModes';\nimport AnnotationStyleStates from './AnnotationStyleStates';\nimport Events from './Events';\nimport SegmentationRepresentations from './SegmentationRepresentations';\nimport { Swipe } from './Touch';\nimport StrategyCallbacks from './StrategyCallbacks';\nimport ChangeTypes from './ChangeTypes';\nimport WorkerTypes from './WorkerTypes';\nexport { MouseBindings, KeyboardBindings, ToolModes, AnnotationStyleStates, Events, SegmentationRepresentations, Swipe, StrategyCallbacks, ChangeTypes, WorkerTypes, };\n", "var MouseBindings;\n(function (MouseBindings) {\n    MouseBindings[MouseBindings[\"Primary\"] = 1] = \"Primary\";\n    MouseBindings[MouseBindings[\"Secondary\"] = 2] = \"Secondary\";\n    MouseBindings[MouseBindings[\"Primary_And_Secondary\"] = 3] = \"Primary_And_Secondary\";\n    MouseBindings[MouseBindings[\"Auxiliary\"] = 4] = \"Auxiliary\";\n    MouseBindings[MouseBindings[\"Primary_And_Auxiliary\"] = 5] = \"Primary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Secondary_And_Auxiliary\"] = 6] = \"Secondary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Primary_And_Secondary_And_Auxiliary\"] = 7] = \"Primary_And_Secondary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Fourth_Button\"] = 8] = \"Fourth_Button\";\n    MouseBindings[MouseBindings[\"Fifth_Button\"] = 16] = \"Fifth_Button\";\n    MouseBindings[MouseBindings[\"Wheel\"] = 524288] = \"Wheel\";\n    MouseBindings[MouseBindings[\"Wheel_Primary\"] = 524289] = \"Wheel_Primary\";\n})(MouseBindings || (MouseBindings = {}));\nvar KeyboardBindings;\n(function (KeyboardBindings) {\n    KeyboardBindings[KeyboardBindings[\"Shift\"] = 16] = \"Shift\";\n    KeyboardBindings[KeyboardBindings[\"Ctrl\"] = 17] = \"Ctrl\";\n    KeyboardBindings[KeyboardBindings[\"Alt\"] = 18] = \"Alt\";\n    KeyboardBindings[KeyboardBindings[\"Meta\"] = 91] = \"Meta\";\n    KeyboardBindings[KeyboardBindings[\"ShiftCtrl\"] = 1617] = \"ShiftCtrl\";\n    KeyboardBindings[KeyboardBindings[\"ShiftAlt\"] = 1618] = \"ShiftAlt\";\n    KeyboardBindings[KeyboardBindings[\"ShiftMeta\"] = 1691] = \"ShiftMeta\";\n    KeyboardBindings[KeyboardBindings[\"CtrlAlt\"] = 1718] = \"CtrlAlt\";\n    KeyboardBindings[KeyboardBindings[\"CtrlMeta\"] = 1791] = \"CtrlMeta\";\n    KeyboardBindings[KeyboardBindings[\"AltMeta\"] = 1891] = \"AltMeta\";\n})(KeyboardBindings || (KeyboardBindings = {}));\nexport { MouseBindings, KeyboardBindings };\n", "var ToolModes;\n(function (ToolModes) {\n    ToolModes[\"Active\"] = \"Active\";\n    ToolModes[\"Passive\"] = \"Passive\";\n    ToolModes[\"Enabled\"] = \"Enabled\";\n    ToolModes[\"Disabled\"] = \"Disabled\";\n})(ToolModes || (ToolModes = {}));\nexport default ToolModes;\n", "var AnnotationStyleStates;\n(function (AnnotationStyleStates) {\n    AnnotationStyleStates[\"Default\"] = \"\";\n    AnnotationStyleStates[\"Highlighted\"] = \"Highlighted\";\n    AnnotationStyleStates[\"Selected\"] = \"Selected\";\n    AnnotationStyleStates[\"Locked\"] = \"Locked\";\n    AnnotationStyleStates[\"AutoGenerated\"] = \"AutoGenerated\";\n})(AnnotationStyleStates || (AnnotationStyleStates = {}));\nexport default AnnotationStyleStates;\n", "var Events;\n(function (Events) {\n    Events[\"TOOL_ACTIVATED\"] = \"CORNERSTONE_TOOLS_TOOL_ACTIVATED\";\n    Events[\"TOOLGROUP_VIEWPORT_ADDED\"] = \"CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_ADDED\";\n    Events[\"TOOLGROUP_VIEWPORT_REMOVED\"] = \"CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_REMOVED\";\n    Events[\"TOOL_MODE_CHANGED\"] = \"CORNERSTONE_TOOLS_TOOL_MODE_CHANGED\";\n    Events[\"CROSSHAIR_TOOL_CENTER_CHANGED\"] = \"CORNERSTONE_TOOLS_CROSSHAIR_TOOL_CENTER_CHANGED\";\n    Events[\"VOLUMECROPPINGCONTROL_TOOL_CHANGED\"] = \"CORNERSTONE_TOOLS_VOLUMECROPPINGCONTROL_TOOL_CHANGED\";\n    Events[\"VOLUMECROPPING_TOOL_CHANGED\"] = \"CORNERSTONE_TOOLS_VOLUMECROPPING_TOOL_CHANGED\";\n    Events[\"STACK_PREFETCH_COMPLETE\"] = \"CORNERSTONE_TOOLS_STACK_PREFETCH_COMPLETE\";\n    Events[\"ANNOTATION_ADDED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_ADDED\";\n    Events[\"ANNOTATION_COMPLETED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_COMPLETED\";\n    Events[\"ANNOTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_MODIFIED\";\n    Events[\"ANNOTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_REMOVED\";\n    Events[\"ANNOTATION_SELECTION_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE\";\n    Events[\"ANNOTATION_LOCK_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE\";\n    Events[\"ANNOTATION_VISIBILITY_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE\";\n    Events[\"ANNOTATION_RENDERED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_RENDERED\";\n    Events[\"ANNOTATION_CUT_MERGE_PROCESS_COMPLETED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_CUT_MERGE_PROCESS_COMPLETED\";\n    Events[\"ANNOTATION_INTERPOLATION_PROCESS_COMPLETED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_INTERPOLATION_PROCESS_COMPLETED\";\n    Events[\"INTERPOLATED_ANNOTATIONS_REMOVED\"] = \"CORNERSTONE_TOOLS_INTERPOLATED_ANNOTATIONS_REMOVED\";\n    Events[\"SEGMENTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED\";\n    Events[\"SEGMENTATION_RENDERED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_RENDERED\";\n    Events[\"SEGMENTATION_REPRESENTATION_ADDED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_ADDED\";\n    Events[\"SEGMENTATION_ADDED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_ADDED\";\n    Events[\"SEGMENTATION_REPRESENTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED\";\n    Events[\"SEGMENTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REMOVED\";\n    Events[\"SEGMENTATION_REPRESENTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED\";\n    Events[\"SEGMENTATION_DATA_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED\";\n    Events[\"HISTORY_UNDO\"] = \"CORNERSTONE_TOOLS_HISTORY_UNDO\";\n    Events[\"HISTORY_REDO\"] = \"CORNERSTONE_TOOLS_HISTORY_REDO\";\n    Events[\"KEY_DOWN\"] = \"CORNERSTONE_TOOLS_KEY_DOWN\";\n    Events[\"KEY_UP\"] = \"CORNERSTONE_TOOLS_KEY_UP\";\n    Events[\"MOUSE_DOWN\"] = \"CORNERSTONE_TOOLS_MOUSE_DOWN\";\n    Events[\"MOUSE_UP\"] = \"CORNERSTONE_TOOLS_MOUSE_UP\";\n    Events[\"MOUSE_DOWN_ACTIVATE\"] = \"CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE\";\n    Events[\"MOUSE_DRAG\"] = \"CORNERSTONE_TOOLS_MOUSE_DRAG\";\n    Events[\"MOUSE_MOVE\"] = \"CORNERSTONE_TOOLS_MOUSE_MOVE\";\n    Events[\"MOUSE_CLICK\"] = \"CORNERSTONE_TOOLS_MOUSE_CLICK\";\n    Events[\"MOUSE_DOUBLE_CLICK\"] = \"CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK\";\n    Events[\"MOUSE_WHEEL\"] = \"CORNERSTONE_TOOLS_MOUSE_WHEEL\";\n    Events[\"TOUCH_START\"] = \"CORNERSTONE_TOOLS_TOUCH_START\";\n    Events[\"TOUCH_START_ACTIVATE\"] = \"CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE\";\n    Events[\"TOUCH_PRESS\"] = \"CORNERSTONE_TOOLS_TOUCH_PRESS\";\n    Events[\"TOUCH_DRAG\"] = \"CORNERSTONE_TOOLS_TOUCH_DRAG\";\n    Events[\"TOUCH_END\"] = \"CORNERSTONE_TOOLS_TOUCH_END\";\n    Events[\"TOUCH_TAP\"] = \"CORNERSTONE_TOOLS_TAP\";\n    Events[\"TOUCH_SWIPE\"] = \"CORNERSTONE_TOOLS_SWIPE\";\n})(Events || (Events = {}));\nexport default Events;\n", "var SegmentationRepresentations;\n(function (SegmentationRepresentations) {\n    SegmentationRepresentations[\"Labelmap\"] = \"Labelmap\";\n    SegmentationRepresentations[\"Contour\"] = \"Contour\";\n    SegmentationRepresentations[\"Surface\"] = \"Surface\";\n})(SegmentationRepresentations || (SegmentationRepresentations = {}));\nexport default SegmentationRepresentations;\n", "var Swipe;\n(function (Swipe) {\n    Swipe[\"UP\"] = \"UP\";\n    Swipe[\"DOWN\"] = \"DOWN\";\n    Swipe[\"LEFT\"] = \"LEFT\";\n    Swipe[\"RIGHT\"] = \"RIGHT\";\n})(Swipe || (Swipe = {}));\nexport { Swipe };\n", "var StrategyCallbacks;\n(function (StrategyCallbacks) {\n    StrategyCallbacks[\"OnInteractionStart\"] = \"onInteractionStart\";\n    StrategyCallbacks[\"OnInteractionEnd\"] = \"onInteractionEnd\";\n    StrategyCallbacks[\"Preview\"] = \"preview\";\n    StrategyCallbacks[\"RejectPreview\"] = \"rejectPreview\";\n    StrategyCallbacks[\"AcceptPreview\"] = \"acceptPreview\";\n    StrategyCallbacks[\"Fill\"] = \"fill\";\n    StrategyCallbacks[\"Interpolate\"] = \"interpolate\";\n    StrategyCallbacks[\"StrategyFunction\"] = \"strategyFunction\";\n    StrategyCallbacks[\"CreateIsInThreshold\"] = \"createIsInThreshold\";\n    StrategyCallbacks[\"Initialize\"] = \"initialize\";\n    StrategyCallbacks[\"INTERNAL_setValue\"] = \"setValue\";\n    StrategyCallbacks[\"AddPreview\"] = \"addPreview\";\n    StrategyCallbacks[\"ComputeInnerCircleRadius\"] = \"computeInnerCircleRadius\";\n    StrategyCallbacks[\"GetStatistics\"] = \"getStatistics\";\n    StrategyCallbacks[\"EnsureImageVolumeFor3DManipulation\"] = \"ensureImageVolumeFor3DManipulation\";\n    StrategyCallbacks[\"EnsureSegmentationVolumeFor3DManipulation\"] = \"ensureSegmentationVolumeFor3DManipulation\";\n})(StrategyCallbacks || (StrategyCallbacks = {}));\nexport default StrategyCallbacks;\n", "var ChangeTypes;\n(function (ChangeTypes) {\n    ChangeTypes[\"Interaction\"] = \"Interaction\";\n    ChangeTypes[\"HandlesUpdated\"] = \"HandlesUpdated\";\n    ChangeTypes[\"StatsUpdated\"] = \"StatsUpdated\";\n    ChangeTypes[\"InitialSetup\"] = \"InitialSetup\";\n    ChangeTypes[\"Completed\"] = \"Completed\";\n    ChangeTypes[\"InterpolationUpdated\"] = \"InterpolationUpdated\";\n    ChangeTypes[\"History\"] = \"History\";\n    ChangeTypes[\"MetadataReferenceModified\"] = \"MetadataReferenceModified\";\n    ChangeTypes[\"LabelChange\"] = \"LabelChange\";\n})(ChangeTypes || (ChangeTypes = {}));\nexport default ChangeTypes;\n", "var ChangeTypes;\n(function (ChangeTypes) {\n    ChangeTypes[\"POLYSEG_CONTOUR_TO_LABELMAP\"] = \"Converting Contour to Labelmap\";\n    ChangeTypes[\"POLYSEG_SURFACE_TO_LABELMAP\"] = \"Converting Surfaces to Labelmap\";\n    ChangeTypes[\"POLYSEG_CONTOUR_TO_SURFACE\"] = \"Converting Contour to Surface\";\n    ChangeTypes[\"POLYSEG_LABELMAP_TO_SURFACE\"] = \"Converting Labelmap to Surface\";\n    ChangeTypes[\"SURFACE_CLIPPING\"] = \"Clipping Surfaces\";\n    ChangeTypes[\"COMPUTE_STATISTICS\"] = \"Computing Statistics\";\n    ChangeTypes[\"INTERPOLATE_LABELMAP\"] = \"Interpolating Labelmap\";\n    ChangeTypes[\"COMPUTE_LARGEST_BIDIRECTIONAL\"] = \"Computing Largest Bidirectional\";\n    ChangeTypes[\"GENERATE_CONTOUR_SETS\"] = \"Generating Contour Sets\";\n})(ChangeTypes || (ChangeTypes = {}));\nexport default ChangeTypes;\n", "import createToolGroup from './createToolGroup';\nimport destroyToolGroup from './destroyToolGroup';\nimport destroy from './destroy';\nimport getToolGroup from './getToolGroup';\nimport getToolGroupForViewport from './getToolGroupForViewport';\nimport getAllToolGroups from './getAllToolGroups';\nimport getToolGroupsWithToolName from './getToolGroupsWithToolName';\nexport { createToolGroup, destroy, destroyToolGroup, getToolGroup, getToolGroupForViewport, getAllToolGroups, getToolGroupsWithToolName, };\n", "let svgNodeCache = {};\nexport function resetSvgNodeCache() {\n    svgNodeCache = {};\n}\nexport default svgNodeCache;\n", "import svgNodeCache, { resetSvgNodeCache } from './svgNodeCache';\nconst defaultState = {\n    isInteractingWithTool: false,\n    isMultiPartToolActive: false,\n    tools: {},\n    toolGroups: [],\n    synchronizers: [],\n    svgNodeCache: svgNodeCache,\n    enabledElements: [],\n    handleRadius: 6,\n};\nlet state = {\n    isInteractingWithTool: false,\n    isMultiPartToolActive: false,\n    tools: {},\n    toolGroups: [],\n    synchronizers: [],\n    svgNodeCache: svgNodeCache,\n    enabledElements: [],\n    handleRadius: 6,\n};\nfunction resetCornerstoneToolsState() {\n    resetSvgNodeCache();\n    state = {\n        ...structuredClone({\n            ...defaultState,\n            svgNodeCache: {},\n        }),\n        svgNodeCache: {\n            ...defaultState.svgNodeCache,\n        },\n    };\n}\nexport { resetCornerstoneToolsState, state, state as default };\n", "import { MouseBindings, ToolModes, Events } from '../../enums';\nimport get from 'lodash.get';\nimport { triggerEvent, eventTarget, getRenderingEngine, getRenderingEngines, getEnabledElementByIds, Settings, } from '@cornerstonejs/core';\nimport { utilities } from '@cornerstonejs/core';\nimport { state } from '../state';\nimport { MouseCursor, SVGMouseCursor } from '../../cursors';\nimport { initElementCursor } from '../../cursors/elementCursor';\nimport getToolGroup from './getToolGroup';\nconst { Active, Passive, Enabled, Disabled } = ToolModes;\nconst PRIMARY_BINDINGS = [{ mouseButton: MouseBindings.Primary }];\nexport default class ToolGroup {\n    constructor(id) {\n        this.viewportsInfo = [];\n        this.toolOptions = {};\n        this.currentActivePrimaryToolName = null;\n        this.prevActivePrimaryToolName = null;\n        this.restoreToolOptions = {};\n        this._toolInstances = {};\n        this.id = id;\n    }\n    getViewportIds() {\n        return this.viewportsInfo.map(({ viewportId }) => viewportId);\n    }\n    getViewportsInfo() {\n        return this.viewportsInfo.slice();\n    }\n    getToolInstance(toolInstanceName) {\n        const toolInstance = this._toolInstances[toolInstanceName];\n        if (!toolInstance) {\n            console.warn(`'${toolInstanceName}' is not registered with this toolGroup (${this.id}).`);\n            return;\n        }\n        return toolInstance;\n    }\n    getToolInstances() {\n        return this._toolInstances;\n    }\n    hasTool(toolName) {\n        return !!this._toolInstances[toolName];\n    }\n    addTool(toolName, configuration = {}) {\n        const toolDefinition = state.tools[toolName];\n        const hasToolName = typeof toolName !== 'undefined' && toolName !== '';\n        const localToolInstance = this.toolOptions[toolName];\n        if (!hasToolName) {\n            console.warn('Tool with configuration did not produce a toolName: ', configuration);\n            return;\n        }\n        if (!toolDefinition) {\n            console.warn(`'${toolName}' is not registered with the library. You need to use cornerstoneTools.addTool to register it.`);\n            return;\n        }\n        if (localToolInstance) {\n            console.warn(`'${toolName}' is already registered for ToolGroup ${this.id}.`);\n            return;\n        }\n        const { toolClass: ToolClass } = toolDefinition;\n        const toolProps = {\n            name: toolName,\n            toolGroupId: this.id,\n            configuration,\n        };\n        const instantiatedTool = new ToolClass(toolProps);\n        this._toolInstances[toolName] = instantiatedTool;\n    }\n    addToolInstance(toolName, parentClassName, configuration = {}) {\n        let ToolClassToUse = state.tools[toolName]\n            ?.toolClass;\n        if (!ToolClassToUse) {\n            const ParentClass = state.tools[parentClassName]\n                .toolClass;\n            class ToolInstance extends ParentClass {\n            }\n            ToolInstance.toolName = toolName;\n            ToolClassToUse = ToolInstance;\n            state.tools[toolName] = {\n                toolClass: ToolInstance,\n            };\n        }\n        this.addTool(ToolClassToUse.toolName, configuration);\n    }\n    addViewport(viewportId, renderingEngineId) {\n        if (typeof viewportId !== 'string') {\n            throw new Error('viewportId must be defined and be a string');\n        }\n        const renderingEngineUIDToUse = this._findRenderingEngine(viewportId, renderingEngineId);\n        if (!this.viewportsInfo.some(({ viewportId: vpId }) => vpId === viewportId)) {\n            this.viewportsInfo.push({\n                viewportId,\n                renderingEngineId: renderingEngineUIDToUse,\n            });\n        }\n        const toolName = this.getActivePrimaryMouseButtonTool();\n        this.setViewportsCursorByToolName(toolName);\n        const eventDetail = {\n            toolGroupId: this.id,\n            viewportId,\n            renderingEngineId: renderingEngineUIDToUse,\n        };\n        triggerEvent(eventTarget, Events.TOOLGROUP_VIEWPORT_ADDED, eventDetail);\n    }\n    removeViewports(renderingEngineId, viewportId) {\n        const indices = [];\n        this.viewportsInfo.forEach((vpInfo, index) => {\n            let match = false;\n            if (vpInfo.renderingEngineId === renderingEngineId) {\n                match = true;\n                if (viewportId && vpInfo.viewportId !== viewportId) {\n                    match = false;\n                }\n            }\n            if (match) {\n                indices.push(index);\n            }\n        });\n        if (indices.length) {\n            for (let i = indices.length - 1; i >= 0; i--) {\n                this.viewportsInfo.splice(indices[i], 1);\n            }\n        }\n        const eventDetail = {\n            toolGroupId: this.id,\n            viewportId,\n            renderingEngineId,\n        };\n        triggerEvent(eventTarget, Events.TOOLGROUP_VIEWPORT_REMOVED, eventDetail);\n    }\n    setActiveStrategy(toolName, strategyName) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool configuration.`);\n            return;\n        }\n        toolInstance.setActiveStrategy(strategyName);\n    }\n    setToolMode(toolName, mode, options = {}) {\n        if (!toolName) {\n            console.warn('setToolMode: toolName must be defined');\n            return;\n        }\n        if (mode === ToolModes.Active) {\n            this.setToolActive(toolName, options || this.restoreToolOptions[toolName]);\n            return;\n        }\n        if (mode === ToolModes.Passive) {\n            this.setToolPassive(toolName);\n            return;\n        }\n        if (mode === ToolModes.Enabled) {\n            this.setToolEnabled(toolName);\n            return;\n        }\n        if (mode === ToolModes.Disabled) {\n            this.setToolDisabled(toolName);\n            return;\n        }\n        console.warn('setToolMode: mode must be defined');\n    }\n    setToolActive(toolName, toolBindingsOptions = {}) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);\n            return;\n        }\n        if (!toolInstance) {\n            console.warn(`'${toolName}' instance ${toolInstance} is not registered with this toolGroup, can't set tool mode.`);\n            return;\n        }\n        const prevBindings = this.toolOptions[toolName]\n            ? this.toolOptions[toolName].bindings\n            : [];\n        const newBindings = toolBindingsOptions.bindings\n            ? toolBindingsOptions.bindings\n            : [];\n        const bindingsToUse = [...prevBindings, ...newBindings].reduce((unique, binding) => {\n            const TouchBinding = binding.numTouchPoints !== undefined;\n            const MouseBinding = binding.mouseButton !== undefined;\n            if (!unique.some((obj) => hasSameBinding(obj, binding)) &&\n                (TouchBinding || MouseBinding)) {\n                unique.push(binding);\n            }\n            return unique;\n        }, []);\n        const toolOptions = {\n            bindings: bindingsToUse,\n            mode: Active,\n        };\n        this.toolOptions[toolName] = toolOptions;\n        this._toolInstances[toolName].mode = Active;\n        if (!this._hasMousePrimaryButtonBinding(toolBindingsOptions)) {\n            const activeToolIdentifier = this.getActivePrimaryMouseButtonTool();\n            if (!activeToolIdentifier) {\n                const cursor = MouseCursor.getDefinedCursor('default');\n                this._setCursorForViewports(cursor);\n            }\n        }\n        else {\n            this.setViewportsCursorByToolName(toolName);\n        }\n        if (this._hasMousePrimaryButtonBinding(toolBindingsOptions)) {\n            if (this.prevActivePrimaryToolName === null) {\n                this.prevActivePrimaryToolName = toolName;\n            }\n            else {\n                this.prevActivePrimaryToolName = this.currentActivePrimaryToolName;\n            }\n            this.currentActivePrimaryToolName = toolName;\n        }\n        if (typeof toolInstance.onSetToolActive === 'function') {\n            toolInstance.onSetToolActive();\n        }\n        this._renderViewports();\n        const eventDetail = {\n            toolGroupId: this.id,\n            toolName,\n            toolBindingsOptions,\n        };\n        triggerEvent(eventTarget, Events.TOOL_ACTIVATED, eventDetail);\n        this._triggerToolModeChangedEvent(toolName, Active, toolBindingsOptions);\n    }\n    setToolPassive(toolName, options) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);\n            return;\n        }\n        const prevToolOptions = this.getToolOptions(toolName);\n        const toolOptions = Object.assign({\n            bindings: prevToolOptions ? prevToolOptions.bindings : [],\n        }, prevToolOptions, {\n            mode: Passive,\n        });\n        const matchBindings = Array.isArray(options?.removeAllBindings)\n            ? options.removeAllBindings\n            : this.getDefaultPrimaryBindings();\n        toolOptions.bindings = toolOptions.bindings.filter((binding) => options?.removeAllBindings !== true &&\n            !matchBindings.some((matchBinding) => hasSameBinding(binding, matchBinding)));\n        let mode = Passive;\n        if (toolOptions.bindings.length !== 0) {\n            mode = Active;\n            toolOptions.mode = mode;\n        }\n        this.toolOptions[toolName] = toolOptions;\n        toolInstance.mode = mode;\n        if (typeof toolInstance.onSetToolPassive === 'function') {\n            toolInstance.onSetToolPassive();\n        }\n        this._renderViewports();\n        this._triggerToolModeChangedEvent(toolName, Passive);\n    }\n    setToolEnabled(toolName) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);\n            return;\n        }\n        const toolOptions = {\n            bindings: [],\n            mode: Enabled,\n        };\n        this.toolOptions[toolName] = toolOptions;\n        toolInstance.mode = Enabled;\n        if (typeof toolInstance.onSetToolEnabled === 'function') {\n            toolInstance.onSetToolEnabled();\n        }\n        this._renderViewports();\n        this._triggerToolModeChangedEvent(toolName, Enabled);\n    }\n    setToolDisabled(toolName) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);\n            return;\n        }\n        const toolOptions = {\n            bindings: [],\n            mode: Disabled,\n        };\n        this.restoreToolOptions[toolName] = this.toolOptions[toolName];\n        this.toolOptions[toolName] = toolOptions;\n        toolInstance.mode = Disabled;\n        if (typeof toolInstance.onSetToolDisabled === 'function') {\n            toolInstance.onSetToolDisabled();\n        }\n        this._renderViewports();\n        this._triggerToolModeChangedEvent(toolName, Disabled);\n    }\n    getToolOptions(toolName) {\n        const toolOptionsForTool = this.toolOptions[toolName];\n        if (toolOptionsForTool === undefined) {\n            return;\n        }\n        return toolOptionsForTool;\n    }\n    getActivePrimaryMouseButtonTool() {\n        return Object.keys(this.toolOptions).find((toolName) => {\n            const toolOptions = this.toolOptions[toolName];\n            return (toolOptions.mode === Active &&\n                this._hasMousePrimaryButtonBinding(toolOptions));\n        });\n    }\n    setViewportsCursorByToolName(toolName, strategyName) {\n        const cursor = this._getCursor(toolName, strategyName);\n        this._setCursorForViewports(cursor);\n    }\n    _getCursor(toolName, strategyName) {\n        let cursorName;\n        let cursor;\n        if (strategyName) {\n            cursorName = `${toolName}.${strategyName}`;\n            cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n            if (cursor) {\n                return cursor;\n            }\n        }\n        cursorName = `${toolName}`;\n        cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n        if (cursor) {\n            return cursor;\n        }\n        cursorName = toolName;\n        cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n        if (cursor) {\n            return cursor;\n        }\n        return MouseCursor.getDefinedCursor('default');\n    }\n    _setCursorForViewports(cursor) {\n        const runtimeSettings = Settings.getRuntimeSettings();\n        if (!runtimeSettings.get('useCursors')) {\n            return;\n        }\n        this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (!enabledElement) {\n                return;\n            }\n            const { viewport } = enabledElement;\n            initElementCursor(viewport.element, cursor);\n        });\n    }\n    setToolConfiguration(toolName, configuration, overwrite) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not present, can't set tool configuration.`);\n            return false;\n        }\n        let _configuration;\n        if (overwrite) {\n            _configuration = configuration;\n        }\n        else {\n            _configuration = Object.assign(toolInstance.configuration, configuration);\n        }\n        toolInstance.configuration = _configuration;\n        if (typeof toolInstance.onSetToolConfiguration === 'function') {\n            toolInstance.onSetToolConfiguration();\n        }\n        this._renderViewports();\n        return true;\n    }\n    getDefaultMousePrimary() {\n        return MouseBindings.Primary;\n    }\n    getDefaultPrimaryBindings() {\n        return PRIMARY_BINDINGS;\n    }\n    getToolConfiguration(toolName, configurationPath) {\n        if (this._toolInstances[toolName] === undefined) {\n            console.warn(`Tool ${toolName} not present, can't set tool configuration.`);\n            return;\n        }\n        const _configuration = get(this._toolInstances[toolName].configuration, configurationPath) ||\n            this._toolInstances[toolName].configuration;\n        return utilities.deepClone(_configuration);\n    }\n    getPrevActivePrimaryToolName() {\n        return this.prevActivePrimaryToolName;\n    }\n    setActivePrimaryTool(toolName) {\n        const activeToolName = this.getCurrentActivePrimaryToolName();\n        this.setToolDisabled(activeToolName);\n        this.setToolActive(toolName, {\n            bindings: [{ mouseButton: MouseBindings.Primary }],\n        });\n    }\n    getCurrentActivePrimaryToolName() {\n        return this.currentActivePrimaryToolName;\n    }\n    clone(newToolGroupId, fnToolFilter = null) {\n        let toolGroup = getToolGroup(newToolGroupId);\n        if (toolGroup) {\n            console.debug(`ToolGroup ${newToolGroupId} already exists`);\n            return toolGroup;\n        }\n        toolGroup = new ToolGroup(newToolGroupId);\n        state.toolGroups.push(toolGroup);\n        fnToolFilter = fnToolFilter ?? (() => true);\n        Object.keys(this._toolInstances)\n            .filter(fnToolFilter)\n            .forEach((toolName) => {\n            const sourceToolInstance = this._toolInstances[toolName];\n            const sourceToolOptions = this.toolOptions[toolName];\n            const sourceToolMode = sourceToolInstance.mode;\n            toolGroup.addTool(toolName);\n            toolGroup.setToolMode(toolName, sourceToolMode, {\n                bindings: sourceToolOptions.bindings ?? [],\n            });\n        });\n        return toolGroup;\n    }\n    _hasMousePrimaryButtonBinding(toolOptions) {\n        const primaryBindings = this.getDefaultPrimaryBindings();\n        return toolOptions?.bindings?.some((binding) => primaryBindings.some((primary) => hasSameBinding(binding, primary)));\n    }\n    _renderViewports() {\n        this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n            getRenderingEngine(renderingEngineId).renderViewport(viewportId);\n        });\n    }\n    _triggerToolModeChangedEvent(toolName, mode, toolBindingsOptions) {\n        const eventDetail = {\n            toolGroupId: this.id,\n            toolName,\n            mode,\n            toolBindingsOptions,\n        };\n        triggerEvent(eventTarget, Events.TOOL_MODE_CHANGED, eventDetail);\n    }\n    _findRenderingEngine(viewportId, renderingEngineId) {\n        const renderingEngines = getRenderingEngines();\n        if (renderingEngines?.length === 0) {\n            throw new Error('No rendering engines found.');\n        }\n        if (renderingEngineId) {\n            return renderingEngineId;\n        }\n        const matchingEngines = renderingEngines.filter((engine) => engine.getViewport(viewportId));\n        if (matchingEngines.length === 0) {\n            if (renderingEngines.length === 1) {\n                return renderingEngines[0].id;\n            }\n            throw new Error('No rendering engines found that contain the viewport with the same viewportId, you must specify a renderingEngineId.');\n        }\n        if (matchingEngines.length > 1) {\n            throw new Error('Multiple rendering engines found that contain the viewport with the same viewportId, you must specify a renderingEngineId.');\n        }\n        return matchingEngines[0].id;\n    }\n}\nfunction hasSameBinding(binding1, binding2) {\n    if (binding1.mouseButton !== binding2.mouseButton) {\n        return false;\n    }\n    if (binding1.numTouchPoints !== binding2.numTouchPoints) {\n        return false;\n    }\n    return binding1.modifierKey === binding2.modifierKey;\n}\n", "import MouseCursor, { standardCursorNames } from './MouseCursor';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport SVGMouseCursor from './SVGMouseCursor';\nimport * as elementCursor from './elementCursor';\nimport setCursorForElement from './setCursorForElement';\nimport { registerCursor, svgCursorNames, CursorSVG, } from './SVGCursorDescriptor';\nconst CursorNames = [...svgCursorNames, ...standardCursorNames];\nexport { MouseCursor, ImageMouseCursor, SVGMouseCursor, elementCursor, registerCursor, CursorNames, CursorSVG, setCursorForElement, };\n", "const DEFINED_CURSORS = Symbol('DefinedCursors');\nconst STANDARD_CURSORS = new Set([\n    'alias',\n    'all-scroll',\n    'auto',\n    'cell',\n    'col-resize',\n    'context-menu',\n    'copy',\n    'crosshair',\n    'default',\n    'e-resize',\n    'ew-resize',\n    'grab',\n    'grabbing',\n    'help',\n    'move',\n    'ne-resize',\n    'nesw-resize',\n    'no-drop',\n    'none',\n    'not-allowed',\n    'n-resize',\n    'ns-resize',\n    'nw-resize',\n    'nwse-resize',\n    'pointer',\n    'progress',\n    'row-resize',\n    'se-resize',\n    's-resize',\n    'sw-resize',\n    'text',\n    'vertical-text',\n    'wait',\n    'w-resize',\n    'zoom-in',\n    'zoom-out',\n]);\nexport default class MouseCursor {\n    constructor(name, fallback) {\n        this.name = name + '';\n        this.fallback = fallback;\n    }\n    getName() {\n        return this.name + '';\n    }\n    addFallbackStyleProperty(style) {\n        const { fallback } = this;\n        if (fallback instanceof MouseCursor) {\n            return `${style}, ${fallback.getStyleProperty()}`;\n        }\n        return style + '';\n    }\n    getStyleProperty() {\n        return this.addFallbackStyleProperty(this.name) + '';\n    }\n    static getDefinedCursor(name) {\n        const definedCursors = getDefinedCursors(MouseCursor, DEFINED_CURSORS);\n        let mouseCursor = definedCursors.get(name);\n        if (mouseCursor instanceof MouseCursor) {\n            return mouseCursor;\n        }\n        if (STANDARD_CURSORS.has(name)) {\n            mouseCursor = new MouseCursor(name);\n            definedCursors.set(name, mouseCursor);\n            return mouseCursor;\n        }\n    }\n    static setDefinedCursor(name, cursor) {\n        if (cursor instanceof MouseCursor) {\n            const definedCursors = getDefinedCursors(MouseCursor, DEFINED_CURSORS);\n            definedCursors.set(name, cursor);\n            return true;\n        }\n        return false;\n    }\n}\nfunction getDefinedCursors(context, symbol) {\n    let definedCursors = context[symbol];\n    if (!(definedCursors instanceof Map)) {\n        definedCursors = new Map();\n        Object.defineProperty(context, symbol, { value: definedCursors });\n    }\n    return definedCursors;\n}\nconst standardCursorNames = STANDARD_CURSORS.values();\nexport { standardCursorNames };\n", "import { utilities } from '@cornerstonejs/core';\nimport MouseCursor from './MouseCursor';\nconst DEFAULT_NAME = 'image-cursor';\nexport default class ImageMouseCursor extends MouseCursor {\n    constructor(url, x, y, name, fallback) {\n        super(name || ImageMouseCursor.getUniqueInstanceName(DEFAULT_NAME), fallback);\n        this.url = url;\n        this.x = Number(x) || 0;\n        this.y = Number(y) || 0;\n    }\n    getStyleProperty() {\n        const { url, x, y } = this;\n        let style = `url('${url}')`;\n        if (x >= 0 && y >= 0 && (x > 0 || y > 0)) {\n            style += ` ${x} ${y}`;\n        }\n        return this.addFallbackStyleProperty(style);\n    }\n    static getUniqueInstanceName(prefix) {\n        return `${prefix}-${utilities.getRuntimeId(ImageMouseCursor)}`;\n    }\n}\n", "const BASE = {\n    iconContent: '',\n    iconSize: 16,\n    viewBox: {\n        x: 16,\n        y: 16,\n    },\n    mousePoint: {\n        x: 8,\n        y: 8,\n    },\n    mousePointerGroupString: `\n    <path stroke=\"{{color}}\" d=\"M8 16L8 0\"></path>\n    <path stroke=\"{{color}}\" d=\"M16 8L0 8\"></path>\n  `,\n};\nconst SEGMENTATION_CURSOR_BOUNDARIES = {\n    x: 127,\n    y: 60,\n};\nconst MINUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n`;\nconst PLUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n<rect fill=\"{{color}}\" x=\"95.84\" y=\"9.38\" width=\"15.85\" height=\"47.14\"/>\n`;\nconst SCISSOR_ICON = `<path fill=\"{{color}}\" d=\"M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z\" transform=\"translate(-1.17 -0.96)\"/>`;\nconst RECTANGLE_ICON = `<path fill=\"{{color}}\" d=\"M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z\" transform=\"translate(-8.86 -2.25)\"/>`;\nconst CIRCLE_ICON = `<path fill=\"{{color}}\" d=\"M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z\" transform=\"translate(-8.86 -2.25)\"/>`;\nconst CursorSVG = {\n    Angle: extend(BASE, {\n        name: 'Angle',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50\n    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23\n    10l50 50q10 10 10 23z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    ArrowAnnotate: extend(BASE, {\n        name: 'ArrowAnnotate',\n        iconContent: `<g id=\"arrowAnnotate-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"arrowAnnotate-arrow\" d=\"M23,7 l-15,15 M7,17 l0,6 6,0\" stroke-width=\"2\" />\n  </g>`,\n        viewBox: {\n            x: 24,\n            y: 24,\n        },\n    }),\n    Bidirectional: extend(BASE, {\n        name: 'Bidirectional',\n        iconContent: `<g fill=\"{{color}}\" stroke-width=\"3\" stroke=\"{{color}}\">\n    <path d=\"M27.63 3.21L3.12 28.81\"></path>\n    <path d=\"M27.63 15.75L15.27 4.43\"></path>\n    <path d=\"M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z\" ></path>\n    <path d=\"M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z\"></path>\n    <path d=\"M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z\"></path>\n    <path d=\"M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z\"></path>\n  </g>`,\n        viewBox: {\n            x: 48,\n            y: 48,\n        },\n    }),\n    CobbAngle: extend(BASE, {\n        name: 'CobbAngle',\n        iconContent: `<g stroke=\"{{color}}\" stroke-width=\"3\">\n    <path d=\"M28.59 2.34L3.82 12.32\"></path>\n    <path d=\"M28.59 29.66L3.82 19.68\"></path>\n    <path stroke-dasharray=\"2\" fill-opacity=\"0\" d=\"M12.37\n      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15\n      9.33C13.11 9.24 13.02 9 12.88 8.63\">\n    </path>\n  </g>`,\n        viewBox: {\n            x: 32,\n            y: 32,\n        },\n    }),\n    CircleROI: extend(BASE, {\n        name: 'CircleROI',\n        iconContent: `<circle stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" cx=\"16\" cy=\"16\" r=\"14\" />`,\n        viewBox: {\n            x: 32,\n            y: 32,\n        },\n    }),\n    EllipticalROI: extend(BASE, {\n        name: 'EllipticalROI',\n        iconContent: `<path stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" d=\"M30.74 15.76C30.74 20.99 24.14 25.23 16\n    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14\n    6.3 30.74 10.54 30.74 15.76Z\" />`,\n        viewBox: {\n            x: 32,\n            y: 32,\n        },\n    }),\n    FreehandROI: extend(BASE, {\n        name: 'FreehandROI',\n        iconContent: `<g fill=\"{{color}}\" stroke=\"{{color}}\" stroke-width=\"2\">\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_3\" cy=\"4.240343\" cx=\"14.306499\"/>\n    <line id=\"svg_4\" y2=\"3.58462\" x2=\"12.242186\" y1=\"3.997482\" x1=\"13.432202\"/>\n    <line id=\"svg_5\" y2=\"3.268901\" x2=\"10.857882\" y1=\"3.608906\" x1=\"12.387902\"/>\n    <line id=\"svg_6\" y2=\"3.147471\" x2=\"9.740724\" y1=\"3.293187\" x1=\"10.955026\"/>\n    <line id=\"svg_7\" y2=\"3.147471\" x2=\"8.089274\" y1=\"3.196043\" x1=\"9.983585\"/>\n    <line id=\"svg_8\" y2=\"3.268901\" x2=\"6.874972\" y1=\"3.123185\" x1=\"8.307848\"/>\n    <line id=\"svg_9\" y2=\"3.657478\" x2=\"5.587812\" y1=\"3.220329\" x1=\"7.020688\"/>\n    <line id=\"svg_10\" y2=\"4.046054\" x2=\"4.737801\" y1=\"3.560334\" x1=\"5.854959\"/>\n    <line id=\"svg_11\" y2=\"4.337487\" x2=\"4.300652\" y1=\"3.997482\" x1=\"4.834945\"/>\n    <line id=\"svg_12\" y2=\"4.726063\" x2=\"3.88779\" y1=\"4.191771\" x1=\"4.470655\"/>\n    <line id=\"svg_15\" y2=\"5.3575\" x2=\"3.377783\" y1=\"4.604633\" x1=\"3.960648\"/>\n    <line id=\"svg_16\" y2=\"6.183226\" x2=\"2.916348\" y1=\"5.138926\" x1=\"3.547785\"/>\n    <line id=\"svg_17\" y2=\"6.960379\" x2=\"2.770632\" y1=\"5.867507\" x1=\"3.037779\"/>\n    <line id=\"svg_18\" y2=\"7.713246\" x2=\"2.673488\" y1=\"6.741804\" x1=\"2.819204\"/>\n    <line id=\"svg_19\" y2=\"8.684687\" x2=\"2.697774\" y1=\"7.616102\" x1=\"2.673488\"/>\n    <line id=\"svg_20\" y2=\"9.753273\" x2=\"2.892062\" y1=\"8.611829\" x1=\"2.697774\"/>\n    <line id=\"svg_21\" y2=\"10.724714\" x2=\"3.134923\" y1=\"9.534698\" x1=\"2.84349\"/>\n    <line id=\"svg_23\" y2=\"11.647583\" x2=\"3.596357\" y1=\"10.578998\" x1=\"3.086351\"/>\n    <line id=\"svg_25\" y2=\"12.521881\" x2=\"4.276366\" y1=\"11.501867\" x1=\"3.499213\"/>\n    <line id=\"svg_26\" y2=\"13.930471\" x2=\"5.830673\" y1=\"12.376165\" x1=\"4.13065\"/>\n    <line id=\"svg_28\" y2=\"14.707624\" x2=\"7.263549\" y1=\"13.881899\" x1=\"5.733528\"/>\n    <line id=\"svg_29\" y2=\"15.339061\" x2=\"8.963571\" y1=\"14.61048\" x1=\"7.06926\"/>\n    <line id=\"svg_30\" y2=\"15.581921\" x2=\"10.882168\" y1=\"15.314775\" x1=\"8.817855\"/>\n    <line id=\"svg_31\" y2=\"15.460491\" x2=\"12.023612\" y1=\"15.581921\" x1=\"10.785024\"/>\n    <line id=\"svg_33\" y2=\"15.120487\" x2=\"13.092197\" y1=\"15.484777\" x1=\"11.877895\"/>\n    <line id=\"svg_34\" y2=\"14.586194\" x2=\"13.86935\" y1=\"15.217631\" x1=\"12.897909\"/>\n    <line id=\"svg_35\" y2=\"13.833327\" x2=\"14.597931\" y1=\"14.756196\" x1=\"13.699348\"/>\n    <line id=\"svg_37\" y2=\"12.716169\" x2=\"15.180796\" y1=\"13.881899\" x1=\"14.549359\"/>\n    <line id=\"svg_39\" y2=\"11.429009\" x2=\"15.520801\" y1=\"12.813313\" x1=\"15.15651\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_40\" cy=\"10.967574\" cx=\"15.520801\"/>\n  </g>`,\n        viewBox: {\n            x: 18,\n            y: 18,\n        },\n    }),\n    FreehandROISculptor: extend(BASE, {\n        name: 'FreehandROISculptor',\n        iconContent: `<g id=\"icon-freehand-sculpt\" fill=\"none\" stroke-width=\"1.5\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <line id=\"svg_1\" y2=\"2.559367\" x2=\"10.184807\" y1=\"4.467781\" x1=\"8.81711\"/>\n    <line id=\"svg_4\" y2=\"1.493836\" x2=\"11.727442\" y1=\"2.766112\" x1=\"10.089386\"/>\n    <line id=\"svg_7\" y2=\"1.080346\" x2=\"13.047428\" y1=\"1.748291\" x1=\"11.345759\"/>\n    <line id=\"svg_8\" y2=\"1.000829\" x2=\"14.351511\" y1=\"1.112153\" x1=\"12.77707\"/>\n    <line id=\"svg_9\" y2=\"1.350705\" x2=\"15.242104\" y1=\"0.905408\" x1=\"13.969828\"/>\n    <line id=\"svg_10\" y2=\"2.098167\" x2=\"15.862339\" y1=\"1.14396\" x1=\"14.955842\"/>\n    <line id=\"svg_11\" y2=\"3.195505\" x2=\"16.41896\" y1=\"1.939133\" x1=\"15.766918\"/>\n    <line id=\"svg_12\" y2=\"4.292843\" x2=\"16.530284\" y1=\"2.925147\" x1=\"16.387153\"/>\n    <line id=\"svg_16\" y2=\"5.644637\" x2=\"16.196311\" y1=\"3.831643\" x1=\"16.593898\"/>\n    <line id=\"svg_18\" y2=\"7.266789\" x2=\"15.623787\" y1=\"5.19934\" x1=\"16.275829\"/>\n    <line id=\"svg_19\" y2=\"10.813258\" x2=\"14.526449\" y1=\"6.726071\" x1=\"15.766918\"/>\n    <line id=\"svg_20\" y2=\"5.056209\" x2=\"8.085552\" y1=\"4.181519\" x1=\"8.976145\"/>\n    <line id=\"svg_23\" y2=\"5.326568\" x2=\"7.481221\" y1=\"4.78585\" x1=\"8.403621\"/>\n    <line id=\"svg_24\" y2=\"5.565119\" x2=\"6.749662\" y1=\"5.294761\" x1=\"7.624352\"/>\n    <line id=\"svg_25\" y2=\"5.994512\" x2=\"5.429675\" y1=\"5.533312\" x1=\"6.956407\"/>\n    <line id=\"svg_27\" y2=\"6.551133\" x2=\"4.284627\" y1=\"5.962706\" x1=\"5.572807\"/>\n    <line id=\"svg_28\" y2=\"7.584858\" x2=\"3.044158\" y1=\"6.392099\" x1=\"4.427758\"/>\n    <line id=\"svg_29\" y2=\"8.84123\" x2=\"2.185372\" y1=\"7.489437\" x1=\"3.219096\"/>\n    <line id=\"svg_31\" y2=\"10.606513\" x2=\"1.644654\" y1=\"8.602678\" x1=\"2.280792\"/>\n    <line id=\"svg_32\" y2=\"13.214679\" x2=\"1.48562\" y1=\"10.352058\" x1=\"1.724171\"/>\n    <line id=\"svg_33\" y2=\"14.375631\" x2=\"1.676461\" y1=\"12.992031\" x1=\"1.453813\"/>\n    <line id=\"svg_34\" y2=\"15.298031\" x2=\"2.264889\" y1=\"14.152983\" x1=\"1.517427\"/>\n    <line id=\"svg_35\" y2=\"16.172721\" x2=\"3.521261\" y1=\"14.948155\" x1=\"1.915013\"/>\n    <line id=\"svg_36\" y2=\"16.824762\" x2=\"5.207027\" y1=\"15.997783\" x1=\"3.28271\"/>\n    <line id=\"svg_38\" y2=\"17.063314\" x2=\"7.035924\" y1=\"16.745245\" x1=\"4.968475\"/>\n    <line id=\"svg_39\" y2=\"16.888376\" x2=\"9.278311\" y1=\"17.047411\" x1=\"6.733758\"/>\n    <line id=\"svg_40\" y2=\"16.284045\" x2=\"10.661911\" y1=\"16.983797\" x1=\"8.992048\"/>\n    <line id=\"svg_41\" y2=\"15.313934\" x2=\"11.647925\" y1=\"16.395369\" x1=\"10.455166\"/>\n    <line id=\"svg_44\" y2=\"13.898527\" x2=\"12.82478\" y1=\"15.425259\" x1=\"11.504794\"/>\n    <line id=\"svg_45\" y2=\"12.037824\" x2=\"14.144766\" y1=\"14.312017\" x1=\"12.522614\"/>\n    <line id=\"svg_47\" y2=\"10.59061\" x2=\"14.605966\" y1=\"12.228665\" x1=\"13.953925\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_48\" cy=\"3.982726\" cx=\"13.460918\"/>\n  </g>`,\n        viewBox: {\n            x: 18,\n            y: 18,\n        },\n    }),\n    Length: extend(BASE, {\n        name: 'Length',\n        iconContent: `<g id=\"length-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"length-dashes\" d=\"m22.5,6 -16.5,16.5\" stroke-width=\"3\" stroke-dasharray=\"0.6666,5\" />\n  </g>`,\n        viewBox: {\n            x: 24,\n            y: 24,\n        },\n    }),\n    Height: extend(BASE, {\n        name: 'Height',\n        iconContent: `<path d=\"m 6 22 l 8.5 0 v -16 h 8\" stroke-width=\"3\" fill=\"none\" stroke=\"{{color}}\" />`,\n        viewBox: {\n            x: 24,\n            y: 24,\n        },\n    }),\n    Probe: extend(BASE, {\n        name: 'Probe',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75\n    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73\n    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5\n    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5\n    385.5-103 385.5 103 279.5 279.5 103 385.5z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    RectangleROI: extend(BASE, {\n        name: 'RectangleROI',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47\n    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0\n    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119\n    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    Label: extend(BASE, {\n        name: 'Label',\n        iconContent: `<path fill=\"{{color}}\" d=\"M789 559l-170 450q33 0 136.5 2t160.5 2q19 0\n    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29\n    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15\n    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5\n    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0\n    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11\n    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0\n    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58\n    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    Crosshairs: extend(BASE, {\n        name: 'Crosshairs',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26\n    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45\n    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26\n    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5\n    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32\n    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5\n    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26\n    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26\n    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161\n    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161\n    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    Eraser: extend(BASE, {\n        name: 'Eraser',\n        iconContent: `<path transform=\"translate(0,1792) scale(1,-1)\" fill=\"{{color}}\" d=\"M960 1408l336-384h-768l-336 384h768zm1013-1077q15\n    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38\n    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38\n    0 69.5 20.5t47.5 54.5z\" />`,\n        viewBox: {\n            x: 2048,\n            y: 1792,\n        },\n    }),\n    Magnify: extend(BASE, {\n        name: 'Magnify',\n        iconContent: `<path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />`,\n        viewBox: {\n            x: 512,\n            y: 512,\n        },\n    }),\n    Pan: extend(BASE, {\n        name: 'Pan',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17\n    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355\n    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59\n    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12\n    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144\n    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19\n    45v448q0 42-39 59-13 5-25 5-26 0-45-19z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    Rotate: extend(BASE, {\n        name: 'Rotate',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39\n    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5\n    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0\n    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109\n    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298\n    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14\n    39 17 39 59z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    StackScroll: extend(BASE, {\n        name: 'StackScroll',\n        iconContent: `<path fill=\"{{color}}\" d=\"M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0\n    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547\n    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z\" />`,\n        viewBox: {\n            x: 24,\n            y: 28,\n        },\n    }),\n    WindowLevelRegion: extend(BASE, {\n        name: 'WindowLevelRegion',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119\n    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5\n    84.5t84.5 203.5z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    WindowLevel: extend(BASE, {\n        name: 'WindowLevel',\n        iconContent: `\n    <path fill=\"{{color}}\" d=\"M14.5,3.5 a1 1 0 0 1 -11,11 Z\" stroke=\"none\" opacity=\"0.8\" />\n    <circle cx=\"9\" cy=\"9\" r=\"8\" fill=\"none\" stroke-width=\"2\" stroke=\"{{color}}\" />`,\n        viewBox: {\n            x: 18,\n            y: 18,\n        },\n    }),\n    Zoom: extend(BASE, {\n        name: 'Zoom',\n        iconContent: `\n  <path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />\n  <path fill=\"{{color}}\" transform=\"scale(0.22,0.22) translate(1400,0)\" d=\"M1216\n    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19\n    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26\n    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z\" />`,\n        viewBox: {\n            x: 640,\n            y: 512,\n        },\n    }),\n    SegmentationFreeHandEraseInside: extend(BASE, {\n        name: 'SegmentationFreeHandEraseInside',\n        iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    SegmentationFreeHandFillInside: extend(BASE, {\n        name: 'SegmentationFreeHandFillInside',\n        iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    SegmentationFreeHandEraseOutside: extend(BASE, {\n        name: 'SegmentationFreeHandEraseOutside',\n        iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    SegmentationFreeHandFillOutside: extend(BASE, {\n        name: 'SegmentationFreeHandFillOutside',\n        iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    SegmentationRectangleEraseInside: extend(BASE, {\n        name: 'SegmentationRectangleEraseInside',\n        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    RectangleScissor: extend(BASE, {\n        name: 'RectangleScissor',\n        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'RectangleScissor.FILL_INSIDE': extend(BASE, {\n        name: 'RectangleScissor.FILL_INSIDE',\n        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'RectangleScissor.FILL_OUTSIDE': extend(BASE, {\n        name: 'RectangleScissor.FILL_OUTSIDE',\n        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'RectangleScissor.ERASE_OUTSIDE': extend(BASE, {\n        name: 'RectangleScissor.ERASE_OUTSIDE',\n        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'RectangleScissor.ERASE_INSIDE': extend(BASE, {\n        name: 'RectangleScissor.ERASE_INSIDE',\n        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    CircleScissor: extend(BASE, {\n        name: 'CircleScissor',\n        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'CircleScissor.FILL_INSIDE': extend(BASE, {\n        name: 'CircleScissor.FILL_INSIDE',\n        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'CircleScissor.ERASE_OUTSIDE': extend(BASE, {\n        name: 'CircleScissor.ERASE_OUTSIDE',\n        iconContent: `${CIRCLE_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'CircleScissor.FILL_OUTSIDE': extend(BASE, {\n        name: 'CircleScissor.FILL_OUTSIDE',\n        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n};\nfunction extend(base, values) {\n    return Object.assign(Object.create(base), {\n        ...values,\n        name: values.name || base.name,\n    });\n}\nfunction registerCursor(toolName, iconContent, viewBox) {\n    CursorSVG[toolName] = extend(BASE, {\n        iconContent,\n        viewBox,\n    });\n}\nfunction getDefinedSVGCursorDescriptor(name) {\n    return CursorSVG[name];\n}\nconst svgCursorNames = Object.keys(CursorSVG);\nexport { getDefinedSVGCursorDescriptor, registerCursor, svgCursorNames, CursorSVG, };\n", "class ToolStyle {\n    constructor() {\n        const defaultConfig = {\n            color: 'rgb(255, 255, 0)',\n            colorHighlighted: 'rgb(0, 255, 0)',\n            colorSelected: 'rgb(0, 220, 0)',\n            colorLocked: 'rgb(209, 193, 90)',\n            lineWidth: '1',\n            lineDash: '',\n            shadow: true,\n            textBoxVisibility: true,\n            textBoxFontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n            textBoxFontSize: '14px',\n            textBoxColor: 'rgb(255, 255, 0)',\n            textBoxColorHighlighted: 'rgb(0, 255, 0)',\n            textBoxColorSelected: 'rgb(0, 255, 0)',\n            textBoxColorLocked: 'rgb(209, 193, 90)',\n            textBoxBackground: '',\n            textBoxLinkLineWidth: '1',\n            textBoxLinkLineDash: '2,3',\n            textBoxShadow: true,\n            markerSize: '10',\n            angleArcLineDash: '',\n        };\n        this._initializeConfig(defaultConfig);\n    }\n    getAnnotationToolStyles(annotationUID) {\n        return this.config.annotations && this.config.annotations[annotationUID];\n    }\n    getViewportToolStyles(viewportId) {\n        return this.config.viewports && this.config.viewports[viewportId];\n    }\n    getToolGroupToolStyles(toolGroupId) {\n        return this.config.toolGroups && this.config.toolGroups[toolGroupId];\n    }\n    getDefaultToolStyles() {\n        return this.config.default;\n    }\n    setAnnotationStyles(annotationUID, styles) {\n        let annotationSpecificStyles = this.config.annotations;\n        if (!annotationSpecificStyles) {\n            this.config = {\n                ...this.config,\n                annotations: {},\n            };\n            annotationSpecificStyles = this.config.annotations;\n        }\n        annotationSpecificStyles[annotationUID] = styles;\n    }\n    setViewportToolStyles(viewportId, styles) {\n        let viewportSpecificStyles = this.config.viewports;\n        if (!viewportSpecificStyles) {\n            this.config = {\n                ...this.config,\n                viewports: {},\n            };\n            viewportSpecificStyles = this.config.viewports;\n        }\n        viewportSpecificStyles[viewportId] = styles;\n    }\n    setToolGroupToolStyles(toolGroupId, styles) {\n        let toolGroupSpecificStyles = this.config.toolGroups;\n        if (!toolGroupSpecificStyles) {\n            this.config = {\n                ...this.config,\n                toolGroups: {},\n            };\n            toolGroupSpecificStyles = this.config.toolGroups;\n        }\n        toolGroupSpecificStyles[toolGroupId] = styles;\n    }\n    setDefaultToolStyles(styles) {\n        this.config.default = styles;\n    }\n    getStyleProperty(toolStyle, specifications) {\n        const { annotationUID, viewportId, toolGroupId, toolName } = specifications;\n        return this._getToolStyle(toolStyle, annotationUID, viewportId, toolGroupId, toolName);\n    }\n    _getToolStyle(property, annotationUID, viewportId, toolGroupId, toolName) {\n        if (annotationUID) {\n            const annotationToolStyles = this.getAnnotationToolStyles(annotationUID);\n            if (annotationToolStyles) {\n                if (annotationToolStyles[property] !== undefined) {\n                    return annotationToolStyles[property];\n                }\n            }\n        }\n        if (viewportId) {\n            const viewportToolStyles = this.getViewportToolStyles(viewportId);\n            if (viewportToolStyles) {\n                if (viewportToolStyles[toolName] &&\n                    viewportToolStyles[toolName][property] !== undefined) {\n                    return viewportToolStyles[toolName][property];\n                }\n                if (viewportToolStyles.global &&\n                    viewportToolStyles.global[property] !== undefined) {\n                    return viewportToolStyles.global[property];\n                }\n            }\n        }\n        if (toolGroupId) {\n            const toolGroupToolStyles = this.getToolGroupToolStyles(toolGroupId);\n            if (toolGroupToolStyles) {\n                if (toolGroupToolStyles[toolName] &&\n                    toolGroupToolStyles[toolName][property] !== undefined) {\n                    return toolGroupToolStyles[toolName][property];\n                }\n                if (toolGroupToolStyles.global &&\n                    toolGroupToolStyles.global[property] !== undefined) {\n                    return toolGroupToolStyles.global[property];\n                }\n            }\n        }\n        const globalStyles = this.getDefaultToolStyles();\n        if (globalStyles[toolName] &&\n            globalStyles[toolName][property] !== undefined) {\n            return globalStyles[toolName][property];\n        }\n        if (globalStyles.global && globalStyles.global[property] !== undefined) {\n            return globalStyles.global[property];\n        }\n    }\n    _initializeConfig(config) {\n        const toolStyles = {};\n        for (const name in config) {\n            toolStyles[name] = config[name];\n        }\n        this.config = {\n            default: {\n                global: toolStyles,\n            },\n        };\n    }\n}\nconst toolStyle = new ToolStyle();\nexport default toolStyle;\n", "import toolStyle from './ToolStyle';\nfunction getHierarchalPropertyStyles(property, state, mode) {\n    const list = [`${property}`];\n    if (state) {\n        list.push(`${list[0]}${state}`);\n    }\n    if (mode) {\n        list.push(`${list[list.length - 1]}${mode}`);\n    }\n    return list;\n}\nfunction getStyleProperty(property, styleSpecifier, state, mode) {\n    const alternatives = getHierarchalPropertyStyles(property, state, mode);\n    for (let i = alternatives.length - 1; i >= 0; --i) {\n        const style = toolStyle.getStyleProperty(alternatives[i], styleSpecifier);\n        if (style !== undefined) {\n            return style;\n        }\n    }\n}\nexport { getStyleProperty };\n", "import { ToolModes, AnnotationStyleStates } from '../enums';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport { getDefinedSVGCursorDescriptor } from './SVGCursorDescriptor';\nimport { getStyleProperty } from '../stateManagement/annotation/config/helpers';\nconst PROPERTY = 'color';\nconst STATE = AnnotationStyleStates.Highlighted;\nconst MODE = ToolModes.Active;\nexport default class SVGMouseCursor extends ImageMouseCursor {\n    constructor(url, x, y, name, fallback) {\n        super(url, x, y, name, fallback);\n    }\n    static getDefinedCursor(name, pointer = false, color) {\n        if (!color) {\n            color = getStyleProperty(PROPERTY, {}, STATE, MODE);\n        }\n        const urn = getCursorURN(name, pointer, color);\n        let cursor = super.getDefinedCursor(urn);\n        const pointerStrokeWidth = Number(getStyleProperty('pointerStrokeWidth', {}));\n        if (!cursor) {\n            const descriptor = getDefinedSVGCursorDescriptor(name);\n            if (descriptor) {\n                cursor = createSVGMouseCursor(descriptor, urn, pointer, color, pointerStrokeWidth, super.getDefinedCursor('default'));\n                super.setDefinedCursor(urn, cursor);\n            }\n        }\n        return cursor;\n    }\n}\nfunction format(template, dictionary) {\n    const dict = Object(dictionary);\n    const defined = Object.prototype.hasOwnProperty.bind(dict);\n    return (template + '').replace(/\\{\\{(\\w+)\\}\\}/g, (match, key) => {\n        return defined(key) ? dict[key] + '' : '';\n    });\n}\nfunction getCursorURN(name, pointer, color) {\n    const type = pointer ? 'pointer' : 'cursor';\n    return `${type}:${name}/${color}`;\n}\nfunction createSVGMouseCursor(descriptor, name, pointer, color, pointerStrokeWidth, fallback) {\n    const { x, y } = descriptor.mousePoint;\n    return new SVGMouseCursor(createSVGIconUrl(descriptor, pointer, { color, pointerStrokeWidth }), x, y, name, fallback);\n}\nfunction createSVGIconUrl(descriptor, pointer, options) {\n    const blob = createSVGIconBlob(descriptor, pointer, options);\n    const url = URL.createObjectURL(blob);\n    const urn = `${url}#${descriptor.name || 'unknown'}-${pointer ? 'pointer' : 'cursor'}`;\n    return urn;\n}\nfunction createSVGIconBlob(descriptor, pointer, options) {\n    const svgString = (pointer ? createSVGIconWithPointer : createSVGIcon)(descriptor, options);\n    return new Blob([svgString], { type: 'image/svg+xml' });\n}\nfunction createSVGIcon(descriptor, options) {\n    const { iconContent, iconSize, viewBox } = descriptor;\n    const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${iconSize}\" height=\"${iconSize}\" viewBox=\"0 0\n      ${viewBox.x} ${viewBox.y}\">\n      ${iconContent}\n    </svg>`;\n    return format(svgString, options);\n}\nfunction createSVGIconWithPointer(descriptor, options) {\n    const { iconContent, iconSize, viewBox, mousePointerGroupString } = descriptor;\n    const scale = iconSize / Math.max(viewBox.x, viewBox.y, 1);\n    const svgSize = 16 + iconSize;\n    const pointerStrokeWidth = options.pointerStrokeWidth || 1;\n    const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${svgSize}\" height=\"${svgSize}\" viewBox=\"0 0 ${svgSize} ${svgSize}\">\n      <g stroke-width=\"${pointerStrokeWidth}\">${mousePointerGroupString}</g>\n      <g transform=\"translate(16, 16) scale(${scale})\">${iconContent}</g>\n    </svg>`;\n    return format(svgString, options);\n}\n", "import MouseCursor from './MouseCursor';\nconst ELEMENT_CURSORS_MAP = Symbol('ElementCursorsMap');\nfunction initElementCursor(element, cursor) {\n    _getElementCursors(element)[0] = cursor;\n    _setElementCursor(element, cursor);\n}\nfunction _setElementCursor(element, cursor) {\n    const cursors = _getElementCursors(element);\n    cursors[1] = cursors[0];\n    cursors[0] = cursor;\n    element.style.cursor = (cursor instanceof MouseCursor\n        ? cursor\n        : MouseCursor.getDefinedCursor('auto')).getStyleProperty();\n}\nfunction resetElementCursor(element) {\n    _setElementCursor(element, _getElementCursors(element)[1]);\n}\nfunction hideElementCursor(element) {\n    _setElementCursor(element, MouseCursor.getDefinedCursor('none'));\n}\nfunction _getElementCursors(element) {\n    let map = _getElementCursors[ELEMENT_CURSORS_MAP];\n    if (!(map instanceof WeakMap)) {\n        map = new WeakMap();\n        Object.defineProperty(_getElementCursors, ELEMENT_CURSORS_MAP, {\n            value: map,\n        });\n    }\n    let cursors = map.get(element);\n    if (!cursors) {\n        cursors = [null, null];\n        map.set(element, cursors);\n    }\n    return cursors;\n}\nexport { initElementCursor, resetElementCursor, hideElementCursor, _setElementCursor as setElementCursor, };\n", "import { setElementCursor } from './elementCursor';\nimport MouseCursor from './MouseCursor';\nimport SVGMouseCursor from './SVGMouseCursor';\nfunction setCursorForElement(element, cursorName) {\n    let cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n    if (!cursor) {\n        cursor = MouseCursor.getDefinedCursor(cursorName);\n    }\n    if (!cursor) {\n        console.log(`Cursor ${cursorName} is not defined either as SVG or as a standard cursor.`);\n        cursor = MouseCursor.getDefinedCursor(cursorName);\n    }\n    setElementCursor(element, cursor);\n}\nexport default setCursorForElement;\n", "import { state } from '../state';\nfunction getToolGroup(toolGroupId) {\n    return state.toolGroups.find((s) => s.id === toolGroupId);\n}\nexport default getToolGroup;\n", "import { state } from '../state';\nimport ToolGroup from './ToolGroup';\nfunction createToolGroup(toolGroupId) {\n    const toolGroupWithIdExists = state.toolGroups.some((tg) => tg.id === toolGroupId);\n    if (toolGroupWithIdExists) {\n        console.warn(`'${toolGroupId}' already exists.`);\n        return;\n    }\n    const toolGroup = new ToolGroup(toolGroupId);\n    state.toolGroups.push(toolGroup);\n    return toolGroup;\n}\nexport default createToolGroup;\n", "import { state } from '../state';\nfunction destroyToolGroup(toolGroupId) {\n    const toolGroupIndex = state.toolGroups.findIndex((tg) => tg.id === toolGroupId);\n    if (toolGroupIndex > -1) {\n        state.toolGroups.splice(toolGroupIndex, 1);\n    }\n}\nexport default destroyToolGroup;\n", "import { state } from '../state';\nimport destroyToolGroup from './destroyToolGroup';\nfunction destroy() {\n    const toolGroups = [...state.toolGroups];\n    for (const toolGroup of toolGroups) {\n        destroyToolGroup(toolGroup.id);\n    }\n    state.toolGroups = [];\n}\nexport default destroy;\n", "import { getRenderingEngines } from '@cornerstonejs/core';\nimport { state } from '../state';\nfunction getToolGroupForViewport(viewportId, renderingEngineId) {\n    if (!renderingEngineId) {\n        renderingEngineId = getRenderingEngines().find((re) => re.getViewports().find((vp) => vp.id === viewportId))?.id;\n    }\n    const toolGroupFilteredByIds = state.toolGroups.filter((tg) => tg.viewportsInfo.some((vp) => vp.renderingEngineId === renderingEngineId &&\n        (!vp.viewportId || vp.viewportId === viewportId)));\n    if (!toolGroupFilteredByIds.length) {\n        return;\n    }\n    if (toolGroupFilteredByIds.length > 1) {\n        throw new Error(`Multiple tool groups found for renderingEngineId: ${renderingEngineId} and viewportId: ${viewportId}. You should only\n      have one tool group per viewport in a renderingEngine.`);\n    }\n    return toolGroupFilteredByIds[0];\n}\nexport default getToolGroupForViewport;\n", "import { state } from '../state';\nfunction getAllToolGroups() {\n    return state.toolGroups;\n}\nexport default getAllToolGroups;\n", "import { state } from '../state';\nimport { ToolModes } from '../../enums';\nconst MODES = [ToolModes.Active, ToolModes.Passive, ToolModes.Enabled];\nfunction getToolGroupsWithToolName(toolName) {\n    return state.toolGroups.filter(({ toolOptions }) => {\n        const toolGroupToolNames = Object.keys(toolOptions);\n        for (let i = 0; i < toolGroupToolNames.length; i++) {\n            if (toolName !== toolGroupToolNames[i]) {\n                continue;\n            }\n            if (!toolOptions[toolName]) {\n                continue;\n            }\n            if (MODES.includes(toolOptions[toolName].mode)) {\n                return true;\n            }\n        }\n        return false;\n    });\n}\nexport default getToolGroupsWithToolName;\n", "import { addTool, hasTool, removeTool } from './addTool';\nimport addEnabledElement from './addEnabledElement';\nimport removeEnabledElement from './removeEnabledElement';\nimport cancelActiveManipulations from './cancelActiveManipulations';\nimport state from './state';\nimport Synchronizer from './SynchronizerManager/Synchronizer';\nimport svgNodeCache from './svgNodeCache';\nimport * as ToolGroupManager from './ToolGroupManager';\nimport * as SynchronizerManager from './SynchronizerManager';\nexport { addTool, hasTool, removeTool, addEnabledElement, removeEnabledElement, cancelActiveManipulations, svgNodeCache, ToolGroupManager, SynchronizerManager, Synchronizer, state, };\n", "import { state } from './state';\nexport function addTool(ToolClass) {\n    const toolName = ToolClass.toolName;\n    if (!toolName) {\n        throw new Error(`No Tool Found for the ToolClass ${ToolClass.name}`);\n    }\n    if (!state.tools[toolName]) {\n        state.tools[toolName] = {\n            toolClass: ToolClass,\n        };\n    }\n}\nexport function hasTool(ToolClass) {\n    const toolName = ToolClass.toolName;\n    return !!(toolName && state.tools[toolName]);\n}\nexport function hasToolByName(toolName) {\n    return !!(toolName && state.tools[toolName]);\n}\nexport function removeTool(ToolClass) {\n    const toolName = ToolClass.toolName;\n    if (!toolName) {\n        throw new Error(`No tool found for: ${ToolClass.name}`);\n    }\n    if (!state.tools[toolName] !== undefined) {\n        delete state.tools[toolName];\n    }\n    else {\n        throw new Error(`${toolName} cannot be removed because it has not been added`);\n    }\n}\nexport default addTool;\n", "import { getEnabledElement } from '@cornerstonejs/core';\nexport default function getMouseEventPoints(evt, element) {\n    const elementToUse = element || evt.currentTarget;\n    const { viewport } = getEnabledElement(elementToUse) || {};\n    if (!viewport) {\n        return;\n    }\n    const clientPoint = _clientToPoint(evt);\n    const pagePoint = _pageToPoint(evt);\n    const canvasPoint = _pagePointsToCanvasPoints(elementToUse, pagePoint);\n    const worldPoint = viewport.canvasToWorld(canvasPoint);\n    return {\n        page: pagePoint,\n        client: clientPoint,\n        canvas: canvasPoint,\n        world: worldPoint,\n    };\n}\nfunction _pagePointsToCanvasPoints(element, pagePoint) {\n    const rect = element.getBoundingClientRect();\n    return [\n        pagePoint[0] - rect.left - window.pageXOffset,\n        pagePoint[1] - rect.top - window.pageYOffset,\n    ];\n}\nfunction _pageToPoint(evt) {\n    return [evt.pageX, evt.pageY];\n}\nfunction _clientToPoint(evt) {\n    return [evt.clientX, evt.clientY];\n}\n", "import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport getMouseEventPoints from './getMouseEventPoints';\nfunction mouseDoubleClickListener(evt) {\n    const element = evt.currentTarget;\n    const { viewportId, renderingEngineId } = getEnabledElement(element);\n    const startPoints = getMouseEventPoints(evt, element);\n    const deltaPoints = {\n        page: [0, 0],\n        client: [0, 0],\n        canvas: [0, 0],\n        world: [0, 0, 0],\n    };\n    const eventDetail = {\n        event: evt,\n        eventName: Events.MOUSE_DOUBLE_CLICK,\n        viewportId,\n        renderingEngineId,\n        camera: {},\n        element,\n        startPoints,\n        lastPoints: startPoints,\n        currentPoints: startPoints,\n        deltaPoints,\n    };\n    const consumed = !triggerEvent(element, Events.MOUSE_DOUBLE_CLICK, eventDetail);\n    if (consumed) {\n        evt.stopImmediatePropagation();\n        evt.preventDefault();\n    }\n}\nexport default mouseDoubleClickListener;\n", "import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport getMouseEventPoints from './getMouseEventPoints';\nconst eventName = Events.MOUSE_MOVE;\nfunction mouseMoveListener(evt) {\n    const element = evt.currentTarget;\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        return;\n    }\n    const { renderingEngineId, viewportId } = enabledElement;\n    const currentPoints = getMouseEventPoints(evt);\n    const eventDetail = {\n        renderingEngineId,\n        viewportId,\n        camera: {},\n        element,\n        currentPoints,\n        eventName,\n        event: evt,\n    };\n    const consumed = !triggerEvent(element, eventName, eventDetail);\n    if (consumed) {\n        evt.stopImmediatePropagation();\n        evt.preventDefault();\n    }\n}\nexport default mouseMoveListener;\n", "import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport mouseMoveListener from './mouseMoveListener';\nimport getMouseEventPoints from './getMouseEventPoints';\nconst { MOUSE_DOWN, MOUSE_DOWN_ACTIVATE, MOUSE_CLICK, MOUSE_UP, MOUSE_DRAG } = Events;\nconst DOUBLE_CLICK_TOLERANCE_MS = 400;\nconst MULTI_BUTTON_TOLERANCE_MS = 150;\nconst DOUBLE_CLICK_DRAG_TOLERANCE = 3;\nconst defaultState = {\n    mouseButton: undefined,\n    element: null,\n    renderingEngineId: undefined,\n    viewportId: undefined,\n    isClickEvent: true,\n    clickDelay: 200,\n    preventClickTimeout: null,\n    startPoints: {\n        page: [0, 0],\n        client: [0, 0],\n        canvas: [0, 0],\n        world: [0, 0, 0],\n    },\n    lastPoints: {\n        page: [0, 0],\n        client: [0, 0],\n        canvas: [0, 0],\n        world: [0, 0, 0],\n    },\n};\nlet state = {\n    mouseButton: undefined,\n    renderingEngineId: undefined,\n    viewportId: undefined,\n    isClickEvent: true,\n    clickDelay: 200,\n    element: null,\n    preventClickTimeout: null,\n    startPoints: {\n        page: [0, 0],\n        client: [0, 0],\n        canvas: [0, 0],\n        world: [0, 0, 0],\n    },\n    lastPoints: {\n        page: [0, 0],\n        client: [0, 0],\n        canvas: [0, 0],\n        world: [0, 0, 0],\n    },\n};\nconst doubleClickState = {\n    doubleClickTimeout: null,\n    mouseDownEvent: null,\n    mouseUpEvent: null,\n    ignoreDoubleClick: false,\n};\nfunction mouseDownListener(evt) {\n    if (doubleClickState.doubleClickTimeout) {\n        if (evt.buttons === doubleClickState.mouseDownEvent.buttons) {\n            return;\n        }\n        doubleClickState.mouseDownEvent = evt;\n        _doStateMouseDownAndUp();\n        return;\n    }\n    doubleClickState.doubleClickTimeout = setTimeout(_doStateMouseDownAndUp, evt.buttons === 1 ? DOUBLE_CLICK_TOLERANCE_MS : MULTI_BUTTON_TOLERANCE_MS);\n    doubleClickState.mouseDownEvent = evt;\n    doubleClickState.ignoreDoubleClick = false;\n    state.element = evt.currentTarget;\n    state.mouseButton = evt.buttons;\n    const enabledElement = getEnabledElement(state.element);\n    const { renderingEngineId, viewportId } = enabledElement;\n    state.renderingEngineId = renderingEngineId;\n    state.viewportId = viewportId;\n    state.preventClickTimeout = setTimeout(_preventClickHandler, state.clickDelay);\n    state.element.removeEventListener('mousemove', mouseMoveListener);\n    const startPoints = getMouseEventPoints(evt, state.element);\n    state.startPoints = _copyPoints(startPoints);\n    state.lastPoints = _copyPoints(startPoints);\n    document.addEventListener('mouseup', _onMouseUp);\n    document.addEventListener('mousemove', _onMouseDrag);\n}\nfunction _doMouseDown(evt) {\n    const deltaPoints = _getDeltaPoints(state.startPoints, state.startPoints);\n    const eventDetail = {\n        event: evt,\n        eventName: MOUSE_DOWN,\n        element: state.element,\n        mouseButton: state.mouseButton,\n        renderingEngineId: state.renderingEngineId,\n        viewportId: state.viewportId,\n        camera: {},\n        startPoints: state.startPoints,\n        lastPoints: state.startPoints,\n        currentPoints: state.startPoints,\n        deltaPoints,\n    };\n    state.lastPoints = _copyPoints(eventDetail.lastPoints);\n    const notConsumed = triggerEvent(eventDetail.element, MOUSE_DOWN, eventDetail);\n    if (notConsumed) {\n        triggerEvent(eventDetail.element, MOUSE_DOWN_ACTIVATE, eventDetail);\n    }\n}\nfunction _onMouseDrag(evt) {\n    const enabledElement = getEnabledElement(state.element);\n    if (!enabledElement?.viewport) {\n        return;\n    }\n    const currentPoints = getMouseEventPoints(evt, state.element);\n    const lastPoints = _updateMouseEventsLastPoints(state.element, state.lastPoints);\n    const deltaPoints = _getDeltaPoints(currentPoints, lastPoints);\n    if (doubleClickState.doubleClickTimeout) {\n        if (_isDragPastDoubleClickTolerance(deltaPoints.canvas)) {\n            _doStateMouseDownAndUp();\n        }\n        else {\n            return;\n        }\n    }\n    const eventDetail = {\n        event: evt,\n        eventName: MOUSE_DRAG,\n        mouseButton: state.mouseButton,\n        renderingEngineId: state.renderingEngineId,\n        viewportId: state.viewportId,\n        camera: {},\n        element: state.element,\n        startPoints: _copyPoints(state.startPoints),\n        lastPoints: _copyPoints(lastPoints),\n        currentPoints,\n        deltaPoints,\n    };\n    const consumed = !triggerEvent(state.element, MOUSE_DRAG, eventDetail);\n    if (consumed) {\n        evt.stopImmediatePropagation();\n        evt.preventDefault();\n    }\n    state.lastPoints = _copyPoints(currentPoints);\n}\nfunction _onMouseUp(evt) {\n    clearTimeout(state.preventClickTimeout);\n    if (doubleClickState.doubleClickTimeout) {\n        if (!doubleClickState.mouseUpEvent) {\n            doubleClickState.mouseUpEvent = evt;\n            state.element.addEventListener('mousemove', _onMouseMove);\n        }\n        else {\n            _cleanUp();\n        }\n    }\n    else {\n        const eventName = state.isClickEvent ? MOUSE_CLICK : MOUSE_UP;\n        const currentPoints = getMouseEventPoints(evt, state.element);\n        const deltaPoints = _getDeltaPoints(currentPoints, state.lastPoints);\n        const eventDetail = {\n            event: evt,\n            eventName,\n            mouseButton: state.mouseButton,\n            element: state.element,\n            renderingEngineId: state.renderingEngineId,\n            viewportId: state.viewportId,\n            camera: {},\n            startPoints: _copyPoints(state.startPoints),\n            lastPoints: _copyPoints(state.lastPoints),\n            currentPoints,\n            deltaPoints,\n        };\n        triggerEvent(eventDetail.element, eventName, eventDetail);\n        _cleanUp();\n    }\n    document.removeEventListener('mousemove', _onMouseDrag);\n}\nfunction _onMouseMove(evt) {\n    const currentPoints = getMouseEventPoints(evt, state.element);\n    const lastPoints = _updateMouseEventsLastPoints(state.element, state.lastPoints);\n    const deltaPoints = _getDeltaPoints(currentPoints, lastPoints);\n    if (!_isDragPastDoubleClickTolerance(deltaPoints.canvas)) {\n        return;\n    }\n    _doStateMouseDownAndUp();\n    mouseMoveListener(evt);\n}\nfunction _isDragPastDoubleClickTolerance(delta) {\n    return Math.abs(delta[0]) + Math.abs(delta[1]) > DOUBLE_CLICK_DRAG_TOLERANCE;\n}\nfunction _preventClickHandler() {\n    state.isClickEvent = false;\n}\nfunction _doStateMouseDownAndUp() {\n    doubleClickState.ignoreDoubleClick = true;\n    const mouseDownEvent = doubleClickState.mouseDownEvent;\n    const mouseUpEvent = doubleClickState.mouseUpEvent;\n    _clearDoubleClickTimeoutAndEvents();\n    _doMouseDown(mouseDownEvent);\n    if (mouseUpEvent) {\n        _onMouseUp(mouseUpEvent);\n    }\n}\nfunction _clearDoubleClickTimeoutAndEvents() {\n    if (doubleClickState.doubleClickTimeout) {\n        clearTimeout(doubleClickState.doubleClickTimeout);\n        doubleClickState.doubleClickTimeout = null;\n    }\n    doubleClickState.mouseDownEvent = null;\n    doubleClickState.mouseUpEvent = null;\n}\nfunction _cleanUp() {\n    document.removeEventListener('mouseup', _onMouseUp);\n    state.element?.removeEventListener('mousemove', _onMouseMove);\n    state.element?.addEventListener('mousemove', mouseMoveListener);\n    _clearDoubleClickTimeoutAndEvents();\n    state = JSON.parse(JSON.stringify(defaultState));\n}\nfunction _copyPoints(points) {\n    return JSON.parse(JSON.stringify(points));\n}\nfunction _updateMouseEventsLastPoints(element, lastPoints) {\n    const { viewport } = getEnabledElement(element) || {};\n    if (!viewport) {\n        return lastPoints;\n    }\n    const world = viewport.canvasToWorld(lastPoints.canvas);\n    return {\n        page: lastPoints.page,\n        client: lastPoints.client,\n        canvas: lastPoints.canvas,\n        world,\n    };\n}\nfunction _getDeltaPoints(currentPoints, lastPoints) {\n    if (!currentPoints || !lastPoints) {\n        return {\n            page: [0, 0],\n            client: [0, 0],\n            canvas: [0, 0],\n            world: [0, 0, 0],\n        };\n    }\n    return {\n        page: _subtractPoints2D(currentPoints.page, lastPoints.page),\n        client: _subtractPoints2D(currentPoints.client, lastPoints.client),\n        canvas: _subtractPoints2D(currentPoints.canvas, lastPoints.canvas),\n        world: _subtractPoints3D(currentPoints.world, lastPoints.world),\n    };\n}\nfunction _subtractPoints2D(point0, point1) {\n    return [point0[0] - point1[0], point0[1] - point1[1]];\n}\nfunction _subtractPoints3D(point0, point1) {\n    return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\n}\nexport function getMouseButton() {\n    return state.mouseButton;\n}\nexport function mouseDoubleClickIgnoreListener(evt) {\n    if (doubleClickState.ignoreDoubleClick) {\n        doubleClickState.ignoreDoubleClick = false;\n        evt.stopImmediatePropagation();\n        evt.preventDefault();\n    }\n    else {\n        _cleanUp();\n    }\n}\nexport default mouseDownListener;\n", "import mouseDoubleClickListener from './mouseDoubleClickListener';\nimport mouseDownListener, { mouseDoubleClickIgnoreListener, } from './mouseDownListener';\nimport mouseMoveListener from './mouseMoveListener';\nfunction disable(element) {\n    element.removeEventListener('dblclick', mouseDoubleClickListener);\n    element.removeEventListener('mousedown', mouseDownListener);\n    element.removeEventListener('mousemove', mouseMoveListener);\n    element.removeEventListener('dblclick', mouseDoubleClickIgnoreListener, {\n        capture: true,\n    });\n}\nfunction enable(element) {\n    disable(element);\n    element.addEventListener('dblclick', mouseDoubleClickListener);\n    element.addEventListener('mousedown', mouseDownListener);\n    element.addEventListener('mousemove', mouseMoveListener);\n    element.addEventListener('dblclick', mouseDoubleClickIgnoreListener, {\n        capture: true,\n    });\n}\nexport default {\n    enable,\n    disable,\n};\n", "const antiGhostDelay = 2000, pointerType = {\n    mouse: 0,\n    touch: 1,\n};\nlet lastInteractionType, lastInteractionTime;\nfunction handleTap(type, e) {\n    const now = Date.now();\n    if (type !== lastInteractionType) {\n        if (now - lastInteractionTime <= antiGhostDelay) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.stopImmediatePropagation();\n            return false;\n        }\n        lastInteractionType = type;\n    }\n    lastInteractionTime = now;\n}\nconst handleTapMouse = handleTap.bind(null, pointerType.mouse);\nconst handleTapTouch = handleTap.bind(null, pointerType.touch);\nfunction attachEvents(element, eventList, interactionType) {\n    const tapHandler = interactionType ? handleTapMouse : handleTapTouch;\n    eventList.forEach(function (eventName) {\n        element.addEventListener(eventName, tapHandler, { passive: false });\n    });\n}\nfunction removeEvents(element, eventList, interactionType) {\n    const tapHandler = interactionType ? handleTapMouse : handleTapTouch;\n    eventList.forEach(function (eventName) {\n        element.removeEventListener(eventName, tapHandler);\n    });\n}\nconst mouseEvents = ['mousedown', 'mouseup', 'mousemove'];\nconst touchEvents = ['touchstart', 'touchend'];\nfunction disable(element) {\n    removeEvents(element, mouseEvents, pointerType.mouse);\n    removeEvents(element, touchEvents, pointerType.touch);\n}\nfunction enable(element) {\n    disable(element);\n    attachEvents(element, mouseEvents, pointerType.mouse);\n    attachEvents(element, touchEvents, pointerType.touch);\n}\nexport default {\n    enable,\n    disable,\n};\n", "import { getEnabledElement } from '@cornerstonejs/core';\nexport default function getTouchEventPoints(evt, element) {\n    const elementToUse = element || evt.currentTarget;\n    const touches = evt.type === 'touchend' ? evt.changedTouches : evt.touches;\n    return Object.keys(touches).map((i) => {\n        const clientPoint = _clientToPoint(touches[i]);\n        const pagePoint = _pageToPoint(touches[i]);\n        const canvasPoint = _pagePointsToCanvasPoints(elementToUse, pagePoint);\n        const { viewport } = getEnabledElement(elementToUse);\n        const worldPoint = viewport.canvasToWorld(canvasPoint);\n        return {\n            page: pagePoint,\n            client: clientPoint,\n            canvas: canvasPoint,\n            world: worldPoint,\n            touch: {\n                identifier: i,\n                radiusX: touches[i].radiusX,\n                radiusY: touches[i].radiusY,\n                force: touches[i].force,\n                rotationAngle: touches[i].rotationAngle,\n            },\n        };\n    });\n}\nfunction _pagePointsToCanvasPoints(element, pagePoint) {\n    const rect = element.getBoundingClientRect();\n    return [\n        pagePoint[0] - rect.left - window.pageXOffset,\n        pagePoint[1] - rect.top - window.pageYOffset,\n    ];\n}\nfunction _pageToPoint(touch) {\n    return [touch.pageX, touch.pageY];\n}\nfunction _clientToPoint(touch) {\n    return [touch.clientX, touch.clientY];\n}\n", "function getDeltaPoints(currentPoints, lastPoints) {\n    const curr = getMeanPoints(currentPoints);\n    const last = getMeanPoints(lastPoints);\n    return {\n        page: _subtractPoints2D(curr.page, last.page),\n        client: _subtractPoints2D(curr.client, last.client),\n        canvas: _subtractPoints2D(curr.canvas, last.canvas),\n        world: _subtractPoints3D(curr.world, last.world),\n    };\n}\nfunction getDeltaDistance(currentPoints, lastPoints) {\n    const curr = getMeanPoints(currentPoints);\n    const last = getMeanPoints(lastPoints);\n    return {\n        page: _getDistance2D(curr.page, last.page),\n        client: _getDistance2D(curr.client, last.client),\n        canvas: _getDistance2D(curr.canvas, last.canvas),\n        world: _getDistance3D(curr.world, last.world),\n    };\n}\nfunction getDeltaRotation(currentPoints, lastPoints) {\n}\nfunction getDeltaDistanceBetweenIPoints(currentPoints, lastPoints) {\n    const currentDistance = _getMeanDistanceBetweenAllIPoints(currentPoints);\n    const lastDistance = _getMeanDistanceBetweenAllIPoints(lastPoints);\n    const deltaDistance = {\n        page: currentDistance.page - lastDistance.page,\n        client: currentDistance.client - lastDistance.client,\n        canvas: currentDistance.canvas - lastDistance.canvas,\n        world: currentDistance.world - lastDistance.world,\n    };\n    return deltaDistance;\n}\nfunction copyPointsList(points) {\n    return JSON.parse(JSON.stringify(points));\n}\nfunction copyPoints(points) {\n    return JSON.parse(JSON.stringify(points));\n}\nfunction getMeanPoints(points) {\n    return points.reduce((prev, curr) => {\n        return {\n            page: [\n                prev.page[0] + curr.page[0] / points.length,\n                prev.page[1] + curr.page[1] / points.length,\n            ],\n            client: [\n                prev.client[0] + curr.client[0] / points.length,\n                prev.client[1] + curr.client[1] / points.length,\n            ],\n            canvas: [\n                prev.canvas[0] + curr.canvas[0] / points.length,\n                prev.canvas[1] + curr.canvas[1] / points.length,\n            ],\n            world: [\n                prev.world[0] + curr.world[0] / points.length,\n                prev.world[1] + curr.world[1] / points.length,\n                prev.world[2] + curr.world[2] / points.length,\n            ],\n        };\n    }, {\n        page: [0, 0],\n        client: [0, 0],\n        canvas: [0, 0],\n        world: [0, 0, 0],\n    });\n}\nfunction getMeanTouchPoints(points) {\n    return points.reduce((prev, curr) => {\n        return {\n            page: [\n                prev.page[0] + curr.page[0] / points.length,\n                prev.page[1] + curr.page[1] / points.length,\n            ],\n            client: [\n                prev.client[0] + curr.client[0] / points.length,\n                prev.client[1] + curr.client[1] / points.length,\n            ],\n            canvas: [\n                prev.canvas[0] + curr.canvas[0] / points.length,\n                prev.canvas[1] + curr.canvas[1] / points.length,\n            ],\n            world: [\n                prev.world[0] + curr.world[0] / points.length,\n                prev.world[1] + curr.world[1] / points.length,\n                prev.world[2] + curr.world[2] / points.length,\n            ],\n            touch: {\n                identifier: null,\n                radiusX: prev.touch.radiusX + curr.touch.radiusX / points.length,\n                radiusY: prev.touch.radiusY + curr.touch.radiusY / points.length,\n                force: prev.touch.force + curr.touch.force / points.length,\n                rotationAngle: prev.touch.rotationAngle + curr.touch.rotationAngle / points.length,\n            },\n        };\n    }, {\n        page: [0, 0],\n        client: [0, 0],\n        canvas: [0, 0],\n        world: [0, 0, 0],\n        touch: {\n            identifier: null,\n            radiusX: 0,\n            radiusY: 0,\n            force: 0,\n            rotationAngle: 0,\n        },\n    });\n}\nfunction _subtractPoints2D(point0, point1) {\n    return [point0[0] - point1[0], point0[1] - point1[1]];\n}\nfunction _subtractPoints3D(point0, point1) {\n    return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\n}\nfunction _getMeanDistanceBetweenAllIPoints(points) {\n    const pairedDistance = [];\n    for (let i = 0; i < points.length; i++) {\n        for (let j = 0; j < points.length; j++) {\n            if (i < j) {\n                pairedDistance.push({\n                    page: _getDistance2D(points[i].page, points[j].page),\n                    client: _getDistance2D(points[i].client, points[j].client),\n                    canvas: _getDistance2D(points[i].canvas, points[j].canvas),\n                    world: _getDistance3D(points[i].world, points[j].world),\n                });\n            }\n        }\n    }\n    return pairedDistance.reduce((prev, curr) => {\n        return {\n            page: prev.page + curr.page / pairedDistance.length,\n            client: prev.client + curr.client / pairedDistance.length,\n            canvas: prev.canvas + curr.canvas / pairedDistance.length,\n            world: prev.world + curr.world / pairedDistance.length,\n        };\n    }, {\n        page: 0,\n        client: 0,\n        canvas: 0,\n        world: 0,\n    });\n}\nfunction _getDistance2D(point0, point1) {\n    return Math.sqrt(Math.pow(point0[0] - point1[0], 2) + Math.pow(point0[1] - point1[1], 2));\n}\nfunction _getDistance3D(point0, point1) {\n    return Math.sqrt(Math.pow(point0[0] - point1[0], 2) +\n        Math.pow(point0[1] - point1[1], 2) +\n        Math.pow(point0[2] - point1[2], 2));\n}\nexport { getMeanPoints, getMeanTouchPoints, copyPoints, copyPointsList, getDeltaDistanceBetweenIPoints, getDeltaPoints, getDeltaDistance, getDeltaRotation, };\n", "import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport { Swipe } from '../../enums/Touch';\nimport getTouchEventPoints from './getTouchEventPoints';\nimport { copyPoints, copyPointsList, getDeltaDistanceBetweenIPoints, getDeltaDistance, getDeltaPoints, getMeanTouchPoints, } from '../../utilities/touch';\nimport { Settings } from '@cornerstonejs/core';\nconst runtimeSettings = Settings.getRuntimeSettings();\nconst { TOUCH_START, TOUCH_START_ACTIVATE, TOUCH_PRESS, TOUCH_DRAG, TOUCH_END, TOUCH_TAP, TOUCH_SWIPE, } = Events;\nconst zeroIPoint = {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n};\nconst zeroIDistance = {\n    page: 0,\n    client: 0,\n    canvas: 0,\n    world: 0,\n};\nconst defaultState = {\n    renderingEngineId: undefined,\n    viewportId: undefined,\n    element: null,\n    startPointsList: [\n        {\n            ...zeroIPoint,\n            touch: null,\n        },\n    ],\n    lastPointsList: [\n        {\n            ...zeroIPoint,\n            touch: null,\n        },\n    ],\n    isTouchStart: false,\n    startTime: null,\n    pressTimeout: null,\n    pressDelay: 700,\n    pressMaxDistance: 5,\n    accumulatedDistance: zeroIDistance,\n    swipeDistanceThreshold: 48,\n    swiped: false,\n    swipeToleranceMs: 300,\n};\nconst defaultTapState = {\n    renderingEngineId: undefined,\n    viewportId: undefined,\n    element: null,\n    startPointsList: [\n        {\n            ...zeroIPoint,\n            touch: null,\n        },\n    ],\n    taps: 0,\n    tapTimeout: null,\n    tapMaxDistance: 24,\n    tapToleranceMs: 300,\n};\nlet state = JSON.parse(JSON.stringify(defaultState));\nlet tapState = JSON.parse(JSON.stringify(defaultTapState));\nfunction triggerEventCallback(ele, name, eventDetail) {\n    return triggerEvent(ele, name, eventDetail);\n}\nfunction touchStartListener(evt) {\n    state.element = evt.currentTarget;\n    const enabledElement = getEnabledElement(state.element);\n    const { renderingEngineId, viewportId } = enabledElement;\n    state.renderingEngineId = renderingEngineId;\n    state.viewportId = viewportId;\n    if (state.isTouchStart) {\n        return;\n    }\n    clearTimeout(state.pressTimeout);\n    state.pressTimeout = setTimeout(() => _onTouchPress(evt), state.pressDelay);\n    _onTouchStart(evt);\n    document.addEventListener('touchmove', _onTouchDrag);\n    document.addEventListener('touchend', _onTouchEnd);\n}\nfunction _onTouchPress(evt) {\n    const totalDistance = state.accumulatedDistance.canvas;\n    if (totalDistance > state.pressMaxDistance) {\n        return;\n    }\n    const eventDetail = {\n        event: evt,\n        eventName: TOUCH_PRESS,\n        renderingEngineId: state.renderingEngineId,\n        viewportId: state.viewportId,\n        camera: {},\n        element: state.element,\n        startPointsList: copyPointsList(state.startPointsList),\n        lastPointsList: copyPointsList(state.lastPointsList),\n        startPoints: copyPoints(getMeanTouchPoints(state.startPointsList)),\n        lastPoints: copyPoints(getMeanTouchPoints(state.lastPointsList)),\n    };\n    triggerEventCallback(eventDetail.element, TOUCH_PRESS, eventDetail);\n}\nfunction _onTouchStart(evt) {\n    state.isTouchStart = true;\n    state.startTime = new Date();\n    const startPointsList = getTouchEventPoints(evt, state.element);\n    const startPoints = getMeanTouchPoints(startPointsList);\n    const deltaPoints = zeroIPoint;\n    const deltaDistance = zeroIDistance;\n    const eventDetail = {\n        event: evt,\n        eventName: TOUCH_START,\n        element: state.element,\n        renderingEngineId: state.renderingEngineId,\n        viewportId: state.viewportId,\n        camera: {},\n        startPointsList: startPointsList,\n        lastPointsList: startPointsList,\n        currentPointsList: startPointsList,\n        startPoints: startPoints,\n        lastPoints: startPoints,\n        currentPoints: startPoints,\n        deltaPoints,\n        deltaDistance,\n    };\n    state.startPointsList = copyPointsList(eventDetail.startPointsList);\n    state.lastPointsList = copyPointsList(eventDetail.lastPointsList);\n    const eventDidPropagate = triggerEventCallback(eventDetail.element, TOUCH_START, eventDetail);\n    if (eventDidPropagate) {\n        triggerEventCallback(eventDetail.element, TOUCH_START_ACTIVATE, eventDetail);\n    }\n}\nfunction _onTouchDrag(evt) {\n    const currentPointsList = getTouchEventPoints(evt, state.element);\n    const lastPointsList = _updateTouchEventsLastPoints(state.element, state.lastPointsList);\n    const deltaPoints = currentPointsList.length === lastPointsList.length\n        ? getDeltaPoints(currentPointsList, lastPointsList)\n        : zeroIPoint;\n    const deltaDistance = currentPointsList.length === lastPointsList.length\n        ? getDeltaDistanceBetweenIPoints(currentPointsList, lastPointsList)\n        : zeroIDistance;\n    const totalDistance = currentPointsList.length === lastPointsList.length\n        ? getDeltaDistance(currentPointsList, state.lastPointsList)\n        : zeroIDistance;\n    state.accumulatedDistance = {\n        page: state.accumulatedDistance.page + totalDistance.page,\n        client: state.accumulatedDistance.client + totalDistance.client,\n        canvas: state.accumulatedDistance.canvas + totalDistance.canvas,\n        world: state.accumulatedDistance.world + totalDistance.world,\n    };\n    const eventDetail = {\n        event: evt,\n        eventName: TOUCH_DRAG,\n        renderingEngineId: state.renderingEngineId,\n        viewportId: state.viewportId,\n        camera: {},\n        element: state.element,\n        startPoints: getMeanTouchPoints(state.startPointsList),\n        lastPoints: getMeanTouchPoints(lastPointsList),\n        currentPoints: getMeanTouchPoints(currentPointsList),\n        startPointsList: copyPointsList(state.startPointsList),\n        lastPointsList: copyPointsList(lastPointsList),\n        currentPointsList,\n        deltaPoints: deltaPoints,\n        deltaDistance: deltaDistance,\n    };\n    triggerEventCallback(state.element, TOUCH_DRAG, eventDetail);\n    _checkTouchSwipe(evt, deltaPoints);\n    state.lastPointsList = copyPointsList(currentPointsList);\n}\nfunction _onTouchEnd(evt) {\n    clearTimeout(state.pressTimeout);\n    const currentPointsList = getTouchEventPoints(evt, state.element);\n    const lastPointsList = _updateTouchEventsLastPoints(state.element, state.lastPointsList);\n    const deltaPoints = currentPointsList.length === lastPointsList.length\n        ? getDeltaPoints(currentPointsList, lastPointsList)\n        : getDeltaPoints(currentPointsList, currentPointsList);\n    const deltaDistance = currentPointsList.length === lastPointsList.length\n        ? getDeltaDistanceBetweenIPoints(currentPointsList, lastPointsList)\n        : getDeltaDistanceBetweenIPoints(currentPointsList, currentPointsList);\n    const eventDetail = {\n        event: evt,\n        eventName: TOUCH_END,\n        element: state.element,\n        renderingEngineId: state.renderingEngineId,\n        viewportId: state.viewportId,\n        camera: {},\n        startPointsList: copyPointsList(state.startPointsList),\n        lastPointsList: copyPointsList(lastPointsList),\n        currentPointsList,\n        startPoints: getMeanTouchPoints(state.startPointsList),\n        lastPoints: getMeanTouchPoints(lastPointsList),\n        currentPoints: getMeanTouchPoints(currentPointsList),\n        deltaPoints,\n        deltaDistance,\n    };\n    triggerEventCallback(eventDetail.element, TOUCH_END, eventDetail);\n    _checkTouchTap(evt);\n    state = JSON.parse(JSON.stringify(defaultState));\n    document.removeEventListener('touchmove', _onTouchDrag);\n    document.removeEventListener('touchend', _onTouchEnd);\n}\nfunction _checkTouchTap(evt) {\n    const currentTime = new Date().getTime();\n    const startTime = state.startTime.getTime();\n    if (currentTime - startTime > tapState.tapToleranceMs) {\n        return;\n    }\n    if (tapState.taps === 0) {\n        tapState.element = state.element;\n        tapState.renderingEngineId = state.renderingEngineId;\n        tapState.viewportId = state.viewportId;\n        tapState.startPointsList = state.startPointsList;\n    }\n    if (tapState.taps > 0 &&\n        !(tapState.element == state.element &&\n            tapState.renderingEngineId == state.renderingEngineId &&\n            tapState.viewportId == state.viewportId)) {\n        return;\n    }\n    const currentPointsList = getTouchEventPoints(evt, tapState.element);\n    const distanceFromStart = getDeltaDistance(currentPointsList, tapState.startPointsList).canvas;\n    if (distanceFromStart > tapState.tapMaxDistance) {\n        return;\n    }\n    clearTimeout(tapState.tapTimeout);\n    tapState.taps += 1;\n    tapState.tapTimeout = setTimeout(() => {\n        const eventDetail = {\n            event: evt,\n            eventName: TOUCH_TAP,\n            element: tapState.element,\n            renderingEngineId: tapState.renderingEngineId,\n            viewportId: tapState.viewportId,\n            camera: {},\n            currentPointsList,\n            currentPoints: getMeanTouchPoints(currentPointsList),\n            taps: tapState.taps,\n        };\n        triggerEventCallback(eventDetail.element, TOUCH_TAP, eventDetail);\n        tapState = JSON.parse(JSON.stringify(defaultTapState));\n    }, tapState.tapToleranceMs);\n}\nfunction _checkTouchSwipe(evt, deltaPoints) {\n    const currentTime = new Date().getTime();\n    const startTime = state.startTime.getTime();\n    if (state.swiped || currentTime - startTime > state.swipeToleranceMs) {\n        return;\n    }\n    const [x, y] = deltaPoints.canvas;\n    const eventDetail = {\n        event: evt,\n        eventName: TOUCH_SWIPE,\n        renderingEngineId: state.renderingEngineId,\n        viewportId: state.viewportId,\n        camera: {},\n        element: state.element,\n        swipe: null,\n    };\n    if (Math.abs(x) > state.swipeDistanceThreshold) {\n        eventDetail.swipe = x > 0 ? Swipe.RIGHT : Swipe.LEFT;\n        triggerEventCallback(eventDetail.element, TOUCH_SWIPE, eventDetail);\n        state.swiped = true;\n    }\n    if (Math.abs(y) > state.swipeDistanceThreshold) {\n        eventDetail.swipe = y > 0 ? Swipe.DOWN : Swipe.UP;\n        triggerEventCallback(eventDetail.element, TOUCH_SWIPE, eventDetail);\n        state.swiped = true;\n    }\n}\nfunction _updateTouchEventsLastPoints(element, lastPoints) {\n    const { viewport } = getEnabledElement(element);\n    return lastPoints.map((lp) => {\n        const world = viewport.canvasToWorld(lp.canvas);\n        return {\n            page: lp.page,\n            client: lp.client,\n            canvas: lp.canvas,\n            world,\n            touch: lp.touch,\n        };\n    });\n}\nexport default touchStartListener;\n", "import preventGhostClick from './preventGhostClick';\nimport touchStartListener from './touchStartListener';\nfunction disable(element) {\n    preventGhostClick.disable(element);\n    element.removeEventListener('touchstart', touchStartListener);\n}\nfunction enable(element) {\n    disable(element);\n    preventGhostClick.enable(element);\n    element.addEventListener('touchstart', touchStartListener, {\n        passive: false,\n    });\n}\nexport default {\n    enable,\n    disable,\n};\n", "const PIXEL_STEP = 10;\nconst LINE_HEIGHT = 40;\nconst PAGE_HEIGHT = 800;\nexport default function normalizeWheel(event) {\n    let spinX = 0, spinY = 0, pixelX = 0, pixelY = 0;\n    if ('detail' in event) {\n        spinY = event.detail;\n    }\n    if ('wheelDelta' in event) {\n        spinY = -event.wheelDelta / 120;\n    }\n    if ('wheelDeltaY' in event) {\n        spinY = -event.wheelDeltaY / 120;\n    }\n    if ('wheelDeltaX' in event) {\n        spinX = -event.wheelDeltaX / 120;\n    }\n    pixelX = spinX * PIXEL_STEP;\n    pixelY = spinY * PIXEL_STEP;\n    if ('deltaY' in event) {\n        pixelY = event.deltaY;\n    }\n    if ('deltaX' in event) {\n        pixelX = event.deltaX;\n    }\n    if ((pixelX || pixelY) && event.deltaMode) {\n        if (event.deltaMode === 1) {\n            pixelX *= LINE_HEIGHT;\n            pixelY *= LINE_HEIGHT;\n        }\n        else {\n            pixelX *= PAGE_HEIGHT;\n            pixelY *= PAGE_HEIGHT;\n        }\n    }\n    if (pixelX && !spinX) {\n        spinX = pixelX < 1 ? -1 : 1;\n    }\n    if (pixelY && !spinY) {\n        spinY = pixelY < 1 ? -1 : 1;\n    }\n    return {\n        spinX,\n        spinY,\n        pixelX,\n        pixelY,\n    };\n}\n", "import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport normalizeWheel from './normalizeWheel';\nimport Events from '../../enums/Events';\nimport getMouseEventPoints from '../mouse/getMouseEventPoints';\nfunction wheelListener(evt) {\n    const element = evt.currentTarget;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngineId, viewportId } = enabledElement;\n    if (evt.deltaY > -1 && evt.deltaY < 1) {\n        return;\n    }\n    evt.preventDefault();\n    const { spinX, spinY, pixelX, pixelY } = normalizeWheel(evt);\n    const direction = spinY < 0 ? -1 : 1;\n    const eventDetail = {\n        event: evt,\n        eventName: Events.MOUSE_WHEEL,\n        renderingEngineId,\n        viewportId,\n        element,\n        camera: {},\n        detail: evt,\n        wheel: {\n            spinX,\n            spinY,\n            pixelX,\n            pixelY,\n            direction,\n        },\n        points: getMouseEventPoints(evt),\n    };\n    triggerEvent(element, Events.MOUSE_WHEEL, eventDetail);\n}\nexport default wheelListener;\n", "import wheelListener from './wheelListener';\nfunction enable(element) {\n    disable(element);\n    element.addEventListener('wheel', wheelListener, { passive: false });\n}\nfunction disable(element) {\n    element.removeEventListener('wheel', wheelListener);\n}\nexport default {\n    enable,\n    disable,\n};\n", "import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nconst defaultState = {\n    renderingEngineId: undefined,\n    viewportId: undefined,\n    key: undefined,\n    keyCode: undefined,\n    element: null,\n};\nlet state = {\n    renderingEngineId: undefined,\n    viewportId: undefined,\n    key: undefined,\n    keyCode: undefined,\n    element: null,\n};\nfunction keyListener(evt) {\n    state.element = evt.currentTarget;\n    const enabledElement = getEnabledElement(state.element);\n    const { renderingEngineId, viewportId } = enabledElement;\n    state.renderingEngineId = renderingEngineId;\n    state.viewportId = viewportId;\n    state.key = evt.key;\n    state.keyCode = evt.keyCode;\n    evt.preventDefault();\n    const eventDetail = {\n        renderingEngineId: state.renderingEngineId,\n        viewportId: state.viewportId,\n        element: state.element,\n        key: state.key,\n        keyCode: state.keyCode,\n    };\n    triggerEvent(eventDetail.element, Events.KEY_DOWN, eventDetail);\n    document.addEventListener('keyup', _onKeyUp);\n    document.addEventListener('visibilitychange', _onVisibilityChange);\n    state.element.removeEventListener('keydown', keyListener);\n}\nfunction _onVisibilityChange() {\n    document.removeEventListener('visibilitychange', _onVisibilityChange);\n    if (document.visibilityState === 'hidden') {\n        resetModifierKey();\n    }\n}\nfunction _onKeyUp(evt) {\n    const eventDetail = {\n        renderingEngineId: state.renderingEngineId,\n        viewportId: state.viewportId,\n        element: state.element,\n        key: state.key,\n        keyCode: state.keyCode,\n    };\n    document.removeEventListener('keyup', _onKeyUp);\n    document.removeEventListener('visibilitychange', _onVisibilityChange);\n    state.element.addEventListener('keydown', keyListener);\n    state = structuredClone(defaultState);\n    triggerEvent(eventDetail.element, Events.KEY_UP, eventDetail);\n}\nexport function getModifierKey() {\n    return state.keyCode;\n}\nexport function resetModifierKey() {\n    state.keyCode = undefined;\n}\nexport default keyListener;\n", "import keyDownListener, { getModifierKey } from './keyDownListener';\nfunction enable(element) {\n    disable(element);\n    element.addEventListener('keydown', keyDownListener);\n}\nfunction disable(element) {\n    element.removeEventListener('keydown', keyDownListener);\n}\nexport default {\n    enable,\n    disable,\n    getModifierKey,\n};\n", "import { triggerSegmentationDataModified } from './events/triggerSegmentationDataModified';\nimport { triggerSegmentationModified } from './events/triggerSegmentationModified';\nimport { triggerSegmentationRemoved } from './events/triggerSegmentationRemoved';\nimport { triggerSegmentationRepresentationModified } from './events/triggerSegmentationRepresentationModified';\nimport { triggerSegmentationRepresentationRemoved } from './events/triggerSegmentationRepresentationRemoved';\nexport { triggerSegmentationDataModified, triggerSegmentationModified, triggerSegmentationRemoved, triggerSegmentationRepresentationModified, triggerSegmentationRepresentationRemoved, };\n", "import { CONSTANTS } from '@cornerstonejs/core';\nconst { EPSILON } = CONSTANTS;\nfunction calculateBoundingBox(points, dimensions, isWorld = false) {\n    let xMin = Infinity;\n    let xMax = isWorld ? -Infinity : 0;\n    let yMin = Infinity;\n    let yMax = isWorld ? -Infinity : 0;\n    let zMin = Infinity;\n    let zMax = isWorld ? -Infinity : 0;\n    const is3D = points[0]?.length === 3;\n    for (let i = 0; i < points.length; i++) {\n        const p = points[i];\n        xMin = Math.min(p[0], xMin);\n        xMax = Math.max(p[0], xMax);\n        yMin = Math.min(p[1], yMin);\n        yMax = Math.max(p[1], yMax);\n        if (is3D) {\n            zMin = Math.min(p[2] ?? zMin, zMin);\n            zMax = Math.max(p[2] ?? zMax, zMax);\n        }\n    }\n    if (dimensions) {\n        xMin = Math.max(isWorld ? dimensions[0] + EPSILON : 0, xMin);\n        xMax = Math.min(isWorld ? dimensions[0] - EPSILON : dimensions[0] - 1, xMax);\n        yMin = Math.max(isWorld ? dimensions[1] + EPSILON : 0, yMin);\n        yMax = Math.min(isWorld ? dimensions[1] - EPSILON : dimensions[1] - 1, yMax);\n        if (is3D && dimensions.length === 3) {\n            zMin = Math.max(isWorld ? dimensions[2] + EPSILON : 0, zMin);\n            zMax = Math.min(isWorld ? dimensions[2] - EPSILON : dimensions[2] - 1, zMax);\n        }\n    }\n    else if (!isWorld) {\n        xMin = Math.max(0, xMin);\n        xMax = Math.min(Infinity, xMax);\n        yMin = Math.max(0, yMin);\n        yMax = Math.min(Infinity, yMax);\n        if (is3D) {\n            zMin = Math.max(0, zMin);\n            zMax = Math.min(Infinity, zMax);\n        }\n    }\n    return is3D\n        ? [\n            [xMin, xMax],\n            [yMin, yMax],\n            [zMin, zMax],\n        ]\n        : [[xMin, xMax], [yMin, yMax], null];\n}\nexport function getBoundingBoxAroundShapeIJK(points, dimensions) {\n    return calculateBoundingBox(points, dimensions, false);\n}\nexport function getBoundingBoxAroundShapeWorld(points, clipBounds) {\n    return calculateBoundingBox(points, clipBounds, true);\n}\n", "import { utilities as csUtils } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShapeIJK } from '../boundingBox/getBoundingBoxAroundShape';\nconst equalsCheck = (a, b) => {\n    return JSON.stringify(a) === JSON.stringify(b);\n};\nexport function getVoxelOverlap(imageData, dimensions, voxelSpacing, voxelCenter) {\n    const halfSpacingX = voxelSpacing[0] / 2;\n    const halfSpacingY = voxelSpacing[1] / 2;\n    const halfSpacingZ = voxelSpacing[2] / 2;\n    const voxelCornersIJK = new Array(8);\n    voxelCornersIJK[0] = csUtils.transformWorldToIndex(imageData, [\n        voxelCenter[0] - halfSpacingX,\n        voxelCenter[1] - halfSpacingY,\n        voxelCenter[2] - halfSpacingZ,\n    ]);\n    const offsets = [\n        [1, -1, -1],\n        [-1, 1, -1],\n        [1, 1, -1],\n        [-1, -1, 1],\n        [1, -1, 1],\n        [-1, 1, 1],\n        [1, 1, 1],\n    ];\n    for (let i = 0; i < 7; i++) {\n        const [xOff, yOff, zOff] = offsets[i];\n        voxelCornersIJK[i + 1] = csUtils.transformWorldToIndex(imageData, [\n            voxelCenter[0] + xOff * halfSpacingX,\n            voxelCenter[1] + yOff * halfSpacingY,\n            voxelCenter[2] + zOff * halfSpacingZ,\n        ]);\n    }\n    return getBoundingBoxAroundShapeIJK(voxelCornersIJK, dimensions);\n}\nexport function processVolumes(segmentationVolume, thresholdVolumeInformation) {\n    const { spacing: segmentationSpacing } = segmentationVolume;\n    const scalarDataLength = segmentationVolume.voxelManager.getScalarDataLength();\n    const volumeInfoList = [];\n    let baseVolumeIdx = 0;\n    for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n        const { imageData, spacing, dimensions, voxelManager } = thresholdVolumeInformation[i].volume;\n        const volumeSize = thresholdVolumeInformation[i].volume.voxelManager.getScalarDataLength();\n        if (volumeSize === scalarDataLength &&\n            equalsCheck(spacing, segmentationSpacing)) {\n            baseVolumeIdx = i;\n        }\n        const lower = thresholdVolumeInformation[i].lower;\n        const upper = thresholdVolumeInformation[i].upper;\n        volumeInfoList.push({\n            imageData,\n            lower,\n            upper,\n            spacing,\n            dimensions,\n            volumeSize,\n            voxelManager,\n        });\n    }\n    return {\n        volumeInfoList,\n        baseVolumeIdx,\n    };\n}\nconst segmentIndicesCache = new Map();\nexport const setSegmentationDirty = (segmentationId) => {\n    const cached = segmentIndicesCache.get(segmentationId);\n    if (cached) {\n        cached.isDirty = true;\n    }\n};\nexport const setSegmentationClean = (segmentationId) => {\n    const cached = segmentIndicesCache.get(segmentationId);\n    if (cached) {\n        cached.isDirty = false;\n    }\n};\nexport const getCachedSegmentIndices = (segmentationId) => {\n    const cached = segmentIndicesCache.get(segmentationId);\n    if (cached && !cached.isDirty) {\n        return cached.indices;\n    }\n    return null;\n};\nexport const setCachedSegmentIndices = (segmentationId, indices) => {\n    segmentIndicesCache.set(segmentationId, { indices, isDirty: false });\n};\n", "import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nimport { setSegmentationDirty } from '../../../utilities/segmentation/utilities';\nexport function triggerSegmentationDataModified(segmentationId, modifiedSlicesToUse, segmentIndex) {\n    const eventDetail = {\n        segmentationId,\n        modifiedSlicesToUse,\n        segmentIndex,\n    };\n    setSegmentationDirty(segmentationId);\n    triggerEvent(eventTarget, Events.SEGMENTATION_DATA_MODIFIED, eventDetail);\n}\n", "import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationModified(segmentationId) {\n    const eventDetail = {\n        segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_MODIFIED, eventDetail);\n}\n", "import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationRemoved(segmentationId) {\n    const eventDetail = {\n        segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_REMOVED, eventDetail);\n}\n", "import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationRepresentationModified(viewportId, segmentationId, type) {\n    const eventDetail = {\n        segmentationId,\n        type,\n        viewportId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_REPRESENTATION_MODIFIED, eventDetail);\n}\n", "import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationRepresentationRemoved(viewportId, segmentationId, type) {\n    const eventDetail = {\n        viewportId,\n        segmentationId,\n        type,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_REPRESENTATION_REMOVED, eventDetail);\n}\n", "const defaultContourConfig = {\n    renderOutline: true,\n    outlineWidthAutoGenerated: 3,\n    outlineWidth: 1,\n    outlineWidthInactive: 1,\n    outlineOpacity: 1,\n    outlineOpacityInactive: 0.85,\n    outlineDash: undefined,\n    outlineDashInactive: undefined,\n    outlineDashAutoGenerated: '5,3',\n    activeSegmentOutlineWidthDelta: 0,\n    renderFill: true,\n    fillAlpha: 0.5,\n    fillAlphaInactive: 0.3,\n    fillAlphaAutoGenerated: 0.3,\n};\nfunction getDefaultContourStyle() {\n    return defaultContourConfig;\n}\nexport default getDefaultContourStyle;\n", "const defaultLabelmapConfig = {\n    renderOutline: true,\n    renderOutlineInactive: true,\n    outlineWidth: 3,\n    outlineWidthInactive: 2,\n    activeSegmentOutlineWidthDelta: 0,\n    renderFill: true,\n    renderFillInactive: true,\n    fillAlpha: 0.5,\n    fillAlphaInactive: 0.4,\n    outlineOpacity: 1,\n    outlineOpacityInactive: 0.85,\n};\nfunction getDefaultLabelmapStyle() {\n    return defaultLabelmapConfig;\n}\nexport default getDefaultLabelmapStyle;\n", "import getDefaultContourConfig from '../../tools/displayTools/Contour/contourConfig';\nimport getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport * as Enums from '../../enums';\nimport { utilities } from '@cornerstonejs/core';\nclass SegmentationStyle {\n    constructor() {\n        this.config = {\n            global: {},\n            segmentations: {},\n            viewportsStyle: {},\n        };\n    }\n    setStyle(specifier, styles) {\n        const { viewportId, segmentationId, type, segmentIndex } = specifier;\n        const currentStyles = this.getStyle(specifier);\n        let updatedStyles;\n        if (!viewportId && !segmentationId) {\n            updatedStyles = {\n                ...currentStyles,\n                ...styles,\n            };\n        }\n        else {\n            updatedStyles = this.copyActiveToInactiveIfNotProvided({\n                ...currentStyles,\n                ...styles,\n            }, type);\n        }\n        if (!type) {\n            throw new Error('Type is required to set a style');\n        }\n        if (viewportId) {\n            if (!this.config.viewportsStyle[viewportId]) {\n                this.config.viewportsStyle[viewportId] = {\n                    renderInactiveSegmentations: false,\n                    representations: {},\n                };\n            }\n            const representations = this.config.viewportsStyle[viewportId].representations;\n            if (segmentationId) {\n                if (!representations[segmentationId]) {\n                    representations[segmentationId] = {};\n                }\n                if (!representations[segmentationId][type]) {\n                    representations[segmentationId][type] = {};\n                }\n                const repConfig = representations[segmentationId][type];\n                if (segmentIndex !== undefined) {\n                    if (!repConfig.perSegment) {\n                        repConfig.perSegment = {};\n                    }\n                    repConfig.perSegment[segmentIndex] = updatedStyles;\n                }\n                else {\n                    repConfig.allSegments = updatedStyles;\n                }\n            }\n            else {\n                const ALL_SEGMENTATIONS_KEY = '__allSegmentations__';\n                if (!representations[ALL_SEGMENTATIONS_KEY]) {\n                    representations[ALL_SEGMENTATIONS_KEY] = {};\n                }\n                if (!representations[ALL_SEGMENTATIONS_KEY][type]) {\n                    representations[ALL_SEGMENTATIONS_KEY][type] = {};\n                }\n                representations[ALL_SEGMENTATIONS_KEY][type].allSegments =\n                    updatedStyles;\n            }\n        }\n        else if (segmentationId) {\n            if (!this.config.segmentations[segmentationId]) {\n                this.config.segmentations[segmentationId] = {};\n            }\n            if (!this.config.segmentations[segmentationId][type]) {\n                this.config.segmentations[segmentationId][type] = {};\n            }\n            const segConfig = this.config.segmentations[segmentationId][type];\n            if (segmentIndex !== undefined) {\n                if (!segConfig.perSegment) {\n                    segConfig.perSegment = {};\n                }\n                segConfig.perSegment[segmentIndex] = updatedStyles;\n            }\n            else {\n                segConfig.allSegments = updatedStyles;\n            }\n        }\n        else {\n            this.config.global[type] = updatedStyles;\n        }\n    }\n    copyActiveToInactiveIfNotProvided(styles, type) {\n        const processedStyles = { ...styles };\n        if (type === Enums.SegmentationRepresentations.Labelmap) {\n            const labelmapStyles = processedStyles;\n            labelmapStyles.renderOutlineInactive ??= labelmapStyles.renderOutline;\n            labelmapStyles.outlineWidthInactive ??= labelmapStyles.outlineWidth;\n            labelmapStyles.renderFillInactive ??= labelmapStyles.renderFill;\n            labelmapStyles.fillAlphaInactive ??= labelmapStyles.fillAlpha;\n            labelmapStyles.outlineOpacityInactive ??= labelmapStyles.outlineOpacity;\n        }\n        else if (type === Enums.SegmentationRepresentations.Contour) {\n            const contourStyles = processedStyles;\n            contourStyles.outlineWidthInactive ??= contourStyles.outlineWidth;\n            contourStyles.outlineOpacityInactive ??= contourStyles.outlineOpacity;\n            contourStyles.outlineDashInactive ??= contourStyles.outlineDash;\n            contourStyles.renderOutlineInactive ??= contourStyles.renderOutline;\n            contourStyles.renderFillInactive ??= contourStyles.renderFill;\n            contourStyles.fillAlphaInactive ??= contourStyles.fillAlpha;\n        }\n        return processedStyles;\n    }\n    getStyle(specifier) {\n        const { viewportId, segmentationId, type, segmentIndex } = specifier;\n        let combinedStyle = this.getDefaultStyle(type);\n        let renderInactiveSegmentations = false;\n        if (this.config.global[type]) {\n            combinedStyle = {\n                ...combinedStyle,\n                ...this.config.global[type],\n            };\n        }\n        if (this.config.segmentations[segmentationId]?.[type]) {\n            combinedStyle = {\n                ...combinedStyle,\n                ...this.config.segmentations[segmentationId][type].allSegments,\n            };\n            if (segmentIndex !== undefined &&\n                this.config.segmentations[segmentationId][type].perSegment?.[segmentIndex]) {\n                combinedStyle = {\n                    ...combinedStyle,\n                    ...this.config.segmentations[segmentationId][type].perSegment[segmentIndex],\n                };\n            }\n        }\n        if (viewportId && this.config.viewportsStyle[viewportId]) {\n            renderInactiveSegmentations =\n                this.config.viewportsStyle[viewportId].renderInactiveSegmentations;\n            const allSegmentationsKey = '__allSegmentations__';\n            if (this.config.viewportsStyle[viewportId].representations[allSegmentationsKey]?.[type]) {\n                combinedStyle = {\n                    ...combinedStyle,\n                    ...this.config.viewportsStyle[viewportId].representations[allSegmentationsKey][type].allSegments,\n                };\n            }\n            if (segmentationId &&\n                this.config.viewportsStyle[viewportId].representations[segmentationId]?.[type]) {\n                combinedStyle = {\n                    ...combinedStyle,\n                    ...this.config.viewportsStyle[viewportId].representations[segmentationId][type].allSegments,\n                };\n                if (segmentIndex !== undefined &&\n                    this.config.viewportsStyle[viewportId].representations[segmentationId][type].perSegment?.[segmentIndex]) {\n                    combinedStyle = {\n                        ...combinedStyle,\n                        ...this.config.viewportsStyle[viewportId].representations[segmentationId][type].perSegment[segmentIndex],\n                    };\n                }\n            }\n        }\n        return combinedStyle;\n    }\n    getRenderInactiveSegmentations(viewportId) {\n        return this.config.viewportsStyle[viewportId]?.renderInactiveSegmentations;\n    }\n    setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations) {\n        if (!this.config.viewportsStyle[viewportId]) {\n            this.config.viewportsStyle[viewportId] = {\n                renderInactiveSegmentations: false,\n                representations: {},\n            };\n        }\n        this.config.viewportsStyle[viewportId].renderInactiveSegmentations =\n            renderInactiveSegmentations;\n    }\n    getDefaultStyle(type) {\n        switch (type) {\n            case Enums.SegmentationRepresentations.Labelmap:\n                return getDefaultLabelmapConfig();\n            case Enums.SegmentationRepresentations.Contour:\n                return getDefaultContourConfig();\n            case Enums.SegmentationRepresentations.Surface:\n                return {};\n            default:\n                throw new Error(`Unknown representation type: ${type}`);\n        }\n    }\n    clearSegmentationStyle(segmentationId) {\n        if (this.config.segmentations[segmentationId]) {\n            delete this.config.segmentations[segmentationId];\n        }\n    }\n    clearAllSegmentationStyles() {\n        this.config.segmentations = {};\n    }\n    clearViewportStyle(viewportId) {\n        if (this.config.viewportsStyle[viewportId]) {\n            delete this.config.viewportsStyle[viewportId];\n        }\n    }\n    clearAllViewportStyles() {\n        for (const viewportId in this.config.viewportsStyle) {\n            const viewportStyle = this.config.viewportsStyle[viewportId];\n            const renderInactiveSegmentations = viewportStyle.renderInactiveSegmentations;\n            this.config.viewportsStyle[viewportId] = {\n                renderInactiveSegmentations,\n                representations: {},\n            };\n        }\n    }\n    resetToGlobalStyle() {\n        this.clearAllSegmentationStyles();\n        this.clearAllViewportStyles();\n    }\n    hasCustomStyle(specifier) {\n        const { type } = specifier;\n        const style = this.getStyle(specifier);\n        const defaultStyle = this.getDefaultStyle(type);\n        return !utilities.deepEqual(style, defaultStyle);\n    }\n}\nconst segmentationStyle = new SegmentationStyle();\nexport { segmentationStyle };\n", "import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationAdded(segmentationId) {\n    const eventDetail = {\n        segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_ADDED, eventDetail);\n}\n", "import { BaseVolumeViewport, cache, utilities as csUtils, getEnabledElementByViewportId, volumeLoader, } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\nimport vtkPiecewiseFunction from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';\nimport { triggerSegmentationModified, triggerSegmentationRemoved, triggerSegmentationRepresentationModified, triggerSegmentationRepresentationRemoved, } from './triggerSegmentationEvents';\nimport { segmentationStyle } from './SegmentationStyle';\nimport { triggerSegmentationAdded } from './events/triggerSegmentationAdded';\nconst initialDefaultState = {\n    colorLUT: [],\n    segmentations: [],\n    viewportSegRepresentations: {},\n};\nexport default class SegmentationStateManager {\n    constructor(uid) {\n        this._stackLabelmapImageIdReferenceMap = new Map();\n        this._labelmapImageIdReferenceMap = new Map();\n        uid ||= csUtils.uuidv4();\n        this.state = Object.freeze(csUtils.deepClone(initialDefaultState));\n        this.uid = uid;\n    }\n    getState() {\n        return this.state;\n    }\n    updateState(updater) {\n        const newState = csUtils.deepClone(this.state);\n        updater(newState);\n        this.state = Object.freeze(newState);\n    }\n    getColorLUT(lutIndex) {\n        return this.state.colorLUT[lutIndex];\n    }\n    getNextColorLUTIndex() {\n        return this.state.colorLUT.length;\n    }\n    resetState() {\n        this._stackLabelmapImageIdReferenceMap.clear();\n        this._labelmapImageIdReferenceMap.clear();\n        this.state = Object.freeze(csUtils.deepClone(initialDefaultState));\n    }\n    getSegmentation(segmentationId) {\n        return this.state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);\n    }\n    updateSegmentation(segmentationId, payload) {\n        this.updateState((draftState) => {\n            const segmentation = draftState.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);\n            if (!segmentation) {\n                console.warn(`Segmentation with id ${segmentationId} not found. Update aborted.`);\n                return;\n            }\n            Object.assign(segmentation, payload);\n        });\n        triggerSegmentationModified(segmentationId);\n    }\n    addSegmentation(segmentation) {\n        if (this.getSegmentation(segmentation.segmentationId)) {\n            throw new Error(`Segmentation with id ${segmentation.segmentationId} already exists`);\n        }\n        this.updateState((state) => {\n            const newSegmentation = csUtils.deepClone(segmentation);\n            if (newSegmentation.representationData.Labelmap &&\n                'volumeId' in newSegmentation.representationData.Labelmap &&\n                !('imageIds' in newSegmentation.representationData.Labelmap)) {\n                const imageIds = this.getLabelmapImageIds(newSegmentation.representationData);\n                newSegmentation.representationData\n                    .Labelmap.imageIds = imageIds;\n            }\n            state.segmentations.push(newSegmentation);\n        });\n        triggerSegmentationAdded(segmentation.segmentationId);\n    }\n    removeSegmentation(segmentationId) {\n        this.updateState((state) => {\n            const filteredSegmentations = state.segmentations.filter((segmentation) => segmentation.segmentationId !== segmentationId);\n            state.segmentations.splice(0, state.segmentations.length, ...filteredSegmentations);\n        });\n        triggerSegmentationRemoved(segmentationId);\n    }\n    addSegmentationRepresentation(viewportId, segmentationId, type, renderingConfig) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const existingRepresentations = this.getSegmentationRepresentations(viewportId, {\n            type: type,\n            segmentationId,\n        });\n        if (existingRepresentations.length > 0) {\n            console.debug('A segmentation representation of type', type, 'already exists in viewport', viewportId, 'for segmentation', segmentationId);\n            return;\n        }\n        this.updateState((state) => {\n            if (!state.viewportSegRepresentations[viewportId]) {\n                state.viewportSegRepresentations[viewportId] = [];\n                segmentationStyle.setRenderInactiveSegmentations(viewportId, true);\n            }\n            if (type !== SegmentationRepresentations.Labelmap) {\n                this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, type, renderingConfig);\n            }\n            else {\n                this.addLabelmapRepresentation(state, viewportId, segmentationId, renderingConfig);\n            }\n        });\n        triggerSegmentationRepresentationModified(viewportId, segmentationId, type);\n    }\n    addDefaultSegmentationRepresentation(state, viewportId, segmentationId, type, renderingConfig) {\n        const segmentation = state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        const segmentReps = {};\n        Object.keys(segmentation.segments).forEach((segmentIndex) => {\n            segmentReps[Number(segmentIndex)] = {\n                visible: true,\n            };\n        });\n        state.viewportSegRepresentations[viewportId].push({\n            segmentationId,\n            type,\n            active: true,\n            visible: true,\n            colorLUTIndex: renderingConfig?.colorLUTIndex || 0,\n            segments: segmentReps,\n            config: {\n                ...getDefaultRenderingConfig(type),\n                ...renderingConfig,\n            },\n        });\n        this._setActiveSegmentation(state, viewportId, segmentationId);\n    }\n    addLabelmapRepresentation(state, viewportId, segmentationId, renderingConfig = getDefaultRenderingConfig(SegmentationRepresentations.Labelmap)) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        const { representationData } = segmentation;\n        if (!representationData.Labelmap) {\n            return this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, SegmentationRepresentations.Labelmap, renderingConfig);\n        }\n        this.processLabelmapRepresentationAddition(viewportId, segmentationId);\n        this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, SegmentationRepresentations.Labelmap, renderingConfig);\n    }\n    async processLabelmapRepresentationAddition(viewportId, segmentationId) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        const volumeViewport = enabledElement.viewport instanceof BaseVolumeViewport;\n        const { representationData } = segmentation;\n        const isBaseVolumeSegmentation = 'volumeId' in representationData.Labelmap;\n        const viewport = enabledElement.viewport;\n        if (!volumeViewport && !isBaseVolumeSegmentation) {\n            !this.updateLabelmapSegmentationImageReferences(viewportId, segmentation.segmentationId);\n        }\n    }\n    _updateLabelmapSegmentationReferences(segmentationId, viewport, labelmapImageIds, updateCallback) {\n        const referenceImageId = viewport.getCurrentImageId();\n        let viewableLabelmapImageIdFound = false;\n        for (const labelmapImageId of labelmapImageIds) {\n            const viewableImageId = viewport.isReferenceViewable({ referencedImageId: labelmapImageId }, { asOverlay: true });\n            if (viewableImageId) {\n                viewableLabelmapImageIdFound = true;\n                this._stackLabelmapImageIdReferenceMap\n                    .get(segmentationId)\n                    .set(referenceImageId, labelmapImageId);\n                this._updateLabelmapImageIdReferenceMap({\n                    segmentationId,\n                    referenceImageId,\n                    labelmapImageId,\n                });\n            }\n        }\n        if (updateCallback) {\n            updateCallback(viewport, segmentationId, labelmapImageIds);\n        }\n        return viewableLabelmapImageIdFound\n            ? this._stackLabelmapImageIdReferenceMap\n                .get(segmentationId)\n                .get(referenceImageId)\n            : undefined;\n    }\n    updateLabelmapSegmentationImageReferences(viewportId, segmentationId) {\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {\n            this._stackLabelmapImageIdReferenceMap.set(segmentationId, new Map());\n        }\n        const { representationData } = segmentation;\n        if (!representationData.Labelmap) {\n            return;\n        }\n        const labelmapImageIds = this.getLabelmapImageIds(representationData);\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        const stackViewport = enabledElement.viewport;\n        return this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, null);\n    }\n    _updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId) {\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {\n            this._stackLabelmapImageIdReferenceMap.set(segmentationId, new Map());\n        }\n        const { representationData } = segmentation;\n        if (!representationData.Labelmap) {\n            return;\n        }\n        const labelmapImageIds = this.getLabelmapImageIds(representationData);\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        const stackViewport = enabledElement.viewport;\n        this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, (stackViewport, segmentationId, labelmapImageIds) => {\n            const imageIds = stackViewport.getImageIds();\n            imageIds.forEach((referenceImageId, index) => {\n                for (const labelmapImageId of labelmapImageIds) {\n                    const viewableImageId = stackViewport.isReferenceViewable({ referencedImageId: labelmapImageId, sliceIndex: index }, { asOverlay: true, withNavigation: true });\n                    if (viewableImageId) {\n                        this._stackLabelmapImageIdReferenceMap\n                            .get(segmentationId)\n                            .set(referenceImageId, labelmapImageId);\n                        this._updateLabelmapImageIdReferenceMap({\n                            segmentationId,\n                            referenceImageId,\n                            labelmapImageId,\n                        });\n                    }\n                }\n            });\n        });\n    }\n    getLabelmapImageIds(representationData) {\n        const labelmapData = representationData.Labelmap;\n        let labelmapImageIds;\n        if (labelmapData.imageIds) {\n            labelmapImageIds = labelmapData\n                .imageIds;\n        }\n        else if (!labelmapImageIds &&\n            labelmapData.volumeId) {\n            const volumeId = labelmapData\n                .volumeId;\n            const volume = cache.getVolume(volumeId);\n            labelmapImageIds = volume.imageIds;\n        }\n        return labelmapImageIds;\n    }\n    getLabelmapImageIdsForImageId(imageId, segmentationId) {\n        const key = this._generateMapKey({\n            segmentationId,\n            referenceImageId: imageId,\n        });\n        return this._labelmapImageIdReferenceMap.get(key);\n    }\n    getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const stackViewport = enabledElement.viewport;\n        const referenceImageId = stackViewport.getCurrentImageId();\n        return this.getLabelmapImageIdsForImageId(referenceImageId, segmentationId);\n    }\n    getCurrentLabelmapImageIdForViewport(viewportId, segmentationId) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {\n            return;\n        }\n        const stackViewport = enabledElement.viewport;\n        const currentImageId = stackViewport.getCurrentImageId();\n        const imageIdReferenceMap = this._stackLabelmapImageIdReferenceMap.get(segmentationId);\n        return imageIdReferenceMap.get(currentImageId);\n    }\n    getStackSegmentationImageIdsForViewport(viewportId, segmentationId) {\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return [];\n        }\n        this._updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId);\n        const { viewport } = getEnabledElementByViewportId(viewportId);\n        const imageIds = viewport.getImageIds();\n        const associatedReferenceImageAndLabelmapImageIds = this._stackLabelmapImageIdReferenceMap.get(segmentationId);\n        return imageIds.map((imageId) => {\n            return associatedReferenceImageAndLabelmapImageIds.get(imageId);\n        });\n    }\n    removeSegmentationRepresentationsInternal(viewportId, specifier) {\n        const removedRepresentations = [];\n        this.updateState((state) => {\n            if (!state.viewportSegRepresentations[viewportId]) {\n                return;\n            }\n            const currentRepresentations = state.viewportSegRepresentations[viewportId];\n            let activeRepresentationRemoved = false;\n            if (!specifier ||\n                Object.values(specifier).every((value) => value === undefined)) {\n                removedRepresentations.push(...currentRepresentations);\n                delete state.viewportSegRepresentations[viewportId];\n            }\n            else {\n                const { segmentationId, type } = specifier;\n                state.viewportSegRepresentations[viewportId] =\n                    currentRepresentations.filter((representation) => {\n                        const shouldRemove = (segmentationId &&\n                            type &&\n                            representation.segmentationId === segmentationId &&\n                            representation.type === type) ||\n                            (segmentationId &&\n                                !type &&\n                                representation.segmentationId === segmentationId) ||\n                            (!segmentationId && type && representation.type === type);\n                        if (shouldRemove) {\n                            removedRepresentations.push(representation);\n                            if (representation.active) {\n                                activeRepresentationRemoved = true;\n                            }\n                        }\n                        return !shouldRemove;\n                    });\n                if (state.viewportSegRepresentations[viewportId].length === 0) {\n                    delete state.viewportSegRepresentations[viewportId];\n                }\n                else if (activeRepresentationRemoved) {\n                    state.viewportSegRepresentations[viewportId][0].active = true;\n                }\n            }\n        });\n        return removedRepresentations;\n    }\n    removeSegmentationRepresentations(viewportId, specifier) {\n        const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);\n        removedRepresentations.forEach((representation) => {\n            triggerSegmentationRepresentationRemoved(viewportId, representation.segmentationId, representation.type);\n        });\n        const remainingRepresentations = this.getSegmentationRepresentations(viewportId);\n        if (remainingRepresentations.length > 0 &&\n            remainingRepresentations[0].active) {\n            triggerSegmentationRepresentationModified(viewportId, remainingRepresentations[0].segmentationId, remainingRepresentations[0].type);\n        }\n        return removedRepresentations;\n    }\n    removeSegmentationRepresentation(viewportId, specifier, suppressEvent) {\n        const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);\n        if (!suppressEvent) {\n            removedRepresentations.forEach(({ segmentationId, type }) => {\n                triggerSegmentationRepresentationRemoved(viewportId, segmentationId, type);\n            });\n        }\n        return removedRepresentations;\n    }\n    _updateLabelmapImageIdReferenceMap({ segmentationId, referenceImageId, labelmapImageId, }) {\n        const key = this._generateMapKey({ segmentationId, referenceImageId });\n        if (!this._labelmapImageIdReferenceMap.has(key)) {\n            this._labelmapImageIdReferenceMap.set(key, [labelmapImageId]);\n            return;\n        }\n        const currentValues = this._labelmapImageIdReferenceMap.get(key);\n        const newValues = Array.from(new Set([...currentValues, labelmapImageId]));\n        this._labelmapImageIdReferenceMap.set(key, newValues);\n    }\n    _setActiveSegmentation(state, viewportId, segmentationId) {\n        const viewport = state.viewportSegRepresentations[viewportId];\n        if (!viewport) {\n            return;\n        }\n        viewport.forEach((value) => {\n            value.active = value.segmentationId === segmentationId;\n        });\n    }\n    setActiveSegmentation(viewportId, segmentationId) {\n        this.updateState((state) => {\n            const viewport = state.viewportSegRepresentations[viewportId];\n            if (!viewport) {\n                return;\n            }\n            viewport.forEach((value) => {\n                value.active = value.segmentationId === segmentationId;\n            });\n        });\n        triggerSegmentationRepresentationModified(viewportId, segmentationId);\n    }\n    getActiveSegmentation(viewportId) {\n        if (!this.state.viewportSegRepresentations[viewportId]) {\n            return;\n        }\n        const activeSegRep = this.state.viewportSegRepresentations[viewportId].find((segRep) => segRep.active);\n        if (!activeSegRep) {\n            return;\n        }\n        return this.getSegmentation(activeSegRep.segmentationId);\n    }\n    getSegmentationRepresentations(viewportId, specifier = {}) {\n        const viewportRepresentations = this.state.viewportSegRepresentations[viewportId];\n        if (!viewportRepresentations) {\n            return [];\n        }\n        if (!specifier.type && !specifier.segmentationId) {\n            return viewportRepresentations;\n        }\n        return viewportRepresentations.filter((representation) => {\n            const typeMatch = specifier.type\n                ? representation.type === specifier.type\n                : true;\n            const idMatch = specifier.segmentationId\n                ? representation.segmentationId === specifier.segmentationId\n                : true;\n            return typeMatch && idMatch;\n        });\n    }\n    getSegmentationRepresentation(viewportId, specifier) {\n        return this.getSegmentationRepresentations(viewportId, specifier)[0];\n    }\n    getSegmentationRepresentationVisibility(viewportId, specifier) {\n        const viewportRepresentation = this.getSegmentationRepresentation(viewportId, specifier);\n        return viewportRepresentation?.visible;\n    }\n    setSegmentationRepresentationVisibility(viewportId, specifier, visible) {\n        this.updateState((state) => {\n            const viewportRepresentations = this.getSegmentationRepresentations(viewportId, specifier);\n            if (!viewportRepresentations) {\n                return;\n            }\n            viewportRepresentations.forEach((representation) => {\n                representation.visible = visible;\n                Object.entries(representation.segments).forEach(([segmentIndex, segment]) => {\n                    segment.visible = visible;\n                });\n            });\n        });\n        triggerSegmentationRepresentationModified(viewportId, specifier.segmentationId, specifier.type);\n    }\n    addColorLUT(colorLUT, lutIndex) {\n        this.updateState((state) => {\n            if (state.colorLUT[lutIndex]) {\n                console.warn('Color LUT table already exists, overwriting');\n            }\n            state.colorLUT[lutIndex] = csUtils.deepClone(colorLUT);\n        });\n    }\n    removeColorLUT(colorLUTIndex) {\n        this.updateState((state) => {\n            delete state.colorLUT[colorLUTIndex];\n        });\n    }\n    _getStackIdForImageIds(imageIds) {\n        return imageIds\n            .map((imageId) => imageId.slice(-Math.round(imageId.length * 0.15)))\n            .join('_');\n    }\n    getAllViewportSegmentationRepresentations() {\n        return Object.entries(this.state.viewportSegRepresentations).map(([viewportId, representations]) => ({\n            viewportId,\n            representations,\n        }));\n    }\n    getSegmentationRepresentationsBySegmentationId(segmentationId) {\n        const result = [];\n        Object.entries(this.state.viewportSegRepresentations).forEach(([viewportId, viewportReps]) => {\n            const filteredReps = viewportReps.filter((representation) => representation.segmentationId === segmentationId);\n            if (filteredReps.length > 0) {\n                result.push({ viewportId, representations: filteredReps });\n            }\n        });\n        return result;\n    }\n    _generateMapKey({ segmentationId, referenceImageId }) {\n        return `${segmentationId}-${referenceImageId}`;\n    }\n}\nasync function internalComputeVolumeLabelmapFromStack({ imageIds, options, }) {\n    const segmentationImageIds = imageIds;\n    const volumeId = options?.volumeId || csUtils.uuidv4();\n    await volumeLoader.createAndCacheVolumeFromImages(volumeId, segmentationImageIds);\n    return { volumeId };\n}\nasync function internalConvertStackToVolumeLabelmap({ segmentationId, options, }) {\n    const segmentation = defaultSegmentationStateManager.getSegmentation(segmentationId);\n    const data = segmentation.representationData\n        .Labelmap;\n    const { volumeId } = await internalComputeVolumeLabelmapFromStack({\n        imageIds: data.imageIds,\n        options,\n    });\n    segmentation.representationData.Labelmap.volumeId = volumeId;\n}\nfunction getDefaultRenderingConfig(type) {\n    const cfun = vtkColorTransferFunction.newInstance();\n    const ofun = vtkPiecewiseFunction.newInstance();\n    ofun.addPoint(0, 0);\n    if (type === SegmentationRepresentations.Labelmap) {\n        return {\n            cfun,\n            ofun,\n        };\n    }\n    else {\n        return {};\n    }\n}\nconst defaultSegmentationStateManager = new SegmentationStateManager('DEFAULT');\nexport { internalConvertStackToVolumeLabelmap, internalComputeVolumeLabelmapFromStack, defaultSegmentationStateManager, };\n", "import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getSegmentationRepresentations(viewportId, specifier = {}) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);\n}\nexport function getSegmentationRepresentation(viewportId, specifier) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    if (!specifier.segmentationId || !specifier.type) {\n        throw new Error('getSegmentationRepresentation: No segmentationId or type provided, you need to provide at least one of them');\n    }\n    const representations = segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);\n    return representations?.[0];\n}\nexport function getSegmentationRepresentationsBySegmentationId(segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentationRepresentationsBySegmentationId(segmentationId);\n}\n", "import { getEnabledElement } from '@cornerstonejs/core';\nfunction removeSurfaceFromElement(element, segmentationId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const actorEntries = viewport.getActors();\n    const filteredSurfaceActors = actorEntries.filter((actor) => actor.representationUID &&\n        typeof actor.representationUID === 'string' &&\n        actor.representationUID.startsWith(segmentationId));\n    viewport.removeActors(filteredSurfaceActors.map((actor) => actor.uid));\n}\nexport default removeSurfaceFromElement;\n", "import { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../../enums';\nfunction getActorEntry(viewportId, segmentationId, filterFn) {\n    const enabledElement = getEnabledElementByViewportId(viewportId);\n    if (!enabledElement) {\n        return;\n    }\n    const { renderingEngine, viewport } = enabledElement;\n    if (!renderingEngine || !viewport) {\n        return;\n    }\n    const actors = viewport.getActors();\n    const filteredActors = actors.filter(filterFn);\n    return filteredActors.length > 0 ? filteredActors[0] : undefined;\n}\nfunction getActorEntries(viewportId, filterFn) {\n    const enabledElement = getEnabledElementByViewportId(viewportId);\n    if (!enabledElement) {\n        return;\n    }\n    const { renderingEngine, viewport } = enabledElement;\n    if (!renderingEngine || !viewport) {\n        return;\n    }\n    const actors = viewport.getActors();\n    const filteredActors = actors.filter(filterFn);\n    return filteredActors.length > 0 ? filteredActors : undefined;\n}\nexport function getLabelmapActorUID(viewportId, segmentationId) {\n    const actorEntry = getLabelmapActorEntry(viewportId, segmentationId);\n    return actorEntry?.uid;\n}\nexport function getLabelmapActorEntries(viewportId, segmentationId) {\n    return getActorEntries(viewportId, (actor) => actor.representationUID?.startsWith(`${segmentationId}-${SegmentationRepresentations.Labelmap}`));\n}\nexport function getLabelmapActorEntry(viewportId, segmentationId) {\n    return getActorEntry(viewportId, segmentationId, (actor) => actor.representationUID?.startsWith(`${segmentationId}-${SegmentationRepresentations.Labelmap}`));\n}\nexport function getSurfaceActorEntry(viewportId, segmentationId, segmentIndex) {\n    return getActorEntry(viewportId, segmentationId, (actor) => actor.representationUID ===\n        getSurfaceRepresentationUID(segmentationId, segmentIndex));\n}\nexport function getSurfaceRepresentationUID(segmentationId, segmentIndex) {\n    return `${segmentationId}-${SegmentationRepresentations.Surface}-${segmentIndex}`;\n}\n", "import { getEnabledElement } from '@cornerstonejs/core';\nimport { utilities } from '@cornerstonejs/core';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport { getSurfaceActorEntry, getSurfaceRepresentationUID, } from '../../../stateManagement/segmentation/helpers/getSegmentationActor';\nfunction addOrUpdateSurfaceToElement(element, surface, segmentationId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const surfaceActorEntry = getSurfaceActorEntry(viewport.id, segmentationId, surface.segmentIndex);\n    const surfaceActor = surfaceActorEntry?.actor;\n    const isVisible = surface.visible;\n    if (surfaceActor) {\n        surfaceActor.setVisibility(isVisible);\n        if (!isVisible) {\n            return;\n        }\n        const surfaceMapper = surfaceActor.getMapper();\n        const currentPolyData = surfaceMapper.getInputData();\n        const newPoints = surface.points;\n        const newPolys = surface.polys;\n        const currentPoints = currentPolyData.getPoints().getData();\n        const currentPolys = currentPolyData.getPolys().getData();\n        if (newPoints.length === currentPoints.length &&\n            newPolys.length === currentPolys.length) {\n            return;\n        }\n        const polyData = vtkPolyData.newInstance();\n        polyData.getPoints().setData(newPoints, 3);\n        const triangles = vtkCellArray.newInstance({\n            values: Float32Array.from(newPolys),\n        });\n        polyData.setPolys(triangles);\n        surfaceMapper.setInputData(polyData);\n        surfaceMapper.modified();\n        viewport.getRenderer().resetCameraClippingRange();\n        return;\n    }\n    const points = surface.points;\n    const polys = surface.polys;\n    const color = surface.color;\n    const surfacePolyData = vtkPolyData.newInstance();\n    surfacePolyData.getPoints().setData(points, 3);\n    const triangles = vtkCellArray.newInstance({\n        values: Float32Array.from(polys),\n    });\n    surfacePolyData.setPolys(triangles);\n    const mapper = vtkMapper.newInstance({});\n    let clippingFilter;\n    mapper.setInputData(surfacePolyData);\n    const actor = vtkActor.newInstance();\n    actor.setMapper(mapper);\n    actor.getProperty().setColor(color[0] / 255, color[1] / 255, color[2] / 255);\n    actor.getProperty().setLineWidth(2);\n    const representationUID = getSurfaceRepresentationUID(segmentationId, surface.segmentIndex);\n    viewport.addActor({\n        uid: utilities.uuidv4(),\n        actor: actor,\n        clippingFilter,\n        representationUID,\n    });\n    viewport.resetCamera();\n    viewport.getRenderer().resetCameraClippingRange();\n    viewport.render();\n}\nexport default addOrUpdateSurfaceToElement;\n", "import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getSegmentation(segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentation(segmentationId);\n}\n", "import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getColorLUT(index) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getColorLUT(index);\n}\n", "import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport Events from './enums/Events';\nlet config = {};\nexport function getConfig() {\n    return config;\n}\nexport function setConfig(newConfig) {\n    config = newConfig;\n}\nexport function getAddOns() {\n    return config.addons;\n}\nlet polysegInitialized = false;\nexport function getPolySeg() {\n    if (!config.addons?.polySeg) {\n        console.warn('PolySeg add-on not configured. This will prevent automatic conversion between segmentation representations (labelmap, contour, surface). To enable these features, install @cornerstonejs/polymorphic-segmentation and register it during initialization: cornerstoneTools.init({ addons: { polySeg } }).');\n        return null;\n    }\n    const polyseg = config.addons.polySeg;\n    if (!polysegInitialized) {\n        polyseg.init();\n        polysegInitialized = true;\n    }\n    return polyseg;\n}\n", "import { getSegmentation } from './getSegmentation';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nfunction internalAddRepresentationData({ segmentationId, type, data, }) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`Segmentation ${segmentationId} not found`);\n    }\n    if (segmentation.representationData[type]) {\n        console.warn(`Representation data of type ${type} already exists for segmentation ${segmentationId}, overwriting it.`);\n    }\n    switch (type) {\n        case SegmentationRepresentations.Labelmap:\n            if (data) {\n                segmentation.representationData[type] =\n                    data;\n            }\n            break;\n        case SegmentationRepresentations.Contour:\n            if (data) {\n                segmentation.representationData[type] = data;\n            }\n            break;\n        case SegmentationRepresentations.Surface:\n            if (data) {\n                segmentation.representationData[type] = data;\n            }\n            break;\n        default:\n            throw new Error(`Invalid representation type ${type}`);\n    }\n}\nexport default internalAddRepresentationData;\n", "function isObject(value) {\n    const type = typeof value;\n    return value !== null && (type === 'object' || type === 'function');\n}\nexport default isObject;\n", "import isObject from './isObject';\nfunction debounce(func, wait, options) {\n    let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;\n    let lastInvokeTime = 0;\n    let leading = false;\n    let maxing = false;\n    let trailing = true;\n    const useRAF = !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';\n    if (typeof func !== 'function') {\n        throw new TypeError('Expected a function');\n    }\n    wait = Number(wait) || 0;\n    if (isObject(options)) {\n        leading = Boolean(options.leading);\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n    }\n    function invokeFunc(time) {\n        const args = lastArgs;\n        const thisArg = lastThis;\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n    }\n    function startTimer(pendingFunc, wait) {\n        if (useRAF) {\n            return window.requestAnimationFrame(pendingFunc);\n        }\n        return setTimeout(pendingFunc, wait);\n    }\n    function cancelTimer(id) {\n        if (useRAF) {\n            return window.cancelAnimationFrame(id);\n        }\n        clearTimeout(id);\n    }\n    function leadingEdge(time) {\n        lastInvokeTime = time;\n        timerId = startTimer(timerExpired, wait);\n        return leading ? invokeFunc(time) : result;\n    }\n    function remainingWait(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n        const timeWaiting = wait - timeSinceLastCall;\n        return maxing\n            ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n            : timeWaiting;\n    }\n    function shouldInvoke(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n        return (lastCallTime === undefined ||\n            timeSinceLastCall >= wait ||\n            timeSinceLastCall < 0 ||\n            (maxing && timeSinceLastInvoke >= maxWait));\n    }\n    function timerExpired() {\n        const time = Date.now();\n        if (shouldInvoke(time)) {\n            return trailingEdge(time);\n        }\n        timerId = startTimer(timerExpired, remainingWait(time));\n    }\n    function trailingEdge(time) {\n        timerId = undefined;\n        if (trailing && lastArgs) {\n            return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n    }\n    function cancel() {\n        if (timerId !== undefined) {\n            cancelTimer(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n    }\n    function flush() {\n        return timerId === undefined ? result : trailingEdge(Date.now());\n    }\n    function pending() {\n        return timerId !== undefined;\n    }\n    function debounced(...args) {\n        const time = Date.now();\n        const isInvoking = shouldInvoke(time);\n        lastArgs = args;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n            if (timerId === undefined) {\n                return leadingEdge(lastCallTime);\n            }\n            if (maxing) {\n                timerId = startTimer(timerExpired, wait);\n                return invokeFunc(lastCallTime);\n            }\n        }\n        if (timerId === undefined) {\n            timerId = startTimer(timerExpired, wait);\n        }\n        return result;\n    }\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    debounced.pending = pending;\n    return debounced;\n}\nexport default debounce;\n", "import { eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport addRepresentationData from '../../stateManagement/segmentation/internalAddRepresentationData';\nimport { triggerSegmentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport debounce from '../debounce';\nconst computedRepresentations = new Map();\nasync function computeAndAddRepresentation(segmentationId, type, computeFunction, updateFunction, onComputationComplete) {\n    const data = await computeFunction();\n    addRepresentationData({\n        segmentationId,\n        type,\n        data,\n    });\n    onComputationComplete?.();\n    if (!computedRepresentations.has(segmentationId)) {\n        computedRepresentations.set(segmentationId, []);\n    }\n    const representations = computedRepresentations.get(segmentationId);\n    if (!representations.includes(type)) {\n        representations.push(type);\n    }\n    subscribeToSegmentationChanges(updateFunction);\n    triggerSegmentationModified(segmentationId);\n    return data;\n}\nfunction subscribeToSegmentationChanges(updateFunction) {\n    const debouncedUpdateFunction = (event) => {\n        _debouncedSegmentationModified(event, updateFunction);\n    };\n    updateFunction._debouncedUpdateFunction = debouncedUpdateFunction;\n    eventTarget.removeEventListener(Events.SEGMENTATION_DATA_MODIFIED, updateFunction._debouncedUpdateFunction);\n    eventTarget.addEventListener(Events.SEGMENTATION_DATA_MODIFIED, updateFunction._debouncedUpdateFunction);\n}\nconst _debouncedSegmentationModified = debounce((event, updateFunction) => {\n    const segmentationId = event.detail.segmentationId;\n    const representations = computedRepresentations.get(segmentationId);\n    if (!representations || !representations.length) {\n        return;\n    }\n    updateFunction(segmentationId);\n    if (representations.length) {\n        triggerSegmentationModified(segmentationId);\n    }\n}, 300);\nexport { computeAndAddRepresentation };\n", "import { getSegmentationRepresentation } from '../getSegmentationRepresentation';\nexport function internalGetHiddenSegmentIndices(viewportId, specifier) {\n    const representation = getSegmentationRepresentation(viewportId, specifier);\n    if (!representation) {\n        return new Set();\n    }\n    const segmentsHidden = Object.entries(representation.segments).reduce((acc, [segmentIndex, segment]) => {\n        if (!segment.visible) {\n            acc.add(Number(segmentIndex));\n        }\n        return acc;\n    }, new Set());\n    return segmentsHidden;\n}\n", "import { cache, getEnabledElementByViewportId, Enums, } from '@cornerstonejs/core';\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport removeSurfaceFromElement from './removeSurfaceFromElement';\nimport addOrUpdateSurfaceToElement from './addOrUpdateSurfaceToElement';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport { getColorLUT } from '../../../stateManagement/segmentation/getColorLUT';\nimport { getPolySeg } from '../../../config';\nimport { computeAndAddRepresentation } from '../../../utilities/segmentation/computeAndAddRepresentation';\nimport { internalGetHiddenSegmentIndices } from '../../../stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices';\nfunction removeRepresentation(viewportId, segmentationId, renderImmediate = false) {\n    const enabledElement = getEnabledElementByViewportId(viewportId);\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    removeSurfaceFromElement(viewport.element, segmentationId);\n    if (!renderImmediate) {\n        return;\n    }\n    viewport.render();\n}\nasync function render(viewport, representation) {\n    const { segmentationId, type } = representation;\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        return;\n    }\n    let SurfaceData = segmentation.representationData[Representations.Surface];\n    if (!SurfaceData &&\n        getPolySeg()?.canComputeRequestedRepresentation(segmentationId, Representations.Surface)) {\n        const polySeg = getPolySeg();\n        SurfaceData = await computeAndAddRepresentation(segmentationId, Representations.Surface, () => polySeg.computeSurfaceData(segmentationId, { viewport }), () => polySeg.updateSurfaceData(segmentationId, { viewport }));\n        if (!SurfaceData) {\n            throw new Error(`No Surface data found for segmentationId ${segmentationId} even we tried to compute it`);\n        }\n    }\n    else if (!SurfaceData && !getPolySeg()) {\n        console.debug(`No surface data found for segmentationId ${segmentationId} and PolySeg add-on is not configured. Unable to convert from other representations to surface. Please register PolySeg using cornerstoneTools.init({ addons: { polySeg } }) to enable automatic conversion.`);\n    }\n    if (!SurfaceData) {\n        console.warn(`No Surface data found for segmentationId ${segmentationId}. Skipping render.`);\n        return;\n    }\n    const { geometryIds } = SurfaceData;\n    if (!geometryIds?.size) {\n        console.warn(`No Surfaces found for segmentationId ${segmentationId}. Skipping render.`);\n    }\n    const { colorLUTIndex } = representation;\n    const colorLUT = getColorLUT(colorLUTIndex);\n    const surfaces = [];\n    geometryIds.forEach((geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        if (!geometry?.data) {\n            console.warn(`No Surfaces found for geometryId ${geometryId}. Skipping render.`);\n            return;\n        }\n        const { segmentIndex } = geometry.data;\n        const hiddenSegments = internalGetHiddenSegmentIndices(viewport.id, {\n            segmentationId,\n            type,\n        });\n        const isHidden = hiddenSegments.has(segmentIndex);\n        const surface = geometry.data;\n        const color = colorLUT[segmentIndex];\n        surface.color = color.slice(0, 3);\n        surface.visible = !isHidden;\n        surfaces.push(surface);\n        addOrUpdateSurfaceToElement(viewport.element, surface, segmentationId);\n    });\n    viewport.render();\n}\nexport default {\n    render,\n    removeRepresentation,\n};\nexport { render, removeRepresentation };\n", "import { utilities, BaseVolumeViewport, StackViewport, cache, metaData, } from '@cornerstonejs/core';\nimport { addAnnotation } from '../stateManagement/annotation/annotationState';\nimport { vec3 } from 'gl-matrix';\nfunction annotationHydration(viewport, toolName, worldPoints, options) {\n    const viewReference = viewport.getViewReference();\n    const { viewPlaneNormal, FrameOfReferenceUID } = viewReference;\n    const annotation = {\n        annotationUID: options?.annotationUID || utilities.uuidv4(),\n        data: {\n            handles: {\n                points: worldPoints,\n            },\n        },\n        highlighted: false,\n        autoGenerated: false,\n        invalidated: false,\n        isLocked: false,\n        isVisible: true,\n        metadata: {\n            toolName,\n            viewPlaneNormal,\n            FrameOfReferenceUID,\n            referencedImageId: getReferencedImageId(viewport, worldPoints[0], viewPlaneNormal),\n            ...options,\n        },\n    };\n    addAnnotation(annotation, viewport.element);\n    return annotation;\n}\nfunction getReferencedImageId(viewport, worldPos, viewPlaneNormal) {\n    let referencedImageId;\n    if (viewport instanceof StackViewport) {\n        referencedImageId = getClosestImageIdForStackViewport(viewport, worldPos, viewPlaneNormal);\n    }\n    else if (viewport instanceof BaseVolumeViewport) {\n        const targetId = getTargetId(viewport);\n        const volumeId = utilities.getVolumeId(targetId);\n        const imageVolume = cache.getVolume(volumeId);\n        referencedImageId = utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n    }\n    else {\n        throw new Error('getReferencedImageId: viewport must be a StackViewport or BaseVolumeViewport');\n    }\n    return referencedImageId;\n}\nfunction getTargetId(viewport) {\n    const targetId = viewport.getViewReferenceId?.();\n    if (targetId) {\n        return targetId;\n    }\n    if (viewport instanceof BaseVolumeViewport) {\n        return `volumeId:${getTargetVolumeId(viewport)}`;\n    }\n    throw new Error('getTargetId: viewport must have a getTargetId method');\n}\nfunction getTargetVolumeId(viewport) {\n    const actorEntries = viewport.getActors();\n    if (!actorEntries) {\n        return;\n    }\n    return actorEntries.find((actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume')?.uid;\n}\nfunction getClosestImageIdForStackViewport(viewport, worldPos, viewPlaneNormal) {\n    const imageIds = viewport.getImageIds();\n    if (!imageIds || !imageIds.length) {\n        return;\n    }\n    const distanceImagePairs = imageIds.map((imageId) => {\n        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\n        const distance = calculateDistanceToImage(worldPos, imagePositionPatient, viewPlaneNormal);\n        return { imageId, distance };\n    });\n    distanceImagePairs.sort((a, b) => a.distance - b.distance);\n    return distanceImagePairs[0].imageId;\n}\nfunction calculateDistanceToImage(worldPos, ImagePositionPatient, viewPlaneNormal) {\n    const dir = vec3.create();\n    vec3.sub(dir, worldPos, ImagePositionPatient);\n    const dot = vec3.dot(dir, viewPlaneNormal);\n    return Math.abs(dot);\n}\nexport { annotationHydration, getClosestImageIdForStackViewport };\n", "import areSameSegment from './areSameSegment';\nimport convertContourSegmentationAnnotation from './convertContourSegmentation';\nimport { copyAnnotation, copyContourSegment } from './copyAnnotation';\nexport * from './logicalOperators';\nexport { default as isContourSegmentationAnnotation } from './isContourSegmentationAnnotation';\nexport { addContourSegmentationAnnotation } from './addContourSegmentationAnnotation';\nexport { removeContourSegmentationAnnotation } from './removeContourSegmentationAnnotation';\nexport { findAllIntersectingContours } from './getIntersectingAnnotations';\nexport { processMultipleIntersections } from './mergeMultipleAnnotations';\nexport { contourSegmentationOperation } from './contourSegmentationOperation';\nexport * from './sharedOperations';\nexport { areSameSegment, convertContourSegmentationAnnotation, copyContourSegment, copyAnnotation, };\nexport * from './polylineUnify';\nexport * from './polylineSubtract';\nexport * from './polylineIntersect';\nexport * from './polylineXor';\n", "export default function areSameSegment(firstAnnotation, secondAnnotation) {\n    const { segmentation: firstSegmentation } = firstAnnotation.data;\n    const { segmentation: secondSegmentation } = secondAnnotation.data;\n    return (firstSegmentation.segmentationId === secondSegmentation.segmentationId &&\n        firstSegmentation.segmentIndex === secondSegmentation.segmentIndex);\n}\n", "import { Enums, eventTarget, getEnabledElement, utilities, } from '@cornerstonejs/core';\nclass FrameOfReferenceSpecificAnnotationManager {\n    constructor(uid) {\n        this.getGroupKey = (annotationGroupSelector) => {\n            if (typeof annotationGroupSelector === 'string') {\n                return annotationGroupSelector;\n            }\n            const element = annotationGroupSelector;\n            const enabledElement = getEnabledElement(element);\n            if (!enabledElement) {\n                throw new Error('Element not enabled, you must have an enabled element if you are not providing a FrameOfReferenceUID');\n            }\n            return enabledElement.FrameOfReferenceUID;\n        };\n        this._imageVolumeModifiedHandler = (evt) => {\n            const eventDetail = evt.detail;\n            const { FrameOfReferenceUID } = eventDetail;\n            const annotations = this.annotations;\n            const frameOfReferenceSpecificAnnotations = annotations[FrameOfReferenceUID];\n            if (!frameOfReferenceSpecificAnnotations) {\n                return;\n            }\n            Object.keys(frameOfReferenceSpecificAnnotations).forEach((toolName) => {\n                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n                toolSpecificAnnotations.forEach((annotation) => {\n                    const invalidated = annotation.invalidated;\n                    if (invalidated !== undefined) {\n                        annotation.invalidated = true;\n                    }\n                });\n            });\n        };\n        this.getFramesOfReference = () => {\n            return Object.keys(this.annotations);\n        };\n        this.getAnnotations = (groupKey, toolName) => {\n            const annotations = this.annotations;\n            if (!annotations[groupKey]) {\n                return [];\n            }\n            if (toolName) {\n                return annotations[groupKey][toolName]\n                    ? annotations[groupKey][toolName]\n                    : [];\n            }\n            return annotations[groupKey];\n        };\n        this.getAnnotation = (annotationUID) => {\n            const annotations = this.annotations;\n            for (const frameOfReferenceUID in annotations) {\n                const frameOfReferenceAnnotations = annotations[frameOfReferenceUID];\n                for (const toolName in frameOfReferenceAnnotations) {\n                    const toolSpecificAnnotations = frameOfReferenceAnnotations[toolName];\n                    for (const annotation of toolSpecificAnnotations) {\n                        if (annotationUID === annotation.annotationUID) {\n                            return annotation;\n                        }\n                    }\n                }\n            }\n        };\n        this.getNumberOfAnnotations = (groupKey, toolName) => {\n            const annotations = this.getAnnotations(groupKey, toolName);\n            if (!annotations.length) {\n                return 0;\n            }\n            if (toolName) {\n                return annotations.length;\n            }\n            let total = 0;\n            for (const toolName in annotations) {\n                total += annotations[toolName].length;\n            }\n            return total;\n        };\n        this.addAnnotation = (annotation, groupKey) => {\n            const { metadata } = annotation;\n            const { FrameOfReferenceUID, toolName } = metadata;\n            groupKey = groupKey || FrameOfReferenceUID;\n            const annotations = this.annotations;\n            let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n            if (!frameOfReferenceSpecificAnnotations) {\n                annotations[groupKey] = {};\n                frameOfReferenceSpecificAnnotations = annotations[groupKey];\n            }\n            let toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n            if (!toolSpecificAnnotations) {\n                frameOfReferenceSpecificAnnotations[toolName] = [];\n                toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n            }\n            if (this.preprocessingFn) {\n                annotation = this.preprocessingFn(annotation);\n            }\n            toolSpecificAnnotations.push(annotation);\n        };\n        this.removeAnnotation = (annotationUID) => {\n            const { annotations } = this;\n            for (const groupKey in annotations) {\n                const groupAnnotations = annotations[groupKey];\n                for (const toolName in groupAnnotations) {\n                    const toolAnnotations = groupAnnotations[toolName];\n                    const index = toolAnnotations.findIndex((annotation) => annotation.annotationUID === annotationUID);\n                    if (index !== -1) {\n                        toolAnnotations.splice(index, 1);\n                        if (toolAnnotations.length === 0) {\n                            delete groupAnnotations[toolName];\n                        }\n                    }\n                }\n                if (Object.keys(groupAnnotations).length === 0) {\n                    delete annotations[groupKey];\n                }\n            }\n        };\n        this.removeAnnotations = (groupKey, toolName) => {\n            const annotations = this.annotations;\n            const removedAnnotations = [];\n            if (!annotations[groupKey]) {\n                return removedAnnotations;\n            }\n            if (toolName) {\n                const annotationsForTool = annotations[groupKey][toolName];\n                if (annotationsForTool) {\n                    for (const annotation of annotationsForTool) {\n                        this.removeAnnotation(annotation.annotationUID);\n                        removedAnnotations.push(annotation);\n                    }\n                }\n            }\n            else {\n                for (const toolName in annotations[groupKey]) {\n                    const annotationsForTool = annotations[groupKey][toolName];\n                    for (const annotation of annotationsForTool) {\n                        this.removeAnnotation(annotation.annotationUID);\n                        removedAnnotations.push(annotation);\n                    }\n                }\n            }\n            return removedAnnotations;\n        };\n        this.saveAnnotations = (groupKey, toolName) => {\n            const annotations = this.annotations;\n            if (groupKey && toolName) {\n                const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                if (!frameOfReferenceSpecificAnnotations) {\n                    return;\n                }\n                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n                return structuredClone(toolSpecificAnnotations);\n            }\n            else if (groupKey) {\n                const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                return structuredClone(frameOfReferenceSpecificAnnotations);\n            }\n            return structuredClone(annotations);\n        };\n        this.restoreAnnotations = (state, groupKey, toolName) => {\n            const annotations = this.annotations;\n            if (groupKey && toolName) {\n                let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                if (!frameOfReferenceSpecificAnnotations) {\n                    annotations[groupKey] = {};\n                    frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                }\n                frameOfReferenceSpecificAnnotations[toolName] = state;\n            }\n            else if (groupKey) {\n                annotations[groupKey] = state;\n            }\n            else {\n                this.annotations = structuredClone(state);\n            }\n        };\n        this.getAllAnnotations = () => {\n            return Object.values(this.annotations)\n                .map((frameOfReferenceSpecificAnnotations) => Object.values(frameOfReferenceSpecificAnnotations))\n                .flat(2);\n        };\n        this.getNumberOfAllAnnotations = () => {\n            let count = 0;\n            const annotations = this.annotations;\n            for (const groupKey in annotations) {\n                const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                for (const toolName in frameOfReferenceSpecificAnnotations) {\n                    const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n                    count += toolSpecificAnnotations.length;\n                }\n            }\n            return count;\n        };\n        this.removeAllAnnotations = () => {\n            const removedAnnotations = [];\n            for (const annotation of this.getAllAnnotations()) {\n                this.removeAnnotation(annotation.annotationUID);\n                removedAnnotations.push(annotation);\n            }\n            return removedAnnotations;\n        };\n        if (!uid) {\n            uid = utilities.uuidv4();\n        }\n        this.annotations = {};\n        this.uid = uid;\n        eventTarget.addEventListener(Enums.Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedHandler);\n    }\n    setPreprocessingFn(preprocessingFn) {\n        this.preprocessingFn = preprocessingFn;\n    }\n}\nconst defaultFrameOfReferenceSpecificAnnotationManager = new FrameOfReferenceSpecificAnnotationManager('DEFAULT');\nexport { defaultFrameOfReferenceSpecificAnnotationManager };\nexport default FrameOfReferenceSpecificAnnotationManager;\n", "import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { getAnnotation } from './annotationState';\nconst globalLockedAnnotationUIDsSet = new Set();\nfunction setAnnotationLocked(annotationUID, locked = true) {\n    const detail = makeEventDetail();\n    if (annotationUID) {\n        if (locked) {\n            lock(annotationUID, globalLockedAnnotationUIDsSet, detail);\n        }\n        else {\n            unlock(annotationUID, globalLockedAnnotationUIDsSet, detail);\n        }\n    }\n    publish(detail, globalLockedAnnotationUIDsSet);\n}\nfunction unlockAllAnnotations() {\n    const detail = makeEventDetail();\n    clearLockedAnnotationsSet(globalLockedAnnotationUIDsSet, detail);\n    publish(detail, globalLockedAnnotationUIDsSet);\n}\nfunction getAnnotationsLocked() {\n    return Array.from(globalLockedAnnotationUIDsSet);\n}\nfunction isAnnotationLocked(annotationUID) {\n    return globalLockedAnnotationUIDsSet.has(annotationUID);\n}\nfunction getAnnotationsLockedCount() {\n    return globalLockedAnnotationUIDsSet.size;\n}\nfunction checkAndSetAnnotationLocked(annotationUID) {\n    const isLocked = isAnnotationLocked(annotationUID);\n    setAnnotationLocked(annotationUID, isLocked);\n    return isLocked;\n}\nfunction makeEventDetail() {\n    return Object.freeze({\n        added: [],\n        removed: [],\n        locked: [],\n    });\n}\nfunction lock(annotationUID, lockedAnnotationUIDsSet, detail) {\n    if (!lockedAnnotationUIDsSet.has(annotationUID)) {\n        lockedAnnotationUIDsSet.add(annotationUID);\n        detail.added.push(annotationUID);\n        const annotation = getAnnotation(annotationUID);\n        if (annotation) {\n            annotation.isLocked = true;\n        }\n    }\n}\nfunction unlock(annotationUID, lockedAnnotationUIDsSet, detail) {\n    if (lockedAnnotationUIDsSet.delete(annotationUID)) {\n        detail.removed.push(annotationUID);\n        const annotation = getAnnotation(annotationUID);\n        if (annotation) {\n            annotation.isLocked = false;\n        }\n    }\n}\nfunction clearLockedAnnotationsSet(lockedAnnotationUIDsSet, detail) {\n    lockedAnnotationUIDsSet.forEach((annotationUID) => {\n        unlock(annotationUID, lockedAnnotationUIDsSet, detail);\n    });\n}\nfunction publish(detail, lockedAnnotationUIDsSet) {\n    if (detail.added.length > 0 || detail.removed.length > 0) {\n        lockedAnnotationUIDsSet.forEach((item) => void detail.locked.push(item));\n        triggerEvent(eventTarget, Events.ANNOTATION_LOCK_CHANGE, detail);\n    }\n}\nexport { setAnnotationLocked, getAnnotationsLocked, getAnnotationsLockedCount, unlockAllAnnotations, isAnnotationLocked, checkAndSetAnnotationLocked, };\n", "import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { getAnnotation } from './annotationState';\nconst selectedAnnotationUIDs = new Set();\nfunction setAnnotationSelected(annotationUID, selected = true, preserveSelected = false) {\n    if (selected) {\n        selectAnnotation(annotationUID, preserveSelected);\n    }\n    else {\n        deselectAnnotation(annotationUID);\n    }\n}\nfunction selectAnnotation(annotationUID, preserveSelected = false) {\n    const detail = makeEventDetail();\n    if (!preserveSelected) {\n        clearSelectionSet(selectedAnnotationUIDs, detail);\n        const annotation = getAnnotation(annotationUID);\n        if (annotation) {\n            annotation.isSelected = true;\n        }\n    }\n    if (annotationUID && !selectedAnnotationUIDs.has(annotationUID)) {\n        selectedAnnotationUIDs.add(annotationUID);\n        detail.added.push(annotationUID);\n        const annotation = getAnnotation(annotationUID);\n        if (annotation) {\n            annotation.isSelected = true;\n        }\n    }\n    publish(detail, selectedAnnotationUIDs);\n}\nfunction deselectAnnotation(annotationUID) {\n    const detail = makeEventDetail();\n    if (annotationUID) {\n        if (selectedAnnotationUIDs.delete(annotationUID)) {\n            detail.removed.push(annotationUID);\n            const annotation = getAnnotation(annotationUID);\n            annotation.isSelected = false;\n        }\n    }\n    else {\n        clearSelectionSet(selectedAnnotationUIDs, detail);\n    }\n    publish(detail, selectedAnnotationUIDs);\n}\nfunction getAnnotationsSelected() {\n    return Array.from(selectedAnnotationUIDs);\n}\nfunction getAnnotationsSelectedByToolName(toolName) {\n    return getAnnotationsSelected().filter((annotationUID) => {\n        const annotation = getAnnotation(annotationUID);\n        return annotation?.metadata?.toolName === toolName;\n    });\n}\nfunction isAnnotationSelected(annotationUID) {\n    return selectedAnnotationUIDs.has(annotationUID);\n}\nfunction getAnnotationsSelectedCount() {\n    return selectedAnnotationUIDs.size;\n}\nfunction makeEventDetail() {\n    return Object.freeze({\n        added: [],\n        removed: [],\n        selection: [],\n    });\n}\nfunction clearSelectionSet(selectionSet, detail) {\n    selectionSet.forEach((value) => {\n        if (selectionSet.delete(value)) {\n            detail.removed.push(value);\n            const annotation = getAnnotation(value);\n            if (annotation) {\n                annotation.isSelected = false;\n            }\n        }\n    });\n}\nfunction publish(detail, selectionSet) {\n    if (detail.added.length > 0 || detail.removed.length > 0) {\n        selectionSet.forEach((item) => void detail.selection.push(item));\n        triggerEvent(eventTarget, Events.ANNOTATION_SELECTION_CHANGE, detail);\n    }\n}\nexport { setAnnotationSelected, getAnnotationsSelected, getAnnotationsSelectedByToolName, getAnnotationsSelectedCount, deselectAnnotation, isAnnotationSelected, };\n", "const checkAndDefineTextBoxProperty = (annotation) => {\n    if (!annotation.data) {\n        annotation.data = {};\n    }\n    if (!annotation.data.handles) {\n        annotation.data.handles = {};\n    }\n    if (!annotation.data.handles.textBox) {\n        annotation.data.handles.textBox = {};\n    }\n    return annotation;\n};\nconst checkAndDefineCachedStatsProperty = (annotation) => {\n    if (!annotation.data) {\n        annotation.data = {};\n    }\n    if (!annotation.data.cachedStats) {\n        annotation.data.cachedStats = {};\n    }\n    return annotation;\n};\nexport { checkAndDefineTextBoxProperty, checkAndDefineCachedStatsProperty };\n", "import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { isAnnotationSelected, deselectAnnotation, } from './annotationSelection';\nimport { getAnnotation } from './annotationState';\nconst globalHiddenAnnotationUIDsSet = new Set();\nfunction setAnnotationVisibility(annotationUID, visible = true) {\n    const detail = makeEventDetail();\n    if (annotationUID) {\n        if (visible) {\n            show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n        }\n        else {\n            hide(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n        }\n    }\n    publish(detail);\n}\nfunction showAllAnnotations() {\n    const detail = makeEventDetail();\n    globalHiddenAnnotationUIDsSet.forEach((annotationUID) => {\n        show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n    });\n    publish(detail);\n}\nfunction isAnnotationVisible(annotationUID) {\n    const annotation = getAnnotation(annotationUID);\n    if (annotation) {\n        return !globalHiddenAnnotationUIDsSet.has(annotationUID);\n    }\n}\nfunction makeEventDetail() {\n    return Object.freeze({\n        lastVisible: [],\n        lastHidden: [],\n        hidden: [],\n    });\n}\nfunction show(annotationUID, annotationUIDsSet, detail) {\n    if (annotationUIDsSet.delete(annotationUID)) {\n        detail.lastVisible.push(annotationUID);\n        const annotation = getAnnotation(annotationUID);\n        annotation.isVisible = true;\n    }\n}\nfunction hide(annotationUID, annotationUIDsSet, detail) {\n    if (!annotationUIDsSet.has(annotationUID)) {\n        annotationUIDsSet.add(annotationUID);\n        if (isAnnotationSelected(annotationUID)) {\n            deselectAnnotation(annotationUID);\n        }\n        detail.lastHidden.push(annotationUID);\n        const annotation = getAnnotation(annotationUID);\n        annotation.isVisible = false;\n    }\n}\nfunction publish(detail) {\n    if (detail.lastHidden.length > 0 || detail.lastVisible.length > 0) {\n        globalHiddenAnnotationUIDsSet.forEach((item) => void detail.hidden.push(item));\n        triggerEvent(eventTarget, Events.ANNOTATION_VISIBILITY_CHANGE, detail);\n    }\n}\nfunction checkAndSetAnnotationVisibility(annotationUID) {\n    const isVisible = !globalHiddenAnnotationUIDsSet.has(annotationUID);\n    setAnnotationVisibility(annotationUID, isVisible);\n    return isVisible;\n}\nexport { setAnnotationVisibility, showAllAnnotations, isAnnotationVisible, checkAndSetAnnotationVisibility, };\n", "import { checkAndDefineCachedStatsProperty, checkAndDefineTextBoxProperty, } from './utilities/defineProperties';\nimport { checkAndSetAnnotationLocked } from './annotationLocking';\nimport { checkAndSetAnnotationVisibility } from './annotationVisibility';\nimport { defaultFrameOfReferenceSpecificAnnotationManager } from './FrameOfReferenceSpecificAnnotationManager';\nimport { setAnnotationManager } from './annotationState';\nconst defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\nconst preprocessingFn = (annotation) => {\n    annotation = checkAndDefineTextBoxProperty(annotation);\n    annotation = checkAndDefineCachedStatsProperty(annotation);\n    const uid = annotation.annotationUID;\n    const isLocked = checkAndSetAnnotationLocked(uid);\n    annotation.isLocked = isLocked;\n    const isVisible = checkAndSetAnnotationVisibility(uid);\n    annotation.isVisible = isVisible;\n    return annotation;\n};\ndefaultManager.setPreprocessingFn(preprocessingFn);\nsetAnnotationManager(defaultManager);\nexport function resetAnnotationManager() {\n    setAnnotationManager(defaultManager);\n}\n", "import { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nexport function removeContourSegmentationAnnotation(annotation) {\n    if (!annotation.data.segmentation) {\n        throw new Error('removeContourSegmentationAnnotation: annotation does not have a segmentation data');\n    }\n    const { segmentationId, segmentIndex } = annotation.data.segmentation;\n    const segmentation = getSegmentation(segmentationId);\n    const { annotationUIDsMap } = segmentation?.representationData.Contour || {};\n    const annotationsUIDsSet = annotationUIDsMap?.get(segmentIndex);\n    if (!annotationsUIDsSet) {\n        return;\n    }\n    annotationsUIDsSet.delete(annotation.annotationUID);\n    if (!annotationsUIDsSet.size) {\n        annotationUIDsMap.delete(segmentIndex);\n    }\n}\n", "import { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nexport function addContourSegmentationAnnotation(annotation) {\n    if (annotation.parentAnnotationUID) {\n        return;\n    }\n    if (!annotation.data.segmentation) {\n        throw new Error('addContourSegmentationAnnotation: annotation does not have a segmentation data');\n    }\n    const { segmentationId, segmentIndex } = annotation.data.segmentation;\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation.representationData.Contour) {\n        segmentation.representationData.Contour = { annotationUIDsMap: new Map() };\n    }\n    let { annotationUIDsMap } = segmentation.representationData.Contour;\n    if (!annotationUIDsMap) {\n        annotationUIDsMap = new Map();\n    }\n    let annotationsUIDsSet = annotationUIDsMap?.get(segmentIndex);\n    if (!annotationsUIDsSet) {\n        annotationsUIDsSet = new Set();\n        annotationUIDsMap.set(segmentIndex, annotationsUIDsSet);\n    }\n    annotationUIDsMap.set(segmentIndex, annotationsUIDsSet.add(annotation.annotationUID));\n}\n", "import { utilities } from '@cornerstonejs/core';\nimport { addAnnotation, removeAnnotation } from '../../stateManagement';\nimport { removeContourSegmentationAnnotation } from './removeContourSegmentationAnnotation';\nimport { addContourSegmentationAnnotation } from './addContourSegmentationAnnotation';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nconst DEFAULT_CONTOUR_SEG_TOOL_NAME = 'PlanarFreehandContourSegmentationTool';\nexport default function convertContourSegmentationAnnotation(annotation) {\n    const { polyline } = annotation.data?.contour || {};\n    if (!polyline || polyline.length < 3) {\n        console.warn('Skipping creation of new annotation due to invalid polyline:', polyline);\n        return;\n    }\n    removeAnnotation(annotation.annotationUID);\n    removeContourSegmentationAnnotation(annotation);\n    const startPointWorld = polyline[0];\n    const endPointWorld = polyline[polyline.length - 1];\n    const newAnnotation = {\n        metadata: {\n            ...annotation.metadata,\n            toolName: DEFAULT_CONTOUR_SEG_TOOL_NAME,\n            originalToolName: annotation.metadata.originalToolName || annotation.metadata.toolName,\n        },\n        data: {\n            cachedStats: {},\n            handles: {\n                points: [startPointWorld, endPointWorld],\n                textBox: annotation.data.handles.textBox\n                    ? { ...annotation.data.handles.textBox }\n                    : undefined,\n            },\n            contour: {\n                ...annotation.data.contour,\n            },\n            spline: annotation.data.spline,\n            segmentation: {\n                ...annotation.data.segmentation,\n            },\n        },\n        annotationUID: utilities.uuidv4(),\n        highlighted: true,\n        invalidated: true,\n        isLocked: false,\n        isVisible: undefined,\n        interpolationUID: annotation.interpolationUID,\n        interpolationCompleted: annotation.interpolationCompleted,\n    };\n    addAnnotation(newAnnotation, annotation.metadata.FrameOfReferenceUID);\n    addContourSegmentationAnnotation(newAnnotation);\n    triggerAnnotationModified(newAnnotation);\n    return newAnnotation;\n}\n", "import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getViewportIdsWithSegmentation(segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const state = segmentationStateManager.getState();\n    const viewportSegRepresentations = state.viewportSegRepresentations;\n    const viewportIdsWithSegmentation = Object.entries(viewportSegRepresentations)\n        .filter(([, viewportSegmentations]) => viewportSegmentations.some((segRep) => segRep.segmentationId === segmentationId))\n        .map(([viewportId]) => viewportId);\n    return viewportIdsWithSegmentation;\n}\n", "import { vec3 } from 'gl-matrix';\nimport { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport { getViewportIdsWithSegmentation } from '../getViewportIdsWithSegmentation';\nexport function getViewportsAssociatedToSegmentation(segmentationId) {\n    const viewportIds = getViewportIdsWithSegmentation(segmentationId);\n    if (viewportIds?.length === 0) {\n        return [];\n    }\n    const viewports = [];\n    for (const viewportId of viewportIds) {\n        const { viewport } = getEnabledElementByViewportId(viewportId) || {};\n        if (viewport) {\n            viewports.push(viewport);\n        }\n    }\n    return viewports;\n}\nexport function getViewportAssociatedToSegmentation(segmentationId) {\n    const viewports = getViewportsAssociatedToSegmentation(segmentationId);\n    return viewports.length > 0 ? viewports[0] : undefined;\n}\nexport function getViewportWithMatchingViewPlaneNormal(viewports, annotation, dotThreshold = 0.99) {\n    const annotationViewPlaneNormal = annotation.metadata?.viewPlaneNormal;\n    if (!annotationViewPlaneNormal || !Array.isArray(annotationViewPlaneNormal)) {\n        return undefined;\n    }\n    const normalizedAnnotationNormal = vec3.create();\n    vec3.normalize(normalizedAnnotationNormal, annotationViewPlaneNormal);\n    for (const viewport of viewports) {\n        const camera = viewport.getCamera();\n        if (!camera?.viewPlaneNormal) {\n            continue;\n        }\n        const normalizedCameraNormal = vec3.create();\n        vec3.normalize(normalizedCameraNormal, camera.viewPlaneNormal);\n        const dotProduct = vec3.dot(normalizedAnnotationNormal, normalizedCameraNormal);\n        if (Math.abs(dotProduct) >= dotThreshold) {\n            return viewport;\n        }\n    }\n    return undefined;\n}\n", "import { getSegmentation } from '../getSegmentation';\nexport function getAnnotationsUIDMapFromSegmentation(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        return;\n    }\n    const contourRepresentationData = segmentation.representationData\n        ?.Contour;\n    if (!contourRepresentationData) {\n        return;\n    }\n    const { annotationUIDsMap } = contourRepresentationData;\n    if (!annotationUIDsMap) {\n        return;\n    }\n    return annotationUIDsMap;\n}\n", "import { utilities } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotation } from '../../stateManagement';\nimport { getViewportAssociatedToSegmentation } from '../../stateManagement/segmentation/utilities/getViewportAssociatedToSegmentation';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nimport { getAnnotationsUIDMapFromSegmentation } from '../../stateManagement/segmentation/utilities/getAnnotationsUIDMapFromSegmentation';\nexport function copyAnnotation(annotation, segmentationId, segmentIndex) {\n    const newAnnotation = {\n        annotationUID: utilities.uuidv4(),\n        data: {\n            contour: {\n                closed: true,\n                polyline: [],\n            },\n            segmentation: {\n                segmentationId,\n                segmentIndex,\n            },\n            handles: {},\n        },\n        handles: {},\n        highlighted: false,\n        autoGenerated: false,\n        invalidated: false,\n        isLocked: false,\n        isVisible: true,\n        metadata: {\n            ...annotation.metadata,\n            toolName: annotation.metadata.toolName,\n        },\n    };\n    newAnnotation.data.segmentation.segmentationId = segmentationId;\n    newAnnotation.data.segmentation.segmentIndex = segmentIndex;\n    if (annotation.data.contour?.polyline) {\n        newAnnotation.data.contour.polyline = [...annotation.data.contour.polyline];\n    }\n    if (annotation.data.handles?.points) {\n        newAnnotation.data.handles.points = annotation.data.handles.points.map((point) => [...point]);\n    }\n    return newAnnotation;\n}\nexport function copyContourSegment(segmentationId, segmentIndex, targetSegmentationId, targetSegmentIndex) {\n    const annotationUIDsMap = getAnnotationsUIDMapFromSegmentation(segmentationId);\n    const targetAnnotationUIDsMap = getAnnotationsUIDMapFromSegmentation(targetSegmentationId);\n    if (!annotationUIDsMap || !targetAnnotationUIDsMap) {\n        return;\n    }\n    if (!annotationUIDsMap?.has(segmentIndex)) {\n        return;\n    }\n    const annotationUIDs = annotationUIDsMap.get(segmentIndex);\n    const viewport = getViewportAssociatedToSegmentation(targetSegmentationId);\n    if (!viewport) {\n        return;\n    }\n    const toolGroup = getToolGroupForViewport(viewport.id);\n    const copyContourAnnotation = (annotation) => {\n        const newAnnotation = copyAnnotation(annotation, targetSegmentationId, targetSegmentIndex);\n        if (toolGroup) {\n            const instance = toolGroup.getToolInstance(annotation.metadata.toolName);\n            if (instance) {\n                if (typeof instance.isSplineAnnotation === 'function' &&\n                    instance.isSplineAnnotation(annotation)) {\n                    instance.createSplineObjectFromType(newAnnotation, annotation.data.spline.type);\n                }\n            }\n        }\n        addAnnotation(newAnnotation, viewport.element);\n        newAnnotationsUID.add(newAnnotation.annotationUID);\n        return newAnnotation;\n    };\n    const newAnnotationsUID = new Set();\n    for (const annotationUID of annotationUIDs) {\n        const annotation = getAnnotation(annotationUID);\n        const newAnnotation = copyContourAnnotation(annotation);\n        if (annotation?.childAnnotationUIDs) {\n            newAnnotation.childAnnotationUIDs = [];\n            for (const childAnnotationUID of annotation.childAnnotationUIDs) {\n                const childAnnotation = getAnnotation(childAnnotationUID);\n                const newChildAnnotation = copyContourAnnotation(childAnnotation);\n                newChildAnnotation.parentAnnotationUID = newAnnotation.annotationUID;\n                newAnnotation.childAnnotationUIDs.push(newChildAnnotation.annotationUID);\n            }\n        }\n    }\n    targetAnnotationUIDsMap.set(targetSegmentIndex, newAnnotationsUID);\n}\n", "export var ContourWindingDirection;\n(function (ContourWindingDirection) {\n    ContourWindingDirection[ContourWindingDirection[\"CounterClockwise\"] = -1] = \"CounterClockwise\";\n    ContourWindingDirection[ContourWindingDirection[\"Unknown\"] = 0] = \"Unknown\";\n    ContourWindingDirection[ContourWindingDirection[\"Clockwise\"] = 1] = \"Clockwise\";\n})(ContourWindingDirection || (ContourWindingDirection = {}));\n", "import * as aabb from './aabb';\nimport * as BasicStatsCalculator from './basic';\nimport * as circle from './circle';\nimport * as ellipse from './ellipse';\nimport * as lineSegment from './line';\nimport * as point from './point';\nimport * as polyline from './polyline';\nimport * as rectangle from './rectangle';\nimport * as vec2 from './vec2';\nimport * as angle from './angle';\nexport { aabb, BasicStatsCalculator, circle, ellipse, lineSegment, point, polyline, rectangle, vec2, angle, };\n", "export { default as intersectAABB } from './intersectAABB';\nexport { default as distanceToPoint } from './distanceToPoint';\nexport { default as distanceToPointSquared } from './distanceToPointSquared';\n", "export default function intersectAABB(aabb1, aabb2) {\n    return (aabb1.minX <= aabb2.maxX &&\n        aabb1.maxX >= aabb2.minX &&\n        aabb1.minY <= aabb2.maxY &&\n        aabb1.maxY >= aabb2.minY);\n}\n", "export default function distanceToPointSquared(aabb, point) {\n    const aabbWidth = aabb.maxX - aabb.minX;\n    const aabbHeight = aabb.maxY - aabb.minY;\n    const aabbSize = [aabbWidth, aabbHeight];\n    const aabbCenter = [\n        aabb.minX + aabbWidth / 2,\n        aabb.minY + aabbHeight / 2,\n    ];\n    const translatedPoint = [\n        Math.abs(point[0] - aabbCenter[0]),\n        Math.abs(point[1] - aabbCenter[1]),\n    ];\n    const dx = translatedPoint[0] - aabbSize[0] * 0.5;\n    const dy = translatedPoint[1] - aabbSize[1] * 0.5;\n    if (dx > 0 && dy > 0) {\n        return dx * dx + dy * dy;\n    }\n    const dist = Math.max(dx, 0) + Math.max(dy, 0);\n    return dist * dist;\n}\n", "import distanceToPointSquared from './distanceToPointSquared';\nexport default function distanceToPoint(aabb, point) {\n    return Math.sqrt(distanceToPointSquared(aabb, point));\n}\n", "import { BasicStatsCalculator, InstanceBasicStatsCalculator, } from './BasicStatsCalculator';\nimport { Calculator, InstanceCalculator } from './Calculator';\nexport { BasicStatsCalculator, InstanceBasicStatsCalculator, Calculator, InstanceCalculator, };\n", "export class Calculator {\n}\nexport class InstanceCalculator {\n    constructor(options) {\n        this.storePointData = options.storePointData;\n    }\n    getStatistics() {\n        console.debug('InstanceCalculator getStatistics called');\n    }\n}\n", "import { utilities } from '@cornerstonejs/core';\nimport { Calculator, InstanceCalculator } from './Calculator';\nconst { PointsManager } = utilities;\nfunction createBasicStatsState(storePointData) {\n    return {\n        max: [-Infinity],\n        min: [Infinity],\n        sum: [0],\n        count: 0,\n        maxIJK: null,\n        maxLPS: null,\n        minIJK: null,\n        minLPS: null,\n        runMean: [0],\n        m2: [0],\n        m3: [0],\n        m4: [0],\n        allValues: [[]],\n        pointsInShape: storePointData ? PointsManager.create3(1024) : null,\n        sumLPS: [0, 0, 0],\n    };\n}\nfunction basicStatsCallback(state, newValue, pointLPS = null, pointIJK = null) {\n    if (Array.isArray(newValue) &&\n        newValue.length > 1 &&\n        state.max.length === 1) {\n        state.max.push(state.max[0], state.max[0]);\n        state.min.push(state.min[0], state.min[0]);\n        state.sum.push(state.sum[0], state.sum[0]);\n        state.runMean.push(0, 0);\n        state.m2.push(state.m2[0], state.m2[0]);\n        state.m3.push(state.m3[0], state.m3[0]);\n        state.m4.push(state.m4[0], state.m4[0]);\n        state.allValues.push([], []);\n    }\n    if (state?.pointsInShape && pointLPS) {\n        state.pointsInShape.push(pointLPS);\n    }\n    const newArray = Array.isArray(newValue) ? newValue : [newValue];\n    state.count += 1;\n    if (pointLPS) {\n        state.sumLPS[0] += pointLPS[0];\n        state.sumLPS[1] += pointLPS[1];\n        state.sumLPS[2] += pointLPS[2];\n    }\n    state.max.forEach((it, idx) => {\n        const value = newArray[idx];\n        state.allValues[idx].push(value);\n        const n = state.count;\n        const delta = value - state.runMean[idx];\n        const delta_n = delta / n;\n        const term1 = delta * delta_n * (n - 1);\n        state.sum[idx] += value;\n        state.runMean[idx] += delta_n;\n        state.m4[idx] +=\n            term1 * delta_n * delta_n * (n * n - 3 * n + 3) +\n                6 * delta_n * delta_n * state.m2[idx] -\n                4 * delta_n * state.m3[idx];\n        state.m3[idx] += term1 * delta_n * (n - 2) - 3 * delta_n * state.m2[idx];\n        state.m2[idx] += term1;\n        if (value < state.min[idx]) {\n            state.min[idx] = value;\n            if (idx === 0) {\n                state.minIJK = pointIJK ? [...pointIJK] : null;\n                state.minLPS = pointLPS ? [...pointLPS] : null;\n            }\n        }\n        if (value > state.max[idx]) {\n            state.max[idx] = value;\n            if (idx === 0) {\n                state.maxIJK = pointIJK ? [...pointIJK] : null;\n                state.maxLPS = pointLPS ? [...pointLPS] : null;\n            }\n        }\n    });\n}\nfunction calculateMedian(values) {\n    if (values.length === 0) {\n        return 0;\n    }\n    const sorted = [...values].sort((a, b) => a - b);\n    const mid = Math.floor(sorted.length / 2);\n    if (sorted.length % 2 === 0) {\n        return (sorted[mid - 1] + sorted[mid]) / 2;\n    }\n    else {\n        return sorted[mid];\n    }\n}\nfunction basicGetStatistics(state, unit) {\n    const mean = state.sum.map((sum) => sum / state.count);\n    const stdDev = state.m2.map((squaredDiffSum) => Math.sqrt(squaredDiffSum / state.count));\n    const center = state.sumLPS.map((sum) => sum / state.count);\n    const skewness = state.m3.map((m3, idx) => {\n        const variance = state.m2[idx] / state.count;\n        if (variance === 0) {\n            return 0;\n        }\n        return m3 / (state.count * Math.pow(variance, 1.5));\n    });\n    const kurtosis = state.m4.map((m4, idx) => {\n        const variance = state.m2[idx] / state.count;\n        if (variance === 0) {\n            return 0;\n        }\n        return m4 / (state.count * variance * variance) - 3;\n    });\n    const median = state.allValues.map((values) => calculateMedian(values));\n    const named = {\n        max: {\n            name: 'max',\n            label: 'Max Pixel',\n            value: state.max.length === 1 ? state.max[0] : state.max,\n            unit,\n            pointIJK: state.maxIJK ? [...state.maxIJK] : null,\n            pointLPS: state.maxLPS ? [...state.maxLPS] : null,\n        },\n        min: {\n            name: 'min',\n            label: 'Min Pixel',\n            value: state.min.length === 1 ? state.min[0] : state.min,\n            unit,\n            pointIJK: state.minIJK ? [...state.minIJK] : null,\n            pointLPS: state.minLPS ? [...state.minLPS] : null,\n        },\n        mean: {\n            name: 'mean',\n            label: 'Mean Pixel',\n            value: mean.length === 1 ? mean[0] : mean,\n            unit,\n        },\n        stdDev: {\n            name: 'stdDev',\n            label: 'Standard Deviation',\n            value: stdDev.length === 1 ? stdDev[0] : stdDev,\n            unit,\n        },\n        count: {\n            name: 'count',\n            label: 'Voxel Count',\n            value: state.count,\n            unit: null,\n        },\n        median: {\n            name: 'median',\n            label: 'Median',\n            value: median.length === 1 ? median[0] : median,\n            unit,\n        },\n        skewness: {\n            name: 'skewness',\n            label: 'Skewness',\n            value: skewness.length === 1 ? skewness[0] : skewness,\n            unit: null,\n        },\n        kurtosis: {\n            name: 'kurtosis',\n            label: 'Kurtosis',\n            value: kurtosis.length === 1 ? kurtosis[0] : kurtosis,\n            unit: null,\n        },\n        maxLPS: {\n            name: 'maxLPS',\n            label: 'Max LPS',\n            value: state.maxLPS ? Array.from(state.maxLPS) : null,\n            unit: null,\n        },\n        minLPS: {\n            name: 'minLPS',\n            label: 'Min LPS',\n            value: state.minLPS ? Array.from(state.minLPS) : null,\n            unit: null,\n        },\n        pointsInShape: state.pointsInShape,\n        center: {\n            name: 'center',\n            label: 'Center',\n            value: center ? [...center] : null,\n            unit: null,\n        },\n        array: [],\n    };\n    named.array.push(named.min, named.max, named.mean, named.stdDev, named.median, named.skewness, named.kurtosis, named.count, named.maxLPS, named.minLPS);\n    if (named.center.value) {\n        named.array.push(named.center);\n    }\n    const store = state.pointsInShape !== null;\n    const freshState = createBasicStatsState(store);\n    state.max = freshState.max;\n    state.min = freshState.min;\n    state.sum = freshState.sum;\n    state.count = freshState.count;\n    state.maxIJK = freshState.maxIJK;\n    state.maxLPS = freshState.maxLPS;\n    state.minIJK = freshState.minIJK;\n    state.minLPS = freshState.minLPS;\n    state.runMean = freshState.runMean;\n    state.m2 = freshState.m2;\n    state.m3 = freshState.m3;\n    state.m4 = freshState.m4;\n    state.allValues = freshState.allValues;\n    state.pointsInShape = freshState.pointsInShape;\n    state.sumLPS = freshState.sumLPS;\n    return named;\n}\nexport class BasicStatsCalculator extends Calculator {\n    static { this.state = createBasicStatsState(true); }\n    static statsInit(options) {\n        if (!options.storePointData) {\n            this.state.pointsInShape = null;\n        }\n        this.state = createBasicStatsState(options.storePointData);\n    }\n    static { this.statsCallback = ({ value: newValue, pointLPS = null, pointIJK = null, }) => {\n        basicStatsCallback(this.state, newValue, pointLPS, pointIJK);\n    }; }\n    static { this.getStatistics = (options) => {\n        return basicGetStatistics(this.state, options?.unit);\n    }; }\n}\nexport class InstanceBasicStatsCalculator extends InstanceCalculator {\n    constructor(options) {\n        super(options);\n        this.state = createBasicStatsState(options.storePointData);\n    }\n    statsInit(options) {\n        this.state = createBasicStatsState(options.storePointData);\n    }\n    statsCallback(data) {\n        basicStatsCallback(this.state, data.value, data.pointLPS, data.pointIJK);\n    }\n    getStatistics(options) {\n        return basicGetStatistics(this.state, options?.unit);\n    }\n}\n", "import getCanvasCircleRadius from './getCanvasCircleRadius';\nimport getCanvasCircleCorners from './getCanvasCircleCorners';\nexport { getCanvasCircleRadius, getCanvasCircleCorners };\n", "export { default as distanceToPoint } from './distanceToPoint';\nexport { default as distanceToPointSquared } from './distanceToPointSquared';\nexport { default as mirror } from './mirror';\n", "export default function distanceToPointSquared(p1, p2) {\n    if (p1.length !== p2.length) {\n        throw Error('Both points should have the same dimensionality');\n    }\n    const [x1, y1, z1 = 0] = p1;\n    const [x2, y2, z2 = 0] = p2;\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const dz = z2 - z1;\n    return dx * dx + dy * dy + dz * dz;\n}\n", "import distanceToPointSquared from './distanceToPointSquared';\nexport default function distanceToPoint(p1, p2) {\n    return Math.sqrt(distanceToPointSquared(p1, p2));\n}\n", "export default function mirror(mirrorPoint, staticPoint) {\n    const [x1, y1] = mirrorPoint;\n    const [x2, y2] = staticPoint;\n    const newX = 2 * x2 - x1;\n    const newY = 2 * y2 - y1;\n    return [newX, newY];\n}\n", "import { distanceToPoint } from '../point';\nexport default function getCanvasCircleRadius(circleCanvasPoints) {\n    const [center, end] = circleCanvasPoints;\n    return distanceToPoint(center, end);\n}\n", "import { distanceToPoint } from '../point';\nexport default function getCanvasCircleCorners(circleCanvasPoints) {\n    const [center, end] = circleCanvasPoints;\n    const radius = distanceToPoint(center, end);\n    const topLeft = [center[0] - radius, center[1] - radius];\n    const bottomRight = [center[0] + radius, center[1] + radius];\n    return [topLeft, bottomRight];\n}\n", "import pointInEllipse, { precalculatePointInEllipse } from './pointInEllipse';\nimport getCanvasEllipseCorners from './getCanvasEllipseCorners';\nexport { pointInEllipse, precalculatePointInEllipse, getCanvasEllipseCorners };\n", "export default function pointInEllipse(ellipse, pointLPS, inverts = {}) {\n    if (!inverts.precalculated) {\n        precalculatePointInEllipse(ellipse, inverts);\n    }\n    return inverts.precalculated(pointLPS);\n}\nconst precalculatePointInEllipse = (ellipse, inverts = {}) => {\n    const { xRadius, yRadius, zRadius } = ellipse;\n    if (inverts.invXRadiusSq === undefined ||\n        inverts.invYRadiusSq === undefined ||\n        inverts.invZRadiusSq === undefined) {\n        inverts.invXRadiusSq = xRadius !== 0 ? 1 / xRadius ** 2 : 0;\n        inverts.invYRadiusSq = yRadius !== 0 ? 1 / yRadius ** 2 : 0;\n        inverts.invZRadiusSq = zRadius !== 0 ? 1 / zRadius ** 2 : 0;\n    }\n    const { invXRadiusSq, invYRadiusSq, invZRadiusSq } = inverts;\n    const { center } = ellipse;\n    const [centerL, centerP, centerS] = center;\n    inverts.precalculated = (pointLPS) => {\n        const dx = pointLPS[0] - centerL;\n        let inside = dx * dx * invXRadiusSq;\n        if (inside > 1) {\n            return false;\n        }\n        const dy = pointLPS[1] - centerP;\n        inside += dy * dy * invYRadiusSq;\n        if (inside > 1) {\n            return false;\n        }\n        const dz = pointLPS[2] - centerS;\n        inside += dz * dz * invZRadiusSq;\n        return inside <= 1;\n    };\n    return inverts;\n};\nexport { precalculatePointInEllipse };\n", "export default function getCanvasEllipseCorners(ellipseCanvasPoints) {\n    const [bottom, top, left, right] = ellipseCanvasPoints;\n    const topLeft = [left[0], top[1]];\n    const bottomRight = [right[0], bottom[1]];\n    return [topLeft, bottomRight];\n}\n", "import distanceToPoint from './distanceToPoint';\nimport distanceToPointSquared from './distanceToPointSquared';\nimport distanceToPointSquaredInfo from './distanceToPointSquaredInfo';\nimport intersectLine from './intersectLine';\nimport isPointOnLineSegment from './isPointOnLineSegment';\nexport { distanceToPoint, distanceToPointSquared, distanceToPointSquaredInfo, intersectLine, isPointOnLineSegment, };\n", "import { distanceToPointSquared } from '../point';\nexport default function distanceToPointSquaredInfo(lineStart, lineEnd, point) {\n    let closestPoint;\n    const distanceSquared = distanceToPointSquared(lineStart, lineEnd);\n    if (lineStart[0] === lineEnd[0] && lineStart[1] === lineEnd[1]) {\n        closestPoint = lineStart;\n    }\n    if (!closestPoint) {\n        const dotProduct = ((point[0] - lineStart[0]) * (lineEnd[0] - lineStart[0]) +\n            (point[1] - lineStart[1]) * (lineEnd[1] - lineStart[1])) /\n            distanceSquared;\n        if (dotProduct < 0) {\n            closestPoint = lineStart;\n        }\n        else if (dotProduct > 1) {\n            closestPoint = lineEnd;\n        }\n        else {\n            closestPoint = [\n                lineStart[0] + dotProduct * (lineEnd[0] - lineStart[0]),\n                lineStart[1] + dotProduct * (lineEnd[1] - lineStart[1]),\n            ];\n        }\n    }\n    return {\n        point: [...closestPoint],\n        distanceSquared: distanceToPointSquared(point, closestPoint),\n    };\n}\n", "import distanceToPointSquaredInfo from './distanceToPointSquaredInfo';\nexport default function distanceToPointSquared(lineStart, lineEnd, point) {\n    return distanceToPointSquaredInfo(lineStart, lineEnd, point).distanceSquared;\n}\n", "import distanceToPointSquared from './distanceToPointSquared';\nexport default function distanceToPoint(lineStart, lineEnd, point) {\n    if (lineStart.length !== 2 || lineEnd.length !== 2 || point.length !== 2) {\n        throw Error('lineStart, lineEnd, and point should have 2 elements of [x, y]');\n    }\n    return Math.sqrt(distanceToPointSquared(lineStart, lineEnd, point));\n}\n", "function sign(x) {\n    return typeof x === 'number'\n        ? x\n            ? x < 0\n                ? -1\n                : 1\n            : x === x\n                ? 0\n                : NaN\n        : NaN;\n}\nexport default function intersectLine(line1Start, line1End, line2Start, line2End, infinite = false) {\n    const [x1, y1] = line1Start;\n    const [x2, y2] = line1End;\n    const [x3, y3] = line2Start;\n    const [x4, y4] = line2End;\n    if (infinite) {\n        const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n        if (Math.abs(denom) < 1e-10) {\n            return undefined;\n        }\n        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n        const x = x1 + t * (x2 - x1);\n        const y = y1 + t * (y2 - y1);\n        return [x, y];\n    }\n    const a1 = y2 - y1;\n    const b1 = x1 - x2;\n    const c1 = x2 * y1 - x1 * y2;\n    const r3 = a1 * x3 + b1 * y3 + c1;\n    const r4 = a1 * x4 + b1 * y4 + c1;\n    if (r3 !== 0 && r4 !== 0 && sign(r3) === sign(r4)) {\n        return undefined;\n    }\n    const a2 = y4 - y3;\n    const b2 = x3 - x4;\n    const c2 = x4 * y3 - x3 * y4;\n    const r1 = a2 * x1 + b2 * y1 + c2;\n    const r2 = a2 * x2 + b2 * y2 + c2;\n    if (r1 !== 0 && r2 !== 0 && sign(r1) === sign(r2)) {\n        return undefined;\n    }\n    const denomSegment = a1 * b2 - a2 * b1;\n    let num;\n    num = b1 * c2 - b2 * c1;\n    const x = num / denomSegment;\n    num = a2 * c1 - a1 * c2;\n    const y = num / denomSegment;\n    const intersectionPoint = [x, y];\n    return intersectionPoint;\n}\n", "const ORIENTATION_TOLERANCE = 1e-2;\nexport default function isPointOnLineSegment(lineStart, lineEnd, point) {\n    const minX = lineStart[0] <= lineEnd[0] ? lineStart[0] : lineEnd[0];\n    const maxX = lineStart[0] >= lineEnd[0] ? lineStart[0] : lineEnd[0];\n    const minY = lineStart[1] <= lineEnd[1] ? lineStart[1] : lineEnd[1];\n    const maxY = lineStart[1] >= lineEnd[1] ? lineStart[1] : lineEnd[1];\n    const aabbContainsPoint = point[0] >= minX - ORIENTATION_TOLERANCE &&\n        point[0] <= maxX + ORIENTATION_TOLERANCE &&\n        point[1] >= minY - ORIENTATION_TOLERANCE &&\n        point[1] <= maxY + ORIENTATION_TOLERANCE;\n    if (!aabbContainsPoint) {\n        return false;\n    }\n    const orientation = (lineEnd[1] - lineStart[1]) * (point[0] - lineEnd[0]) -\n        (lineEnd[0] - lineStart[0]) * (point[1] - lineEnd[1]);\n    const absOrientation = orientation >= 0 ? orientation : -orientation;\n    return absOrientation <= ORIENTATION_TOLERANCE;\n}\n", "import isClosed from './isClosed';\nimport containsPoint from './containsPoint';\nimport containsPoints from './containsPoints';\nimport getAABB from './getAABB';\nimport getArea from './getArea';\nimport getSignedArea from './getSignedArea';\nimport getWindingDirection from './getWindingDirection';\nimport getNormal3 from './getNormal3';\nimport getNormal2 from './getNormal2';\nimport subtractPolylines from './subtractPolylines';\nimport intersectPolylines from './intersectPolylines';\nimport { mergePolylines } from './combinePolyline';\nimport intersectPolyline from './intersectPolyline';\nimport decimate from './decimate';\nimport getFirstLineSegmentIntersectionIndexes from './getFirstLineSegmentIntersectionIndexes';\nimport getLineSegmentIntersectionsIndexes from './getLineSegmentIntersectionsIndexes';\nimport getLineSegmentIntersectionsCoordinates from './getLineSegmentIntersectionsCoordinates';\nimport getClosestLineSegmentIntersection from './getClosestLineSegmentIntersection';\nimport getSubPixelSpacingAndXYDirections from './getSubPixelSpacingAndXYDirections';\nimport pointsAreWithinCloseContourProximity from './pointsAreWithinCloseContourProximity';\nimport addCanvasPointsToArray from './addCanvasPointsToArray';\nimport pointCanProjectOnLine from './pointCanProjectOnLine';\nimport { isPointInsidePolyline3D } from './isPointInsidePolyline3D';\nimport { projectTo2D } from './projectTo2D';\nimport convexHull from './convexHull';\nimport arePolylinesIdentical from './arePolylinesIdentical';\nexport { isClosed, containsPoint, containsPoints, getAABB, getArea, getSignedArea, getWindingDirection, getNormal3, getNormal2, intersectPolyline, decimate, getFirstLineSegmentIntersectionIndexes, getLineSegmentIntersectionsIndexes, getLineSegmentIntersectionsCoordinates, getClosestLineSegmentIntersection, getSubPixelSpacingAndXYDirections, pointsAreWithinCloseContourProximity, addCanvasPointsToArray, pointCanProjectOnLine, mergePolylines, subtractPolylines, intersectPolylines, isPointInsidePolyline3D, projectTo2D, convexHull, arePolylinesIdentical, };\n", "import { glMatrix } from 'gl-matrix';\nimport { distanceToPointSquared } from '../point';\nexport default function isClosed(polyline) {\n    if (polyline.length < 3) {\n        return false;\n    }\n    const numPolylinePoints = polyline.length;\n    const firstPoint = polyline[0];\n    const lastPoint = polyline[numPolylinePoints - 1];\n    const distFirstToLastPoints = distanceToPointSquared(firstPoint, lastPoint);\n    return glMatrix.equals(0, distFirstToLastPoints);\n}\n", "import isClosed from './isClosed';\nexport default function containsPoint(polyline, point, options = {\n    closed: undefined,\n}) {\n    if (polyline.length < 3) {\n        return false;\n    }\n    const numPolylinePoints = polyline.length;\n    let numIntersections = 0;\n    const { closed, holes } = options;\n    if (holes?.length) {\n        for (const hole of holes) {\n            if (containsPoint(hole, point)) {\n                return false;\n            }\n        }\n    }\n    const shouldClose = !(closed === undefined ? isClosed(polyline) : closed);\n    const maxSegmentIndex = polyline.length - (shouldClose ? 1 : 2);\n    for (let i = 0; i <= maxSegmentIndex; i++) {\n        const p1 = polyline[i];\n        const p2Index = i === numPolylinePoints - 1 ? 0 : i + 1;\n        const p2 = polyline[p2Index];\n        const maxX = p1[0] >= p2[0] ? p1[0] : p2[0];\n        const maxY = p1[1] >= p2[1] ? p1[1] : p2[1];\n        const minY = p1[1] <= p2[1] ? p1[1] : p2[1];\n        const mayIntersectLineSegment = point[0] <= maxX && point[1] >= minY && point[1] < maxY;\n        if (mayIntersectLineSegment) {\n            const isVerticalLine = p1[0] === p2[0];\n            let intersects = isVerticalLine;\n            if (!intersects) {\n                const xIntersection = ((point[1] - p1[1]) * (p2[0] - p1[0])) / (p2[1] - p1[1]) + p1[0];\n                intersects = point[0] <= xIntersection;\n            }\n            numIntersections += intersects ? 1 : 0;\n        }\n    }\n    return !!(numIntersections % 2);\n}\n", "import containsPoint from './containsPoint';\nexport default function containsPoints(polyline, points) {\n    for (let i = 0, numPoint = points.length; i < numPoint; i++) {\n        if (!containsPoint(polyline, points[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n", "export default function getAABB(polyline, options) {\n    let polylineToUse = polyline;\n    const numDimensions = options?.numDimensions || 2;\n    const is3D = numDimensions === 3;\n    if (!Array.isArray(polyline[0])) {\n        const currentPolyline = polyline;\n        const totalPoints = currentPolyline.length / numDimensions;\n        polylineToUse = new Array(currentPolyline.length / numDimensions);\n        for (let i = 0, len = totalPoints; i < len; i++) {\n            polylineToUse[i] = [\n                currentPolyline[i * numDimensions],\n                currentPolyline[i * numDimensions + 1],\n            ];\n            if (is3D) {\n                polylineToUse[i].push(currentPolyline[i * numDimensions + 2]);\n            }\n        }\n    }\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    let minZ = Infinity;\n    let maxZ = -Infinity;\n    polylineToUse = polylineToUse;\n    for (let i = 0, len = polylineToUse.length; i < len; i++) {\n        const [x, y, z] = polylineToUse[i];\n        minX = minX < x ? minX : x;\n        minY = minY < y ? minY : y;\n        maxX = maxX > x ? maxX : x;\n        maxY = maxY > y ? maxY : y;\n        if (is3D) {\n            minZ = minZ < z ? minZ : z;\n            maxZ = maxZ > z ? maxZ : z;\n        }\n    }\n    return is3D\n        ? { minX, maxX, minY, maxY, minZ, maxZ }\n        : { minX, maxX, minY, maxY };\n}\n", "export default function getArea(points) {\n    const n = points.length;\n    let area = 0.0;\n    let j = n - 1;\n    for (let i = 0; i < n; i++) {\n        area += (points[j][0] + points[i][0]) * (points[j][1] - points[i][1]);\n        j = i;\n    }\n    return Math.abs(area / 2.0);\n}\n", "export default function getSignedArea(polyline) {\n    if (polyline.length < 3) {\n        return 0;\n    }\n    const refPoint = polyline[0];\n    let area = 0;\n    for (let i = 0, len = polyline.length; i < len; i++) {\n        const p1 = polyline[i];\n        const p2Index = i === len - 1 ? 0 : i + 1;\n        const p2 = polyline[p2Index];\n        const aX = p1[0] - refPoint[0];\n        const aY = p1[1] - refPoint[1];\n        const bX = p2[0] - refPoint[0];\n        const bY = p2[1] - refPoint[1];\n        area += aX * bY - aY * bX;\n    }\n    area *= 0.5;\n    return area;\n}\n", "import getSignedArea from './getSignedArea';\nexport default function getWindingDirection(polyline) {\n    const signedArea = getSignedArea(polyline);\n    return signedArea >= 0 ? 1 : -1;\n}\n", "import { vec3 } from 'gl-matrix';\nfunction _getAreaVector(polyline) {\n    const vecArea = vec3.create();\n    const refPoint = polyline[0];\n    for (let i = 0, len = polyline.length; i < len; i++) {\n        const p1 = polyline[i];\n        const p2Index = i === len - 1 ? 0 : i + 1;\n        const p2 = polyline[p2Index];\n        const aX = p1[0] - refPoint[0];\n        const aY = p1[1] - refPoint[1];\n        const aZ = p1[2] - refPoint[2];\n        const bX = p2[0] - refPoint[0];\n        const bY = p2[1] - refPoint[1];\n        const bZ = p2[2] - refPoint[2];\n        vecArea[0] += aY * bZ - aZ * bY;\n        vecArea[1] += aZ * bX - aX * bZ;\n        vecArea[2] += aX * bY - aY * bX;\n    }\n    vec3.scale(vecArea, vecArea, 0.5);\n    return vecArea;\n}\nexport default function getNormal3(polyline) {\n    const vecArea = _getAreaVector(polyline);\n    return vec3.normalize(vecArea, vecArea);\n}\n", "import getSignedArea from './getSignedArea';\nexport default function getNormal2(polyline) {\n    const area = getSignedArea(polyline);\n    return [0, 0, area / Math.abs(area)];\n}\n", "import { utilities } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\nexport const EPSILON = 1e-7;\nexport function vec2CrossZ(a, b) {\n    return a[0] * b[1] - a[1] * b[0];\n}\nexport function pointsAreEqual(p1, p2) {\n    return utilities.isEqual(p1, p2, EPSILON);\n}\nexport function robustSegmentIntersection(p1, p2, q1, q2) {\n    const r = vec2.subtract(vec2.create(), p2, p1);\n    const s = vec2.subtract(vec2.create(), q2, q1);\n    const rxs = vec2CrossZ(r, s);\n    const qmp = vec2.subtract(vec2.create(), q1, p1);\n    const qmpxr = vec2CrossZ(qmp, r);\n    if (Math.abs(rxs) < EPSILON) {\n        if (Math.abs(qmpxr) < EPSILON) {\n            const rDotR = vec2.dot(r, r);\n            const sDotS = vec2.dot(s, s);\n            if (rDotR < EPSILON || sDotS < EPSILON) {\n                if (pointsAreEqual(p1, q1) || pointsAreEqual(p1, q2)) {\n                    return p1;\n                }\n                if (pointsAreEqual(p2, q1) || pointsAreEqual(p2, q2)) {\n                    return p2;\n                }\n                return null;\n            }\n            const t0 = vec2.dot(vec2.subtract(vec2.create(), q1, p1), r) / rDotR;\n            const t1 = vec2.dot(vec2.subtract(vec2.create(), q2, p1), r) / rDotR;\n            const u0 = vec2.dot(vec2.subtract(vec2.create(), p1, q1), s) / sDotS;\n            const u1 = vec2.dot(vec2.subtract(vec2.create(), p2, q1), s) / sDotS;\n            const isInRange = (t) => t >= -EPSILON && t <= 1 + EPSILON;\n            if (isInRange(t0)) {\n                const projectedPoint = vec2.scaleAndAdd(vec2.create(), p1, r, t0);\n                if (pointsAreEqual(q1, projectedPoint)) {\n                    return q1;\n                }\n            }\n            if (isInRange(t1)) {\n                const projectedPoint = vec2.scaleAndAdd(vec2.create(), p1, r, t1);\n                if (pointsAreEqual(q2, projectedPoint)) {\n                    return q2;\n                }\n            }\n            if (isInRange(u0)) {\n                const projectedPoint = vec2.scaleAndAdd(vec2.create(), q1, s, u0);\n                if (pointsAreEqual(p1, projectedPoint)) {\n                    return p1;\n                }\n            }\n            if (isInRange(u1)) {\n                const projectedPoint = vec2.scaleAndAdd(vec2.create(), q1, s, u1);\n                if (pointsAreEqual(p2, projectedPoint)) {\n                    return p2;\n                }\n            }\n        }\n        return null;\n    }\n    const t = vec2CrossZ(qmp, s) / rxs;\n    const u = qmpxr / rxs;\n    if (t >= -EPSILON && t <= 1 + EPSILON && u >= -EPSILON && u <= 1 + EPSILON) {\n        return [p1[0] + t * r[0], p1[1] + t * r[1]];\n    }\n    return null;\n}\nexport var PolylineNodeType;\n(function (PolylineNodeType) {\n    PolylineNodeType[PolylineNodeType[\"Vertex\"] = 0] = \"Vertex\";\n    PolylineNodeType[PolylineNodeType[\"Intersection\"] = 1] = \"Intersection\";\n})(PolylineNodeType || (PolylineNodeType = {}));\nexport var IntersectionDirection;\n(function (IntersectionDirection) {\n    IntersectionDirection[IntersectionDirection[\"Entering\"] = 0] = \"Entering\";\n    IntersectionDirection[IntersectionDirection[\"Exiting\"] = 1] = \"Exiting\";\n    IntersectionDirection[IntersectionDirection[\"Unknown\"] = 2] = \"Unknown\";\n})(IntersectionDirection || (IntersectionDirection = {}));\n", "import { pointsAreEqual } from './robustSegmentIntersection';\nexport default function arePolylinesIdentical(poly1, poly2) {\n    if (poly1.length !== poly2.length) {\n        return false;\n    }\n    const len = poly1.length;\n    if (len === 0) {\n        return true;\n    }\n    let identicalForward = true;\n    for (let i = 0; i < len; i++) {\n        if (!pointsAreEqual(poly1[i], poly2[i])) {\n            identicalForward = false;\n            break;\n        }\n    }\n    if (identicalForward) {\n        return true;\n    }\n    let identicalReverse = true;\n    for (let i = 0; i < len; i++) {\n        if (!pointsAreEqual(poly1[i], poly2[len - 1 - i])) {\n            identicalReverse = false;\n            break;\n        }\n    }\n    if (identicalReverse) {\n        return true;\n    }\n    for (let offset = 1; offset < len; offset++) {\n        let cyclicForward = true;\n        for (let i = 0; i < len; i++) {\n            if (!pointsAreEqual(poly1[i], poly2[(i + offset) % len])) {\n                cyclicForward = false;\n                break;\n            }\n        }\n        if (cyclicForward) {\n            return true;\n        }\n        let cyclicReverse = true;\n        for (let i = 0; i < len; i++) {\n            if (!pointsAreEqual(poly1[i], poly2[(len - 1 - i + offset) % len])) {\n                cyclicReverse = false;\n                break;\n            }\n        }\n        if (cyclicReverse) {\n            return true;\n        }\n    }\n    return false;\n}\n", "import { vec2 } from 'gl-matrix';\nimport getSignedArea from './getSignedArea';\nimport { EPSILON, IntersectionDirection, pointsAreEqual, PolylineNodeType, robustSegmentIntersection, } from './robustSegmentIntersection';\nimport containsPoint from './containsPoint';\nimport arePolylinesIdentical from './arePolylinesIdentical';\nexport default function subtractPolylines(targetPolylineCoords, sourcePolylineCoordsInput) {\n    if (targetPolylineCoords.length < 3) {\n        return [];\n    }\n    if (sourcePolylineCoordsInput.length < 3) {\n        return [targetPolylineCoords.slice()];\n    }\n    const sourcePolylineCoords = sourcePolylineCoordsInput.slice();\n    if (arePolylinesIdentical(targetPolylineCoords, sourcePolylineCoordsInput)) {\n        return [];\n    }\n    const targetArea = getSignedArea(targetPolylineCoords);\n    const sourceArea = getSignedArea(sourcePolylineCoords);\n    if (Math.sign(targetArea) === Math.sign(sourceArea) &&\n        Math.abs(sourceArea) > EPSILON) {\n        sourcePolylineCoords.reverse();\n    }\n    const intersections = [];\n    for (let i = 0; i < targetPolylineCoords.length; i++) {\n        const p1 = targetPolylineCoords[i];\n        const p2 = targetPolylineCoords[(i + 1) % targetPolylineCoords.length];\n        for (let j = 0; j < sourcePolylineCoords.length; j++) {\n            const q1 = sourcePolylineCoords[j];\n            const q2 = sourcePolylineCoords[(j + 1) % sourcePolylineCoords.length];\n            const intersectPt = robustSegmentIntersection(p1, p2, q1, q2);\n            if (intersectPt) {\n                const lenP = Math.sqrt(vec2.squaredDistance(p1, p2));\n                const lenQ = Math.sqrt(vec2.squaredDistance(q1, q2));\n                intersections.push({\n                    coord: intersectPt,\n                    seg1Idx: i,\n                    seg2Idx: j,\n                    alpha1: lenP < EPSILON\n                        ? 0\n                        : Math.sqrt(vec2.squaredDistance(p1, intersectPt)) / lenP,\n                    alpha2: lenQ < EPSILON\n                        ? 0\n                        : Math.sqrt(vec2.squaredDistance(q1, intersectPt)) / lenQ,\n                });\n            }\n        }\n    }\n    const buildAugmentedList = (polyCoords, polyIndex, allIntersections) => {\n        const augmentedList = [];\n        let nodeIdCounter = 0;\n        for (let i = 0; i < polyCoords.length; i++) {\n            const p1 = polyCoords[i];\n            augmentedList.push({\n                id: `${polyIndex}_v${nodeIdCounter++}`,\n                coordinates: p1,\n                type: PolylineNodeType.Vertex,\n                originalPolyIndex: polyIndex,\n                originalVertexIndex: i,\n                next: null,\n                prev: null,\n                isIntersection: false,\n                visited: false,\n            });\n            const segmentIntersections = allIntersections\n                .filter((isect) => (polyIndex === 0 ? isect.seg1Idx : isect.seg2Idx) === i)\n                .sort((a, b) => (polyIndex === 0 ? a.alpha1 : a.alpha2) -\n                (polyIndex === 0 ? b.alpha1 : b.alpha2));\n            for (const isect of segmentIntersections) {\n                if (augmentedList.length > 0 &&\n                    pointsAreEqual(augmentedList[augmentedList.length - 1].coordinates, isect.coord)) {\n                    if (!augmentedList[augmentedList.length - 1].isIntersection) {\n                        augmentedList[augmentedList.length - 1].isIntersection = true;\n                        augmentedList[augmentedList.length - 1].intersectionInfo = isect;\n                        augmentedList[augmentedList.length - 1].alpha =\n                            polyIndex === 0 ? isect.alpha1 : isect.alpha2;\n                    }\n                    continue;\n                }\n                augmentedList.push({\n                    id: `${polyIndex}_i${nodeIdCounter++}`,\n                    coordinates: isect.coord,\n                    type: PolylineNodeType.Intersection,\n                    originalPolyIndex: polyIndex,\n                    next: null,\n                    prev: null,\n                    isIntersection: true,\n                    visited: false,\n                    alpha: polyIndex === 0 ? isect.alpha1 : isect.alpha2,\n                    intersectionInfo: isect,\n                });\n            }\n        }\n        const finalList = [];\n        if (augmentedList.length > 0) {\n            finalList.push(augmentedList[0]);\n            for (let i = 1; i < augmentedList.length; i++) {\n                if (!pointsAreEqual(augmentedList[i].coordinates, finalList[finalList.length - 1].coordinates)) {\n                    finalList.push(augmentedList[i]);\n                }\n                else {\n                    if (augmentedList[i].isIntersection) {\n                        finalList[finalList.length - 1].isIntersection = true;\n                        finalList[finalList.length - 1].intersectionInfo =\n                            augmentedList[i].intersectionInfo;\n                        finalList[finalList.length - 1].alpha = augmentedList[i].alpha;\n                    }\n                }\n            }\n        }\n        if (finalList.length > 0) {\n            for (let i = 0; i < finalList.length; i++) {\n                finalList[i].next = finalList[(i + 1) % finalList.length];\n                finalList[i].prev =\n                    finalList[(i - 1 + finalList.length) % finalList.length];\n            }\n        }\n        return finalList;\n    };\n    const targetAugmented = buildAugmentedList(targetPolylineCoords, 0, intersections);\n    const sourceAugmented = buildAugmentedList(sourcePolylineCoords, 1, intersections);\n    targetAugmented.forEach((tnode) => {\n        if (tnode.isIntersection) {\n            const tData = tnode.intersectionInfo;\n            const partner = sourceAugmented.find((snode) => snode.isIntersection &&\n                pointsAreEqual(snode.coordinates, tnode.coordinates) &&\n                snode.intersectionInfo.seg1Idx ===\n                    tData.seg1Idx &&\n                snode.intersectionInfo.seg2Idx === tData.seg2Idx);\n            if (partner) {\n                tnode.partnerNode = partner;\n                partner.partnerNode = tnode;\n                const p_prev = tnode.prev.coordinates;\n                const p_curr = tnode.coordinates;\n                const p_next_source = partner.next.coordinates;\n                const v_target_arrival = vec2.subtract(vec2.create(), p_curr, p_prev);\n                const v_source_departure = vec2.subtract(vec2.create(), p_next_source, p_curr);\n                const midPrevTargetSeg = [\n                    (tnode.prev.coordinates[0] + tnode.coordinates[0]) / 2,\n                    (tnode.prev.coordinates[1] + tnode.coordinates[1]) / 2,\n                ];\n                const prevSegMidpointInsideSource = containsPoint(sourcePolylineCoordsInput, midPrevTargetSeg);\n                if (prevSegMidpointInsideSource) {\n                    tnode.intersectionDir = IntersectionDirection.Exiting;\n                }\n                else {\n                    tnode.intersectionDir = IntersectionDirection.Entering;\n                }\n            }\n            else {\n                tnode.isIntersection = false;\n            }\n        }\n    });\n    targetAugmented.forEach((n) => delete n.intersectionInfo);\n    sourceAugmented.forEach((n) => delete n.intersectionInfo);\n    const resultPolylines = [];\n    for (let i = 0; i < targetAugmented.length; i++) {\n        const startNode = targetAugmented[i];\n        if (startNode.visited || startNode.isIntersection) {\n            continue;\n        }\n        if (containsPoint(sourcePolylineCoordsInput, startNode.coordinates)) {\n            continue;\n        }\n        const currentPathCoords = [];\n        let currentNode = startNode;\n        let onTargetList = true;\n        let safetyBreak = 0;\n        const maxIter = (targetAugmented.length + sourceAugmented.length) * 2;\n        do {\n            if (safetyBreak++ > maxIter) {\n                console.warn('Subtraction: Max iterations reached, possible infinite loop.');\n                break;\n            }\n            currentNode.visited = true;\n            if (currentPathCoords.length === 0 ||\n                !pointsAreEqual(currentPathCoords[currentPathCoords.length - 1], currentNode.coordinates)) {\n                currentPathCoords.push(currentNode.coordinates);\n            }\n            if (currentNode.isIntersection) {\n                if (onTargetList) {\n                    if (currentNode.intersectionDir === IntersectionDirection.Entering &&\n                        currentNode.partnerNode) {\n                        currentNode = currentNode.partnerNode;\n                        onTargetList = false;\n                    }\n                }\n                else {\n                    if (currentNode.partnerNode) {\n                        currentNode = currentNode.partnerNode;\n                        onTargetList = true;\n                    }\n                    else {\n                        console.warn('Subtraction: Intersection on source without partner.');\n                    }\n                }\n            }\n            currentNode = currentNode.next;\n        } while (currentNode !== startNode || !onTargetList);\n        if (currentPathCoords.length >= 3) {\n            if (pointsAreEqual(currentPathCoords[0], currentPathCoords[currentPathCoords.length - 1])) {\n                currentPathCoords.pop();\n            }\n            if (currentPathCoords.length >= 3) {\n                resultPolylines.push(currentPathCoords);\n            }\n        }\n    }\n    return resultPolylines;\n}\n", "import { vec2 } from 'gl-matrix';\nimport containsPoint from './containsPoint';\nimport getSignedArea from './getSignedArea';\nimport { EPSILON, IntersectionDirection, pointsAreEqual, PolylineNodeType, robustSegmentIntersection, } from './robustSegmentIntersection';\nexport default function intersectPolylines(mainPolyCoords, clipPolyCoordsInput) {\n    if (mainPolyCoords.length < 3 || clipPolyCoordsInput.length < 3) {\n        return [];\n    }\n    let clipPolyCoords = clipPolyCoordsInput.slice();\n    const mainArea = getSignedArea(mainPolyCoords);\n    const clipArea = getSignedArea(clipPolyCoords);\n    if (Math.abs(mainArea) < EPSILON || Math.abs(clipArea) < EPSILON) {\n        return [];\n    }\n    if (mainArea < 0) {\n        mainPolyCoords = mainPolyCoords.slice().reverse();\n    }\n    if (clipArea < 0) {\n        clipPolyCoords = clipPolyCoords.slice().reverse();\n    }\n    const currentClipPolyForPIP = clipPolyCoords;\n    const intersections = [];\n    for (let i = 0; i < mainPolyCoords.length; i++) {\n        const p1 = mainPolyCoords[i];\n        const p2 = mainPolyCoords[(i + 1) % mainPolyCoords.length];\n        for (let j = 0; j < clipPolyCoords.length; j++) {\n            const q1 = clipPolyCoords[j];\n            const q2 = clipPolyCoords[(j + 1) % clipPolyCoords.length];\n            const intersectPt = robustSegmentIntersection(p1, p2, q1, q2);\n            if (intersectPt) {\n                const lenP = Math.sqrt(vec2.squaredDistance(p1, p2));\n                const lenQ = Math.sqrt(vec2.squaredDistance(q1, q2));\n                intersections.push({\n                    coord: [...intersectPt],\n                    seg1Idx: i,\n                    seg2Idx: j,\n                    alpha1: lenP < EPSILON\n                        ? 0\n                        : Math.sqrt(vec2.squaredDistance(p1, intersectPt)) / lenP,\n                    alpha2: lenQ < EPSILON\n                        ? 0\n                        : Math.sqrt(vec2.squaredDistance(q1, intersectPt)) / lenQ,\n                });\n            }\n        }\n    }\n    if (intersections.length === 0) {\n        if (containsPoint(currentClipPolyForPIP, mainPolyCoords[0]) &&\n            mainPolyCoords.every((pt) => containsPoint(currentClipPolyForPIP, pt))) {\n            return [[...mainPolyCoords.map((p) => [...p])]];\n        }\n        if (containsPoint(mainPolyCoords, clipPolyCoords[0]) &&\n            clipPolyCoords.every((pt) => containsPoint(mainPolyCoords, pt))) {\n            return [[...clipPolyCoords.map((p) => [...p])]];\n        }\n        return [];\n    }\n    const buildAugmentedList = (polyCoords, polyIndex, allIntersections) => {\n        const augmentedList = [];\n        let nodeIdCounter = 0;\n        for (let i = 0; i < polyCoords.length; i++) {\n            const p1 = polyCoords[i];\n            augmentedList.push({\n                id: `${polyIndex}_v${nodeIdCounter++}`,\n                coordinates: [...p1],\n                type: PolylineNodeType.Vertex,\n                originalPolyIndex: polyIndex,\n                originalVertexIndex: i,\n                next: null,\n                prev: null,\n                isIntersection: false,\n                visited: false,\n                processedInPath: false,\n                intersectionDir: IntersectionDirection.Unknown,\n            });\n            const segmentIntersections = allIntersections\n                .filter((isect) => (polyIndex === 0 ? isect.seg1Idx : isect.seg2Idx) === i)\n                .sort((a, b) => (polyIndex === 0 ? a.alpha1 : a.alpha2) -\n                (polyIndex === 0 ? b.alpha1 : b.alpha2));\n            for (const isect of segmentIntersections) {\n                if (augmentedList.length > 0 &&\n                    pointsAreEqual(augmentedList[augmentedList.length - 1].coordinates, isect.coord)) {\n                    const lastNode = augmentedList[augmentedList.length - 1];\n                    if (!lastNode.isIntersection) {\n                        lastNode.isIntersection = true;\n                        lastNode.intersectionInfo = isect;\n                        lastNode.alpha = polyIndex === 0 ? isect.alpha1 : isect.alpha2;\n                        lastNode.type = PolylineNodeType.Intersection;\n                    }\n                    continue;\n                }\n                augmentedList.push({\n                    id: `${polyIndex}_i${nodeIdCounter++}`,\n                    coordinates: [...isect.coord],\n                    type: PolylineNodeType.Intersection,\n                    originalPolyIndex: polyIndex,\n                    next: null,\n                    prev: null,\n                    isIntersection: true,\n                    visited: false,\n                    processedInPath: false,\n                    alpha: polyIndex === 0 ? isect.alpha1 : isect.alpha2,\n                    intersectionInfo: isect,\n                    intersectionDir: IntersectionDirection.Unknown,\n                });\n            }\n        }\n        const finalList = [];\n        if (augmentedList.length > 0) {\n            finalList.push(augmentedList[0]);\n            for (let i = 1; i < augmentedList.length; i++) {\n                if (!pointsAreEqual(augmentedList[i].coordinates, finalList[finalList.length - 1].coordinates)) {\n                    finalList.push(augmentedList[i]);\n                }\n                else {\n                    const lastNodeInFinal = finalList[finalList.length - 1];\n                    if (augmentedList[i].isIntersection &&\n                        augmentedList[i].intersectionInfo) {\n                        lastNodeInFinal.isIntersection = true;\n                        lastNodeInFinal.intersectionInfo =\n                            augmentedList[i].intersectionInfo;\n                        lastNodeInFinal.alpha = augmentedList[i].alpha;\n                        lastNodeInFinal.type = PolylineNodeType.Intersection;\n                    }\n                }\n            }\n        }\n        if (finalList.length > 1 &&\n            pointsAreEqual(finalList[0].coordinates, finalList[finalList.length - 1].coordinates)) {\n            const firstNode = finalList[0];\n            const lastNodePopped = finalList.pop();\n            if (lastNodePopped.isIntersection &&\n                !firstNode.isIntersection &&\n                lastNodePopped.intersectionInfo) {\n                firstNode.isIntersection = true;\n                firstNode.intersectionInfo = lastNodePopped.intersectionInfo;\n                firstNode.alpha = lastNodePopped.alpha;\n                firstNode.type = PolylineNodeType.Intersection;\n            }\n        }\n        if (finalList.length > 0) {\n            for (let i = 0; i < finalList.length; i++) {\n                finalList[i].next = finalList[(i + 1) % finalList.length];\n                finalList[i].prev =\n                    finalList[(i - 1 + finalList.length) % finalList.length];\n            }\n        }\n        return finalList;\n    };\n    const mainAugmented = buildAugmentedList(mainPolyCoords, 0, intersections);\n    const clipAugmented = buildAugmentedList(clipPolyCoords, 1, intersections);\n    if (mainAugmented.length === 0 || clipAugmented.length === 0) {\n        return [];\n    }\n    mainAugmented.forEach((mainNode) => {\n        if (mainNode.isIntersection && mainNode.intersectionInfo) {\n            const mainIntersectData = mainNode.intersectionInfo;\n            const partnerNode = clipAugmented.find((clipNode) => clipNode.isIntersection &&\n                clipNode.intersectionInfo &&\n                pointsAreEqual(clipNode.coordinates, mainNode.coordinates) &&\n                clipNode.intersectionInfo.seg1Idx === mainIntersectData.seg1Idx &&\n                clipNode.intersectionInfo.seg2Idx === mainIntersectData.seg2Idx);\n            if (partnerNode) {\n                mainNode.partnerNode = partnerNode;\n                partnerNode.partnerNode = mainNode;\n                const v_arrival_main = vec2.subtract(vec2.create(), mainNode.coordinates, mainNode.prev.coordinates);\n                const v_departure_clip = vec2.subtract(vec2.create(), partnerNode.next.coordinates, partnerNode.coordinates);\n                const crossZ = v_arrival_main[0] * v_departure_clip[1] -\n                    v_arrival_main[1] * v_departure_clip[0];\n                if (crossZ > EPSILON) {\n                    mainNode.intersectionDir = IntersectionDirection.Entering;\n                    partnerNode.intersectionDir = IntersectionDirection.Exiting;\n                }\n                else if (crossZ < -EPSILON) {\n                    mainNode.intersectionDir = IntersectionDirection.Exiting;\n                    partnerNode.intersectionDir = IntersectionDirection.Entering;\n                }\n                else {\n                    const midPrevMainSeg = [\n                        (mainNode.prev.coordinates[0] + mainNode.coordinates[0]) / 2,\n                        (mainNode.prev.coordinates[1] + mainNode.coordinates[1]) / 2,\n                    ];\n                    if (containsPoint(currentClipPolyForPIP, midPrevMainSeg)) {\n                        mainNode.intersectionDir = IntersectionDirection.Exiting;\n                        partnerNode.intersectionDir = IntersectionDirection.Entering;\n                    }\n                    else {\n                        mainNode.intersectionDir = IntersectionDirection.Entering;\n                        partnerNode.intersectionDir = IntersectionDirection.Exiting;\n                    }\n                }\n            }\n            else {\n                mainNode.isIntersection = false;\n                mainNode.intersectionInfo = undefined;\n            }\n        }\n    });\n    const resultPolygons = [];\n    for (const startCand of mainAugmented) {\n        if (!startCand.isIntersection ||\n            startCand.visited ||\n            startCand.intersectionDir !== IntersectionDirection.Entering) {\n            continue;\n        }\n        let currentPathCoords = [];\n        let currentNode = startCand;\n        let onMainList = true;\n        const pathStartNode = startCand;\n        let safetyBreak = 0;\n        const maxIter = (mainAugmented.length + clipAugmented.length) * 2;\n        mainAugmented.forEach((n) => (n.processedInPath = false));\n        clipAugmented.forEach((n) => (n.processedInPath = false));\n        do {\n            if (safetyBreak++ > maxIter) {\n                console.warn('Intersection: Max iterations in path tracing.', pathStartNode.id, currentNode.id);\n                currentPathCoords = [];\n                break;\n            }\n            if (currentNode.processedInPath && currentNode !== pathStartNode) {\n                console.warn('Intersection: Path processing loop detected, discarding path segment.', pathStartNode.id, currentNode.id);\n                currentPathCoords = [];\n                break;\n            }\n            currentNode.processedInPath = true;\n            currentNode.visited = true;\n            if (currentPathCoords.length === 0 ||\n                !pointsAreEqual(currentPathCoords[currentPathCoords.length - 1], currentNode.coordinates)) {\n                currentPathCoords.push([...currentNode.coordinates]);\n            }\n            let switchedList = false;\n            if (currentNode.isIntersection && currentNode.partnerNode) {\n                if (onMainList) {\n                    currentNode = currentNode.partnerNode;\n                    onMainList = false;\n                    switchedList = true;\n                }\n                else {\n                    currentNode = currentNode.partnerNode;\n                    onMainList = true;\n                    switchedList = true;\n                }\n            }\n            if (!switchedList) {\n                currentNode = currentNode.next;\n            }\n            else {\n                currentNode = currentNode.next;\n            }\n        } while (currentNode !== pathStartNode ||\n            (onMainList && currentNode.originalPolyIndex !== 0) ||\n            (!onMainList && currentNode.originalPolyIndex !== 1));\n        if (safetyBreak > maxIter || currentPathCoords.length === 0) {\n        }\n        else if (currentPathCoords.length > 0 &&\n            pointsAreEqual(currentPathCoords[0], currentPathCoords[currentPathCoords.length - 1])) {\n            currentPathCoords.pop();\n        }\n        if (currentPathCoords.length >= 3) {\n            const resultArea = getSignedArea(currentPathCoords);\n            if (mainArea > 0 && resultArea < 0) {\n                currentPathCoords.reverse();\n            }\n            else if (mainArea < 0 && resultArea > 0) {\n                currentPathCoords.reverse();\n            }\n            resultPolygons.push(currentPathCoords.map((p) => [...p]));\n        }\n    }\n    return resultPolygons;\n}\n", "export default function areLineSegmentsIntersecting(p1, q1, p2, q2) {\n    let result = false;\n    const line1MinX = p1[0] < q1[0] ? p1[0] : q1[0];\n    const line1MinY = p1[1] < q1[1] ? p1[1] : q1[1];\n    const line1MaxX = p1[0] > q1[0] ? p1[0] : q1[0];\n    const line1MaxY = p1[1] > q1[1] ? p1[1] : q1[1];\n    const line2MinX = p2[0] < q2[0] ? p2[0] : q2[0];\n    const line2MinY = p2[1] < q2[1] ? p2[1] : q2[1];\n    const line2MaxX = p2[0] > q2[0] ? p2[0] : q2[0];\n    const line2MaxY = p2[1] > q2[1] ? p2[1] : q2[1];\n    if (line1MinX > line2MaxX ||\n        line1MaxX < line2MinX ||\n        line1MinY > line2MaxY ||\n        line1MaxY < line2MinY) {\n        return false;\n    }\n    const orient = [\n        orientation(p1, q1, p2),\n        orientation(p1, q1, q2),\n        orientation(p2, q2, p1),\n        orientation(p2, q2, q1),\n    ];\n    if (orient[0] !== orient[1] && orient[2] !== orient[3]) {\n        return true;\n    }\n    if (orient[0] === 0 && onSegment(p1, p2, q1)) {\n        result = true;\n    }\n    else if (orient[1] === 0 && onSegment(p1, q2, q1)) {\n        result = true;\n    }\n    else if (orient[2] === 0 && onSegment(p2, p1, q2)) {\n        result = true;\n    }\n    else if (orient[3] === 0 && onSegment(p2, q1, q2)) {\n        result = true;\n    }\n    return result;\n}\nfunction orientation(p, q, r) {\n    const orientationValue = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n    if (orientationValue === 0) {\n        return 0;\n    }\n    return orientationValue > 0 ? 1 : 2;\n}\nfunction onSegment(p, q, r) {\n    if (q[0] <= Math.max(p[0], r[0]) &&\n        q[0] >= Math.min(p[0], r[0]) &&\n        q[1] <= Math.max(p[1], r[1]) &&\n        q[1] >= Math.min(p[1], r[1])) {\n        return true;\n    }\n    return false;\n}\n", "import areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\nexport default function getLineSegmentIntersectionsIndexes(polyline, p1, q1, closed = true) {\n    const intersections = [];\n    const numPoints = polyline.length;\n    const maxI = numPoints - (closed ? 1 : 2);\n    for (let i = 0; i <= maxI; i++) {\n        const p2 = polyline[i];\n        const j = i === numPoints - 1 ? 0 : i + 1;\n        const q2 = polyline[j];\n        if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n            intersections.push([i, j]);\n        }\n    }\n    return intersections;\n}\n", "import areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\nexport default function getFirstLineSegmentIntersectionIndexes(points, p1, q1, closed = true) {\n    let initialI;\n    let j;\n    if (closed) {\n        j = points.length - 1;\n        initialI = 0;\n    }\n    else {\n        j = 0;\n        initialI = 1;\n    }\n    for (let i = initialI; i < points.length; i++) {\n        const p2 = points[j];\n        const q2 = points[i];\n        if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n            return [j, i];\n        }\n        j = i;\n    }\n}\n", "import getFirstLineSegmentIntersectionIndexes from './getFirstLineSegmentIntersectionIndexes';\nexport default function intersectPolyline(sourcePolyline, targetPolyline) {\n    for (let i = 0, sourceLen = sourcePolyline.length; i < sourceLen; i++) {\n        const sourceP1 = sourcePolyline[i];\n        const sourceP2Index = i === sourceLen - 1 ? 0 : i + 1;\n        const sourceP2 = sourcePolyline[sourceP2Index];\n        const intersectionPointIndexes = getFirstLineSegmentIntersectionIndexes(targetPolyline, sourceP1, sourceP2);\n        if (intersectionPointIndexes?.length === 2) {\n            return true;\n        }\n    }\n    return false;\n}\n", "import * as mathLine from '../line';\nconst PARALLEL_LINES_TOLERANCE = 1e-2;\nexport default function getLinesIntersection(p1, q1, p2, q2) {\n    const diffQ1P1 = [q1[0] - p1[0], q1[1] - p1[1]];\n    const diffQ2P2 = [q2[0] - p2[0], q2[1] - p2[1]];\n    const denominator = diffQ2P2[1] * diffQ1P1[0] - diffQ2P2[0] * diffQ1P1[1];\n    const absDenominator = denominator >= 0 ? denominator : -denominator;\n    if (absDenominator < PARALLEL_LINES_TOLERANCE) {\n        const line1AABB = [\n            p1[0] < q1[0] ? p1[0] : q1[0],\n            p1[0] > q1[0] ? p1[0] : q1[0],\n            p1[1] < q1[1] ? p1[1] : q1[1],\n            p1[1] > q1[1] ? p1[1] : q1[1],\n        ];\n        const line2AABB = [\n            p2[0] < q2[0] ? p2[0] : q2[0],\n            p2[0] > q2[0] ? p2[0] : q2[0],\n            p2[1] < q2[1] ? p2[1] : q2[1],\n            p2[1] > q2[1] ? p2[1] : q2[1],\n        ];\n        const aabbIntersects = line1AABB[0] <= line2AABB[1] &&\n            line1AABB[1] >= line2AABB[0] &&\n            line1AABB[2] <= line2AABB[3] &&\n            line1AABB[3] >= line2AABB[2];\n        if (!aabbIntersects) {\n            return;\n        }\n        const overlap = mathLine.isPointOnLineSegment(p1, q1, p2) ||\n            mathLine.isPointOnLineSegment(p1, q1, q2) ||\n            mathLine.isPointOnLineSegment(p2, q2, p1);\n        if (!overlap) {\n            return;\n        }\n        const minX = line1AABB[0] > line2AABB[0] ? line1AABB[0] : line2AABB[0];\n        const maxX = line1AABB[1] < line2AABB[1] ? line1AABB[1] : line2AABB[1];\n        const minY = line1AABB[2] > line2AABB[2] ? line1AABB[2] : line2AABB[2];\n        const maxY = line1AABB[3] < line2AABB[3] ? line1AABB[3] : line2AABB[3];\n        const midX = (minX + maxX) * 0.5;\n        const midY = (minY + maxY) * 0.5;\n        return [midX, midY];\n    }\n    let a = p1[1] - p2[1];\n    let b = p1[0] - p2[0];\n    const numerator1 = diffQ2P2[0] * a - diffQ2P2[1] * b;\n    const numerator2 = diffQ1P1[0] * a - diffQ1P1[1] * b;\n    a = numerator1 / denominator;\n    b = numerator2 / denominator;\n    const resultX = p1[0] + a * diffQ1P1[0];\n    const resultY = p1[1] + a * diffQ1P1[1];\n    return [resultX, resultY];\n}\n", "import * as mathPoint from '../point';\nimport getLineSegmentIntersectionsIndexes from './getLineSegmentIntersectionsIndexes';\nimport containsPoint from './containsPoint';\nimport containsPoints from './containsPoints';\nimport intersectPolyline from './intersectPolyline';\nimport getNormal2 from './getNormal2';\nimport { glMatrix, vec3 } from 'gl-matrix';\nimport getLinesIntersection from './getLinesIntersection';\nvar PolylinePointType;\n(function (PolylinePointType) {\n    PolylinePointType[PolylinePointType[\"Vertex\"] = 0] = \"Vertex\";\n    PolylinePointType[PolylinePointType[\"Intersection\"] = 1] = \"Intersection\";\n})(PolylinePointType || (PolylinePointType = {}));\nvar PolylinePointPosition;\n(function (PolylinePointPosition) {\n    PolylinePointPosition[PolylinePointPosition[\"Outside\"] = -1] = \"Outside\";\n    PolylinePointPosition[PolylinePointPosition[\"Edge\"] = 0] = \"Edge\";\n    PolylinePointPosition[PolylinePointPosition[\"Inside\"] = 1] = \"Inside\";\n})(PolylinePointPosition || (PolylinePointPosition = {}));\nvar PolylinePointDirection;\n(function (PolylinePointDirection) {\n    PolylinePointDirection[PolylinePointDirection[\"Exiting\"] = -1] = \"Exiting\";\n    PolylinePointDirection[PolylinePointDirection[\"Unknown\"] = 0] = \"Unknown\";\n    PolylinePointDirection[PolylinePointDirection[\"Entering\"] = 1] = \"Entering\";\n})(PolylinePointDirection || (PolylinePointDirection = {}));\nfunction ensuresNextPointers(polylinePoints) {\n    for (let i = 0, len = polylinePoints.length; i < len; i++) {\n        const currentPoint = polylinePoints[i];\n        if (!currentPoint.next) {\n            currentPoint.next = polylinePoints[i === len - 1 ? 0 : i + 1];\n        }\n    }\n}\nfunction getSourceAndTargetPointsList(targetPolyline, sourcePolyline) {\n    const targetPolylinePoints = [];\n    const sourcePolylinePoints = [];\n    const sourceIntersectionsCache = new Map();\n    const isFirstPointInside = containsPoint(sourcePolyline, targetPolyline[0]);\n    let intersectionPointDirection = isFirstPointInside\n        ? PolylinePointDirection.Exiting\n        : PolylinePointDirection.Entering;\n    for (let i = 0, len = targetPolyline.length; i < len; i++) {\n        const p1 = targetPolyline[i];\n        const pointInside = containsPoint(sourcePolyline, p1);\n        const vertexPoint = {\n            type: PolylinePointType.Vertex,\n            coordinates: p1,\n            position: pointInside\n                ? PolylinePointPosition.Inside\n                : PolylinePointPosition.Outside,\n            visited: false,\n            next: null,\n        };\n        targetPolylinePoints.push(vertexPoint);\n        const q1 = targetPolyline[i === len - 1 ? 0 : i + 1];\n        const intersectionsInfo = getLineSegmentIntersectionsIndexes(sourcePolyline, p1, q1).map((intersectedLineSegment) => {\n            const sourceLineSegmentId = intersectedLineSegment[0];\n            const p2 = sourcePolyline[intersectedLineSegment[0]];\n            const q2 = sourcePolyline[intersectedLineSegment[1]];\n            const intersectionCoordinate = getLinesIntersection(p1, q1, p2, q2);\n            const targetStartPointDistSquared = mathPoint.distanceToPointSquared(p1, intersectionCoordinate);\n            return {\n                sourceLineSegmentId,\n                coordinate: intersectionCoordinate,\n                targetStartPointDistSquared,\n            };\n        });\n        intersectionsInfo.sort((left, right) => left.targetStartPointDistSquared - right.targetStartPointDistSquared);\n        intersectionsInfo.forEach((intersectionInfo) => {\n            const { sourceLineSegmentId, coordinate: intersectionCoordinate } = intersectionInfo;\n            const targetEdgePoint = {\n                type: PolylinePointType.Intersection,\n                coordinates: intersectionCoordinate,\n                position: PolylinePointPosition.Edge,\n                direction: intersectionPointDirection,\n                visited: false,\n                next: null,\n            };\n            const sourceEdgePoint = {\n                ...targetEdgePoint,\n                direction: PolylinePointDirection.Unknown,\n                cloned: true,\n            };\n            if (intersectionPointDirection === PolylinePointDirection.Entering) {\n                targetEdgePoint.next = sourceEdgePoint;\n            }\n            else {\n                sourceEdgePoint.next = targetEdgePoint;\n            }\n            let sourceIntersectionPoints = sourceIntersectionsCache.get(sourceLineSegmentId);\n            if (!sourceIntersectionPoints) {\n                sourceIntersectionPoints = [];\n                sourceIntersectionsCache.set(sourceLineSegmentId, sourceIntersectionPoints);\n            }\n            targetPolylinePoints.push(targetEdgePoint);\n            sourceIntersectionPoints.push(sourceEdgePoint);\n            intersectionPointDirection *= -1;\n        });\n    }\n    for (let i = 0, len = sourcePolyline.length; i < len; i++) {\n        const lineSegmentId = i;\n        const p1 = sourcePolyline[i];\n        const vertexPoint = {\n            type: PolylinePointType.Vertex,\n            coordinates: p1,\n            visited: false,\n            next: null,\n        };\n        sourcePolylinePoints.push(vertexPoint);\n        const sourceIntersectionPoints = sourceIntersectionsCache.get(lineSegmentId);\n        if (!sourceIntersectionPoints?.length) {\n            continue;\n        }\n        sourceIntersectionPoints\n            .map((intersectionPoint) => ({\n            intersectionPoint,\n            lineSegStartDistSquared: mathPoint.distanceToPointSquared(p1, intersectionPoint.coordinates),\n        }))\n            .sort((left, right) => left.lineSegStartDistSquared - right.lineSegStartDistSquared)\n            .map(({ intersectionPoint }) => intersectionPoint)\n            .forEach((intersectionPoint) => sourcePolylinePoints.push(intersectionPoint));\n    }\n    ensuresNextPointers(targetPolylinePoints);\n    ensuresNextPointers(sourcePolylinePoints);\n    return { targetPolylinePoints, sourcePolylinePoints };\n}\nfunction getUnvisitedOutsidePoint(polylinePoints) {\n    for (let i = 0, len = polylinePoints.length; i < len; i++) {\n        const point = polylinePoints[i];\n        if (!point.visited &&\n            point.position === PolylinePointPosition.Outside &&\n            point.type === PolylinePointType.Vertex) {\n            return point;\n        }\n    }\n    for (let i = 0, len = polylinePoints.length; i < len; i++) {\n        const point = polylinePoints[i];\n        if (!point.visited && point.position === PolylinePointPosition.Outside) {\n            return point;\n        }\n    }\n    return undefined;\n}\nfunction mergePolylines(targetPolyline, sourcePolyline) {\n    const targetNormal = getNormal2(targetPolyline);\n    const sourceNormal = getNormal2(sourcePolyline);\n    const dotNormals = vec3.dot(sourceNormal, targetNormal);\n    if (!glMatrix.equals(1, dotNormals)) {\n        sourcePolyline = sourcePolyline.slice().reverse();\n    }\n    const lineSegmentsIntersect = intersectPolyline(sourcePolyline, targetPolyline);\n    const targetContainedInSource = !lineSegmentsIntersect && containsPoints(sourcePolyline, targetPolyline);\n    if (targetContainedInSource) {\n        return sourcePolyline.slice();\n    }\n    const { targetPolylinePoints } = getSourceAndTargetPointsList(targetPolyline, sourcePolyline);\n    const startPoint = getUnvisitedOutsidePoint(targetPolylinePoints);\n    if (!startPoint) {\n        return targetPolyline.slice();\n    }\n    const mergedPolyline = [startPoint.coordinates];\n    let currentPoint = startPoint.next;\n    let iterationCount = 0;\n    const maxIterations = targetPolyline.length + sourcePolyline.length + 1000;\n    while (currentPoint !== startPoint && iterationCount < maxIterations) {\n        iterationCount++;\n        if (currentPoint.type === PolylinePointType.Intersection &&\n            currentPoint.cloned) {\n            currentPoint = currentPoint.next;\n            continue;\n        }\n        mergedPolyline.push(currentPoint.coordinates);\n        currentPoint = currentPoint.next;\n        if (!currentPoint) {\n            console.warn('Broken linked list detected in mergePolylines, breaking loop');\n            break;\n        }\n    }\n    if (iterationCount >= maxIterations) {\n        console.warn('Maximum iterations reached in mergePolylines, possible infinite loop detected');\n    }\n    return mergedPolyline;\n}\nexport { mergePolylines };\n", "import * as mathLine from '../line';\nconst DEFAULT_EPSILON = 0.1;\nexport default function decimate(polyline, epsilon = DEFAULT_EPSILON) {\n    const numPoints = polyline.length;\n    if (numPoints < 3) {\n        return polyline;\n    }\n    const epsilonSquared = epsilon * epsilon;\n    const partitionQueue = [[0, numPoints - 1]];\n    const polylinePointFlags = new Array(numPoints).fill(false);\n    let numDecimatedPoints = 2;\n    polylinePointFlags[0] = true;\n    polylinePointFlags[numPoints - 1] = true;\n    while (partitionQueue.length) {\n        const [startIndex, endIndex] = partitionQueue.pop();\n        if (endIndex - startIndex === 1) {\n            continue;\n        }\n        const startPoint = polyline[startIndex];\n        const endPoint = polyline[endIndex];\n        let maxDistSquared = -Infinity;\n        let maxDistIndex = -1;\n        for (let i = startIndex + 1; i < endIndex; i++) {\n            const currentPoint = polyline[i];\n            const distSquared = mathLine.distanceToPointSquared(startPoint, endPoint, currentPoint);\n            if (distSquared > maxDistSquared) {\n                maxDistSquared = distSquared;\n                maxDistIndex = i;\n            }\n        }\n        if (maxDistSquared < epsilonSquared) {\n            continue;\n        }\n        polylinePointFlags[maxDistIndex] = true;\n        numDecimatedPoints++;\n        partitionQueue.push([maxDistIndex, endIndex]);\n        partitionQueue.push([startIndex, maxDistIndex]);\n    }\n    const decimatedPolyline = new Array(numDecimatedPoints);\n    for (let srcIndex = 0, dstIndex = 0; srcIndex < numPoints; srcIndex++) {\n        if (polylinePointFlags[srcIndex]) {\n            decimatedPolyline[dstIndex++] = polyline[srcIndex];\n        }\n    }\n    return decimatedPolyline;\n}\n", "import getLineSegmentIntersectionsIndexes from './getLineSegmentIntersectionsIndexes';\nimport getLinesIntersection from './getLinesIntersection';\nexport default function getLineSegmentIntersectionsCoordinates(points, p1, q1, closed = true) {\n    const result = [];\n    const polylineIndexes = getLineSegmentIntersectionsIndexes(points, p1, q1, closed);\n    for (let i = 0; i < polylineIndexes.length; i++) {\n        const p2 = points[polylineIndexes[i][0]];\n        const q2 = points[polylineIndexes[i][1]];\n        const intersection = getLinesIntersection(p1, q1, p2, q2);\n        result.push(intersection);\n    }\n    return result;\n}\n", "import { vec2 } from 'gl-matrix';\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\nexport default function getClosestLineSegmentIntersection(points, p1, q1, closed = true) {\n    let initialQ2Index;\n    let p2Index;\n    if (closed) {\n        p2Index = points.length - 1;\n        initialQ2Index = 0;\n    }\n    else {\n        p2Index = 0;\n        initialQ2Index = 1;\n    }\n    const intersections = [];\n    for (let q2Index = initialQ2Index; q2Index < points.length; q2Index++) {\n        const p2 = points[p2Index];\n        const q2 = points[q2Index];\n        if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n            intersections.push([p2Index, q2Index]);\n        }\n        p2Index = q2Index;\n    }\n    if (intersections.length === 0) {\n        return;\n    }\n    const distances = [];\n    intersections.forEach((intersection) => {\n        const intersectionPoints = [\n            points[intersection[0]],\n            points[intersection[1]],\n        ];\n        const midpoint = [\n            (intersectionPoints[0][0] + intersectionPoints[1][0]) / 2,\n            (intersectionPoints[0][1] + intersectionPoints[1][1]) / 2,\n        ];\n        distances.push(vec2.distance(midpoint, p1));\n    });\n    const minDistance = Math.min(...distances);\n    const indexOfMinDistance = distances.indexOf(minDistance);\n    return {\n        segment: intersections[indexOfMinDistance],\n        distance: minDistance,\n    };\n}\n", "import { StackViewport } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nconst EPSILON = 1e-3;\nconst getSubPixelSpacingAndXYDirections = (viewport, subPixelResolution) => {\n    let spacing;\n    let xDir;\n    let yDir;\n    if (viewport instanceof StackViewport) {\n        const imageData = viewport.getImageData();\n        if (!imageData) {\n            return;\n        }\n        xDir = imageData.direction.slice(0, 3);\n        yDir = imageData.direction.slice(3, 6);\n        spacing = imageData.spacing;\n    }\n    else {\n        const imageData = viewport.getImageData();\n        const { direction, spacing: volumeSpacing } = imageData;\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\n        const iVector = direction.slice(0, 3);\n        const jVector = direction.slice(3, 6);\n        const kVector = direction.slice(6, 9);\n        const viewRight = vec3.create();\n        vec3.cross(viewRight, viewUp, viewPlaneNormal);\n        const absViewRightDotI = Math.abs(vec3.dot(viewRight, iVector));\n        const absViewRightDotJ = Math.abs(vec3.dot(viewRight, jVector));\n        const absViewRightDotK = Math.abs(vec3.dot(viewRight, kVector));\n        let xSpacing;\n        if (Math.abs(1 - absViewRightDotI) < EPSILON) {\n            xSpacing = volumeSpacing[0];\n            xDir = iVector;\n        }\n        else if (Math.abs(1 - absViewRightDotJ) < EPSILON) {\n            xSpacing = volumeSpacing[1];\n            xDir = jVector;\n        }\n        else if (Math.abs(1 - absViewRightDotK) < EPSILON) {\n            xSpacing = volumeSpacing[2];\n            xDir = kVector;\n        }\n        else {\n            throw new Error('No support yet for oblique plane planar contours');\n        }\n        const absViewUpDotI = Math.abs(vec3.dot(viewUp, iVector));\n        const absViewUpDotJ = Math.abs(vec3.dot(viewUp, jVector));\n        const absViewUpDotK = Math.abs(vec3.dot(viewUp, kVector));\n        let ySpacing;\n        if (Math.abs(1 - absViewUpDotI) < EPSILON) {\n            ySpacing = volumeSpacing[0];\n            yDir = iVector;\n        }\n        else if (Math.abs(1 - absViewUpDotJ) < EPSILON) {\n            ySpacing = volumeSpacing[1];\n            yDir = jVector;\n        }\n        else if (Math.abs(1 - absViewUpDotK) < EPSILON) {\n            ySpacing = volumeSpacing[2];\n            yDir = kVector;\n        }\n        else {\n            throw new Error('No support yet for oblique plane planar contours');\n        }\n        spacing = [xSpacing, ySpacing];\n    }\n    const subPixelSpacing = [\n        spacing[0] / subPixelResolution,\n        spacing[1] / subPixelResolution,\n    ];\n    return { spacing: subPixelSpacing, xDir, yDir };\n};\nexport default getSubPixelSpacingAndXYDirections;\n", "import { vec2 } from 'gl-matrix';\nconst pointsAreWithinCloseContourProximity = (p1, p2, closeContourProximity) => {\n    return vec2.dist(p1, p2) < closeContourProximity;\n};\nexport default pointsAreWithinCloseContourProximity;\n", "import { getEnabledElement } from '@cornerstonejs/core';\nimport { vec2, vec3 } from 'gl-matrix';\nconst addCanvasPointsToArray = (element, canvasPoints, newCanvasPoint, commonData) => {\n    const { xDir, yDir, spacing } = commonData;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    if (!canvasPoints.length) {\n        canvasPoints.push(newCanvasPoint);\n        console.log('>>>>> !canvasPoints. :: RETURN');\n        return 1;\n    }\n    const lastWorldPos = viewport.canvasToWorld(canvasPoints[canvasPoints.length - 1]);\n    const newWorldPos = viewport.canvasToWorld(newCanvasPoint);\n    const worldPosDiff = vec3.create();\n    vec3.subtract(worldPosDiff, newWorldPos, lastWorldPos);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    const numPointsToAdd = Math.max(Math.floor(xDist / spacing[0]), Math.floor(yDist / spacing[0]));\n    if (numPointsToAdd > 1) {\n        const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n        const canvasDist = vec2.dist(lastCanvasPoint, newCanvasPoint);\n        const canvasDir = vec2.create();\n        vec2.subtract(canvasDir, newCanvasPoint, lastCanvasPoint);\n        vec2.set(canvasDir, canvasDir[0] / canvasDist, canvasDir[1] / canvasDist);\n        const distPerPoint = canvasDist / numPointsToAdd;\n        for (let i = 1; i <= numPointsToAdd; i++) {\n            canvasPoints.push([\n                lastCanvasPoint[0] + distPerPoint * canvasDir[0] * i,\n                lastCanvasPoint[1] + distPerPoint * canvasDir[1] * i,\n            ]);\n        }\n    }\n    else {\n        canvasPoints.push(newCanvasPoint);\n    }\n    return numPointsToAdd;\n};\nexport default addCanvasPointsToArray;\n", "import { vec2 } from 'gl-matrix';\nconst pointCanProjectOnLine = (p, p1, p2, proximity) => {\n    const p1p = [p[0] - p1[0], p[1] - p1[1]];\n    const p1p2 = [p2[0] - p1[0], p2[1] - p1[1]];\n    const dot = p1p[0] * p1p2[0] + p1p[1] * p1p2[1];\n    if (dot < 0) {\n        return false;\n    }\n    const p1p2Mag = Math.sqrt(p1p2[0] * p1p2[0] + p1p2[1] * p1p2[1]);\n    if (p1p2Mag === 0) {\n        return false;\n    }\n    const projectionVectorMag = dot / p1p2Mag;\n    const p1p2UnitVector = [p1p2[0] / p1p2Mag, p1p2[1] / p1p2Mag];\n    const projectionVector = [\n        p1p2UnitVector[0] * projectionVectorMag,\n        p1p2UnitVector[1] * projectionVectorMag,\n    ];\n    const projectionPoint = [\n        p1[0] + projectionVector[0],\n        p1[1] + projectionVector[1],\n    ];\n    const distance = vec2.distance(p, projectionPoint);\n    if (distance > proximity) {\n        return false;\n    }\n    if (vec2.distance(p1, projectionPoint) > vec2.distance(p1, p2)) {\n        return false;\n    }\n    return true;\n};\nexport default pointCanProjectOnLine;\n", "import { utilities } from '@cornerstonejs/core';\nconst epsilon = 1e-6;\nexport function projectTo2D(polyline) {\n    let sharedDimensionIndex;\n    const testPoints = utilities.getRandomSampleFromArray(polyline, 50);\n    for (let i = 0; i < 3; i++) {\n        if (testPoints.every((point, index, array) => Math.abs(point[i] - array[0][i]) < epsilon)) {\n            sharedDimensionIndex = i;\n            break;\n        }\n    }\n    if (sharedDimensionIndex === undefined) {\n        throw new Error('Cannot find a shared dimension index for polyline, probably oblique plane');\n    }\n    const points2D = [];\n    const firstDim = (sharedDimensionIndex + 1) % 3;\n    const secondDim = (sharedDimensionIndex + 2) % 3;\n    for (let i = 0; i < polyline.length; i++) {\n        points2D.push([polyline[i][firstDim], polyline[i][secondDim]]);\n    }\n    return {\n        sharedDimensionIndex,\n        projectedPolyline: points2D,\n    };\n}\n", "import containsPoint from './containsPoint';\nimport { projectTo2D } from './projectTo2D';\nexport function isPointInsidePolyline3D(point, polyline, options = {}) {\n    const { sharedDimensionIndex, projectedPolyline } = projectTo2D(polyline);\n    const { holes } = options;\n    const projectedHoles = [];\n    if (holes) {\n        for (let i = 0; i < holes.length; i++) {\n            const hole = holes[i];\n            const hole2D = [];\n            for (let j = 0; j < hole.length; j++) {\n                hole2D.push([\n                    hole[j][(sharedDimensionIndex + 1) % 3],\n                    hole[j][(sharedDimensionIndex + 2) % 3],\n                ]);\n            }\n            projectedHoles.push(hole2D);\n        }\n    }\n    const point2D = [\n        point[(sharedDimensionIndex + 1) % 3],\n        point[(sharedDimensionIndex + 2) % 3],\n    ];\n    return containsPoint(projectedPolyline, point2D, { holes: projectedHoles });\n}\n", "export default function convexHull(pts) {\n    if (pts.length < 3) {\n        return pts.slice();\n    }\n    const points = pts\n        .map((p) => [p[0], p[1]])\n        .sort((a, b) => a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]);\n    function cross(o, a, b) {\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n    }\n    const lower = [];\n    for (const p of points) {\n        while (lower.length >= 2 &&\n            cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {\n            lower.pop();\n        }\n        lower.push(p);\n    }\n    const upper = [];\n    for (let i = points.length - 1; i >= 0; i--) {\n        const p = points[i];\n        while (upper.length >= 2 &&\n            cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {\n            upper.pop();\n        }\n        upper.push(p);\n    }\n    lower.pop();\n    upper.pop();\n    return lower.concat(upper);\n}\n", "import distanceToPoint from './distanceToPoint';\nexport { distanceToPoint };\n", "import * as lineSegment from '../line';\nfunction rectToLineSegments(left, top, width, height) {\n    const topLineStart = [left, top];\n    const topLineEnd = [left + width, top];\n    const rightLineStart = [left + width, top];\n    const rightLineEnd = [left + width, top + height];\n    const bottomLineStart = [left + width, top + height];\n    const bottomLineEnd = [left, top + height];\n    const leftLineStart = [left, top + height];\n    const leftLineEnd = [left, top];\n    const lineSegments = {\n        top: [topLineStart, topLineEnd],\n        right: [rightLineStart, rightLineEnd],\n        bottom: [bottomLineStart, bottomLineEnd],\n        left: [leftLineStart, leftLineEnd],\n    };\n    return lineSegments;\n}\nexport default function distanceToPoint(rect, point) {\n    if (rect.length !== 4 || point.length !== 2) {\n        throw Error('rectangle:[left, top, width, height] or point: [x,y] not defined correctly');\n    }\n    const [left, top, width, height] = rect;\n    let minDistance = 655535;\n    const lineSegments = rectToLineSegments(left, top, width, height);\n    Object.keys(lineSegments).forEach((segment) => {\n        const [lineStart, lineEnd] = lineSegments[segment];\n        const distance = lineSegment.distanceToPoint(lineStart, lineEnd, point);\n        if (distance < minDistance) {\n            minDistance = distance;\n        }\n    });\n    return minDistance;\n}\n", "import findClosestPoint from './findClosestPoint';\nimport liangBarksyClip from './liangBarksyClip';\nexport { findClosestPoint, liangBarksyClip };\n", "export default function findClosestPoint(sourcePoints, targetPoint) {\n    let minPoint = [0, 0];\n    let minDistance = Number.MAX_SAFE_INTEGER;\n    sourcePoints.forEach(function (sourcePoint) {\n        const distance = _distanceBetween(targetPoint, sourcePoint);\n        if (distance < minDistance) {\n            minDistance = distance;\n            minPoint = [...sourcePoint];\n        }\n    });\n    return minPoint;\n}\nfunction _distanceBetween(p1, p2) {\n    const [x1, y1] = p1;\n    const [x2, y2] = p2;\n    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n}\n", "const EPSILON = 1e-6;\nconst INSIDE = 1;\nconst OUTSIDE = 0;\nfunction clipT(num, denom, c) {\n    const [tE, tL] = c;\n    if (Math.abs(denom) < EPSILON) {\n        return num < 0;\n    }\n    const t = num / denom;\n    if (denom > 0) {\n        if (t > tL) {\n            return 0;\n        }\n        if (t > tE) {\n            c[0] = t;\n        }\n    }\n    else {\n        if (t < tE) {\n            return 0;\n        }\n        if (t < tL) {\n            c[1] = t;\n        }\n    }\n    return 1;\n}\nexport default function clip(a, b, box, da, db) {\n    const [x1, y1] = a;\n    const [x2, y2] = b;\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    if (da === undefined || db === undefined) {\n        da = a;\n        db = b;\n    }\n    else {\n        da[0] = a[0];\n        da[1] = a[1];\n        db[0] = b[0];\n        db[1] = b[1];\n    }\n    if (Math.abs(dx) < EPSILON &&\n        Math.abs(dy) < EPSILON &&\n        x1 >= box[0] &&\n        x1 <= box[2] &&\n        y1 >= box[1] &&\n        y1 <= box[3]) {\n        return INSIDE;\n    }\n    const c = [0, 1];\n    if (clipT(box[0] - x1, dx, c) &&\n        clipT(x1 - box[2], -dx, c) &&\n        clipT(box[1] - y1, dy, c) &&\n        clipT(y1 - box[3], -dy, c)) {\n        const [tE, tL] = c;\n        if (tL < 1) {\n            db[0] = x1 + tL * dx;\n            db[1] = y1 + tL * dy;\n        }\n        if (tE > 0) {\n            da[0] += tE * dx;\n            da[1] += tE * dy;\n        }\n        return INSIDE;\n    }\n    return OUTSIDE;\n}\n", "import angleBetweenLines from './angleBetweenLines';\nexport { angleBetweenLines };\n", "import { vec2, vec3 } from 'gl-matrix';\nfunction angleBetween3DLines(line1, line2) {\n    const [p1, p2] = line1;\n    const [p3, p4] = line2;\n    const v1 = vec3.sub(vec3.create(), p2, p1);\n    const v2 = vec3.sub(vec3.create(), p3, p4);\n    const dot = vec3.dot(v1, v2);\n    const v1Length = vec3.length(v1);\n    const v2Length = vec3.length(v2);\n    const cos = dot / (v1Length * v2Length);\n    const radian = Math.acos(cos);\n    return (radian * 180) / Math.PI;\n}\nfunction angleBetween2DLines(line1, line2) {\n    const [p1, p2] = line1;\n    const [p3, p4] = line2;\n    const v1 = vec2.sub(vec2.create(), p2, p1);\n    const v2 = vec2.sub(vec2.create(), p3, p4);\n    const dot = vec2.dot(v1, v2);\n    const v1Length = vec2.length(v1);\n    const v2Length = vec2.length(v2);\n    const cos = dot / (v1Length * v2Length);\n    return Math.acos(cos) * (180 / Math.PI);\n}\nexport default function angleBetweenLines(line1, line2) {\n    const is3D = line1[0].length === 3;\n    return is3D\n        ? angleBetween3DLines(line1, line2)\n        : angleBetween2DLines(line1, line2);\n}\n", "import { utilities as csUtils } from '@cornerstonejs/core';\nimport * as math from '../math';\nimport { getParentAnnotation, invalidateAnnotation, } from '../../stateManagement/annotation/annotationState';\nexport default function updateContourPolyline(annotation, polylineData, transforms, options) {\n    const { canvasToWorld, worldToCanvas } = transforms;\n    const { data } = annotation;\n    const { targetWindingDirection } = polylineData;\n    let { points: polyline } = polylineData;\n    let windingDirection = math.polyline.getWindingDirection(polyline);\n    if (options?.decimate?.enabled) {\n        polyline = math.polyline.decimate(polylineData.points, options?.decimate?.epsilon);\n    }\n    let { closed } = polylineData;\n    const numPoints = polyline.length;\n    const polylineWorldPoints = new Array(numPoints);\n    const currentPolylineWindingDirection = math.polyline.getWindingDirection(polyline);\n    const parentAnnotation = getParentAnnotation(annotation);\n    if (closed === undefined) {\n        let currentClosedState = false;\n        if (polyline.length > 3) {\n            const lastToFirstDist = math.point.distanceToPointSquared(polyline[0], polyline[numPoints - 1]);\n            currentClosedState = csUtils.isEqual(0, lastToFirstDist);\n        }\n        closed = currentClosedState;\n    }\n    if (options?.updateWindingDirection !== false) {\n        let updatedWindingDirection = parentAnnotation\n            ? parentAnnotation.data.contour.windingDirection * -1\n            : targetWindingDirection;\n        if (updatedWindingDirection === undefined) {\n            updatedWindingDirection = windingDirection;\n        }\n        if (updatedWindingDirection !== windingDirection) {\n            polyline.reverse();\n        }\n        const handlePoints = (data.handles?.points ?? []).map(worldToCanvas);\n        if (handlePoints.length > 2) {\n            const currentHandlesWindingDirection = math.polyline.getWindingDirection(handlePoints);\n            if (currentHandlesWindingDirection !== updatedWindingDirection) {\n                data.handles.points.reverse();\n            }\n        }\n        windingDirection = updatedWindingDirection;\n    }\n    for (let i = 0; i < numPoints; i++) {\n        polylineWorldPoints[i] = canvasToWorld(polyline[i]);\n    }\n    data.contour.polyline = polylineWorldPoints;\n    data.contour.closed = closed;\n    data.contour.windingDirection = windingDirection;\n    invalidateAnnotation(annotation);\n}\n", "import draw from './draw';\nimport drawCircle from './drawCircle';\nimport drawEllipse from './drawEllipse';\nimport drawEllipseByCoordinates from './drawEllipseByCoordinates';\nimport drawHandles from './drawHandles';\nimport drawHandle from './drawHandle';\nimport drawLine from './drawLine';\nimport drawHeight from './drawHeight';\nimport drawPolyline from './drawPolyline';\nimport drawPath from './drawPath';\nimport drawFan from './drawFan';\nimport drawLinkedTextBox from './drawLinkedTextBox';\nimport drawRect from './drawRect';\nimport drawRectByCoordinates from './drawRectByCoordinates';\nimport drawTextBox from './drawTextBox';\nimport drawArrow from './drawArrow';\nimport drawRedactionRect from './drawRedactionRect';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nexport { draw, drawCircle, drawEllipse, drawEllipseByCoordinates, drawFan, drawHandles, drawHandle, drawLine, drawHeight, drawPolyline, drawPath, drawLinkedTextBox, drawRect, drawRectByCoordinates, drawTextBox, drawArrow, drawRedactionRect, setAttributesIfNecessary, setNewAttributesIfValid, };\n", "import { state } from '../store/state';\nimport { getEnabledElement } from '@cornerstonejs/core';\nconst VIEWPORT_ELEMENT = 'viewport-element';\nfunction getSvgDrawingHelper(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewportId, renderingEngineId } = enabledElement;\n    const canvasHash = `${viewportId}:${renderingEngineId}`;\n    const svgLayerElement = _getSvgLayer(element);\n    Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n        state.svgNodeCache[canvasHash][cacheKey].touched = false;\n    });\n    return {\n        svgLayerElement: svgLayerElement,\n        svgNodeCacheForCanvas: state.svgNodeCache,\n        getSvgNode: getSvgNode.bind(this, canvasHash),\n        appendNode: appendNode.bind(this, svgLayerElement, canvasHash),\n        setNodeTouched: setNodeTouched.bind(this, canvasHash),\n        clearUntouched: clearUntouched.bind(this, svgLayerElement, canvasHash),\n    };\n}\nfunction _getSvgLayer(element) {\n    const viewportElement = `.${VIEWPORT_ELEMENT}`;\n    const internalDivElement = element.querySelector(viewportElement);\n    const svgLayer = internalDivElement?.querySelector(':scope > .svg-layer');\n    return svgLayer;\n}\nfunction getSvgNode(canvasHash, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    if (state.svgNodeCache[canvasHash][cacheKey]) {\n        return state.svgNodeCache[canvasHash][cacheKey].domRef;\n    }\n}\nfunction appendNode(svgLayerElement, canvasHash, svgNode, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return null;\n    }\n    state.svgNodeCache[canvasHash][cacheKey] = {\n        touched: true,\n        domRef: svgNode,\n    };\n    svgLayerElement.appendChild(svgNode);\n}\nfunction setNodeTouched(canvasHash, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    if (state.svgNodeCache[canvasHash][cacheKey]) {\n        state.svgNodeCache[canvasHash][cacheKey].touched = true;\n    }\n}\nfunction clearUntouched(svgLayerElement, canvasHash) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n        const cacheEntry = state.svgNodeCache[canvasHash][cacheKey];\n        if (!cacheEntry.touched && cacheEntry.domRef) {\n            svgLayerElement.removeChild(cacheEntry.domRef);\n            delete state.svgNodeCache[canvasHash][cacheKey];\n        }\n    });\n}\nexport default getSvgDrawingHelper;\n", "import getSvgDrawingHelper from './getSvgDrawingHelper';\nfunction draw(element, fn) {\n    const svgDrawingHelper = getSvgDrawingHelper(element);\n    fn(svgDrawingHelper);\n    svgDrawingHelper.clearUntouched();\n}\nexport default draw;\n", "function _getHash(annotationUID, drawingElementType, nodeUID) {\n    return `${annotationUID}::${drawingElementType}::${nodeUID}`;\n}\nexport default _getHash;\n", "export function setAttributesIfNecessary(attributes, svgNode) {\n    Object.keys(attributes).forEach((key) => {\n        const currentValue = svgNode.getAttribute(key);\n        const newValue = attributes[key];\n        if (newValue === undefined || newValue === '') {\n            svgNode.removeAttribute(key);\n        }\n        else if (currentValue !== newValue) {\n            svgNode.setAttribute(key, newValue);\n        }\n    });\n}\nexport default setAttributesIfNecessary;\n", "export function setNewAttributesIfValid(attributes, svgNode) {\n    Object.keys(attributes).forEach((key) => {\n        const newValue = attributes[key];\n        if (newValue !== undefined && newValue !== '') {\n            svgNode.setAttribute(key, newValue);\n        }\n    });\n}\nexport default setNewAttributesIfValid;\n", "import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nfunction drawCircle(svgDrawingHelper, annotationUID, circleUID, center, radius, options = {}, dataId = '') {\n    const { color, fill, width, lineWidth, lineDash, fillOpacity, strokeOpacity, } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        fill: 'transparent',\n        width: '2',\n        lineDash: undefined,\n        lineWidth: undefined,\n        strokeOpacity: 1,\n        fillOpacity: 1,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'circle', circleUID);\n    const existingCircleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const attributes = {\n        cx: `${center[0]}`,\n        cy: `${center[1]}`,\n        r: `${radius}`,\n        stroke: color,\n        fill,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n        'fill-opacity': fillOpacity,\n        'stroke-opacity': strokeOpacity,\n    };\n    if (existingCircleElement) {\n        setAttributesIfNecessary(attributes, existingCircleElement);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newCircleElement = document.createElementNS(svgns, 'circle');\n        if (dataId !== '') {\n            newCircleElement.setAttribute('data-id', dataId);\n        }\n        setNewAttributesIfValid(attributes, newCircleElement);\n        svgDrawingHelper.appendNode(newCircleElement, svgNodeHash);\n    }\n}\nexport default drawCircle;\n", "import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nfunction drawEllipseByCoordinates(svgDrawingHelper, annotationUID, ellipseUID, canvasCoordinates, options = {}, dataId = '') {\n    const { color, width, lineWidth, lineDash } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'ellipse', ellipseUID);\n    const existingEllipse = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const [bottom, top, left, right] = canvasCoordinates;\n    const w = Math.hypot(left[0] - right[0], left[1] - right[1]);\n    const h = Math.hypot(top[0] - bottom[0], top[1] - bottom[1]);\n    const angle = (Math.atan2(left[1] - right[1], left[0] - right[0]) * 180) / Math.PI;\n    const center = [(left[0] + right[0]) / 2, (top[1] + bottom[1]) / 2];\n    const radiusX = w / 2;\n    const radiusY = h / 2;\n    const attributes = {\n        cx: `${center[0]}`,\n        cy: `${center[1]}`,\n        rx: `${radiusX}`,\n        ry: `${radiusY}`,\n        stroke: color,\n        fill: 'transparent',\n        transform: `rotate(${angle} ${center[0]} ${center[1]})`,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingEllipse) {\n        setAttributesIfNecessary(attributes, existingEllipse);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const svgEllipseElement = document.createElementNS(svgns, 'ellipse');\n        if (dataId !== '') {\n            svgEllipseElement.setAttribute('data-id', dataId);\n        }\n        setNewAttributesIfValid(attributes, svgEllipseElement);\n        svgDrawingHelper.appendNode(svgEllipseElement, svgNodeHash);\n    }\n}\nexport default drawEllipseByCoordinates;\n", "import _getHash from './_getHash';\nimport drawEllipseByCoordinates from './drawEllipseByCoordinates';\nfunction drawEllipse(svgDrawingHelper, annotationUID, ellipseUID, corner1, corner2, options = {}, dataId = '') {\n    const top = [(corner1[0] + corner2[0]) / 2, corner1[1]];\n    const bottom = [(corner1[0] + corner2[0]) / 2, corner2[1]];\n    const left = [corner1[0], (corner1[1] + corner2[1]) / 2];\n    const right = [corner2[0], (corner1[1] + corner2[1]) / 2];\n    drawEllipseByCoordinates(svgDrawingHelper, annotationUID, ellipseUID, [bottom, top, left, right], (options = {}), (dataId = ''));\n}\nexport default drawEllipse;\n", "import _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nfunction drawHandle(svgDrawingHelper, annotationUID, handleGroupUID, handle, options = {}, uniqueIndex) {\n    const { color, handleRadius, width, lineWidth, fill, type, opacity } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        handleRadius: '6',\n        width: '2',\n        lineWidth: undefined,\n        fill: 'transparent',\n        type: 'circle',\n        opacity: 1,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'handle', `hg-${handleGroupUID}-index-${uniqueIndex}`);\n    let attributes;\n    if (type === 'circle') {\n        attributes = {\n            cx: `${handle[0]}`,\n            cy: `${handle[1]}`,\n            r: handleRadius,\n            stroke: color,\n            fill,\n            'stroke-width': strokeWidth,\n            opacity: opacity,\n        };\n    }\n    else if (type === 'rect') {\n        const handleRadiusFloat = parseFloat(handleRadius);\n        const side = handleRadiusFloat * 1.5;\n        const x = handle[0] - side * 0.5;\n        const y = handle[1] - side * 0.5;\n        attributes = {\n            x: `${x}`,\n            y: `${y}`,\n            width: `${side}`,\n            height: `${side}`,\n            stroke: color,\n            fill,\n            'stroke-width': strokeWidth,\n            rx: `${side * 0.1}`,\n            opacity: opacity,\n        };\n    }\n    else {\n        throw new Error(`Unsupported handle type: ${type}`);\n    }\n    const existingHandleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n    if (existingHandleElement) {\n        setAttributesIfNecessary(attributes, existingHandleElement);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newHandleElement = document.createElementNS(svgns, type);\n        setNewAttributesIfValid(attributes, newHandleElement);\n        svgDrawingHelper.appendNode(newHandleElement, svgNodeHash);\n    }\n}\nexport default drawHandle;\n", "import drawHandle from './drawHandle';\nfunction drawHandles(svgDrawingHelper, annotationUID, handleGroupUID, handlePoints, options = {}) {\n    handlePoints.forEach((handle, i) => {\n        drawHandle(svgDrawingHelper, annotationUID, handleGroupUID, handle, options, i);\n    });\n}\nexport default drawHandles;\n", "import _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nexport default function drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, options = {}, dataId = '') {\n    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n        return;\n    }\n    const { color = 'rgb(0, 255, 0)', width = 10, lineWidth, lineDash, markerStartId = null, markerEndId = null, shadow = false, strokeOpacity = 1, } = options;\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'line', lineUID);\n    const existingLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const layerId = svgDrawingHelper.svgLayerElement.id;\n    const dropShadowStyle = shadow ? `filter:url(#shadow-${layerId});` : '';\n    const attributes = {\n        x1: `${start[0]}`,\n        y1: `${start[1]}`,\n        x2: `${end[0]}`,\n        y2: `${end[1]}`,\n        stroke: color,\n        style: dropShadowStyle,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n        'marker-start': markerStartId ? `url(#${markerStartId})` : '',\n        'marker-end': markerEndId ? `url(#${markerEndId})` : '',\n        'stroke-opacity': strokeOpacity,\n    };\n    if (existingLine) {\n        setAttributesIfNecessary(attributes, existingLine);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newLine = document.createElementNS(svgns, 'line');\n        if (dataId !== '') {\n            newLine.setAttribute('data-id', dataId);\n        }\n        setNewAttributesIfValid(attributes, newLine);\n        svgDrawingHelper.appendNode(newLine, svgNodeHash);\n    }\n}\n", "import drawLine from './drawLine';\nexport default function drawHeight(svgDrawingHelper, annotationUID, heightUID, start, end, options = {}) {\n    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n        return;\n    }\n    const { color, width, lineWidth, lineDash } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const midX = end[0] + (start[0] - end[0]) / 2;\n    const endfirstLine = [midX, start[1]];\n    const endsecondLine = [midX, end[1]];\n    const firstLine = {\n        start: start,\n        end: endfirstLine,\n    };\n    const secondLine = {\n        start: endfirstLine,\n        end: endsecondLine,\n    };\n    const threeLine = {\n        start: endsecondLine,\n        end: end,\n    };\n    drawLine(svgDrawingHelper, annotationUID, '1', firstLine.start, firstLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '2', secondLine.start, secondLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '3', threeLine.start, threeLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n}\n", "import _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nexport default function drawPolyline(svgDrawingHelper, annotationUID, polylineUID, points, options) {\n    if (points.length < 2) {\n        return;\n    }\n    const { color = 'rgb(0, 255, 0)', width = 10, fillColor = 'none', fillOpacity = 0, lineWidth, lineDash, closePath = false, markerStartId = null, markerEndId = null, } = options;\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'polyline', polylineUID);\n    const existingPolyLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n    let pointsAttribute = '';\n    for (const point of points) {\n        pointsAttribute += `${point[0].toFixed(1)}, ${point[1].toFixed(1)} `;\n    }\n    if (closePath) {\n        const firstPoint = points[0];\n        pointsAttribute += `${firstPoint[0]}, ${firstPoint[1]}`;\n    }\n    const attributes = {\n        points: pointsAttribute,\n        stroke: color,\n        fill: fillColor,\n        'fill-opacity': fillOpacity,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n        'marker-start': markerStartId ? `url(#${markerStartId})` : '',\n        'marker-end': markerEndId ? `url(#${markerEndId})` : '',\n    };\n    if (existingPolyLine) {\n        setAttributesIfNecessary(attributes, existingPolyLine);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newPolyLine = document.createElementNS(svgns, 'polyline');\n        setNewAttributesIfValid(attributes, newPolyLine);\n        svgDrawingHelper.appendNode(newPolyLine, svgNodeHash);\n    }\n}\n", "import _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nexport default function drawPath(svgDrawingHelper, annotationUID, pathUID, points, options) {\n    const hasSubArrays = points.length && points[0].length && Array.isArray(points[0][0]);\n    const pointsArrays = hasSubArrays ? points : [points];\n    const { color = 'rgb(0, 255, 0)', width = 10, fillColor = 'none', fillOpacity = 0, lineWidth, lineDash, closePath = false, } = options;\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'path', pathUID);\n    const existingNode = svgDrawingHelper.getSvgNode(svgNodeHash);\n    let pointsAttribute = '';\n    for (let i = 0, numArrays = pointsArrays.length; i < numArrays; i++) {\n        const points = pointsArrays[i];\n        const numPoints = points.length;\n        if (numPoints < 2) {\n            continue;\n        }\n        for (let j = 0; j < numPoints; j++) {\n            const point = points[j];\n            const cmd = j ? 'L' : 'M';\n            pointsAttribute += `${cmd} ${point[0].toFixed(1)}, ${point[1].toFixed(1)} `;\n        }\n        if (closePath) {\n            pointsAttribute += 'Z ';\n        }\n    }\n    if (!pointsAttribute) {\n        return;\n    }\n    const attributes = {\n        d: pointsAttribute,\n        stroke: color,\n        fill: fillColor,\n        'fill-opacity': fillOpacity,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingNode) {\n        setAttributesIfNecessary(attributes, existingNode);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newNode = document.createElementNS(svgns, 'path');\n        setNewAttributesIfValid(attributes, newNode);\n        svgDrawingHelper.appendNode(newNode, svgNodeHash);\n    }\n}\n", "import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nfunction drawFan(svgDrawingHelper, annotationUID, fanUID, center, innerRadius, outerRadius, startAngle, endAngle, options = {}, dataId = '', zIndex) {\n    const { color, fill, width, lineWidth, lineDash, fillOpacity, strokeOpacity, } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        fill: 'transparent',\n        width: '2',\n        lineDash: undefined,\n        lineWidth: undefined,\n        strokeOpacity: 1,\n        fillOpacity: 1,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'fan', fanUID);\n    const existingFanElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const startRad = (startAngle * Math.PI) / 180;\n    const endRad = (endAngle * Math.PI) / 180;\n    const centerX = center[0];\n    const centerY = center[1];\n    const outerStartX = centerX + outerRadius * Math.cos(startRad);\n    const outerStartY = centerY + outerRadius * Math.sin(startRad);\n    const outerEndX = centerX + outerRadius * Math.cos(endRad);\n    const outerEndY = centerY + outerRadius * Math.sin(endRad);\n    const innerStartX = centerX + innerRadius * Math.cos(startRad);\n    const innerStartY = centerY + innerRadius * Math.sin(startRad);\n    const innerEndX = centerX + innerRadius * Math.cos(endRad);\n    const innerEndY = centerY + innerRadius * Math.sin(endRad);\n    const largeArcFlag = endAngle - startAngle <= 180 ? 0 : 1;\n    let pathData = `M ${outerStartX} ${outerStartY}`;\n    pathData += ` A ${outerRadius} ${outerRadius} 0 ${largeArcFlag} 1 ${outerEndX} ${outerEndY}`;\n    pathData += ` L ${innerEndX} ${innerEndY}`;\n    pathData += ` A ${innerRadius} ${innerRadius} 0 ${largeArcFlag} 0 ${innerStartX} ${innerStartY}`;\n    pathData += ` Z`;\n    const attributes = {\n        d: pathData,\n        stroke: color,\n        fill,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n        'fill-opacity': fillOpacity,\n        'stroke-opacity': strokeOpacity,\n        'mix-blend-mode': 'normal',\n    };\n    if (existingFanElement) {\n        setAttributesIfNecessary(attributes, existingFanElement);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newFanElement = document.createElementNS(svgns, 'path');\n        if (dataId !== '') {\n            newFanElement.setAttribute('data-id', dataId);\n        }\n        if (zIndex !== undefined) {\n            newFanElement.style.zIndex = zIndex.toString();\n        }\n        setNewAttributesIfValid(attributes, newFanElement);\n        svgDrawingHelper.appendNode(newFanElement, svgNodeHash);\n    }\n}\nexport default drawFan;\n", "import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nfunction drawTextBox(svgDrawingHelper, annotationUID, textUID, textLines, position, options = {}) {\n    const mergedOptions = Object.assign({\n        fontFamily: 'Helvetica, Arial, sans-serif',\n        fontSize: '14px',\n        color: 'rgb(255, 255, 0)',\n        background: '',\n        padding: 25,\n        centerX: false,\n        centerY: true,\n    }, options);\n    const textGroupBoundingBox = _drawTextGroup(svgDrawingHelper, annotationUID, textUID, textLines, position, mergedOptions);\n    return textGroupBoundingBox;\n}\nfunction _drawTextGroup(svgDrawingHelper, annotationUID, textUID, textLines = [''], position, options) {\n    const { padding, color, fontFamily, fontSize, background } = options;\n    let textGroupBoundingBox;\n    const [x, y] = [position[0] + padding, position[1] + padding];\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'text', textUID);\n    const existingTextGroup = svgDrawingHelper.getSvgNode(svgNodeHash);\n    if (existingTextGroup) {\n        const textElement = existingTextGroup.querySelector('text');\n        const textSpans = Array.from(textElement.children);\n        for (let i = 0; i < textSpans.length; i++) {\n            const textSpanElement = textSpans[i];\n            const text = textLines[i] || '';\n            textSpanElement.textContent = text;\n        }\n        if (textLines.length > textSpans.length) {\n            for (let i = 0; i < textLines.length - textSpans.length; i++) {\n                const textLine = textLines[i + textSpans.length];\n                const textSpan = _createTextSpan(textLine);\n                textElement.appendChild(textSpan);\n            }\n            existingTextGroup.appendChild(textElement);\n            svgDrawingHelper.appendNode(existingTextGroup, svgNodeHash);\n        }\n        const textAttributes = {\n            fill: color,\n            'font-size': fontSize,\n            'font-family': fontFamily,\n        };\n        const textGroupAttributes = {\n            transform: `translate(${x} ${y})`,\n        };\n        setAttributesIfNecessary(textAttributes, textElement);\n        setAttributesIfNecessary(textGroupAttributes, existingTextGroup);\n        existingTextGroup.setAttribute('data-annotation-uid', annotationUID);\n        textGroupBoundingBox = _drawTextBackground(existingTextGroup, background);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const textGroup = document.createElementNS(svgns, 'g');\n        textGroup.setAttribute('data-annotation-uid', annotationUID);\n        textGroup.setAttribute('transform', `translate(${x} ${y})`);\n        const textElement = _createTextElement(svgDrawingHelper, options);\n        for (let i = 0; i < textLines.length; i++) {\n            const textLine = textLines[i];\n            const textSpan = _createTextSpan(textLine);\n            textElement.appendChild(textSpan);\n        }\n        textGroup.appendChild(textElement);\n        svgDrawingHelper.appendNode(textGroup, svgNodeHash);\n        textGroupBoundingBox = _drawTextBackground(textGroup, background);\n    }\n    return Object.assign({}, textGroupBoundingBox, {\n        x,\n        y,\n        height: textGroupBoundingBox.height + padding,\n        width: textGroupBoundingBox.width + padding,\n    });\n}\nfunction _createTextElement(svgDrawingHelper, options) {\n    const { color, fontFamily, fontSize } = options;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const textElement = document.createElementNS(svgns, 'text');\n    const noSelectStyle = 'user-select: none; pointer-events: none; -webkit-tap-highlight-color:  rgba(255, 255, 255, 0);';\n    const dropShadowStyle = `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`;\n    const combinedStyle = `${noSelectStyle}${dropShadowStyle}`;\n    textElement.setAttribute('x', '0');\n    textElement.setAttribute('y', '0');\n    textElement.setAttribute('fill', color);\n    textElement.setAttribute('font-family', fontFamily);\n    textElement.setAttribute('font-size', fontSize);\n    textElement.setAttribute('style', combinedStyle);\n    textElement.setAttribute('pointer-events', 'visible');\n    return textElement;\n}\nfunction _createTextSpan(text) {\n    const svgns = 'http://www.w3.org/2000/svg';\n    const textSpanElement = document.createElementNS(svgns, 'tspan');\n    textSpanElement.setAttribute('x', '0');\n    textSpanElement.setAttribute('dy', '1.2em');\n    textSpanElement.textContent = text;\n    return textSpanElement;\n}\nfunction _drawTextBackground(group, color) {\n    let element = group.querySelector('rect.background');\n    if (!color) {\n        if (element) {\n            group.removeChild(element);\n        }\n        return group.getBBox();\n    }\n    if (!element) {\n        element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n        element.setAttribute('class', 'background');\n        group.insertBefore(element, group.firstChild);\n    }\n    const bBox = group.getBBox();\n    const attributes = {\n        x: `${bBox.x}`,\n        y: `${bBox.y}`,\n        width: `${bBox.width}`,\n        height: `${bBox.height}`,\n        fill: color,\n    };\n    setAttributesIfNecessary(attributes, element);\n    return bBox;\n}\nexport default drawTextBox;\n", "import drawLine from './drawLine';\nimport findClosestPoint from '../utilities/math/vec2/findClosestPoint';\nfunction drawLink(svgDrawingHelper, annotationUID, linkUID, annotationAnchorPoints, refPoint, boundingBox, options = {}) {\n    const start = annotationAnchorPoints.length > 0\n        ? findClosestPoint(annotationAnchorPoints, refPoint)\n        : refPoint;\n    const boundingBoxPoints = _boundingBoxPoints(boundingBox);\n    const end = findClosestPoint(boundingBoxPoints, start);\n    const mergedOptions = Object.assign({\n        color: 'rgb(255, 255, 0)',\n        lineWidth: '1',\n        lineDash: '2,3',\n    }, options);\n    drawLine(svgDrawingHelper, annotationUID, `link-${linkUID}`, start, end, mergedOptions);\n}\nfunction _boundingBoxPoints(boundingBox) {\n    const { x: left, y: top, height, width } = boundingBox;\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n    const topMiddle = [left + halfWidth, top];\n    const leftMiddle = [left, top + halfHeight];\n    const bottomMiddle = [left + halfWidth, top + height];\n    const rightMiddle = [left + width, top + halfHeight];\n    return [topMiddle, leftMiddle, bottomMiddle, rightMiddle];\n}\nexport default drawLink;\n", "import drawTextBox from './drawTextBox';\nimport drawLink from './drawLink';\nfunction drawLinkedTextBox(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, annotationAnchorPoints, textBox, options = {}) {\n    const mergedOptions = Object.assign({\n        handleRadius: '6',\n        centering: {\n            x: false,\n            y: true,\n        },\n    }, options);\n    const canvasBoundingBox = drawTextBox(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, mergedOptions);\n    drawLink(svgDrawingHelper, annotationUID, textBoxUID, annotationAnchorPoints, textBoxPosition, canvasBoundingBox, mergedOptions);\n    return canvasBoundingBox;\n}\nexport default drawLinkedTextBox;\n", "import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nexport default function drawRectByCoordinates(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates, options = {}, dataId = '') {\n    const { color, width: _width, lineWidth, lineDash, } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const strokeWidth = lineWidth || _width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n    const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const [topLeft, topRight, bottomLeft, bottomRight] = canvasCoordinates;\n    const width = Math.hypot(topLeft[0] - topRight[0], topLeft[1] - topRight[1]);\n    const height = Math.hypot(topLeft[0] - bottomLeft[0], topLeft[1] - bottomLeft[1]);\n    const center = [\n        (bottomRight[0] + topLeft[0]) / 2,\n        (bottomRight[1] + topLeft[1]) / 2,\n    ];\n    const leftEdgeCenter = [\n        (bottomLeft[0] + topLeft[0]) / 2,\n        (bottomLeft[1] + topLeft[1]) / 2,\n    ];\n    const angle = (Math.atan2(center[1] - leftEdgeCenter[1], center[0] - leftEdgeCenter[0]) *\n        180) /\n        Math.PI;\n    const attributes = {\n        x: `${center[0] - width / 2}`,\n        y: `${center[1] - height / 2}`,\n        width: `${width}`,\n        height: `${height}`,\n        stroke: color,\n        fill: 'transparent',\n        transform: `rotate(${angle} ${center[0]} ${center[1]})`,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingRect) {\n        setAttributesIfNecessary(attributes, existingRect);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const svgRectElement = document.createElementNS(svgns, 'rect');\n        if (dataId !== '') {\n            svgRectElement.setAttribute('data-id', dataId);\n        }\n        setNewAttributesIfValid(attributes, svgRectElement);\n        svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n    }\n}\n", "import _getHash from './_getHash';\nimport drawRectByCoordinates from './drawRectByCoordinates';\nexport default function drawRect(svgDrawingHelper, annotationUID, rectangleUID, start, end, options = {}, dataId = '') {\n    const topLeft = [start[0], start[1]];\n    const topRight = [end[0], start[1]];\n    const bottomLeft = [start[0], end[1]];\n    const bottomRight = [end[0], end[1]];\n    drawRectByCoordinates(svgDrawingHelper, annotationUID, rectangleUID, [topLeft, topRight, bottomLeft, bottomRight], options, dataId);\n}\n", "import drawLine from './drawLine';\nconst svgns = 'http://www.w3.org/2000/svg';\nexport default function drawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options = {}) {\n    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n        return;\n    }\n    const { viaMarker = false, color = 'rgb(0, 255, 0)', markerSize = 10, } = options;\n    if (!viaMarker) {\n        legacyDrawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options);\n        return;\n    }\n    const layerId = svgDrawingHelper.svgLayerElement.id;\n    const markerBaseId = `arrow-${annotationUID}`;\n    const markerFullId = `${markerBaseId}-${layerId}`;\n    const defs = svgDrawingHelper.svgLayerElement.querySelector('defs');\n    let arrowMarker = defs.querySelector(`#${markerFullId}`);\n    if (!arrowMarker) {\n        arrowMarker = document.createElementNS(svgns, 'marker');\n        arrowMarker.setAttribute('id', markerFullId);\n        arrowMarker.setAttribute('viewBox', '0 0 10 10');\n        arrowMarker.setAttribute('refX', '8');\n        arrowMarker.setAttribute('refY', '5');\n        arrowMarker.setAttribute('markerWidth', `${markerSize}`);\n        arrowMarker.setAttribute('markerHeight', `${markerSize}`);\n        arrowMarker.setAttribute('orient', 'auto');\n        const arrowPath = document.createElementNS(svgns, 'path');\n        arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');\n        arrowPath.setAttribute('fill', color);\n        arrowMarker.appendChild(arrowPath);\n        defs.appendChild(arrowMarker);\n    }\n    else {\n        arrowMarker.setAttribute('markerWidth', `${markerSize}`);\n        arrowMarker.setAttribute('markerHeight', `${markerSize}`);\n        const arrowPath = arrowMarker.querySelector('path');\n        if (arrowPath) {\n            arrowPath.setAttribute('fill', color);\n        }\n    }\n    options.markerEndId = markerFullId;\n    drawLine(svgDrawingHelper, annotationUID, arrowUID, start, end, options);\n}\nfunction legacyDrawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options = {}) {\n    const { color = 'rgb(0, 255, 0)', width = 2, lineWidth, lineDash } = options;\n    const headLength = 10;\n    const angle = Math.atan2(end[1] - start[1], end[0] - start[0]);\n    const firstLine = {\n        start: [\n            end[0] - headLength * Math.cos(angle - Math.PI / 7),\n            end[1] - headLength * Math.sin(angle - Math.PI / 7),\n        ],\n        end: end,\n    };\n    const secondLine = {\n        start: [\n            end[0] - headLength * Math.cos(angle + Math.PI / 7),\n            end[1] - headLength * Math.sin(angle + Math.PI / 7),\n        ],\n        end: end,\n    };\n    drawLine(svgDrawingHelper, annotationUID, arrowUID, start, end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '2', firstLine.start, firstLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '3', secondLine.start, secondLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n}\n", "import _getHash from './_getHash';\nimport _setAttributesIfNecessary from './setAttributesIfNecessary';\nimport _setNewAttributesIfValid from './setNewAttributesIfValid';\nexport default function drawRedactionRect(svgDrawingHelper, annotationUID, rectangleUID, start, end, options = {}) {\n    const { color, width: _width, lineWidth, lineDash, } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const strokeWidth = lineWidth || _width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n    const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];\n    const width = Math.abs(start[0] - end[0]);\n    const height = Math.abs(start[1] - end[1]);\n    const attributes = {\n        x: `${tlhc[0]}`,\n        y: `${tlhc[1]}`,\n        width: `${width}`,\n        height: `${height}`,\n        stroke: color,\n        fill: 'black',\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingRect) {\n        _setAttributesIfNecessary(attributes, existingRect);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const svgRectElement = document.createElementNS(svgns, 'rect');\n        _setNewAttributesIfValid(attributes, svgRectElement);\n        svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n    }\n}\n", "import { getEnabledElement } from '@cornerstonejs/core';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nexport default function getToolsWithModesForElement(element, modesFilter) {\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngineId, viewportId } = enabledElement;\n    const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n    if (!toolGroup) {\n        return [];\n    }\n    const enabledTools = [];\n    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n    for (let j = 0; j < toolGroupToolNames.length; j++) {\n        const toolName = toolGroupToolNames[j];\n        const toolOptions = toolGroup.toolOptions[toolName];\n        if (!toolOptions) {\n            continue;\n        }\n        if (modesFilter.includes(toolOptions.mode)) {\n            const toolInstance = toolGroup.getToolInstance(toolName);\n            enabledTools.push(toolInstance);\n        }\n    }\n    return enabledTools;\n}\n", "import { getEnabledElement, triggerEvent, getRenderingEngine, } from '@cornerstonejs/core';\nimport { Events, ToolModes } from '../../enums';\nimport { draw as drawSvg } from '../../drawingSvg';\nimport getToolsWithModesForElement from '../../utilities/getToolsWithModesForElement';\nconst { Active, Passive, Enabled } = ToolModes;\nclass AnnotationRenderingEngine {\n    constructor() {\n        this._needsRender = new Set();\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        this._renderFlaggedViewports = () => {\n            this._throwIfDestroyed();\n            const elements = Array.from(this._viewportElements.values());\n            for (let i = 0; i < elements.length; i++) {\n                const element = elements[i];\n                if (this._needsRender.has(element)) {\n                    this._triggerRender(element);\n                    this._needsRender.delete(element);\n                    if (this._needsRender.size === 0) {\n                        break;\n                    }\n                }\n            }\n            this._animationFrameSet = false;\n            this._animationFrameHandle = null;\n            this._render();\n        };\n        this._viewportElements = new Map();\n    }\n    addViewportElement(viewportId, element) {\n        this._viewportElements.set(viewportId, element);\n    }\n    removeViewportElement(viewportId, element) {\n        this._viewportElements.delete(viewportId);\n        this._needsRender.delete(element);\n        this._reset();\n    }\n    renderViewport(element) {\n        this._setViewportsToBeRenderedNextFrame([element]);\n    }\n    _throwIfDestroyed() {\n        if (this.hasBeenDestroyed) {\n            throw new Error('this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.');\n        }\n    }\n    _setAllViewportsToBeRenderedNextFrame() {\n        const elements = [...this._viewportElements.values()];\n        elements.forEach((element) => {\n            this._needsRender.add(element);\n        });\n        this._renderFlaggedViewports();\n    }\n    _setViewportsToBeRenderedNextFrame(elements) {\n        const elementsEnabled = [...this._viewportElements.values()];\n        elements.forEach((element) => {\n            if (elementsEnabled.indexOf(element) !== -1) {\n                this._needsRender.add(element);\n            }\n        });\n        this._render();\n    }\n    _render() {\n        if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n            this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedViewports);\n            this._animationFrameSet = true;\n        }\n    }\n    _triggerRender(element) {\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        const renderingEngine = getRenderingEngine(enabledElement.renderingEngineId);\n        if (!renderingEngine) {\n            console.warn('rendering Engine has been destroyed');\n            return;\n        }\n        const enabledTools = getToolsWithModesForElement(element, [\n            Active,\n            Passive,\n            Enabled,\n        ]);\n        const { renderingEngineId, viewportId } = enabledElement;\n        const eventDetail = {\n            element,\n            renderingEngineId,\n            viewportId,\n        };\n        drawSvg(element, (svgDrawingHelper) => {\n            let anyRendered = false;\n            const handleDrawSvg = (tool) => {\n                if (tool.renderAnnotation) {\n                    const rendered = tool.renderAnnotation(enabledElement, svgDrawingHelper);\n                    anyRendered = anyRendered || rendered;\n                }\n            };\n            enabledTools.forEach(handleDrawSvg);\n            if (anyRendered) {\n                triggerEvent(element, Events.ANNOTATION_RENDERED, { ...eventDetail });\n            }\n        });\n    }\n    _reset() {\n        window.cancelAnimationFrame(this._animationFrameHandle);\n        this._needsRender.clear();\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        this._setAllViewportsToBeRenderedNextFrame();\n    }\n}\nconst annotationRenderingEngine = new AnnotationRenderingEngine();\nexport { annotationRenderingEngine };\n", "import { annotationRenderingEngine } from '../stateManagement/annotation/AnnotationRenderingEngine';\nfunction triggerAnnotationRender(element) {\n    annotationRenderingEngine.renderViewport(element);\n}\nexport default triggerAnnotationRender;\n", "import { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nexport function triggerAnnotationRenderForViewportIds(viewportIdsToRender) {\n    if (!viewportIdsToRender.length) {\n        return;\n    }\n    viewportIdsToRender.forEach((viewportId) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            console.warn(`Viewport not available for ${viewportId}`);\n            return;\n        }\n        const { viewport } = enabledElement;\n        if (!viewport) {\n            console.warn(`Viewport not available for ${viewportId}`);\n            return;\n        }\n        const element = viewport.element;\n        triggerAnnotationRender(element);\n    });\n}\nexport default triggerAnnotationRenderForViewportIds;\n", "import filterViewportsWithFrameOfReferenceUID from './filterViewportsWithFrameOfReferenceUID';\nimport filterViewportsWithToolEnabled from './filterViewportsWithToolEnabled';\nimport getViewportIdsWithToolToRender from './getViewportIdsWithToolToRender';\nimport filterViewportsWithParallelNormals from './filterViewportsWithParallelNormals';\nexport { filterViewportsWithToolEnabled, filterViewportsWithFrameOfReferenceUID, getViewportIdsWithToolToRender, filterViewportsWithParallelNormals, };\n", "export default function filterViewportsWithFrameOfReferenceUID(viewports, FrameOfReferenceUID) {\n    const numViewports = viewports.length;\n    const viewportsWithFrameOfReferenceUID = [];\n    for (let vp = 0; vp < numViewports; vp++) {\n        const viewport = viewports[vp];\n        if (viewport.getFrameOfReferenceUID() === FrameOfReferenceUID) {\n            viewportsWithFrameOfReferenceUID.push(viewport);\n        }\n    }\n    return viewportsWithFrameOfReferenceUID;\n}\n", "import { ToolModes } from '../../enums';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nconst { Active, Passive, Enabled } = ToolModes;\nexport default function filterViewportsWithToolEnabled(viewports, toolName) {\n    const numViewports = viewports.length;\n    const viewportsWithToolEnabled = [];\n    for (let vp = 0; vp < numViewports; vp++) {\n        const viewport = viewports[vp];\n        const toolGroup = getToolGroupForViewport(viewport.id, viewport.renderingEngineId);\n        if (!toolGroup) {\n            continue;\n        }\n        const hasTool = _toolGroupHasActiveEnabledOrPassiveTool(toolGroup, toolName);\n        if (hasTool) {\n            viewportsWithToolEnabled.push(viewport);\n        }\n    }\n    return viewportsWithToolEnabled;\n}\nfunction _toolGroupHasActiveEnabledOrPassiveTool(toolGroup, toolName) {\n    const { toolOptions } = toolGroup;\n    const tool = toolOptions[toolName];\n    if (!tool) {\n        return false;\n    }\n    const toolMode = tool.mode;\n    return toolMode === Active || toolMode === Passive || toolMode === Enabled;\n}\n", "import { vec3 } from 'gl-matrix';\nexport function filterViewportsWithParallelNormals(viewports, camera, EPS = 0.999) {\n    return viewports.filter((viewport) => {\n        const vpCamera = viewport.getCamera();\n        const isParallel = Math.abs(vec3.dot(vpCamera.viewPlaneNormal, camera.viewPlaneNormal)) >\n            EPS;\n        return isParallel;\n    });\n}\nexport default filterViewportsWithParallelNormals;\n", "import { getEnabledElement } from '@cornerstonejs/core';\nimport filterViewportsWithFrameOfReferenceUID from './filterViewportsWithFrameOfReferenceUID';\nimport filterViewportsWithToolEnabled from './filterViewportsWithToolEnabled';\nimport filterViewportsWithParallelNormals from './filterViewportsWithParallelNormals';\nexport default function getViewportIdsWithToolToRender(element, toolName, requireParallelNormals = true) {\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, FrameOfReferenceUID } = enabledElement;\n    let viewports = renderingEngine.getViewports();\n    viewports = filterViewportsWithFrameOfReferenceUID(viewports, FrameOfReferenceUID);\n    viewports = filterViewportsWithToolEnabled(viewports, toolName);\n    const viewport = renderingEngine.getViewport(enabledElement.viewportId);\n    if (requireParallelNormals) {\n        viewports = filterViewportsWithParallelNormals(viewports, viewport.getCamera());\n    }\n    const viewportIds = viewports.map((vp) => vp.id);\n    return viewportIds;\n}\n", "import { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport * as math from '../math';\nimport updateContourPolyline from '../contours/updateContourPolyline';\nimport { addAnnotation, removeAnnotation, getChildAnnotations, addChildAnnotation, clearParentAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { addContourSegmentationAnnotation } from './addContourSegmentationAnnotation';\nimport { removeContourSegmentationAnnotation } from './removeContourSegmentationAnnotation';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getViewportIdsWithToolToRender } from '../viewportFilters';\nimport { hasToolByName } from '../../store/addTool';\nconst TOLERANCE = 1e-10;\nconst DEFAULT_CONTOUR_SEG_TOOL_NAME = 'PlanarFreehandContourSegmentationTool';\nexport function convertContourPolylineToCanvasSpace(polyline, viewport) {\n    const numPoints = polyline.length;\n    const projectedPolyline = new Array(numPoints);\n    for (let i = 0; i < numPoints; i++) {\n        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n    }\n    return projectedPolyline;\n}\nexport function convertContourPolylineToWorld(polyline, viewport) {\n    const numPoints = polyline.length;\n    const projectedPolyline = new Array(numPoints);\n    for (let i = 0; i < numPoints; i++) {\n        projectedPolyline[i] = viewport.canvasToWorld(polyline[i]);\n    }\n    return projectedPolyline;\n}\nexport function checkIntersection(sourcePolyline, targetPolyline) {\n    const sourceAABB = math.polyline.getAABB(sourcePolyline);\n    const targetAABB = math.polyline.getAABB(targetPolyline);\n    const aabbIntersect = math.aabb.intersectAABB(sourceAABB, targetAABB);\n    if (!aabbIntersect) {\n        return { hasIntersection: false, isContourHole: false };\n    }\n    const lineSegmentsIntersect = math.polyline.intersectPolyline(sourcePolyline, targetPolyline);\n    const isContourHole = !lineSegmentsIntersect &&\n        math.polyline.containsPoints(targetPolyline, sourcePolyline);\n    const hasIntersection = lineSegmentsIntersect || isContourHole;\n    return { hasIntersection, isContourHole };\n}\nexport function getContourHolesData(viewport, annotation) {\n    return getChildAnnotations(annotation).map((holeAnnotation) => {\n        const contourHoleAnnotation = holeAnnotation;\n        const polyline = convertContourPolylineToCanvasSpace(contourHoleAnnotation.data.contour.polyline, viewport);\n        return { annotation: contourHoleAnnotation, polyline };\n    });\n}\nexport function createPolylineHole(viewport, targetAnnotation, holeAnnotation) {\n    addChildAnnotation(targetAnnotation, holeAnnotation);\n    removeContourSegmentationAnnotation(holeAnnotation);\n    const { contour: holeContour } = holeAnnotation.data;\n    const holePolylineCanvas = convertContourPolylineToCanvasSpace(holeContour.polyline, viewport);\n    updateContourPolyline(holeAnnotation, {\n        points: holePolylineCanvas,\n        closed: holeContour.closed,\n        targetWindingDirection: targetAnnotation.data.contour.windingDirection ===\n            ContourWindingDirection.Clockwise\n            ? ContourWindingDirection.CounterClockwise\n            : ContourWindingDirection.Clockwise,\n    }, viewport);\n    const { element } = viewport;\n    updateViewportsForAnnotations(viewport, [targetAnnotation, holeAnnotation]);\n}\nexport function combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline) {\n    if (!hasToolByName(DEFAULT_CONTOUR_SEG_TOOL_NAME)) {\n        console.warn(`${DEFAULT_CONTOUR_SEG_TOOL_NAME} is not registered in cornerstone. Cannot combine polylines.`);\n        return;\n    }\n    const sourceStartPoint = sourcePolyline[0];\n    const mergePolylines = math.polyline.containsPoint(targetPolyline, sourceStartPoint);\n    const contourHolesData = getContourHolesData(viewport, targetAnnotation);\n    const unassignedContourHolesSet = new Set(contourHolesData);\n    const reassignedContourHolesMap = new Map();\n    const assignHoleToPolyline = (parentPolyline, holeData) => {\n        let holes = reassignedContourHolesMap.get(parentPolyline);\n        if (!holes) {\n            holes = [];\n            reassignedContourHolesMap.set(parentPolyline, holes);\n        }\n        holes.push(holeData);\n        unassignedContourHolesSet.delete(holeData);\n    };\n    const newPolylines = [];\n    if (mergePolylines) {\n        const mergedPolyline = math.polyline.mergePolylines(targetPolyline, sourcePolyline);\n        newPolylines.push(mergedPolyline);\n        Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => assignHoleToPolyline(mergedPolyline, holeData));\n    }\n    else {\n        const subtractedPolylines = math.polyline.subtractPolylines(targetPolyline, sourcePolyline);\n        subtractedPolylines.forEach((newPolyline) => {\n            newPolylines.push(newPolyline);\n            Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => {\n                const containsHole = math.polyline.containsPoints(newPolyline, holeData.polyline);\n                if (containsHole) {\n                    assignHoleToPolyline(newPolyline, holeData);\n                }\n            });\n        });\n    }\n    Array.from(reassignedContourHolesMap.values()).forEach((contourHolesDataArray) => contourHolesDataArray.forEach((contourHoleData) => clearParentAnnotation(contourHoleData.annotation)));\n    const { element } = viewport;\n    const { metadata, data } = targetAnnotation;\n    const { handles, segmentation } = data;\n    const { textBox } = handles;\n    removeAnnotation(sourceAnnotation.annotationUID);\n    removeAnnotation(targetAnnotation.annotationUID);\n    removeContourSegmentationAnnotation(sourceAnnotation);\n    removeContourSegmentationAnnotation(targetAnnotation);\n    const newAnnotations = [];\n    for (let i = 0; i < newPolylines.length; i++) {\n        const polyline = newPolylines[i];\n        if (!polyline || polyline.length < 3) {\n            console.warn('Skipping creation of new annotation due to invalid polyline:', polyline);\n            continue;\n        }\n        const newAnnotation = createNewAnnotationFromPolyline(viewport, targetAnnotation, polyline);\n        addAnnotation(newAnnotation, element);\n        addContourSegmentationAnnotation(newAnnotation);\n        triggerAnnotationModified(newAnnotation, viewport.element);\n        newAnnotations.push(newAnnotation);\n        reassignedContourHolesMap\n            .get(polyline)\n            ?.forEach((holeData) => addChildAnnotation(newAnnotation, holeData.annotation));\n    }\n    updateViewportsForAnnotations(viewport, [targetAnnotation, sourceAnnotation]);\n}\nexport function createNewAnnotationFromPolyline(viewport, templateAnnotation, polyline) {\n    const startPointWorld = viewport.canvasToWorld(polyline[0]);\n    const endPointWorld = viewport.canvasToWorld(polyline[polyline.length - 1]);\n    const newAnnotation = {\n        metadata: {\n            ...templateAnnotation.metadata,\n            toolName: DEFAULT_CONTOUR_SEG_TOOL_NAME,\n            originalToolName: templateAnnotation.metadata.originalToolName ||\n                templateAnnotation.metadata.toolName,\n        },\n        data: {\n            cachedStats: {},\n            handles: {\n                points: [startPointWorld, endPointWorld],\n                textBox: templateAnnotation.data.handles.textBox\n                    ? { ...templateAnnotation.data.handles.textBox }\n                    : undefined,\n            },\n            contour: {\n                polyline: [],\n                closed: true,\n            },\n            spline: templateAnnotation.data.spline,\n            segmentation: {\n                ...templateAnnotation.data.segmentation,\n            },\n        },\n        annotationUID: csUtils.uuidv4(),\n        highlighted: true,\n        invalidated: true,\n        isLocked: false,\n        isVisible: undefined,\n        interpolationUID: templateAnnotation.interpolationUID,\n        interpolationCompleted: templateAnnotation.interpolationCompleted,\n    };\n    updateContourPolyline(newAnnotation, {\n        points: polyline,\n        closed: true,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n    }, viewport);\n    return newAnnotation;\n}\nexport function updateViewportsForAnnotations(viewport, annotations) {\n    const { element } = viewport;\n    const updatedToolNames = new Set([DEFAULT_CONTOUR_SEG_TOOL_NAME]);\n    annotations.forEach((annotation) => {\n        updatedToolNames.add(annotation.metadata.toolName);\n    });\n    for (const toolName of updatedToolNames.values()) {\n        if (hasToolByName(toolName)) {\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, toolName);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        }\n    }\n}\nexport function removeDuplicatePoints(polyline) {\n    if (!polyline || polyline.length < 2) {\n        return polyline;\n    }\n    const cleaned = [polyline[0]];\n    for (let i = 1; i < polyline.length; i++) {\n        const currentPoint = polyline[i];\n        const lastPoint = cleaned[cleaned.length - 1];\n        const dx = Math.abs(currentPoint[0] - lastPoint[0]);\n        const dy = Math.abs(currentPoint[1] - lastPoint[1]);\n        if (dx > TOLERANCE || dy > TOLERANCE) {\n            cleaned.push(currentPoint);\n        }\n    }\n    return cleaned;\n}\nexport function cleanupPolylines(polylines) {\n    const validPolylines = [];\n    const seenPolylines = new Set();\n    for (let polyline of polylines) {\n        if (!polyline || polyline.length < 3) {\n            continue;\n        }\n        polyline = removeDuplicatePoints(polyline);\n        if (polyline.length < 3) {\n            continue;\n        }\n        const sortedPoints = [...polyline].sort((a, b) => {\n            if (a[0] !== b[0]) {\n                return a[0] - b[0];\n            }\n            return a[1] - b[1];\n        });\n        const polylineKey = sortedPoints\n            .map((p) => `${p[0].toFixed(6)},${p[1].toFixed(6)}`)\n            .join('|');\n        if (!seenPolylines.has(polylineKey)) {\n            seenPolylines.add(polylineKey);\n            validPolylines.push(polyline);\n        }\n    }\n    return validPolylines;\n}\n", "import { utilities } from '@cornerstonejs/core';\nimport { addAnnotation } from '../../stateManagement';\nconst DEFAULT_CONTOUR_SEG_TOOLNAME = 'PlanarFreehandContourSegmentationTool';\nexport default function addPolylinesToSegmentation(viewport, annotationUIDsMap, segmentationId, polylinesInfo, segmentIndex) {\n    polylinesInfo.forEach(({ polyline, viewReference }) => {\n        if (polyline.length < 3) {\n            return;\n        }\n        const contourSegmentationAnnotation = {\n            annotationUID: utilities.uuidv4(),\n            data: {\n                contour: {\n                    closed: true,\n                    polyline,\n                },\n                segmentation: {\n                    segmentationId,\n                    segmentIndex,\n                },\n                handles: {},\n            },\n            handles: {},\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: DEFAULT_CONTOUR_SEG_TOOLNAME,\n                ...viewReference,\n            },\n        };\n        addAnnotation(contourSegmentationAnnotation, viewport.element);\n        const currentSet = annotationUIDsMap?.get(segmentIndex) || new Set();\n        currentSet.add(contourSegmentationAnnotation.annotationUID);\n        annotationUIDsMap.set(segmentIndex, currentSet);\n    });\n    return annotationUIDsMap;\n}\n", "export function getViewReferenceFromAnnotation(annotation) {\n    const { metadata } = annotation;\n    if (!metadata) {\n        return {};\n    }\n    const { FrameOfReferenceUID, referencedImageId, referencedImageURI, multiSliceReference, cameraFocalPoint, viewPlaneNormal, viewUp, sliceIndex, volumeId, bounds, } = metadata;\n    const viewReference = {\n        FrameOfReferenceUID,\n        referencedImageId,\n        referencedImageURI,\n        multiSliceReference,\n        cameraFocalPoint,\n        viewPlaneNormal,\n        viewUp,\n        sliceIndex,\n        volumeId,\n        bounds,\n    };\n    return viewReference;\n}\n", "export function areViewReferencesEqual(a, b) {\n    if (!a || !b) {\n        return false;\n    }\n    if (a.FrameOfReferenceUID !== b.FrameOfReferenceUID) {\n        return false;\n    }\n    if (a.referencedImageId !== b.referencedImageId) {\n        return false;\n    }\n    if (!a.viewPlaneNormal || !b.viewPlaneNormal) {\n        return false;\n    }\n    if (a.viewPlaneNormal.length !== b.viewPlaneNormal.length) {\n        return false;\n    }\n    for (let i = 0; i < a.viewPlaneNormal.length; i++) {\n        if (a.viewPlaneNormal[i] !== b.viewPlaneNormal[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n", "import * as math from '../math';\nimport { checkIntersection, convertContourPolylineToCanvasSpace, } from './sharedOperations';\nimport arePolylinesIdentical from '../math/polyline/arePolylinesIdentical';\nimport { getViewReferenceFromAnnotation } from './getViewReferenceFromAnnotation';\nimport { areViewReferencesEqual } from './areViewReferencesEqual';\nexport function unifyPolylineSets(polylinesSetA, polylinesSetB) {\n    const result = [];\n    const processedFromA = new Set();\n    const processedFromB = new Set();\n    for (let i = 0; i < polylinesSetA.length; i++) {\n        if (processedFromA.has(i)) {\n            continue;\n        }\n        const polylineA = polylinesSetA[i];\n        let merged = false;\n        for (let j = 0; j < polylinesSetB.length; j++) {\n            if (processedFromB.has(j)) {\n                continue;\n            }\n            const polylineB = polylinesSetB[j];\n            if (!areViewReferencesEqual(polylineA.viewReference, polylineB.viewReference)) {\n                continue;\n            }\n            if (arePolylinesIdentical(polylineA.polyline, polylineB.polyline)) {\n                result.push(polylineA);\n                processedFromA.add(i);\n                processedFromB.add(j);\n                merged = true;\n                break;\n            }\n            const intersection = checkIntersection(polylineA.polyline, polylineB.polyline);\n            if (intersection.hasIntersection && !intersection.isContourHole) {\n                const mergedPolyline = math.polyline.mergePolylines(polylineA.polyline, polylineB.polyline);\n                result.push({\n                    polyline: mergedPolyline,\n                    viewReference: polylineA.viewReference,\n                });\n                processedFromA.add(i);\n                processedFromB.add(j);\n                merged = true;\n                break;\n            }\n        }\n        if (!merged) {\n            result.push(polylineA);\n            processedFromA.add(i);\n        }\n    }\n    for (let j = 0; j < polylinesSetB.length; j++) {\n        if (!processedFromB.has(j)) {\n            result.push(polylinesSetB[j]);\n        }\n    }\n    return result;\n}\nexport function unifyMultiplePolylineSets(polylineSets) {\n    if (polylineSets.length === 0) {\n        return [];\n    }\n    if (polylineSets.length === 1) {\n        return [...polylineSets[0]];\n    }\n    let result = [...polylineSets[0]];\n    for (let i = 1; i < polylineSets.length; i++) {\n        result = unifyPolylineSets(result, polylineSets[i]);\n    }\n    return result;\n}\nexport function unifyAnnotationPolylines(annotationsSetA, annotationsSetB, viewport) {\n    const polylinesSetA = annotationsSetA.map((annotation) => ({\n        polyline: convertContourPolylineToCanvasSpace(annotation.data.contour.polyline, viewport),\n        viewReference: getViewReferenceFromAnnotation(annotation),\n    }));\n    const polylinesSetB = annotationsSetB.map((annotation) => ({\n        polyline: convertContourPolylineToCanvasSpace(annotation.data.contour.polyline, viewport),\n        viewReference: getViewReferenceFromAnnotation(annotation),\n    }));\n    return unifyPolylineSets(polylinesSetA, polylinesSetB);\n}\n", "import * as math from '../math';\nimport { checkIntersection, cleanupPolylines, convertContourPolylineToCanvasSpace, removeDuplicatePoints, } from './sharedOperations';\nimport arePolylinesIdentical from '../math/polyline/arePolylinesIdentical';\nimport { getViewReferenceFromAnnotation } from './getViewReferenceFromAnnotation';\nimport { areViewReferencesEqual } from './areViewReferencesEqual';\nexport function subtractPolylineSets(polylinesSetA, polylinesSetB) {\n    const result = [];\n    for (let i = 0; i < polylinesSetA.length; i++) {\n        let currentPolylines = [polylinesSetA[i]];\n        for (let j = 0; j < polylinesSetB.length; j++) {\n            const polylineB = polylinesSetB[j];\n            const newPolylines = [];\n            for (const currentPolyline of currentPolylines) {\n                if (!areViewReferencesEqual(currentPolyline.viewReference, polylineB.viewReference)) {\n                    newPolylines.push(currentPolyline);\n                    continue;\n                }\n                if (arePolylinesIdentical(currentPolyline.polyline, polylineB.polyline)) {\n                    continue;\n                }\n                const intersection = checkIntersection(currentPolyline.polyline, polylineB.polyline);\n                if (intersection.hasIntersection && !intersection.isContourHole) {\n                    const subtractedPolylines = cleanupPolylines(math.polyline.subtractPolylines(currentPolyline.polyline, polylineB.polyline));\n                    for (const subtractedPolyline of subtractedPolylines) {\n                        const cleaned = removeDuplicatePoints(subtractedPolyline);\n                        if (cleaned.length >= 3) {\n                            newPolylines.push({\n                                polyline: cleaned,\n                                viewReference: currentPolyline.viewReference,\n                            });\n                        }\n                    }\n                }\n                else {\n                    newPolylines.push({\n                        polyline: currentPolyline.polyline,\n                        viewReference: currentPolyline.viewReference,\n                    });\n                }\n            }\n            currentPolylines = newPolylines;\n        }\n        result.push(...currentPolylines);\n    }\n    return result;\n}\nexport function subtractMultiplePolylineSets(basePolylineSet, subtractorSets) {\n    if (subtractorSets.length === 0) {\n        return [...basePolylineSet];\n    }\n    let result = [...basePolylineSet];\n    for (let i = 0; i < subtractorSets.length; i++) {\n        result = subtractPolylineSets(result, subtractorSets[i]);\n    }\n    return result;\n}\nexport function subtractAnnotationPolylines(baseAnnotations, subtractorAnnotations, viewport) {\n    const basePolylines = baseAnnotations.map((annotation) => ({\n        polyline: convertContourPolylineToCanvasSpace(annotation.data.contour.polyline, viewport),\n        viewReference: getViewReferenceFromAnnotation(annotation),\n    }));\n    const subtractorPolylines = subtractorAnnotations.map((annotation) => ({\n        polyline: convertContourPolylineToCanvasSpace(annotation.data.contour.polyline, viewport),\n        viewReference: getViewReferenceFromAnnotation(annotation),\n    }));\n    return subtractPolylineSets(basePolylines, subtractorPolylines);\n}\n", "import { checkIntersection, cleanupPolylines } from './sharedOperations';\nimport { intersectPolylines } from '../math/polyline';\nimport arePolylinesIdentical from '../math/polyline/arePolylinesIdentical';\nimport { areViewReferencesEqual } from './areViewReferencesEqual';\nexport function intersectPolylinesSets(set1, set2) {\n    if (!set1.length || !set2.length) {\n        return [];\n    }\n    const result = [];\n    for (const polyA of set1) {\n        for (const polyB of set2) {\n            if (!areViewReferencesEqual(polyA.viewReference, polyB.viewReference)) {\n                continue;\n            }\n            if (arePolylinesIdentical(polyA.polyline, polyB.polyline)) {\n                result.push({ ...polyA });\n                continue;\n            }\n            const intersection = checkIntersection(polyA.polyline, polyB.polyline);\n            if (intersection.hasIntersection && !intersection.isContourHole) {\n                const intersectionRegions = cleanupPolylines(intersectPolylines(polyA.polyline, polyB.polyline));\n                if (intersectionRegions && intersectionRegions.length > 0) {\n                    intersectionRegions.forEach((region) => {\n                        result.push({\n                            polyline: region,\n                            viewReference: polyA.viewReference,\n                        });\n                    });\n                }\n            }\n        }\n    }\n    return result;\n}\n", "import { cleanupPolylines } from './sharedOperations';\nimport arePolylinesIdentical from '../math/polyline/arePolylinesIdentical';\nimport { subtractPolylineSets } from './polylineSubtract';\nimport { areViewReferencesEqual } from './areViewReferencesEqual';\nexport function xorPolylinesSets(polylinesSetA, polylinesSetB) {\n    if (!polylinesSetA.length && !polylinesSetB.length) {\n        return [];\n    }\n    if (!polylinesSetA.length) {\n        return polylinesSetB;\n    }\n    if (!polylinesSetB.length) {\n        return polylinesSetA;\n    }\n    if (polylinesSetA.length === polylinesSetB.length) {\n        let allIdentical = true;\n        for (let i = 0; i < polylinesSetA.length; i++) {\n            let foundMatch = false;\n            for (let j = 0; j < polylinesSetB.length; j++) {\n                if (!areViewReferencesEqual(polylinesSetA[i].viewReference, polylinesSetB[j].viewReference)) {\n                    continue;\n                }\n                if (arePolylinesIdentical(polylinesSetA[i].polyline, polylinesSetB[j].polyline)) {\n                    foundMatch = true;\n                    break;\n                }\n            }\n            if (!foundMatch) {\n                allIdentical = false;\n                break;\n            }\n        }\n        if (allIdentical) {\n            return [];\n        }\n    }\n    const aMinusB = subtractPolylineSets(polylinesSetA, polylinesSetB);\n    const bMinusA = subtractPolylineSets(polylinesSetB, polylinesSetA);\n    const xorResult = [...aMinusB, ...bMinusA];\n    return xorResult;\n}\n", "import { getAnnotation, removeAnnotation } from '../../stateManagement';\nimport { convertContourPolylineToCanvasSpace, convertContourPolylineToWorld, } from './sharedOperations';\nimport addPolylinesToSegmentation from './addPolylinesToSegmentation';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport { copyContourSegment } from './copyAnnotation';\nimport { removeContourSegmentationAnnotation } from './removeContourSegmentationAnnotation';\nimport { getViewportAssociatedToSegmentation } from '../../stateManagement/segmentation/utilities/getViewportAssociatedToSegmentation';\nimport { unifyPolylineSets } from './polylineUnify';\nimport { subtractPolylineSets } from './polylineSubtract';\nimport { intersectPolylinesSets } from './polylineIntersect';\nimport { xorPolylinesSets } from './polylineXor';\nimport { getViewReferenceFromAnnotation } from './getViewReferenceFromAnnotation';\nexport var LogicalOperation;\n(function (LogicalOperation) {\n    LogicalOperation[LogicalOperation[\"Union\"] = 0] = \"Union\";\n    LogicalOperation[LogicalOperation[\"Subtract\"] = 1] = \"Subtract\";\n    LogicalOperation[LogicalOperation[\"Intersect\"] = 2] = \"Intersect\";\n    LogicalOperation[LogicalOperation[\"XOR\"] = 3] = \"XOR\";\n    LogicalOperation[LogicalOperation[\"Copy\"] = 4] = \"Copy\";\n    LogicalOperation[LogicalOperation[\"Delete\"] = 5] = \"Delete\";\n})(LogicalOperation || (LogicalOperation = {}));\nfunction getPolylinesInfoWorld(contourRepresentationData, segmentIndex) {\n    const polylinesInfo = [];\n    const { annotationUIDsMap } = contourRepresentationData || {};\n    if (!annotationUIDsMap?.has(segmentIndex)) {\n        return;\n    }\n    const annotationUIDs = annotationUIDsMap.get(segmentIndex);\n    for (const annotationUID of annotationUIDs) {\n        const annotation = getAnnotation(annotationUID);\n        const { polyline } = annotation.data.contour;\n        polylinesInfo.push({\n            polyline,\n            viewReference: getViewReferenceFromAnnotation(annotation),\n        });\n    }\n    return polylinesInfo;\n}\nfunction extractPolylinesInCanvasSpace(viewport, segment1, segment2) {\n    const segmentation1 = getSegmentation(segment1.segmentationId);\n    const segmentation2 = getSegmentation(segment2.segmentationId);\n    if (!segmentation1 || !segmentation2) {\n        return;\n    }\n    if (!segmentation1.representationData.Contour ||\n        !segmentation2.representationData.Contour) {\n        return;\n    }\n    const polyLinesInfoWorld1 = getPolylinesInfoWorld(segmentation1.representationData.Contour, segment1.segmentIndex);\n    const polyLinesInfoWorld2 = getPolylinesInfoWorld(segmentation2.representationData.Contour, segment2.segmentIndex);\n    if (!polyLinesInfoWorld1 || !polyLinesInfoWorld2) {\n        return;\n    }\n    const polyLinesInfoCanvas1 = polyLinesInfoWorld1.map(({ polyline, viewReference }) => {\n        return {\n            polyline: convertContourPolylineToCanvasSpace(polyline, viewport),\n            viewReference,\n        };\n    });\n    const polyLinesInfoCanvas2 = polyLinesInfoWorld2.map(({ polyline, viewReference }) => {\n        return {\n            polyline: convertContourPolylineToCanvasSpace(polyline, viewport),\n            viewReference,\n        };\n    });\n    return { polyLinesInfoCanvas1, polyLinesInfoCanvas2 };\n}\nfunction addSegmentInSegmentation(segmentation, { segmentIndex, label, color }) {\n    if (!segmentation?.segments) {\n        return;\n    }\n    const segmentData = segmentation.segments[segmentIndex] ?? {\n        active: false,\n        locked: false,\n        segmentIndex,\n        cachedStats: {},\n        label,\n        color,\n    };\n    if (label !== undefined) {\n        segmentData.label = label;\n    }\n    if (color !== undefined) {\n        segmentData.color = color;\n    }\n    segmentation.segments[segmentIndex] = segmentData;\n}\nfunction removeAnnotations(annotationUIDList) {\n    annotationUIDList.forEach((annotationUID) => {\n        const annotation = getAnnotation(annotationUID);\n        removeAnnotation(annotationUID);\n        removeContourSegmentationAnnotation(annotation);\n    });\n    annotationUIDList.clear();\n}\nfunction applyLogicalOperation(segment1, segment2, options, operation) {\n    const viewport = getViewportAssociatedToSegmentation(segment1.segmentationId);\n    if (!viewport) {\n        return;\n    }\n    const { polyLinesInfoCanvas1, polyLinesInfoCanvas2 } = extractPolylinesInCanvasSpace(viewport, segment1, segment2) || {};\n    if (!polyLinesInfoCanvas1 || !polyLinesInfoCanvas2) {\n        return;\n    }\n    let polylinesMerged;\n    switch (operation) {\n        case LogicalOperation.Union:\n            polylinesMerged = unifyPolylineSets(polyLinesInfoCanvas1, polyLinesInfoCanvas2);\n            break;\n        case LogicalOperation.Subtract:\n            polylinesMerged = subtractPolylineSets(polyLinesInfoCanvas1, polyLinesInfoCanvas2);\n            break;\n        case LogicalOperation.Intersect:\n            polylinesMerged = intersectPolylinesSets(polyLinesInfoCanvas1, polyLinesInfoCanvas2);\n            break;\n        case LogicalOperation.XOR:\n            polylinesMerged = xorPolylinesSets(polyLinesInfoCanvas1, polyLinesInfoCanvas2);\n            break;\n        default:\n            polylinesMerged = unifyPolylineSets(polyLinesInfoCanvas1, polyLinesInfoCanvas2);\n            break;\n    }\n    const polyLinesWorld = polylinesMerged.map(({ polyline, viewReference }) => {\n        return {\n            polyline: convertContourPolylineToWorld(polyline, viewport),\n            viewReference,\n        };\n    });\n    const resultSegment = options;\n    const segmentation = getSegmentation(resultSegment.segmentationId);\n    const segmentIndex = resultSegment.segmentIndex;\n    const color = resultSegment.color;\n    const label = resultSegment.label;\n    const contourRepresentationData = segmentation.representationData\n        .Contour;\n    const { annotationUIDsMap } = contourRepresentationData;\n    if (!annotationUIDsMap) {\n        return;\n    }\n    if (segment1.segmentationId === resultSegment.segmentationId &&\n        segment1.segmentIndex === segmentIndex) {\n        const existingAnnotationUIDs = annotationUIDsMap.get(segmentIndex);\n        if (existingAnnotationUIDs) {\n            removeAnnotations(existingAnnotationUIDs);\n        }\n    }\n    addPolylinesToSegmentation(viewport, annotationUIDsMap, segmentation.segmentationId, polyLinesWorld, segmentIndex);\n    addSegmentInSegmentation(segmentation, { segmentIndex, color, label });\n}\nexport function add(segment1, segment2, options) {\n    applyLogicalOperation(segment1, segment2, options, LogicalOperation.Union);\n}\nexport function subtract(segment1, segment2, options) {\n    applyLogicalOperation(segment1, segment2, options, LogicalOperation.Subtract);\n}\nexport function intersect(segment1, segment2, options) {\n    applyLogicalOperation(segment1, segment2, options, LogicalOperation.Intersect);\n}\nexport function xor(segment1, segment2, options) {\n    applyLogicalOperation(segment1, segment2, options, LogicalOperation.XOR);\n}\nexport function copy(segment, options) {\n    copyContourSegment(segment.segmentationId, segment.segmentIndex, options.segmentationId, options.segmentIndex);\n}\nexport function deleteOperation(segment) {\n    const segmentation = getSegmentation(segment.segmentationId);\n    if (!segmentation) {\n        console.log('No active segmentation detected');\n        return;\n    }\n    if (!segmentation.representationData.Contour) {\n        console.log('No contour representation found');\n        return;\n    }\n    const representationData = segmentation.representationData.Contour;\n    const { annotationUIDsMap } = representationData;\n    if (!annotationUIDsMap) {\n        console.log('No annotation map found');\n        return;\n    }\n    if (!annotationUIDsMap.has(segment.segmentIndex)) {\n        console.log('Segmentation index has no annotations');\n        return;\n    }\n    const annotationUIDList = annotationUIDsMap.get(segment.segmentIndex);\n    removeAnnotations(annotationUIDList);\n}\n", "export default function isContourSegmentationAnnotation(annotation) {\n    return !!annotation.data?.segmentation;\n}\n", "import * as math from '../math';\nfunction findAllIntersectingContours(viewport, sourcePolyline, contourSegmentationAnnotations) {\n    const intersectingContours = [];\n    const sourceAABB = math.polyline.getAABB(sourcePolyline);\n    for (let i = 0; i < contourSegmentationAnnotations.length; i++) {\n        const targetAnnotation = contourSegmentationAnnotations[i];\n        const targetPolyline = convertContourPolylineToCanvasSpace(targetAnnotation.data.contour.polyline, viewport);\n        const targetAABB = math.polyline.getAABB(targetPolyline);\n        const aabbIntersect = math.aabb.intersectAABB(sourceAABB, targetAABB);\n        if (!aabbIntersect) {\n            continue;\n        }\n        const lineSegmentsIntersect = math.polyline.intersectPolyline(sourcePolyline, targetPolyline);\n        const isContourHole = !lineSegmentsIntersect &&\n            math.polyline.containsPoints(targetPolyline, sourcePolyline);\n        if (lineSegmentsIntersect || isContourHole) {\n            intersectingContours.push({\n                targetAnnotation,\n                targetPolyline,\n                isContourHole,\n            });\n        }\n    }\n    return intersectingContours;\n}\nfunction convertContourPolylineToCanvasSpace(polyline, viewport) {\n    const numPoints = polyline.length;\n    const projectedPolyline = new Array(numPoints);\n    for (let i = 0; i < numPoints; i++) {\n        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n    }\n    return projectedPolyline;\n}\nexport { findAllIntersectingContours };\n", "import { utilities as csUtils, getEnabledElement } from '@cornerstonejs/core';\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport * as math from '../math';\nimport updateContourPolyline from '../contours/updateContourPolyline';\nimport { addAnnotation, removeAnnotation, getChildAnnotations, addChildAnnotation, clearParentAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { addContourSegmentationAnnotation } from './addContourSegmentationAnnotation';\nimport { removeContourSegmentationAnnotation } from './removeContourSegmentationAnnotation';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getViewportIdsWithToolToRender } from '../viewportFilters';\nimport { hasToolByName, hasTool } from '../../store/addTool';\nconst DEFAULT_CONTOUR_SEG_TOOL_NAME = 'PlanarFreehandContourSegmentationTool';\nfunction processMultipleIntersections(viewport, sourceAnnotation, sourcePolyline, intersectingContours) {\n    const holeOperations = intersectingContours.filter((item) => item.isContourHole);\n    const mergeOperations = intersectingContours.filter((item) => !item.isContourHole);\n    if (holeOperations.length > 0) {\n        const primaryHoleTarget = holeOperations[0];\n        createPolylineHole(viewport, primaryHoleTarget.targetAnnotation, sourceAnnotation);\n        updateViewportsForAnnotations(viewport, [\n            sourceAnnotation,\n            primaryHoleTarget.targetAnnotation,\n        ]);\n        return;\n    }\n    if (mergeOperations.length === 0) {\n        return;\n    }\n    if (!hasToolByName(DEFAULT_CONTOUR_SEG_TOOL_NAME)) {\n        console.warn(`${DEFAULT_CONTOUR_SEG_TOOL_NAME} is not registered in cornerstone. Cannot process multiple intersections.`);\n        return;\n    }\n    processSequentialIntersections(viewport, sourceAnnotation, sourcePolyline, mergeOperations);\n}\nfunction processSequentialIntersections(viewport, sourceAnnotation, sourcePolyline, mergeOperations) {\n    const { element } = viewport;\n    const allAnnotationsToRemove = [sourceAnnotation];\n    const allResultPolylines = [];\n    const allHoles = [];\n    mergeOperations.forEach(({ targetAnnotation }) => {\n        const holes = getContourHolesData(viewport, targetAnnotation);\n        allHoles.push(...holes);\n        allAnnotationsToRemove.push(targetAnnotation);\n    });\n    const sourceStartPoint = sourcePolyline[0];\n    const shouldMerge = mergeOperations.some(({ targetPolyline }) => math.polyline.containsPoint(targetPolyline, sourceStartPoint));\n    if (shouldMerge) {\n        let resultPolyline = sourcePolyline;\n        mergeOperations.forEach(({ targetPolyline }) => {\n            resultPolyline = math.polyline.mergePolylines(resultPolyline, targetPolyline);\n        });\n        allResultPolylines.push(resultPolyline);\n    }\n    else {\n        mergeOperations.forEach(({ targetPolyline }) => {\n            const subtractedPolylines = math.polyline.subtractPolylines(targetPolyline, sourcePolyline);\n            allResultPolylines.push(...subtractedPolylines);\n        });\n    }\n    allAnnotationsToRemove.forEach((annotation) => {\n        removeAnnotation(annotation.annotationUID);\n        removeContourSegmentationAnnotation(annotation);\n    });\n    allHoles.forEach((holeData) => clearParentAnnotation(holeData.annotation));\n    const baseAnnotation = mergeOperations[0].targetAnnotation;\n    const newAnnotations = [];\n    allResultPolylines.forEach((polyline) => {\n        if (!polyline || polyline.length < 3) {\n            console.warn('Skipping creation of new annotation due to invalid polyline:', polyline);\n            return;\n        }\n        const newAnnotation = createNewAnnotationFromPolyline(viewport, baseAnnotation, polyline);\n        addAnnotation(newAnnotation, element);\n        addContourSegmentationAnnotation(newAnnotation);\n        triggerAnnotationModified(newAnnotation, viewport.element);\n        newAnnotations.push(newAnnotation);\n    });\n    reassignHolesToNewAnnotations(viewport, allHoles, newAnnotations);\n    updateViewportsForAnnotations(viewport, allAnnotationsToRemove);\n}\nfunction createNewAnnotationFromPolyline(viewport, baseAnnotation, polyline) {\n    const startPointWorld = viewport.canvasToWorld(polyline[0]);\n    const endPointWorld = viewport.canvasToWorld(polyline[polyline.length - 1]);\n    const newAnnotation = {\n        metadata: {\n            ...baseAnnotation.metadata,\n            toolName: DEFAULT_CONTOUR_SEG_TOOL_NAME,\n            originalToolName: baseAnnotation.metadata.originalToolName ||\n                baseAnnotation.metadata.toolName,\n        },\n        data: {\n            cachedStats: {},\n            handles: {\n                points: [startPointWorld, endPointWorld],\n                textBox: baseAnnotation.data.handles.textBox\n                    ? { ...baseAnnotation.data.handles.textBox }\n                    : undefined,\n            },\n            contour: {\n                polyline: [],\n                closed: true,\n            },\n            spline: baseAnnotation.data.spline,\n            segmentation: {\n                ...baseAnnotation.data.segmentation,\n            },\n        },\n        annotationUID: csUtils.uuidv4(),\n        highlighted: true,\n        invalidated: true,\n        isLocked: false,\n        isVisible: undefined,\n        interpolationUID: baseAnnotation.interpolationUID,\n        interpolationCompleted: baseAnnotation.interpolationCompleted,\n    };\n    updateContourPolyline(newAnnotation, {\n        points: polyline,\n        closed: true,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n    }, viewport);\n    return newAnnotation;\n}\nfunction reassignHolesToNewAnnotations(viewport, holes, newAnnotations) {\n    holes.forEach((holeData) => {\n        const parentAnnotation = newAnnotations.find((annotation) => {\n            const parentPolyline = convertContourPolylineToCanvasSpace(annotation.data.contour.polyline, viewport);\n            return math.polyline.containsPoints(parentPolyline, holeData.polyline);\n        });\n        if (parentAnnotation) {\n            addChildAnnotation(parentAnnotation, holeData.annotation);\n        }\n    });\n}\nfunction getContourHolesData(viewport, annotation) {\n    return getChildAnnotations(annotation).map((holeAnnotation) => {\n        const contourHoleAnnotation = holeAnnotation;\n        const polyline = convertContourPolylineToCanvasSpace(contourHoleAnnotation.data.contour.polyline, viewport);\n        return { annotation: contourHoleAnnotation, polyline };\n    });\n}\nfunction createPolylineHole(viewport, targetAnnotation, holeAnnotation) {\n    addChildAnnotation(targetAnnotation, holeAnnotation);\n    removeContourSegmentationAnnotation(holeAnnotation);\n    const { contour: holeContour } = holeAnnotation.data;\n    const holePolylineCanvas = convertContourPolylineToCanvasSpace(holeContour.polyline, viewport);\n    updateContourPolyline(holeAnnotation, {\n        points: holePolylineCanvas,\n        closed: holeContour.closed,\n        targetWindingDirection: targetAnnotation.data.contour.windingDirection ===\n            ContourWindingDirection.Clockwise\n            ? ContourWindingDirection.CounterClockwise\n            : ContourWindingDirection.Clockwise,\n    }, viewport);\n}\nfunction convertContourPolylineToCanvasSpace(polyline, viewport) {\n    const numPoints = polyline.length;\n    const projectedPolyline = new Array(numPoints);\n    for (let i = 0; i < numPoints; i++) {\n        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n    }\n    return projectedPolyline;\n}\nfunction updateViewportsForAnnotations(viewport, annotations) {\n    const { element } = viewport;\n    const updatedToolNames = new Set([DEFAULT_CONTOUR_SEG_TOOL_NAME]);\n    annotations.forEach((annotation) => {\n        updatedToolNames.add(annotation.metadata.toolName);\n    });\n    for (const toolName of updatedToolNames.values()) {\n        if (hasToolByName(toolName)) {\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, toolName);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        }\n    }\n}\nexport { processMultipleIntersections };\n", "import { getEnabledElements, utilities as csUtils } from '@cornerstonejs/core';\nconst { isEqual } = csUtils;\nexport default function getViewportsForAnnotation(annotation) {\n    const { metadata } = annotation;\n    return getEnabledElements()\n        .filter((enabledElement) => {\n        if (enabledElement.FrameOfReferenceUID === metadata.FrameOfReferenceUID) {\n            const viewport = enabledElement.viewport;\n            const { viewPlaneNormal, viewUp } = viewport.getCamera();\n            return (isEqual(viewPlaneNormal, metadata.viewPlaneNormal) &&\n                (!metadata.viewUp || isEqual(viewUp, metadata.viewUp)));\n        }\n        return;\n    })\n        .map((enabledElement) => enabledElement.viewport);\n}\n", "import { getAnnotation } from '../../stateManagement/annotation/annotationState';\nimport getViewportsForAnnotation from '../getViewportsForAnnotation';\nimport { convertContourPolylineToCanvasSpace, checkIntersection, createPolylineHole, combinePolylines, } from './sharedOperations';\nexport async function contourSegmentationOperation(sourceAnnotationOrUID, targetAnnotationOrUID, viewport, contourHoleProcessingEnabled = true) {\n    const sourceAnnotation = typeof sourceAnnotationOrUID === 'string'\n        ? getAnnotation(sourceAnnotationOrUID)\n        : sourceAnnotationOrUID;\n    const targetAnnotation = typeof targetAnnotationOrUID === 'string'\n        ? getAnnotation(targetAnnotationOrUID)\n        : targetAnnotationOrUID;\n    if (!sourceAnnotation || !targetAnnotation) {\n        throw new Error('Both source and target annotations must be valid');\n    }\n    if (!viewport) {\n        viewport = getViewportFromAnnotation(sourceAnnotation);\n    }\n    const sourcePolyline = convertContourPolylineToCanvasSpace(sourceAnnotation.data.contour.polyline, viewport);\n    const targetPolyline = convertContourPolylineToCanvasSpace(targetAnnotation.data.contour.polyline, viewport);\n    const intersectionInfo = checkIntersection(sourcePolyline, targetPolyline);\n    if (!intersectionInfo.hasIntersection) {\n        console.warn('No intersection found between the two annotations');\n        return;\n    }\n    if (intersectionInfo.isContourHole) {\n        if (!contourHoleProcessingEnabled) {\n            console.warn('Hole processing is disabled');\n            return;\n        }\n        createPolylineHole(viewport, targetAnnotation, sourceAnnotation);\n    }\n    else {\n        combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline);\n    }\n}\nfunction getViewportFromAnnotation(annotation) {\n    const viewports = getViewportsForAnnotation(annotation);\n    if (!viewports.length) {\n        throw new Error('No viewport found for the annotation');\n    }\n    return viewports[0];\n}\n", "import { Enums } from '@cornerstonejs/core';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport vtkPoints from '@kitware/vtk.js/Common/Core/Points';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nexport function validateGeometry(geometry) {\n    if (!geometry) {\n        throw new Error(`No contours found for geometryId ${geometry.id}`);\n    }\n    const geometryId = geometry.id;\n    if (geometry.type !== Enums.GeometryType.CONTOUR) {\n        throw new Error(`Geometry type ${geometry.type} not supported for rendering.`);\n    }\n    if (!geometry.data) {\n        console.warn(`No contours found for geometryId ${geometryId}. Skipping render.`);\n        return;\n    }\n}\nexport function getPolyData(contourSet) {\n    const pointArray = [];\n    const points = vtkPoints.newInstance();\n    const lines = vtkCellArray.newInstance();\n    let pointIndex = 0;\n    contourSet.contours.forEach((contour) => {\n        const pointList = contour.points;\n        const flatPoints = contour.flatPointsArray;\n        const type = contour.type;\n        const pointIndexes = pointList.map((_, pointListIndex) => pointListIndex + pointIndex);\n        if (type === Enums.ContourType.CLOSED_PLANAR) {\n            pointIndexes.push(pointIndexes[0]);\n        }\n        const linePoints = Float32Array.from(flatPoints);\n        pointArray.push(...linePoints);\n        lines.insertNextCell([...pointIndexes]);\n        pointIndex = pointIndex + pointList.length;\n    });\n    points.setData(pointArray, 3);\n    const polygon = vtkPolyData.newInstance();\n    polygon.setPoints(points);\n    polygon.setLines(lines);\n    return polygon;\n}\n", "import { addAnnotation } from '../../../../stateManagement/annotation/annotationState';\nimport { cache, utilities } from '@cornerstonejs/core';\nimport { getClosestImageIdForStackViewport } from '../../../../utilities/annotationHydration';\nimport { addContourSegmentationAnnotation } from '../../../../utilities/contourSegmentation';\nimport { validateGeometry } from './utils';\nimport { SegmentationRepresentations } from '../../../../enums';\nimport { segmentationStyle } from '../../../../stateManagement/segmentation/SegmentationStyle';\nfunction handleContourSegmentation(viewport, geometryIds, annotationUIDsMap, contourRepresentation) {\n    if (annotationUIDsMap.size) {\n        viewport.render();\n    }\n    else {\n        addContourSetsToElement(viewport, geometryIds, contourRepresentation);\n    }\n}\nfunction addContourSetsToElement(viewport, geometryIds, contourRepresentation) {\n    const { segmentationId } = contourRepresentation;\n    const segmentSpecificMap = new Map();\n    geometryIds.forEach((geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        if (!geometry) {\n            console.warn(`No geometry found for geometryId ${geometryId}. Skipping render.`);\n            return;\n        }\n        const segmentIndex = geometry.data.segmentIndex;\n        validateGeometry(geometry);\n        const segmentSpecificConfig = segmentationStyle.getStyle({\n            viewportId: viewport.id,\n            segmentationId,\n            type: SegmentationRepresentations.Contour,\n            segmentIndex,\n        });\n        const contourSet = geometry.data;\n        const viewPlaneNormal = viewport.getCamera().viewPlaneNormal;\n        contourSet.contours.forEach((contour) => {\n            const { points, color, id } = contour;\n            const referencedImageId = getClosestImageIdForStackViewport(viewport, points[0], viewPlaneNormal);\n            const contourSegmentationAnnotation = {\n                annotationUID: utilities.uuidv4(),\n                data: {\n                    contour: {\n                        closed: true,\n                        polyline: points,\n                    },\n                    segmentation: {\n                        segmentationId,\n                        segmentIndex,\n                        color,\n                        id,\n                    },\n                    handles: {},\n                },\n                handles: {},\n                highlighted: false,\n                autoGenerated: false,\n                invalidated: false,\n                isLocked: true,\n                isVisible: true,\n                metadata: {\n                    referencedImageId,\n                    toolName: 'PlanarFreehandContourSegmentationTool',\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    viewPlaneNormal: viewport.getCamera().viewPlaneNormal,\n                },\n            };\n            const annotationGroupSelector = viewport.element;\n            addAnnotation(contourSegmentationAnnotation, annotationGroupSelector);\n            addContourSegmentationAnnotation(contourSegmentationAnnotation);\n        });\n        if (segmentSpecificConfig) {\n            segmentSpecificMap.set(segmentIndex, segmentSpecificConfig);\n        }\n    });\n    viewport.render();\n}\nexport { handleContourSegmentation, addContourSetsToElement };\n", "import { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport { removeAnnotation } from '../../../stateManagement';\nfunction removeContourFromElement(viewportId, segmentationId, removeFromCache = false) {\n    const segmentation = getSegmentation(segmentationId);\n    const { annotationUIDsMap } = segmentation.representationData.Contour;\n    annotationUIDsMap.forEach((annotationSet) => {\n        annotationSet.forEach((annotationUID) => {\n            removeAnnotation(annotationUID);\n        });\n    });\n}\nexport default removeContourFromElement;\n", "import { cache } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport { getCachedSegmentIndices, setCachedSegmentIndices } from './utilities';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nfunction getUniqueSegmentIndices(segmentationId) {\n    const cachedResult = getCachedSegmentIndices(segmentationId);\n    if (cachedResult) {\n        return cachedResult;\n    }\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation found for segmentationId ${segmentationId}`);\n    }\n    let indices;\n    if (segmentation.representationData.Labelmap) {\n        indices = handleLabelmapSegmentation(segmentation, segmentationId);\n    }\n    else if (segmentation.representationData.Contour) {\n        indices = handleContourSegmentation(segmentation);\n    }\n    else if (segmentation.representationData.Surface) {\n        indices = handleSurfaceSegmentation(segmentation);\n    }\n    else {\n        throw new Error(`Unsupported segmentation type: ${segmentation.representationData}`);\n    }\n    setCachedSegmentIndices(segmentationId, indices);\n    return indices;\n}\nfunction handleLabelmapSegmentation(segmentation, segmentationId) {\n    const labelmapData = segmentation.representationData[SegmentationRepresentations.Labelmap];\n    const keySet = new Set();\n    if (labelmapData.imageIds) {\n        addImageSegmentIndices(keySet, labelmapData.imageIds);\n    }\n    else {\n        addVolumeSegmentIndices(keySet, segmentationId);\n    }\n    return Array.from(keySet)\n        .map(Number)\n        .sort((a, b) => a - b);\n}\nfunction addVolumeSegmentIndices(keySet, segmentationId) {\n    const volume = cache.getVolume(segmentationId);\n    volume.voxelManager.forEach(({ value }) => {\n        if (value !== 0) {\n            keySet.add(value);\n        }\n    });\n}\nfunction addImageSegmentIndices(keySet, imageIds) {\n    imageIds.forEach((segmentationImageId) => {\n        const image = cache.getImage(segmentationImageId);\n        const scalarData = image.voxelManager.getScalarData();\n        scalarData.forEach((segmentIndex) => {\n            if (segmentIndex !== 0) {\n                keySet.add(segmentIndex);\n            }\n        });\n    });\n}\nfunction handleContourSegmentation(segmentation) {\n    const { annotationUIDsMap, geometryIds } = segmentation.representationData.Contour || {};\n    if (!geometryIds) {\n        throw new Error(`No geometryIds found for segmentationId ${segmentation.segmentationId}`);\n    }\n    const indices = new Set([...annotationUIDsMap.keys()]);\n    geometryIds.forEach((geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        indices.add(geometry.data.segmentIndex);\n    });\n    return Array.from(indices).sort((a, b) => a - b);\n}\nfunction handleSurfaceSegmentation(segmentation) {\n    const geometryIds = segmentation.representationData.Surface?.geometryIds ?? [];\n    return Array.from(geometryIds.keys())\n        .map(Number)\n        .sort((a, b) => a - b);\n}\nexport { getUniqueSegmentIndices };\n", "import { cache, getEnabledElementByViewportId, Enums, utilities, } from '@cornerstonejs/core';\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport { handleContourSegmentation } from './contourHandler/handleContourSegmentation';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport removeContourFromElement from './removeContourFromElement';\nimport { getPolySeg } from '../../../config';\nimport { computeAndAddRepresentation } from '../../../utilities/segmentation/computeAndAddRepresentation';\nimport { getUniqueSegmentIndices } from '../../../utilities/segmentation/getUniqueSegmentIndices';\nimport { getAnnotation } from '../../../stateManagement/annotation/annotationState';\nimport { vec3 } from 'gl-matrix';\nconst polySegConversionInProgressForViewportId = new Map();\nconst processedViewportSegmentations = new Map();\nfunction removeRepresentation(viewportId, segmentationId, renderImmediate = false) {\n    const enabledElement = getEnabledElementByViewportId(viewportId);\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    removeContourFromElement(viewportId, segmentationId);\n    if (!renderImmediate) {\n        return;\n    }\n    viewport.render();\n}\nasync function render(viewport, contourRepresentation) {\n    const { segmentationId } = contourRepresentation;\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        return;\n    }\n    let contourData = segmentation.representationData[Representations.Contour];\n    const polySeg = getPolySeg();\n    if (!contourData &&\n        getPolySeg()?.canComputeRequestedRepresentation(segmentationId, Representations.Contour) &&\n        !polySegConversionInProgressForViewportId.get(viewport.id)) {\n        polySegConversionInProgressForViewportId.set(viewport.id, true);\n        contourData = await computeAndAddRepresentation(segmentationId, Representations.Contour, () => polySeg.computeContourData(segmentationId, { viewport }), () => undefined);\n        polySegConversionInProgressForViewportId.set(viewport.id, false);\n    }\n    else if (!contourData && !getPolySeg()) {\n        console.debug(`No contour data found for segmentationId ${segmentationId} and PolySeg add-on is not configured. Unable to convert from other representations to contour. Please register PolySeg using cornerstoneTools.init({ addons: { polySeg } }) to enable automatic conversion.`);\n    }\n    if (!contourData) {\n        return;\n    }\n    if (!contourData.geometryIds?.length) {\n        return;\n    }\n    let hasContourDataButNotMatchingViewport = false;\n    const viewportNormal = viewport.getCamera().viewPlaneNormal;\n    if (contourData.annotationUIDsMap) {\n        hasContourDataButNotMatchingViewport = !_checkContourNormalsMatchViewport(contourData.annotationUIDsMap, viewportNormal);\n    }\n    if (contourData.geometryIds.length > 0) {\n        hasContourDataButNotMatchingViewport = !_checkContourGeometryMatchViewport(contourData.geometryIds, viewportNormal);\n    }\n    const viewportProcessed = processedViewportSegmentations.get(viewport.id) || new Set();\n    if (hasContourDataButNotMatchingViewport &&\n        !polySegConversionInProgressForViewportId.get(viewport.id) &&\n        !viewportProcessed.has(segmentationId) &&\n        viewport.viewportStatus === Enums.ViewportStatus.RENDERED) {\n        polySegConversionInProgressForViewportId.set(viewport.id, true);\n        const segmentIndices = getUniqueSegmentIndices(segmentationId);\n        const surfacesInfo = await polySeg.computeSurfaceData(segmentationId, {\n            segmentIndices,\n            viewport,\n        });\n        const geometryIds = surfacesInfo.geometryIds;\n        const pointsAndPolys = [];\n        for (const geometryId of geometryIds.values()) {\n            const geometry = cache.getGeometry(geometryId);\n            const data = geometry.data;\n            pointsAndPolys.push({\n                points: data.points,\n                polys: data.polys,\n                segmentIndex: data.segmentIndex,\n                id: data.segmentIndex,\n            });\n        }\n        const polyDataCache = await polySeg.clipAndCacheSurfacesForViewport(pointsAndPolys, viewport);\n        const rawResults = polySeg.extractContourData(polyDataCache);\n        const annotationUIDsMap = polySeg.createAndAddContourSegmentationsFromClippedSurfaces(rawResults, viewport, segmentationId);\n        contourData.annotationUIDsMap = new Map([\n            ...contourData.annotationUIDsMap,\n            ...annotationUIDsMap,\n        ]);\n        viewportProcessed.add(segmentationId);\n        processedViewportSegmentations.set(viewport.id, viewportProcessed);\n        polySegConversionInProgressForViewportId.set(viewport.id, false);\n    }\n    handleContourSegmentation(viewport, contourData.geometryIds, contourData.annotationUIDsMap, contourRepresentation);\n}\nfunction _checkContourGeometryMatchViewport(geometryIds, viewportNormal) {\n    let validGeometry = null;\n    let geometryData = null;\n    for (const geometryId of geometryIds) {\n        const geometry = cache.getGeometry(geometryId);\n        if (!geometry) {\n            continue;\n        }\n        const data = geometry.data;\n        if (data.contours?.[0]?.points?.length >= 3) {\n            validGeometry = geometry;\n            geometryData = data;\n            break;\n        }\n    }\n    if (!validGeometry || !geometryData) {\n        return false;\n    }\n    const contours = geometryData.contours;\n    const points = contours[0].points;\n    const point1 = points[0];\n    const point2 = points[1];\n    const point3 = points[2];\n    let normal = vec3.cross(vec3.create(), vec3.sub(vec3.create(), point2, point1), vec3.sub(vec3.create(), point3, point1));\n    normal = vec3.normalize(vec3.create(), normal);\n    const dotProduct = vec3.dot(normal, viewportNormal);\n    return Math.abs(dotProduct) > 0.9;\n}\nfunction _checkContourNormalsMatchViewport(annotationUIDsMap, viewportNormal) {\n    const annotationUIDs = Array.from(annotationUIDsMap.values())\n        .flat()\n        .map((uidSet) => Array.from(uidSet))\n        .flat();\n    const randomAnnotationUIDs = utilities.getRandomSampleFromArray(annotationUIDs, 3);\n    for (const annotationUID of randomAnnotationUIDs) {\n        const annotation = getAnnotation(annotationUID);\n        if (annotation?.metadata) {\n            if (!annotation.metadata.viewPlaneNormal) {\n                continue;\n            }\n            const annotationNormal = annotation.metadata.viewPlaneNormal;\n            const dotProduct = Math.abs(viewportNormal[0] * annotationNormal[0] +\n                viewportNormal[1] * annotationNormal[1] +\n                viewportNormal[2] * annotationNormal[2]);\n            if (Math.abs(dotProduct - 1) > 0.01) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nexport default {\n    render,\n    removeRepresentation,\n};\n", "import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getCurrentLabelmapImageIdForViewport(viewportId, segmentationId) {\n    const imageIds = getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId);\n    return imageIds[0];\n}\nexport function getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId);\n}\nexport function getLabelmapImageIdsForImageId(imageId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getLabelmapImageIdsForImageId(imageId, segmentationId);\n}\n", "import { cache, Enums, convertMapperToNotSharedMapper, volumeLoader, eventTarget, createVolumeActor, } from '@cornerstonejs/core';\nimport { Events, SegmentationRepresentations } from '../../../enums';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nconst internalCache = new Map();\nconst load = ({ cfun, ofun, actor }) => {\n    actor.getProperty().setRGBTransferFunction(1, cfun);\n    actor.getProperty().setScalarOpacity(1, ofun);\n};\nexport async function addVolumesAsIndependentComponents({ viewport, volumeInputs, segmentationId, }) {\n    const defaultActor = viewport.getDefaultActor();\n    const { actor } = defaultActor;\n    const { uid, callback } = defaultActor;\n    const referenceVolumeId = viewport.getVolumeId();\n    if (internalCache.get(uid)?.added) {\n        return {\n            uid,\n            actor,\n        };\n    }\n    const volumeInputArray = volumeInputs;\n    const firstImageVolume = cache.getVolume(volumeInputArray[0].volumeId);\n    if (!firstImageVolume) {\n        throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist`);\n    }\n    const { volumeId } = volumeInputArray[0];\n    const segImageVolume = await volumeLoader.loadVolume(volumeId);\n    if (!segImageVolume) {\n        throw new Error(`segImageVolume with id: ${segImageVolume.volumeId} does not exist`);\n    }\n    const segVoxelManager = segImageVolume.voxelManager;\n    const segData = segVoxelManager.getCompleteScalarDataArray();\n    const { imageData: segImageData } = segImageVolume;\n    const baseVolume = cache.getVolume(referenceVolumeId);\n    const baseVoxelManager = baseVolume.voxelManager;\n    const baseData = baseVoxelManager.getCompleteScalarDataArray();\n    const newComp = 2;\n    const cubeData = new Float32Array(newComp * baseVolume.voxelManager.getScalarDataLength());\n    const dims = segImageData.getDimensions();\n    for (let z = 0; z < dims[2]; ++z) {\n        for (let y = 0; y < dims[1]; ++y) {\n            for (let x = 0; x < dims[0]; ++x) {\n                const iTuple = x + dims[0] * (y + dims[1] * z);\n                cubeData[iTuple * newComp + 0] = baseData[iTuple];\n                cubeData[iTuple * newComp + 1] = segData[iTuple];\n            }\n        }\n    }\n    viewport.removeActors([uid]);\n    const oldMapper = actor.getMapper();\n    const mapper = convertMapperToNotSharedMapper(oldMapper);\n    actor.setMapper(mapper);\n    mapper.setBlendMode(Enums.BlendModes.LABELMAP_EDGE_PROJECTION_BLEND);\n    const arrayAgain = mapper.getInputData().getPointData().getArray(0);\n    arrayAgain.setData(cubeData);\n    arrayAgain.setNumberOfComponents(2);\n    actor.getProperty().setColorMixPreset(1);\n    actor.getProperty().setForceNearestInterpolation(1, true);\n    actor.getProperty().setIndependentComponents(true);\n    viewport.addActor({\n        actor,\n        uid,\n        callback,\n        referencedId: referenceVolumeId,\n        representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}`,\n    });\n    internalCache.set(uid, {\n        added: true,\n        segmentationRepresentationUID: `${segmentationId}`,\n        originalBlendMode: viewport.getBlendMode(),\n    });\n    actor.set({\n        preLoad: load,\n    });\n    function onSegmentationDataModified(evt) {\n        const { segmentationId } = evt.detail;\n        const { representationData } = getSegmentation(segmentationId);\n        const { volumeId: segVolumeId } = representationData.Labelmap;\n        if (segVolumeId !== segImageVolume.volumeId) {\n            return;\n        }\n        const segmentationVolume = cache.getVolume(segVolumeId);\n        const segVoxelManager = segmentationVolume.voxelManager;\n        const imageData = mapper.getInputData();\n        const array = imageData.getPointData().getArray(0);\n        const baseData = array.getData();\n        const newComp = 2;\n        const dims = segImageData.getDimensions();\n        const slices = Array.from({ length: dims[2] }, (_, i) => i);\n        for (const z of slices) {\n            for (let y = 0; y < dims[1]; ++y) {\n                for (let x = 0; x < dims[0]; ++x) {\n                    const iTuple = x + dims[0] * (y + dims[1] * z);\n                    baseData[iTuple * newComp + 1] = segVoxelManager.getAtIndex(iTuple);\n                }\n            }\n        }\n        array.setData(baseData);\n        imageData.modified();\n        viewport.render();\n    }\n    eventTarget.addEventListenerDebounced(Events.SEGMENTATION_DATA_MODIFIED, onSegmentationDataModified, 200);\n    eventTarget.addEventListener(Events.SEGMENTATION_REPRESENTATION_REMOVED, async (evt) => {\n        eventTarget.removeEventListener(Events.SEGMENTATION_DATA_MODIFIED, onSegmentationDataModified);\n        const actorEntry = viewport.getActor(uid);\n        const { element, id } = viewport;\n        viewport.removeActors([uid]);\n        const actor = await createVolumeActor({\n            volumeId: uid,\n            blendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n            callback: ({ volumeActor }) => {\n                if (actorEntry.callback) {\n                    actorEntry.callback({\n                        volumeActor,\n                        volumeId,\n                    });\n                }\n            },\n        }, element, id);\n        viewport.addActor({ actor, uid });\n        viewport.render();\n    });\n    return {\n        uid,\n        actor,\n    };\n}\n", "import { getEnabledElement, addVolumesToViewports, addImageSlicesToViewports, Enums, cache, BaseVolumeViewport, volumeLoader, utilities, } from '@cornerstonejs/core';\nimport { getCurrentLabelmapImageIdsForViewport } from '../../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport { triggerSegmentationDataModified, triggerSegmentationModified, } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { SegmentationRepresentations } from '../../../enums';\nimport { addVolumesAsIndependentComponents } from './addVolumesAsIndependentComponents';\nconst { uuidv4 } = utilities;\nasync function addLabelmapToElement(element, labelMapData, segmentationId, config) {\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { id: viewportId } = viewport;\n    const visibility = true;\n    const immediateRender = false;\n    const suppressEvents = true;\n    if (viewport instanceof BaseVolumeViewport) {\n        const volumeLabelMapData = labelMapData;\n        const volumeId = _ensureVolumeHasVolumeId(volumeLabelMapData, segmentationId);\n        if (!cache.getVolume(volumeId)) {\n            await _handleMissingVolume(labelMapData);\n        }\n        let blendMode = config?.blendMode ?? Enums.BlendModes.MAXIMUM_INTENSITY_BLEND;\n        let useIndependentComponents = blendMode === Enums.BlendModes.LABELMAP_EDGE_PROJECTION_BLEND;\n        if (useIndependentComponents) {\n            const referenceVolumeId = viewport.getVolumeId();\n            const baseVolume = cache.getVolume(referenceVolumeId);\n            const segVolume = cache.getVolume(volumeId);\n            const segDims = segVolume.dimensions;\n            const refDims = baseVolume.dimensions;\n            if (segDims[0] !== refDims[0] ||\n                segDims[1] !== refDims[1] ||\n                segDims[2] !== refDims[2]) {\n                useIndependentComponents = false;\n                blendMode = Enums.BlendModes.MAXIMUM_INTENSITY_BLEND;\n                console.debug('Dimensions mismatch - falling back to regular volume addition');\n            }\n        }\n        const volumeInputs = [\n            {\n                volumeId,\n                visibility,\n                representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}`,\n                useIndependentComponents,\n                blendMode,\n            },\n        ];\n        if (!volumeInputs[0].useIndependentComponents) {\n            await addVolumesToViewports(renderingEngine, volumeInputs, [viewportId], immediateRender, suppressEvents);\n        }\n        else {\n            const result = await addVolumesAsIndependentComponents({\n                viewport,\n                volumeInputs,\n                segmentationId,\n            });\n            return result;\n        }\n    }\n    else {\n        const segmentationImageIds = getCurrentLabelmapImageIdsForViewport(viewport.id, segmentationId);\n        const stackInputs = segmentationImageIds.map((imageId) => ({\n            imageId,\n            representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}-${imageId}`,\n        }));\n        addImageSlicesToViewports(renderingEngine, stackInputs, [viewportId]);\n    }\n    triggerSegmentationDataModified(segmentationId);\n}\nfunction _ensureVolumeHasVolumeId(labelMapData, segmentationId) {\n    let { volumeId } = labelMapData;\n    if (!volumeId) {\n        volumeId = uuidv4();\n        const segmentation = getSegmentation(segmentationId);\n        segmentation.representationData.Labelmap = {\n            ...segmentation.representationData.Labelmap,\n            volumeId,\n        };\n        labelMapData.volumeId = volumeId;\n        triggerSegmentationModified(segmentationId);\n    }\n    return volumeId;\n}\nasync function _handleMissingVolume(labelMapData) {\n    const stackData = labelMapData;\n    const hasImageIds = stackData.imageIds.length > 0;\n    if (!hasImageIds) {\n        throw new Error('cannot create labelmap, no imageIds found for the volume labelmap');\n    }\n    const volume = await volumeLoader.createAndCacheVolumeFromImages(labelMapData.volumeId || uuidv4(), stackData.imageIds);\n    return volume;\n}\nexport default addLabelmapToElement;\n", "import { getEnabledElement } from '@cornerstonejs/core';\nimport { getLabelmapActorUID } from '../../../stateManagement/segmentation/helpers/getSegmentationActor';\nfunction removeLabelmapFromElement(element, segmentationId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    viewport.removeActors([getLabelmapActorUID(viewport.id, segmentationId)]);\n}\nexport default removeLabelmapFromElement;\n", "import { getActiveSegmentation as _getActiveSegmentation } from './getActiveSegmentation';\nimport { setActiveSegmentation as _setActiveSegmentation } from './setActiveSegmentation';\nfunction getActiveSegmentation(viewportId) {\n    return _getActiveSegmentation(viewportId);\n}\nfunction setActiveSegmentation(viewportId, segmentationId) {\n    _setActiveSegmentation(viewportId, segmentationId);\n}\nexport { getActiveSegmentation, setActiveSegmentation, };\n", "import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getActiveSegmentation(viewportId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getActiveSegmentation(viewportId);\n}\n", "import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function setActiveSegmentation(viewportId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    segmentationStateManager.setActiveSegmentation(viewportId, segmentationId);\n}\n", "import { getSegmentation } from './getSegmentation';\nexport function getActiveSegmentIndex(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    if (segmentation) {\n        const activeSegmentIndex = Object.keys(segmentation.segments).find((segmentIndex) => segmentation.segments[segmentIndex].active);\n        return activeSegmentIndex ? Number(activeSegmentIndex) : undefined;\n    }\n    return undefined;\n}\n", "import { getEnabledElementByViewportId, VolumeViewport, } from '@cornerstonejs/core';\nimport addLabelmapToElement from './addLabelmapToElement';\nimport removeLabelmapFromElement from './removeLabelmapFromElement';\nimport { getActiveSegmentation } from '../../../stateManagement/segmentation/activeSegmentation';\nimport { getColorLUT } from '../../../stateManagement/segmentation/getColorLUT';\nimport { getCurrentLabelmapImageIdsForViewport } from '../../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport { segmentationStyle } from '../../../stateManagement/segmentation/SegmentationStyle';\nimport SegmentationRepresentations from '../../../enums/SegmentationRepresentations';\nimport { internalGetHiddenSegmentIndices } from '../../../stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices';\nimport { getActiveSegmentIndex } from '../../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { getLabelmapActorEntries } from '../../../stateManagement/segmentation/helpers/getSegmentationActor';\nimport { getPolySeg } from '../../../config';\nimport { computeAndAddRepresentation } from '../../../utilities/segmentation/computeAndAddRepresentation';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { defaultSegmentationStateManager } from '../../../stateManagement/segmentation/SegmentationStateManager';\nexport const MAX_NUMBER_COLORS = 255;\nconst labelMapConfigCache = new Map();\nlet polySegConversionInProgress = false;\nfunction removeRepresentation(viewportId, segmentationId, renderImmediate = false) {\n    const enabledElement = getEnabledElementByViewportId(viewportId);\n    labelMapConfigCache.forEach((value, key) => {\n        if (key.includes(segmentationId)) {\n            labelMapConfigCache.delete(key);\n        }\n    });\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    removeLabelmapFromElement(viewport.element, segmentationId);\n    if (!renderImmediate) {\n        return;\n    }\n    viewport.render();\n}\nasync function render(viewport, representation) {\n    const { segmentationId, config } = representation;\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        console.warn('No segmentation found for segmentationId: ', segmentationId);\n        return;\n    }\n    let labelmapData = segmentation.representationData[SegmentationRepresentations.Labelmap];\n    let labelmapActorEntries = getLabelmapActorEntries(viewport.id, segmentationId);\n    if (!labelmapData &&\n        getPolySeg()?.canComputeRequestedRepresentation(segmentationId, SegmentationRepresentations.Labelmap) &&\n        !polySegConversionInProgress) {\n        polySegConversionInProgress = true;\n        const polySeg = getPolySeg();\n        labelmapData = await computeAndAddRepresentation(segmentationId, SegmentationRepresentations.Labelmap, () => polySeg.computeLabelmapData(segmentationId, { viewport }), () => null, () => {\n            defaultSegmentationStateManager.processLabelmapRepresentationAddition(viewport.id, segmentationId);\n            setTimeout(() => {\n                triggerSegmentationDataModified(segmentationId);\n            }, 0);\n        });\n        if (!labelmapData) {\n            throw new Error(`No labelmap data found for segmentationId ${segmentationId}.`);\n        }\n        polySegConversionInProgress = false;\n    }\n    else if (!labelmapData && !getPolySeg()) {\n        console.debug(`No labelmap data found for segmentationId ${segmentationId} and PolySeg add-on is not configured. Unable to convert from other representations to labelmap. Please register PolySeg using cornerstoneTools.init({ addons: { polySeg } }) to enable automatic conversion.`);\n    }\n    if (!labelmapData) {\n        return;\n    }\n    if (viewport instanceof VolumeViewport) {\n        if (!labelmapActorEntries?.length) {\n            await _addLabelmapToViewport(viewport, labelmapData, segmentationId, config);\n        }\n        labelmapActorEntries = getLabelmapActorEntries(viewport.id, segmentationId);\n    }\n    else {\n        const labelmapImageIds = getCurrentLabelmapImageIdsForViewport(viewport.id, segmentationId);\n        if (!labelmapImageIds?.length) {\n            return;\n        }\n        if (!labelmapActorEntries) {\n            await _addLabelmapToViewport(viewport, labelmapData, segmentationId, config);\n        }\n        labelmapActorEntries = getLabelmapActorEntries(viewport.id, segmentationId);\n    }\n    if (!labelmapActorEntries?.length) {\n        return;\n    }\n    for (const labelmapActorEntry of labelmapActorEntries) {\n        _setLabelmapColorAndOpacity(viewport.id, labelmapActorEntry, representation);\n    }\n}\nfunction _setLabelmapColorAndOpacity(viewportId, labelmapActorEntry, segmentationRepresentation) {\n    const { segmentationId } = segmentationRepresentation;\n    const { cfun, ofun } = segmentationRepresentation.config;\n    const { colorLUTIndex } = segmentationRepresentation;\n    const activeSegmentation = getActiveSegmentation(viewportId);\n    const isActiveLabelmap = activeSegmentation?.segmentationId === segmentationId;\n    const labelmapStyle = segmentationStyle.getStyle({\n        viewportId,\n        type: SegmentationRepresentations.Labelmap,\n        segmentationId,\n    });\n    const renderInactiveSegmentations = segmentationStyle.getRenderInactiveSegmentations(viewportId);\n    const colorLUT = getColorLUT(colorLUTIndex);\n    const numColors = Math.min(256, colorLUT.length);\n    const { outlineWidth, renderOutline, outlineOpacity, activeSegmentOutlineWidthDelta, } = _getLabelmapConfig(labelmapStyle, isActiveLabelmap);\n    const segmentsHidden = internalGetHiddenSegmentIndices(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Labelmap,\n    });\n    for (let i = 0; i < numColors; i++) {\n        const segmentIndex = i;\n        const segmentColor = colorLUT[segmentIndex];\n        const perSegmentStyle = segmentationStyle.getStyle({\n            viewportId,\n            type: SegmentationRepresentations.Labelmap,\n            segmentationId,\n            segmentIndex,\n        });\n        const segmentSpecificLabelmapConfig = perSegmentStyle;\n        const { fillAlpha, outlineWidth, renderFill, renderOutline } = _getLabelmapConfig(labelmapStyle, isActiveLabelmap, segmentSpecificLabelmapConfig);\n        const { forceOpacityUpdate, forceColorUpdate } = _needsTransferFunctionUpdate(viewportId, segmentationId, segmentIndex, {\n            fillAlpha,\n            renderFill,\n            renderOutline,\n            segmentColor,\n            outlineWidth,\n            segmentsHidden: segmentsHidden,\n            cfun,\n            ofun,\n        });\n        if (forceColorUpdate) {\n            cfun.addRGBPoint(segmentIndex, segmentColor[0] / MAX_NUMBER_COLORS, segmentColor[1] / MAX_NUMBER_COLORS, segmentColor[2] / MAX_NUMBER_COLORS);\n        }\n        if (forceOpacityUpdate) {\n            if (renderFill) {\n                const segmentOpacity = segmentsHidden.has(segmentIndex)\n                    ? 0\n                    : (segmentColor[3] / 255) * fillAlpha;\n                ofun.removePoint(segmentIndex);\n                ofun.addPointLong(segmentIndex, segmentOpacity, 0.5, 1.0);\n            }\n            else {\n                ofun.addPointLong(segmentIndex, 0.01, 0.5, 1.0);\n            }\n        }\n    }\n    ofun.setClamping(false);\n    const labelmapActor = labelmapActorEntry.actor;\n    const { preLoad } = labelmapActor.get?.('preLoad') || { preLoad: null };\n    if (preLoad) {\n        preLoad({ cfun, ofun, actor: labelmapActor });\n    }\n    else {\n        labelmapActor.getProperty().setRGBTransferFunction(0, cfun);\n        labelmapActor.getProperty().setScalarOpacity(0, ofun);\n        labelmapActor.getProperty().setInterpolationTypeToNearest();\n    }\n    if (renderOutline) {\n        labelmapActor.getProperty().setUseLabelOutline(renderOutline);\n        labelmapActor.getProperty().setLabelOutlineOpacity(outlineOpacity);\n        const activeSegmentIndex = getActiveSegmentIndex(segmentationRepresentation.segmentationId);\n        const outlineWidths = new Array(numColors - 1);\n        for (let i = 1; i < numColors; i++) {\n            const isHidden = segmentsHidden.has(i);\n            if (isHidden) {\n                outlineWidths[i - 1] = 0;\n                continue;\n            }\n            outlineWidths[i - 1] =\n                i === activeSegmentIndex\n                    ? outlineWidth + activeSegmentOutlineWidthDelta\n                    : outlineWidth;\n        }\n        labelmapActor.getProperty().setLabelOutlineThickness(outlineWidths);\n        labelmapActor.modified();\n        labelmapActor.getProperty().modified();\n        labelmapActor.getMapper().modified();\n    }\n    else {\n        labelmapActor\n            .getProperty()\n            .setLabelOutlineThickness(new Array(numColors - 1).fill(0));\n    }\n    const visible = isActiveLabelmap || renderInactiveSegmentations;\n    labelmapActor.setVisibility(visible);\n}\nfunction _getLabelmapConfig(labelmapConfig, isActiveLabelmap, segmentsLabelmapConfig) {\n    const segmentLabelmapConfig = segmentsLabelmapConfig || {};\n    const configToUse = {\n        ...labelmapConfig,\n        ...segmentLabelmapConfig,\n    };\n    const fillAlpha = isActiveLabelmap\n        ? configToUse.fillAlpha\n        : configToUse.fillAlphaInactive;\n    const outlineWidth = isActiveLabelmap\n        ? configToUse.outlineWidth\n        : configToUse.outlineWidthInactive;\n    const renderFill = isActiveLabelmap\n        ? configToUse.renderFill\n        : configToUse.renderFillInactive;\n    const renderOutline = isActiveLabelmap\n        ? configToUse.renderOutline\n        : configToUse.renderOutlineInactive;\n    const outlineOpacity = isActiveLabelmap\n        ? configToUse.outlineOpacity\n        : configToUse.outlineOpacityInactive;\n    const activeSegmentOutlineWidthDelta = configToUse.activeSegmentOutlineWidthDelta;\n    return {\n        fillAlpha,\n        outlineWidth,\n        renderFill,\n        renderOutline,\n        outlineOpacity,\n        activeSegmentOutlineWidthDelta,\n    };\n}\nfunction _needsTransferFunctionUpdate(viewportId, segmentationId, segmentIndex, { fillAlpha, renderFill, renderOutline, segmentColor, outlineWidth, segmentsHidden, cfun, ofun, }) {\n    const cacheUID = `${viewportId}-${segmentationId}-${segmentIndex}`;\n    const oldConfig = labelMapConfigCache.get(cacheUID);\n    if (!oldConfig) {\n        labelMapConfigCache.set(cacheUID, {\n            fillAlpha,\n            renderFill,\n            renderOutline,\n            outlineWidth,\n            segmentColor: segmentColor.slice(),\n            segmentsHidden: new Set(segmentsHidden),\n            cfunMTime: cfun.getMTime(),\n            ofunMTime: ofun.getMTime(),\n        });\n        return {\n            forceOpacityUpdate: true,\n            forceColorUpdate: true,\n        };\n    }\n    const { fillAlpha: oldFillAlpha, renderFill: oldRenderFill, renderOutline: oldRenderOutline, outlineWidth: oldOutlineWidth, segmentColor: oldSegmentColor, segmentsHidden: oldSegmentsHidden, cfunMTime: oldCfunMTime, ofunMTime: oldOfunMTime, } = oldConfig;\n    const forceColorUpdate = oldSegmentColor[0] !== segmentColor[0] ||\n        oldSegmentColor[1] !== segmentColor[1] ||\n        oldSegmentColor[2] !== segmentColor[2];\n    const forceOpacityUpdate = oldSegmentColor[3] !== segmentColor[3] ||\n        oldFillAlpha !== fillAlpha ||\n        oldRenderFill !== renderFill ||\n        oldRenderOutline !== renderOutline ||\n        oldOutlineWidth !== outlineWidth ||\n        oldSegmentsHidden !== segmentsHidden;\n    if (forceOpacityUpdate || forceColorUpdate) {\n        labelMapConfigCache.set(cacheUID, {\n            fillAlpha,\n            renderFill,\n            renderOutline,\n            outlineWidth,\n            segmentColor: segmentColor.slice(),\n            segmentsHidden: new Set(segmentsHidden),\n            cfunMTime: cfun.getMTime(),\n            ofunMTime: ofun.getMTime(),\n        });\n    }\n    return {\n        forceOpacityUpdate,\n        forceColorUpdate,\n    };\n}\nasync function _addLabelmapToViewport(viewport, labelmapData, segmentationId, config) {\n    const result = await addLabelmapToElement(viewport.element, labelmapData, segmentationId, config);\n    return result || undefined;\n}\nexport default {\n    render,\n    removeRepresentation,\n};\nexport { render, removeRepresentation };\n", "import { utilities } from '@cornerstonejs/core';\nimport ToolModes from '../../enums/ToolModes';\nconst { DefaultHistoryMemo } = utilities.HistoryMemo;\nclass BaseTool {\n    static { this.defaults = {\n        configuration: {\n            strategies: {},\n            defaultStrategy: undefined,\n            activeStrategy: undefined,\n            strategyOptions: {},\n        },\n    }; }\n    constructor(toolProps, defaultToolProps) {\n        const mergedDefaults = BaseTool.mergeDefaultProps(BaseTool.defaults, defaultToolProps);\n        const initialProps = utilities.deepMerge(mergedDefaults, toolProps);\n        const { configuration = {}, supportedInteractionTypes, toolGroupId, } = initialProps;\n        this.toolGroupId = toolGroupId;\n        this.supportedInteractionTypes = supportedInteractionTypes || [];\n        this.configuration = Object.assign({}, configuration);\n        this.mode = ToolModes.Disabled;\n    }\n    static mergeDefaultProps(defaultProps = {}, additionalProps) {\n        if (!additionalProps) {\n            return defaultProps;\n        }\n        return utilities.deepMerge(defaultProps, additionalProps);\n    }\n    get toolName() {\n        return this.getToolName();\n    }\n    getToolName() {\n        return this.constructor.toolName;\n    }\n    applyActiveStrategy(enabledElement, operationData) {\n        const { strategies, activeStrategy } = this.configuration;\n        return strategies[activeStrategy]?.call(this, enabledElement, operationData);\n    }\n    applyActiveStrategyCallback(enabledElement, operationData, callbackType, ...extraArgs) {\n        const { strategies, activeStrategy } = this.configuration;\n        if (!strategies[activeStrategy]) {\n            throw new Error(`applyActiveStrategyCallback: active strategy ${activeStrategy} not found, check tool configuration or spellings`);\n        }\n        return strategies[activeStrategy][callbackType]?.call(this, enabledElement, operationData, ...extraArgs);\n    }\n    setConfiguration(newConfiguration) {\n        this.configuration = utilities.deepMerge(this.configuration, newConfiguration);\n    }\n    setActiveStrategy(strategyName) {\n        this.setConfiguration({ activeStrategy: strategyName });\n    }\n    getTargetImageData(targetId) {\n        if (targetId.startsWith('imageId:')) {\n            const imageId = targetId.split('imageId:')[1];\n            const imageURI = utilities.imageIdToURI(imageId);\n            let viewports = utilities.getViewportsWithImageURI(imageURI);\n            if (!viewports || !viewports.length) {\n                return;\n            }\n            viewports = viewports.filter((viewport) => {\n                return viewport.getCurrentImageId() === imageId;\n            });\n            if (!viewports || !viewports.length) {\n                return;\n            }\n            return viewports[0].getImageData();\n        }\n        else if (targetId.startsWith('volumeId:')) {\n            const volumeId = utilities.getVolumeId(targetId);\n            const viewports = utilities.getViewportsWithVolumeId(volumeId);\n            if (!viewports || !viewports.length) {\n                return;\n            }\n            return viewports[0].getImageData();\n        }\n        else if (targetId.startsWith('videoId:')) {\n            const imageURI = utilities.imageIdToURI(targetId);\n            const viewports = utilities.getViewportsWithImageURI(imageURI);\n            if (!viewports || !viewports.length) {\n                return;\n            }\n            return viewports[0].getImageData();\n        }\n        else {\n            throw new Error('getTargetIdImage: targetId must start with \"imageId:\" or \"volumeId:\"');\n        }\n    }\n    getTargetId(viewport) {\n        const targetId = viewport.getViewReferenceId?.();\n        if (targetId) {\n            return targetId;\n        }\n        throw new Error('getTargetId: viewport must have a getViewReferenceId method');\n    }\n    undo() {\n        this.doneEditMemo();\n        DefaultHistoryMemo.undo();\n    }\n    redo() {\n        DefaultHistoryMemo.redo();\n    }\n    static createZoomPanMemo(viewport) {\n        const state = {\n            pan: viewport.getPan(),\n            zoom: viewport.getZoom(),\n        };\n        const zoomPanMemo = {\n            restoreMemo: () => {\n                const currentPan = viewport.getPan();\n                const currentZoom = viewport.getZoom();\n                viewport.setZoom(state.zoom);\n                viewport.setPan(state.pan);\n                viewport.render();\n                state.pan = currentPan;\n                state.zoom = currentZoom;\n            },\n        };\n        DefaultHistoryMemo.push(zoomPanMemo);\n        return zoomPanMemo;\n    }\n    doneEditMemo() {\n        if (this.memo?.commitMemo?.()) {\n            DefaultHistoryMemo.push(this.memo);\n        }\n        this.memo = null;\n    }\n    static startGroupRecording() {\n        DefaultHistoryMemo.startGroupRecording();\n    }\n    static endGroupRecording() {\n        DefaultHistoryMemo.endGroupRecording();\n    }\n}\nBaseTool.toolName = 'BaseTool';\nexport default BaseTool;\n", "import { vec3 } from 'gl-matrix';\nimport { CONSTANTS, metaData, utilities } from '@cornerstonejs/core';\nconst { isEqual } = utilities;\nconst { EPSILON } = CONSTANTS;\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\nexport default function filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {\n    const { viewPlaneNormal } = camera;\n    const annotationsWithParallelNormals = annotations.filter((td) => {\n        const { planeRestriction, referencedImageId } = td.metadata;\n        let { viewPlaneNormal: annotationViewPlaneNormal } = td.metadata;\n        if (planeRestriction) {\n            const { inPlaneVector1, inPlaneVector2 } = planeRestriction;\n            if (inPlaneVector1 &&\n                !isEqual(0, vec3.dot(viewPlaneNormal, inPlaneVector1))) {\n                return false;\n            }\n            if (inPlaneVector2 &&\n                !isEqual(0, vec3.dot(viewPlaneNormal, inPlaneVector2))) {\n                return false;\n            }\n            return true;\n        }\n        if (!td.metadata.referencedImageId &&\n            !annotationViewPlaneNormal &&\n            td.metadata.FrameOfReferenceUID) {\n            for (const point of td.data.handles.points) {\n                const vector = vec3.sub(vec3.create(), point, camera.focalPoint);\n                const dotProduct = vec3.dot(vector, viewPlaneNormal);\n                if (!isEqual(dotProduct, 0)) {\n                    return false;\n                }\n            }\n            td.metadata.viewPlaneNormal = viewPlaneNormal;\n            td.metadata.cameraFocalPoint = camera.focalPoint;\n            return true;\n        }\n        if (!annotationViewPlaneNormal && referencedImageId) {\n            const { imageOrientationPatient } = metaData.get('imagePlaneModule', referencedImageId);\n            const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n            const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n            annotationViewPlaneNormal = vec3.create();\n            vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);\n            td.metadata.viewPlaneNormal = annotationViewPlaneNormal;\n        }\n        const isParallel = Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n            PARALLEL_THRESHOLD;\n        return annotationViewPlaneNormal && isParallel;\n    });\n    if (!annotationsWithParallelNormals.length) {\n        return [];\n    }\n    const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n    const { focalPoint } = camera;\n    const annotationsWithinSlice = [];\n    for (const annotation of annotationsWithParallelNormals) {\n        const data = annotation.data;\n        const point = data.handles.points[0] || data.contour?.polyline[0];\n        if (!annotation.isVisible) {\n            continue;\n        }\n        const dir = vec3.create();\n        if (!point) {\n            annotationsWithinSlice.push(annotation);\n            continue;\n        }\n        vec3.sub(dir, focalPoint, point);\n        const dot = vec3.dot(dir, viewPlaneNormal);\n        if (Math.abs(dot) < halfSpacingInNormalDirection) {\n            annotationsWithinSlice.push(annotation);\n        }\n    }\n    return annotationsWithinSlice;\n}\n", "import { StackViewport, VolumeViewport, utilities as csUtils, } from '@cornerstonejs/core';\nimport filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nexport default function filterAnnotationsForDisplay(viewport, annotations, filterOptions = {}) {\n    if (viewport instanceof VolumeViewport) {\n        const camera = viewport.getCamera();\n        const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n        return filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection);\n    }\n    if (viewport instanceof StackViewport) {\n        const imageId = viewport.getCurrentImageId();\n        if (!imageId) {\n            return [];\n        }\n        const colonIndex = imageId.indexOf(':');\n        filterOptions.imageURI = imageId.substring(colonIndex + 1);\n    }\n    return annotations.filter((annotation) => {\n        if (!annotation.isVisible) {\n            return false;\n        }\n        if (annotation.data.isCanvasAnnotation) {\n            return true;\n        }\n        return viewport.isReferenceViewable(annotation.metadata, filterOptions);\n    });\n}\n", "import getState from './getState';\nimport getFont from './getFont';\nimport style from './ToolStyle';\nexport { getState, getFont, style };\n", "import { isAnnotationLocked } from '../annotationLocking';\nimport { isAnnotationSelected } from '../annotationSelection';\nimport { AnnotationStyleStates } from '../../../enums';\nfunction getState(annotation) {\n    if (annotation) {\n        if (annotation.data && annotation.highlighted) {\n            return AnnotationStyleStates.Highlighted;\n        }\n        if (isAnnotationSelected(annotation.annotationUID)) {\n            return AnnotationStyleStates.Selected;\n        }\n        if (isAnnotationLocked(annotation.annotationUID)) {\n            return AnnotationStyleStates.Locked;\n        }\n        if (annotation.data && annotation.autoGenerated) {\n            return AnnotationStyleStates.AutoGenerated;\n        }\n    }\n    return AnnotationStyleStates.Default;\n}\nexport default getState;\n", "import { getStyleProperty } from './helpers';\nfunction getFont(styleSpecifier, state, mode) {\n    const fontSize = getStyleProperty('textBoxFontSize', styleSpecifier, state, mode);\n    const fontFamily = getStyleProperty('textBoxFontFamily', styleSpecifier, state, mode);\n    return `${fontSize}px ${fontFamily}`;\n}\nexport default getFont;\n", "import { utilities, getEnabledElement, cache, BaseVolumeViewport, } from '@cornerstonejs/core';\nimport BaseTool from './BaseTool';\nimport { getAnnotationManager } from '../../stateManagement/annotation/annotationState';\nimport triggerAnnotationRender from '../../utilities/triggerAnnotationRender';\nimport filterAnnotationsForDisplay from '../../utilities/planar/filterAnnotationsForDisplay';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nimport { getState } from '../../stateManagement/annotation/config';\nclass AnnotationDisplayTool extends BaseTool {\n    constructor() {\n        super(...arguments);\n        this.onImageSpacingCalibrated = (evt) => {\n            const { element, imageId } = evt.detail;\n            const imageURI = utilities.imageIdToURI(imageId);\n            const annotationManager = getAnnotationManager();\n            const framesOfReference = annotationManager.getFramesOfReference();\n            framesOfReference.forEach((frameOfReference) => {\n                const frameOfReferenceSpecificAnnotations = annotationManager.getAnnotations(frameOfReference);\n                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[this.getToolName()];\n                if (!toolSpecificAnnotations || !toolSpecificAnnotations.length) {\n                    return;\n                }\n                toolSpecificAnnotations.forEach((annotation) => {\n                    if (!annotation.metadata?.referencedImageId) {\n                        return;\n                    }\n                    const referencedImageURI = utilities.imageIdToURI(annotation.metadata.referencedImageId);\n                    if (referencedImageURI === imageURI) {\n                        annotation.invalidated = true;\n                        annotation.data.cachedStats = {};\n                    }\n                });\n                triggerAnnotationRender(element);\n            });\n        };\n    }\n    filterInteractableAnnotationsForElement(element, annotations) {\n        if (!annotations?.length) {\n            return [];\n        }\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        return filterAnnotationsForDisplay(viewport, annotations);\n    }\n    static createAnnotation(...annotationBaseData) {\n        let annotation = {\n            annotationUID: null,\n            highlighted: true,\n            invalidated: true,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: this.toolName,\n            },\n            data: {\n                handles: {\n                    points: new Array(),\n                    activeHandleIndex: null,\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                },\n                cachedStats: {},\n                label: '',\n            },\n        };\n        for (const baseData of annotationBaseData) {\n            annotation = utilities.deepMerge(annotation, baseData);\n        }\n        return annotation;\n    }\n    createAnnotation(evt, points, ...annotationBaseData) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const { world: worldPos } = currentPoints;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, viewUp, position: cameraPosition } = camera;\n        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n        const viewReference = viewport.getViewReference({ points: [worldPos] });\n        const annotation = AnnotationDisplayTool.createAnnotation({\n            metadata: {\n                toolName: this.getToolName(),\n                ...viewReference,\n                referencedImageId,\n                viewUp,\n                cameraPosition,\n            },\n            data: {\n                handles: {\n                    points: points || [],\n                },\n            },\n        }, ...annotationBaseData);\n        return annotation;\n    }\n    getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp) {\n        const targetId = this.getTargetId(viewport);\n        let referencedImageId = targetId.split(/^[a-zA-Z]+:/)[1];\n        if (viewport instanceof BaseVolumeViewport) {\n            const volumeId = utilities.getVolumeId(targetId);\n            const imageVolume = cache.getVolume(volumeId);\n            referencedImageId = utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n        }\n        return referencedImageId;\n    }\n    getStyle(property, specifications, annotation) {\n        return getStyleProperty(property, specifications, getState(annotation), this.mode);\n    }\n}\nAnnotationDisplayTool.toolName = 'AnnotationDisplayTool';\nexport default AnnotationDisplayTool;\n", "import { BaseVolumeViewport, cache, getEnabledElement, metaData, utilities as csUtils, StackViewport, } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\nimport AnnotationDisplayTool from './AnnotationDisplayTool';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { addAnnotation, removeAnnotation, getAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport ChangeTypes from '../../enums/ChangeTypes';\nimport { setAnnotationSelected } from '../../stateManagement/annotation/annotationSelection';\nimport { addContourSegmentationAnnotation } from '../../utilities/contourSegmentation';\nconst { DefaultHistoryMemo } = csUtils.HistoryMemo;\nconst { PointsManager } = csUtils;\nclass AnnotationTool extends AnnotationDisplayTool {\n    static createAnnotationForViewport(viewport, ...annotationBaseData) {\n        return this.createAnnotation({ metadata: viewport.getViewReference() }, ...annotationBaseData);\n    }\n    static createAndAddAnnotation(viewport, ...annotationBaseData) {\n        const annotation = this.createAnnotationForViewport(viewport, ...annotationBaseData);\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationModified(annotation, viewport.element);\n    }\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n        this.mouseMoveCallback = (evt, filteredAnnotations) => {\n            if (!filteredAnnotations) {\n                return false;\n            }\n            const { element, currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            let annotationsNeedToBeRedrawn = false;\n            for (const annotation of filteredAnnotations) {\n                if (isAnnotationLocked(annotation.annotationUID) ||\n                    !isAnnotationVisible(annotation.annotationUID)) {\n                    continue;\n                }\n                const { data } = annotation;\n                const activateHandleIndex = data.handles\n                    ? data.handles.activeHandleIndex\n                    : undefined;\n                const near = this._imagePointNearToolOrHandle(element, annotation, canvasCoords, 6);\n                const nearToolAndNotMarkedActive = near && !annotation.highlighted;\n                const notNearToolAndMarkedActive = !near && annotation.highlighted;\n                if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n                    annotation.highlighted = !annotation.highlighted;\n                    annotationsNeedToBeRedrawn = true;\n                }\n                else if (data.handles &&\n                    data.handles.activeHandleIndex !== activateHandleIndex) {\n                    annotationsNeedToBeRedrawn = true;\n                }\n            }\n            return annotationsNeedToBeRedrawn;\n        };\n        this.isSuvScaled = AnnotationTool.isSuvScaled;\n        if (toolProps.configuration?.getTextLines) {\n            this.configuration.getTextLines = toolProps.configuration.getTextLines;\n        }\n        if (toolProps.configuration?.statsCalculator) {\n            this.configuration.statsCalculator =\n                toolProps.configuration.statsCalculator;\n        }\n    }\n    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { data } = annotation;\n        const { isCanvasAnnotation } = data;\n        const { points, textBox } = data.handles;\n        if (textBox) {\n            const { worldBoundingBox } = textBox;\n            if (worldBoundingBox) {\n                const canvasBoundingBox = {\n                    topLeft: viewport.worldToCanvas(worldBoundingBox.topLeft),\n                    topRight: viewport.worldToCanvas(worldBoundingBox.topRight),\n                    bottomLeft: viewport.worldToCanvas(worldBoundingBox.bottomLeft),\n                    bottomRight: viewport.worldToCanvas(worldBoundingBox.bottomRight),\n                };\n                if (canvasCoords[0] >= canvasBoundingBox.topLeft[0] &&\n                    canvasCoords[0] <= canvasBoundingBox.bottomRight[0] &&\n                    canvasCoords[1] >= canvasBoundingBox.topLeft[1] &&\n                    canvasCoords[1] <= canvasBoundingBox.bottomRight[1]) {\n                    data.handles.activeHandleIndex = null;\n                    return textBox;\n                }\n            }\n        }\n        for (let i = 0; i < points?.length; i++) {\n            const point = points[i];\n            const annotationCanvasCoordinate = isCanvasAnnotation\n                ? point.slice(0, 2)\n                : viewport.worldToCanvas(point);\n            const near = vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n            if (near === true) {\n                data.handles.activeHandleIndex = i;\n                return point;\n            }\n        }\n        data.handles.activeHandleIndex = null;\n    }\n    getLinkedTextBoxStyle(specifications, annotation) {\n        return {\n            visibility: this.getStyle('textBoxVisibility', specifications, annotation),\n            fontFamily: this.getStyle('textBoxFontFamily', specifications, annotation),\n            fontSize: this.getStyle('textBoxFontSize', specifications, annotation),\n            color: this.getStyle('textBoxColor', specifications, annotation),\n            shadow: this.getStyle('textBoxShadow', specifications, annotation),\n            background: this.getStyle('textBoxBackground', specifications, annotation),\n            lineWidth: this.getStyle('textBoxLinkLineWidth', specifications, annotation),\n            lineDash: this.getStyle('textBoxLinkLineDash', specifications, annotation),\n        };\n    }\n    static isSuvScaled(viewport, targetId, imageId) {\n        if (viewport instanceof BaseVolumeViewport) {\n            const volumeId = csUtils.getVolumeId(targetId);\n            const volume = cache.getVolume(volumeId);\n            return volume?.scaling?.PT !== undefined;\n        }\n        const scalingModule = imageId && metaData.get('scalingModule', imageId);\n        return typeof scalingModule?.suvbw === 'number';\n    }\n    getAnnotationStyle(context) {\n        const { annotation, styleSpecifier } = context;\n        const getStyle = (property) => this.getStyle(property, styleSpecifier, annotation);\n        const { annotationUID } = annotation;\n        const visibility = isAnnotationVisible(annotationUID);\n        const locked = isAnnotationLocked(annotationUID);\n        const lineWidth = getStyle('lineWidth');\n        const lineDash = getStyle('lineDash');\n        const angleArcLineDash = getStyle('angleArcLineDash');\n        const color = getStyle('color');\n        const markerSize = getStyle('markerSize');\n        const shadow = getStyle('shadow');\n        const textboxStyle = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n        return {\n            visibility,\n            locked,\n            color,\n            lineWidth,\n            lineDash,\n            lineOpacity: 1,\n            fillColor: color,\n            fillOpacity: 0,\n            shadow,\n            textbox: textboxStyle,\n            markerSize,\n            angleArcLineDash,\n        };\n    }\n    _imagePointNearToolOrHandle(element, annotation, canvasCoords, proximity) {\n        const handleNearImagePoint = this.getHandleNearImagePoint(element, annotation, canvasCoords, proximity);\n        if (handleNearImagePoint) {\n            return true;\n        }\n        const toolNewImagePoint = this.isPointNearTool(element, annotation, canvasCoords, proximity, 'mouse');\n        if (toolNewImagePoint) {\n            return true;\n        }\n    }\n    static createAnnotationState(annotation, deleting) {\n        const { data, annotationUID } = annotation;\n        const cloneData = {\n            ...data,\n            cachedStats: {},\n        };\n        delete cloneData.contour;\n        delete cloneData.spline;\n        const state = {\n            annotationUID,\n            data: structuredClone(cloneData),\n            deleting,\n        };\n        const contour = data.contour;\n        if (contour) {\n            state.data.contour = {\n                ...contour,\n                polyline: null,\n                pointsManager: PointsManager.create3(contour.polyline.length, contour.polyline),\n            };\n        }\n        return state;\n    }\n    static createAnnotationMemo(element, annotation, options) {\n        if (!annotation) {\n            return;\n        }\n        const { newAnnotation, deleting = newAnnotation ? false : undefined } = options || {};\n        const { annotationUID } = annotation;\n        const state = AnnotationTool.createAnnotationState(annotation, deleting);\n        const annotationMemo = {\n            restoreMemo: () => {\n                const newState = AnnotationTool.createAnnotationState(annotation, deleting);\n                const { viewport } = getEnabledElement(element) || {};\n                viewport?.setViewReference(annotation.metadata);\n                if (state.deleting === true) {\n                    state.deleting = false;\n                    Object.assign(annotation.data, state.data);\n                    if (annotation.data.contour) {\n                        const annotationData = annotation.data;\n                        annotationData.contour.polyline = state.data.contour.pointsManager.points;\n                        delete state.data.contour.pointsManager;\n                        if (annotationData.segmentation) {\n                            addContourSegmentationAnnotation(annotation);\n                        }\n                    }\n                    state.data = newState.data;\n                    addAnnotation(annotation, element);\n                    setAnnotationSelected(annotation.annotationUID, true);\n                    viewport?.render();\n                    return;\n                }\n                if (state.deleting === false) {\n                    state.deleting = true;\n                    state.data = newState.data;\n                    setAnnotationSelected(annotation.annotationUID);\n                    removeAnnotation(annotation.annotationUID);\n                    viewport?.render();\n                    return;\n                }\n                const currentAnnotation = getAnnotation(annotationUID);\n                if (!currentAnnotation) {\n                    console.warn('No current annotation');\n                    return;\n                }\n                Object.assign(currentAnnotation.data, state.data);\n                if (currentAnnotation.data.contour) {\n                    currentAnnotation.data\n                        .contour.polyline = state.data.contour.pointsManager.points;\n                }\n                state.data = newState.data;\n                currentAnnotation.invalidated = true;\n                triggerAnnotationModified(currentAnnotation, element, ChangeTypes.History);\n            },\n            id: annotationUID,\n            operationType: 'annotation',\n        };\n        DefaultHistoryMemo.push(annotationMemo);\n        return annotationMemo;\n    }\n    createMemo(element, annotation, options) {\n        this.memo ||= AnnotationTool.createAnnotationMemo(element, annotation, options);\n    }\n    static hydrateBase(ToolClass, enabledElement, points, options = {}) {\n        if (!enabledElement) {\n            return null;\n        }\n        const { viewport } = enabledElement;\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const camera = viewport.getCamera();\n        const viewPlaneNormal = options.viewplaneNormal ?? camera.viewPlaneNormal;\n        const viewUp = options.viewUp ?? camera.viewUp;\n        const instance = options.toolInstance || new ToolClass();\n        let referencedImageId;\n        let finalViewPlaneNormal = viewPlaneNormal;\n        let finalViewUp = viewUp;\n        if (options.referencedImageId) {\n            referencedImageId = options.referencedImageId;\n            finalViewPlaneNormal = undefined;\n            finalViewUp = undefined;\n        }\n        else {\n            if (viewport instanceof StackViewport) {\n                const closestImageIndex = csUtils.getClosestStackImageIndexForPoint(points[0], viewport);\n                if (closestImageIndex !== undefined) {\n                    referencedImageId = viewport.getImageIds()[closestImageIndex];\n                }\n            }\n            else if (viewport instanceof BaseVolumeViewport) {\n                referencedImageId = instance.getReferencedImageId(viewport, points[0], viewPlaneNormal, viewUp);\n            }\n            else {\n                throw new Error('Unsupported viewport type');\n            }\n        }\n        return {\n            FrameOfReferenceUID,\n            referencedImageId,\n            viewPlaneNormal: finalViewPlaneNormal,\n            viewUp: finalViewUp,\n            instance,\n            viewport,\n        };\n    }\n}\nAnnotationTool.toolName = 'AnnotationTool';\nexport default AnnotationTool;\n", "import { Enums, utilities } from '@cornerstonejs/core';\nconst { CalibrationTypes } = Enums;\nconst PIXEL_UNITS = 'px';\nconst VOXEL_UNITS = 'voxels';\nconst SUPPORTED_REGION_DATA_TYPES = [\n    1,\n    2,\n    3,\n    4,\n];\nconst SUPPORTED_LENGTH_VARIANT = [\n    '3,3',\n    '4,7',\n];\nconst SUPPORTED_PROBE_VARIANT = [\n    '4,3',\n    '4,7',\n];\nconst UNIT_MAPPING = {\n    0: 'px',\n    1: 'percent',\n    2: 'dB',\n    3: 'cm',\n    4: 'seconds',\n    5: 'hertz',\n    6: 'dB/seconds',\n    7: 'cm/sec',\n    8: 'cm\\xb2',\n    9: 'cm\\xb2/s',\n    0xc: 'degrees',\n};\nconst EPS = 1e-3;\nconst SQUARE = '\\xb2';\nconst getCalibratedLengthUnitsAndScale = (image, handles) => {\n    const { calibration, hasPixelSpacing } = image;\n    let unit = hasPixelSpacing ? 'mm' : PIXEL_UNITS;\n    const volumeUnit = hasPixelSpacing ? 'mm\\xb3' : VOXEL_UNITS;\n    let areaUnit = unit + SQUARE;\n    let scale = 1;\n    let calibrationType = '';\n    if (!calibration ||\n        (!calibration.type && !calibration.sequenceOfUltrasoundRegions)) {\n        return { unit, areaUnit, scale, volumeUnit };\n    }\n    if (calibration.type === CalibrationTypes.UNCALIBRATED) {\n        return {\n            unit: PIXEL_UNITS,\n            areaUnit: PIXEL_UNITS + SQUARE,\n            scale,\n            volumeUnit: VOXEL_UNITS,\n        };\n    }\n    if (calibration.sequenceOfUltrasoundRegions) {\n        let imageIndex1, imageIndex2;\n        if (Array.isArray(handles) && handles.length === 2) {\n            [imageIndex1, imageIndex2] = handles;\n        }\n        else if (typeof handles === 'function') {\n            const points = handles();\n            imageIndex1 = points[0];\n            imageIndex2 = points[1];\n        }\n        let regions = calibration.sequenceOfUltrasoundRegions.filter((region) => imageIndex1[0] >= region.regionLocationMinX0 &&\n            imageIndex1[0] <= region.regionLocationMaxX1 &&\n            imageIndex1[1] >= region.regionLocationMinY0 &&\n            imageIndex1[1] <= region.regionLocationMaxY1 &&\n            imageIndex2[0] >= region.regionLocationMinX0 &&\n            imageIndex2[0] <= region.regionLocationMaxX1 &&\n            imageIndex2[1] >= region.regionLocationMinY0 &&\n            imageIndex2[1] <= region.regionLocationMaxY1);\n        if (!regions?.length) {\n            return { unit, areaUnit, scale, volumeUnit };\n        }\n        regions = regions.filter((region) => SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n            SUPPORTED_LENGTH_VARIANT.includes(`${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`));\n        if (!regions.length) {\n            return {\n                unit: PIXEL_UNITS,\n                areaUnit: PIXEL_UNITS + SQUARE,\n                scale,\n                volumeUnit: VOXEL_UNITS,\n            };\n        }\n        const region = regions[0];\n        const physicalDeltaX = Math.abs(region.physicalDeltaX);\n        const physicalDeltaY = Math.abs(region.physicalDeltaY);\n        const isSamePhysicalDelta = utilities.isEqual(physicalDeltaX, physicalDeltaY, EPS);\n        if (isSamePhysicalDelta) {\n            scale = 1 / physicalDeltaX;\n            calibrationType = 'US Region';\n            unit = UNIT_MAPPING[region.physicalUnitsXDirection] || 'unknown';\n            areaUnit = unit + SQUARE;\n        }\n        else {\n            return {\n                unit: PIXEL_UNITS,\n                areaUnit: PIXEL_UNITS + SQUARE,\n                scale,\n                volumeUnit: VOXEL_UNITS,\n            };\n        }\n    }\n    else if (calibration.scale) {\n        scale = calibration.scale;\n    }\n    const types = [\n        CalibrationTypes.ERMF,\n        CalibrationTypes.USER,\n        CalibrationTypes.ERROR,\n        CalibrationTypes.PROJECTION,\n        CalibrationTypes.CALIBRATED,\n        CalibrationTypes.UNKNOWN,\n    ];\n    if (types.includes(calibration?.type)) {\n        calibrationType = calibration.type;\n    }\n    return {\n        unit: unit + (calibrationType ? ` ${calibrationType}` : ''),\n        areaUnit: areaUnit + (calibrationType ? ` ${calibrationType}` : ''),\n        scale,\n        volumeUnit: volumeUnit + (calibrationType ? ` ${calibrationType}` : ''),\n    };\n};\nconst getCalibratedProbeUnitsAndValue = (image, handles) => {\n    const [imageIndex] = handles;\n    const { calibration } = image;\n    let units = ['raw'];\n    let values = [null];\n    let calibrationType = '';\n    if (!calibration ||\n        (!calibration.type && !calibration.sequenceOfUltrasoundRegions)) {\n        return { units, values };\n    }\n    if (calibration.sequenceOfUltrasoundRegions) {\n        const supportedRegionsMetadata = calibration.sequenceOfUltrasoundRegions.filter((region) => SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n            SUPPORTED_PROBE_VARIANT.includes(`${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`));\n        if (!supportedRegionsMetadata?.length) {\n            return { units, values };\n        }\n        const region = supportedRegionsMetadata.find((region) => imageIndex[0] >= region.regionLocationMinX0 &&\n            imageIndex[0] <= region.regionLocationMaxX1 &&\n            imageIndex[1] >= region.regionLocationMinY0 &&\n            imageIndex[1] <= region.regionLocationMaxY1);\n        if (!region) {\n            return { units, values };\n        }\n        const { referencePixelX0 = 0, referencePixelY0 = 0 } = region;\n        const { physicalDeltaX, physicalDeltaY } = region;\n        const yValue = (imageIndex[1] - region.regionLocationMinY0 - referencePixelY0) *\n            physicalDeltaY;\n        const xValue = (imageIndex[0] - region.regionLocationMinX0 - referencePixelX0) *\n            physicalDeltaX;\n        calibrationType = 'US Region';\n        values = [xValue, yValue];\n        units = [\n            UNIT_MAPPING[region.physicalUnitsXDirection],\n            UNIT_MAPPING[region.physicalUnitsYDirection],\n        ];\n    }\n    return {\n        units,\n        values,\n        calibrationType,\n    };\n};\nconst getCalibratedAspect = (image) => image.calibration?.aspect || 1;\nexport { getCalibratedLengthUnitsAndScale, getCalibratedAspect, getCalibratedProbeUnitsAndValue, };\n", "import filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nimport getWorldWidthAndHeightFromCorners from './getWorldWidthAndHeightFromCorners';\nimport filterAnnotationsForDisplay from './filterAnnotationsForDisplay';\nimport getWorldWidthAndHeightFromTwoPoints from './getWorldWidthAndHeightFromTwoPoints';\nimport { getPointInLineOfSightWithCriteria, getPointsInLineOfSight, } from './getPointInLineOfSightWithCriteria';\nimport { isPlaneIntersectingAABB } from './isPlaneIntersectingAABB';\nimport { filterAnnotationsWithinSamePlane } from './filterAnnotationsWithinPlane';\nexport default {\n    filterAnnotationsWithinSlice,\n    getWorldWidthAndHeightFromCorners,\n    getWorldWidthAndHeightFromTwoPoints,\n    filterAnnotationsForDisplay,\n    getPointInLineOfSightWithCriteria,\n    isPlaneIntersectingAABB,\n    filterAnnotationsWithinSamePlane,\n    getPointsInLineOfSight,\n};\nexport { filterAnnotationsWithinSlice, getWorldWidthAndHeightFromCorners, getWorldWidthAndHeightFromTwoPoints, filterAnnotationsForDisplay, getPointInLineOfSightWithCriteria, isPlaneIntersectingAABB, filterAnnotationsWithinSamePlane, getPointsInLineOfSight, };\n", "import { vec3 } from 'gl-matrix';\nexport default function getWorldWidthAndHeightFromCorners(viewPlaneNormal, viewUp, topLeftWorld, bottomRightWorld) {\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const pos1 = vec3.fromValues(...topLeftWorld);\n    const pos2 = vec3.fromValues(...bottomRightWorld);\n    const diagonal = vec3.create();\n    vec3.subtract(diagonal, pos1, pos2);\n    const diagonalLength = vec3.length(diagonal);\n    if (diagonalLength < 0.0001) {\n        return { worldWidth: 0, worldHeight: 0 };\n    }\n    const cosTheta = vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n    const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n    const worldWidth = sinTheta * diagonalLength;\n    const worldHeight = cosTheta * diagonalLength;\n    return { worldWidth, worldHeight };\n}\n", "import { vec3 } from 'gl-matrix';\nexport default function getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2) {\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const pos1 = vec3.fromValues(...worldPos1);\n    const pos2 = vec3.fromValues(...worldPos2);\n    const diagonal = vec3.create();\n    vec3.subtract(diagonal, pos1, pos2);\n    const diagonalLength = vec3.length(diagonal);\n    if (diagonalLength < 0.0001) {\n        return { worldWidth: 0, worldHeight: 0 };\n    }\n    const cosTheta = vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n    const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n    const worldWidth = sinTheta * diagonalLength;\n    const worldHeight = cosTheta * diagonalLength;\n    return { worldWidth, worldHeight };\n}\n", "import { utilities as csUtils } from '@cornerstonejs/core';\nexport function getPointInLineOfSightWithCriteria(viewport, worldPos, targetVolumeId, criteriaFunction, stepSize = 0.25) {\n    const points = getPointsInLineOfSight(viewport, worldPos, {\n        targetVolumeId,\n        stepSize,\n    });\n    let pickedPoint;\n    for (const point of points) {\n        const intensity = viewport.getIntensityFromWorld(point);\n        const pointToPick = criteriaFunction(intensity, point);\n        if (pointToPick) {\n            pickedPoint = pointToPick;\n        }\n    }\n    return pickedPoint;\n}\nexport function getPointsInLineOfSight(viewport, worldPos, { targetVolumeId, stepSize }) {\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal: normalDirection } = camera;\n    const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera, targetVolumeId);\n    const step = spacingInNormalDirection * stepSize || 1;\n    const bounds = viewport.getBounds();\n    const points = [];\n    let currentPos = [...worldPos];\n    while (_inBounds(currentPos, bounds)) {\n        points.push([...currentPos]);\n        currentPos[0] += normalDirection[0] * step;\n        currentPos[1] += normalDirection[1] * step;\n        currentPos[2] += normalDirection[2] * step;\n    }\n    currentPos = [...worldPos];\n    while (_inBounds(currentPos, bounds)) {\n        points.push([...currentPos]);\n        currentPos[0] -= normalDirection[0] * step;\n        currentPos[1] -= normalDirection[1] * step;\n        currentPos[2] -= normalDirection[2] * step;\n    }\n    return points;\n}\nconst _inBounds = function (point, bounds) {\n    const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n    const padding = 10;\n    return (point[0] > xMin + padding &&\n        point[0] < xMax - padding &&\n        point[1] > yMin + padding &&\n        point[1] < yMax - padding &&\n        point[2] > zMin + padding &&\n        point[2] < zMax - padding);\n};\n", "import { vec3 } from 'gl-matrix';\nexport const isPlaneIntersectingAABB = (origin, normal, minX, minY, minZ, maxX, maxY, maxZ) => {\n    const vertices = [\n        vec3.fromValues(minX, minY, minZ),\n        vec3.fromValues(maxX, minY, minZ),\n        vec3.fromValues(minX, maxY, minZ),\n        vec3.fromValues(maxX, maxY, minZ),\n        vec3.fromValues(minX, minY, maxZ),\n        vec3.fromValues(maxX, minY, maxZ),\n        vec3.fromValues(minX, maxY, maxZ),\n        vec3.fromValues(maxX, maxY, maxZ),\n    ];\n    const normalVec = vec3.fromValues(normal[0], normal[1], normal[2]);\n    const originVec = vec3.fromValues(origin[0], origin[1], origin[2]);\n    const planeDistance = -vec3.dot(normalVec, originVec);\n    let initialSign = null;\n    for (const vertex of vertices) {\n        const distance = vec3.dot(normalVec, vertex) + planeDistance;\n        if (initialSign === null) {\n            initialSign = Math.sign(distance);\n        }\n        else if (Math.sign(distance) !== initialSign) {\n            return true;\n        }\n    }\n    return false;\n};\n", "import { vec3 } from 'gl-matrix';\nimport { CONSTANTS, metaData } from '@cornerstonejs/core';\nconst { EPSILON } = CONSTANTS;\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\nexport function filterAnnotationsWithinSamePlane(annotations, camera) {\n    const { viewPlaneNormal } = camera;\n    const annotationsWithParallelNormals = annotations.filter((td) => {\n        let annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n        if (!annotationViewPlaneNormal) {\n            const { referencedImageId } = td.metadata;\n            const { imageOrientationPatient } = metaData.get('imagePlaneModule', referencedImageId);\n            const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n            const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n            annotationViewPlaneNormal = vec3.create();\n            vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);\n            td.metadata.viewPlaneNormal = annotationViewPlaneNormal;\n        }\n        const isParallel = Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n            PARALLEL_THRESHOLD;\n        return annotationViewPlaneNormal && isParallel;\n    });\n    if (!annotationsWithParallelNormals.length) {\n        return [];\n    }\n    return annotationsWithParallelNormals;\n}\n", "import debounce from './debounce';\nimport isObject from './isObject';\nfunction throttle(func, wait, options) {\n    let leading = true;\n    let trailing = true;\n    if (typeof func !== 'function') {\n        throw new TypeError('Expected a function');\n    }\n    if (isObject(options)) {\n        leading = 'leading' in options ? Boolean(options.leading) : leading;\n        trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n    }\n    return debounce(func, wait, {\n        leading,\n        trailing,\n        maxWait: wait,\n    });\n}\nexport default throttle;\n", "import { interpolateBasis as d3InterpolateBasis, quantize as d3Quantize, } from 'd3-interpolate';\nimport { zip as d3Zip } from 'd3-array';\nfunction isPoints3D(points) {\n    return points[0]?.length === 3;\n}\nexport function interpolatePoints(originalPoints, knotsIndexes) {\n    if (!knotsIndexes ||\n        knotsIndexes.length === 0 ||\n        knotsIndexes.length === originalPoints.length) {\n        return originalPoints;\n    }\n    const n = knotsIndexes[knotsIndexes.length - 1] - knotsIndexes[0] + 1;\n    const xInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][0]));\n    const yInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][1]));\n    if (isPoints3D(originalPoints)) {\n        const zInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][2]));\n        return (d3Zip(d3Quantize(xInterpolator, n), d3Quantize(yInterpolator, n), d3Quantize(zInterpolator, n)));\n    }\n    else {\n        return (d3Zip(d3Quantize(xInterpolator, n), d3Quantize(yInterpolator, n)));\n    }\n}\n", "import { interpolatePoints } from './algorithms/bspline';\nfunction getContinuousUniformDistributionValues(minDistributionDistance, closedInterval) {\n    const result = [];\n    const [intervalIni, intervalEnd] = closedInterval;\n    const intervalSize = intervalEnd - intervalIni + 1;\n    const intensity = Math.floor(intervalSize / minDistributionDistance);\n    let x = 0;\n    let continuosDistributionValue = Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n    while (continuosDistributionValue <= intervalEnd) {\n        result.push(continuosDistributionValue);\n        x++;\n        continuosDistributionValue =\n            Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n    }\n    return result;\n}\nexport default function interpolateSegmentPoints(points, iniIndex, endIndex, knotsRatioPercentage) {\n    const segmentSize = endIndex - iniIndex + 1;\n    const amountOfKnots = Math.floor((knotsRatioPercentage / 100) * segmentSize) ?? 1;\n    const minKnotDistance = Math.floor(segmentSize / amountOfKnots) ?? 1;\n    if (isNaN(segmentSize) || !segmentSize || !minKnotDistance) {\n        return points;\n    }\n    if (segmentSize / minKnotDistance < 2) {\n        return points;\n    }\n    const interpolationIniIndex = Math.max(0, iniIndex);\n    const interpolationEndIndex = Math.min(points.length - 1, endIndex);\n    const segmentPointsUnchangedBeg = points.slice(0, interpolationIniIndex);\n    const segmentPointsUnchangedEnd = points.slice(interpolationEndIndex + 1, points.length);\n    const knotsIndexes = getContinuousUniformDistributionValues(minKnotDistance, [\n        interpolationIniIndex,\n        interpolationEndIndex,\n    ]);\n    const interpolatedPoints = interpolatePoints(points, knotsIndexes);\n    return [\n        ...segmentPointsUnchangedBeg,\n        ...interpolatedPoints,\n        ...segmentPointsUnchangedEnd,\n    ];\n}\n", "import { point } from '../math';\nimport interpolateSegmentPoints from './interpolation/interpolateSegmentPoints';\nexport function shouldSmooth(configuration, annotation) {\n    if (annotation?.autoGenerated) {\n        return false;\n    }\n    const shouldSmooth = configuration?.smoothing?.smoothOnAdd === true ||\n        configuration?.smoothing?.smoothOnEdit === true;\n    return shouldSmooth;\n}\nfunction isEqualByProximity(pointA, pointB) {\n    return point.distanceToPoint(pointA, pointB) < 0.001;\n}\nfunction isEqual(pointA, pointB) {\n    return point.distanceToPoint(pointA, pointB) === 0;\n}\nfunction findMatchIndexes(points, otherPoints) {\n    for (let i = 0; i < points.length; i++) {\n        for (let j = 0; j < otherPoints.length; j++) {\n            if (isEqual(points[i], otherPoints[j])) {\n                return [i, j];\n            }\n        }\n    }\n}\nfunction followingIndex(index, size, direction) {\n    return (index + size + direction) % size;\n}\nfunction circularFindNextIndexBy(listParams, otherListParams, criteria, direction) {\n    const [, indexDelimiter, points] = listParams;\n    const [, otherIndexDelimiter, otherPoints] = otherListParams;\n    const pointsLength = points.length;\n    const otherPointsLength = otherPoints.length;\n    let startIndex = listParams[0];\n    let otherStartIndex = otherListParams[0];\n    if (!points[startIndex] ||\n        !otherPoints[otherStartIndex] ||\n        !points[indexDelimiter] ||\n        !otherPoints[otherIndexDelimiter]) {\n        return [undefined, undefined];\n    }\n    while (startIndex !== indexDelimiter &&\n        otherStartIndex !== otherIndexDelimiter) {\n        if (criteria(otherPoints[otherStartIndex], points[startIndex])) {\n            return [startIndex, otherStartIndex];\n        }\n        startIndex = followingIndex(startIndex, pointsLength, direction);\n        otherStartIndex = followingIndex(otherStartIndex, otherPointsLength, direction);\n    }\n    return [undefined, undefined];\n}\nfunction findChangedSegment(points, previousPoints) {\n    const [firstMatchIndex, previousFirstMatchIndex] = findMatchIndexes(points, previousPoints) || [];\n    const toBeNotEqualCriteria = (pointA, pointB) => isEqualByProximity(pointA, pointB) === false;\n    const [lowDiffIndex, lowOtherDiffIndex] = circularFindNextIndexBy([\n        followingIndex(firstMatchIndex, points.length, 1),\n        firstMatchIndex,\n        points,\n    ], [\n        followingIndex(previousFirstMatchIndex, previousPoints.length, 1),\n        previousFirstMatchIndex,\n        previousPoints,\n    ], toBeNotEqualCriteria, 1);\n    const [highIndex] = circularFindNextIndexBy([followingIndex(lowDiffIndex, points.length, -1), lowDiffIndex, points], [\n        followingIndex(lowOtherDiffIndex, previousPoints.length, -1),\n        lowOtherDiffIndex,\n        previousPoints,\n    ], toBeNotEqualCriteria, -1);\n    return [lowDiffIndex, highIndex];\n}\nexport function getInterpolatedPoints(configuration, points, pointsOfReference) {\n    const { interpolation, smoothing } = configuration;\n    const result = points;\n    if (interpolation) {\n        const { knotsRatioPercentageOnAdd, knotsRatioPercentageOnEdit, smoothOnAdd = false, smoothOnEdit = false, } = smoothing;\n        const knotsRatioPercentage = pointsOfReference\n            ? knotsRatioPercentageOnEdit\n            : knotsRatioPercentageOnAdd;\n        const isEnabled = pointsOfReference ? smoothOnEdit : smoothOnAdd;\n        if (isEnabled) {\n            const [changedIniIndex, changedEndIndex] = pointsOfReference\n                ? findChangedSegment(points, pointsOfReference)\n                : [0, points.length - 1];\n            if (!points[changedIniIndex] || !points[changedEndIndex]) {\n                return points;\n            }\n            return (interpolateSegmentPoints(points, changedIniIndex, changedEndIndex, knotsRatioPercentage));\n        }\n    }\n    return result;\n}\n", "import { KeyboardBindings as kb } from '../../enums';\nconst getMouseModifierKey = (evt) => {\n    if (evt.shiftKey) {\n        if (evt.ctrlKey) {\n            return kb.ShiftCtrl;\n        }\n        if (evt.altKey) {\n            return kb.ShiftAlt;\n        }\n        if (evt.metaKey) {\n            return kb.ShiftMeta;\n        }\n        return kb.Shift;\n    }\n    if (evt.ctrlKey) {\n        if (evt.altKey) {\n            return kb.CtrlAlt;\n        }\n        if (evt.metaKey) {\n            return kb.CtrlMeta;\n        }\n        return kb.Ctrl;\n    }\n    if (evt.altKey) {\n        return (evt.metaKey && kb.AltMeta) || kb.Alt;\n    }\n    if (evt.metaKey) {\n        return kb.Meta;\n    }\n    return undefined;\n};\nexport default getMouseModifierKey;\n", "import { vec2 } from 'gl-matrix';\nexport default function findOpenUShapedContourVectorToPeak(canvasPoints, viewport) {\n    const first = canvasPoints[0];\n    const last = canvasPoints[canvasPoints.length - 1];\n    const firstToLastUnitVector = vec2.create();\n    vec2.set(firstToLastUnitVector, last[0] - first[0], last[1] - first[1]);\n    vec2.normalize(firstToLastUnitVector, firstToLastUnitVector);\n    const normalVector1 = vec2.create();\n    const normalVector2 = vec2.create();\n    vec2.set(normalVector1, -firstToLastUnitVector[1], firstToLastUnitVector[0]);\n    vec2.set(normalVector2, firstToLastUnitVector[1], -firstToLastUnitVector[0]);\n    const centerOfFirstToLast = [\n        (first[0] + last[0]) / 2,\n        (first[1] + last[1]) / 2,\n    ];\n    const furthest = {\n        dist: 0,\n        index: null,\n    };\n    for (let i = 0; i < canvasPoints.length; i++) {\n        const canvasPoint = canvasPoints[i];\n        const distance = vec2.dist(canvasPoint, centerOfFirstToLast);\n        if (distance > furthest.dist) {\n            furthest.dist = distance;\n            furthest.index = i;\n        }\n    }\n    const toFurthest = [\n        canvasPoints[furthest.index],\n        centerOfFirstToLast,\n    ];\n    const toFurthestWorld = toFurthest.map(viewport.canvasToWorld);\n    return toFurthestWorld;\n}\nexport function findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation) {\n    const { viewport } = enabledElement;\n    const canvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    return findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n}\n", "import { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { ChangeTypes, Events } from '../../../enums';\nimport { state } from '../../../store/state';\nimport { vec3 } from 'gl-matrix';\nimport { shouldSmooth, getInterpolatedPoints, } from '../../../utilities/planarFreehandROITool/smoothPoints';\nimport getMouseModifierKey from '../../../eventDispatchers/shared/getMouseModifier';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationModified, triggerContourAnnotationCompleted, } from '../../../stateManagement/annotation/helpers/state';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\nimport { polyline } from '../../../utilities/math';\nimport { removeAnnotation } from '../../../stateManagement/annotation/annotationState';\nimport { ContourWindingDirection } from '../../../types/ContourAnnotation';\nconst { addCanvasPointsToArray, pointsAreWithinCloseContourProximity, getFirstLineSegmentIntersectionIndexes, getSubPixelSpacingAndXYDirections, } = polyline;\nfunction activateDraw(evt, annotation, viewportIdsToRender) {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const contourHoleProcessingEnabled = getMouseModifierKey(evt.detail.event) ===\n        this.configuration.contourHoleAdditionModifierKey;\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution) || {};\n    if (!spacing || !xDir || !yDir) {\n        return;\n    }\n    this.drawData = {\n        canvasPoints: [canvasPos],\n        polylineIndex: 0,\n        contourHoleProcessingEnabled,\n        newAnnotation: true,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    hideElementCursor(element);\n}\nfunction deactivateDraw(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragDrawCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender, xDir, yDir, spacing, movingTextBox, } = this.commonData;\n    const { polylineIndex, canvasPoints, newAnnotation } = this.drawData;\n    this.createMemo(element, annotation, { newAnnotation });\n    const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (movingTextBox) {\n        this.isDrawing = false;\n        const { deltaPoints } = eventDetail;\n        const worldPosDelta = deltaPoints.world;\n        const { textBox } = annotation.data.handles;\n        const { worldPosition } = textBox;\n        worldPosition[0] += worldPosDelta[0];\n        worldPosition[1] += worldPosDelta[1];\n        worldPosition[2] += worldPosDelta[2];\n        textBox.hasMoved = true;\n    }\n    else {\n        const crossingIndex = this.findCrossingIndexDuringCreate(evt);\n        if (crossingIndex !== undefined) {\n            this.applyCreateOnCross(evt, crossingIndex);\n        }\n        else {\n            const numPointsAdded = addCanvasPointsToArray(element, canvasPoints, canvasPos, this.commonData);\n            this.drawData.polylineIndex = polylineIndex + numPointsAdded;\n        }\n        annotation.invalidated = true;\n    }\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    if (annotation.invalidated) {\n        triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n    }\n}\nfunction mouseUpDrawCallback(evt) {\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;\n    const firstPoint = canvasPoints[0];\n    const lastPoint = canvasPoints[canvasPoints.length - 1];\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    this.doneEditMemo();\n    this.drawData.newAnnotation = false;\n    if (allowOpenContours &&\n        !pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n        this.completeDrawOpenContour(element, { contourHoleProcessingEnabled });\n    }\n    else {\n        this.completeDrawClosedContour(element, { contourHoleProcessingEnabled });\n    }\n}\nfunction completeDrawClosedContour(element, options) {\n    this.removeCrossedLinesOnCompleteDraw();\n    const { canvasPoints } = this.drawData;\n    const { contourHoleProcessingEnabled, minPointsToSave } = options ?? {};\n    if (minPointsToSave && canvasPoints.length < minPointsToSave) {\n        return false;\n    }\n    if (this.haltDrawing(element, canvasPoints)) {\n        return false;\n    }\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    addCanvasPointsToArray(element, canvasPoints, canvasPoints[0], this.commonData);\n    canvasPoints.pop();\n    const updatedPoints = shouldSmooth(this.configuration, annotation)\n        ? getInterpolatedPoints(this.configuration, canvasPoints)\n        : canvasPoints;\n    this.updateContourPolyline(annotation, {\n        points: updatedPoints,\n        closed: true,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n    }, viewport);\n    const { textBox } = annotation.data.handles;\n    if (!textBox?.hasMoved) {\n        triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n    }\n    this.isDrawing = false;\n    this.drawData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateDraw(element);\n    return true;\n}\nfunction removeCrossedLinesOnCompleteDraw() {\n    const { canvasPoints } = this.drawData;\n    const numPoints = canvasPoints.length;\n    const endToStart = [canvasPoints[0], canvasPoints[numPoints - 1]];\n    const canvasPointsMinusEnds = canvasPoints.slice(0, -1).slice(1);\n    const lineSegment = getFirstLineSegmentIntersectionIndexes(canvasPointsMinusEnds, endToStart[0], endToStart[1], false);\n    if (lineSegment) {\n        const indexToRemoveUpTo = lineSegment[1];\n        if (indexToRemoveUpTo === 1) {\n            this.drawData.canvasPoints = canvasPoints.splice(1);\n        }\n        else {\n            this.drawData.canvasPoints = canvasPoints.splice(0, indexToRemoveUpTo);\n        }\n    }\n}\nfunction completeDrawOpenContour(element, options) {\n    const { canvasPoints } = this.drawData;\n    const { contourHoleProcessingEnabled } = options ?? {};\n    if (this.haltDrawing(element, canvasPoints)) {\n        return false;\n    }\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const updatedPoints = shouldSmooth(this.configuration, annotation)\n        ? getInterpolatedPoints(this.configuration, canvasPoints)\n        : canvasPoints;\n    this.updateContourPolyline(annotation, {\n        points: updatedPoints,\n        closed: false,\n    }, viewport);\n    const { textBox } = annotation.data.handles;\n    const worldPoints = annotation.data.contour.polyline;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    if (annotation.data.isOpenUShapeContour) {\n        annotation.data.openUShapeContourVectorToPeak =\n            findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n    }\n    if (!textBox.hasMoved) {\n        triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n    }\n    this.isDrawing = false;\n    this.drawData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateDraw(element);\n    return true;\n}\nfunction findCrossingIndexDuringCreate(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { canvasPoints } = this.drawData;\n    const pointsLessLastOne = canvasPoints.slice(0, -1);\n    const lineSegment = getFirstLineSegmentIntersectionIndexes(pointsLessLastOne, canvasPos, lastCanvasPoint, false);\n    if (lineSegment === undefined) {\n        return;\n    }\n    const crossingIndex = lineSegment[0];\n    return crossingIndex;\n}\nfunction applyCreateOnCross(evt, crossingIndex) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    addCanvasPointsToArray(element, canvasPoints, canvasPoints[crossingIndex], this.commonData);\n    canvasPoints.pop();\n    const remainingPoints = canvasPoints.slice(crossingIndex);\n    const newArea = polyline.getArea(remainingPoints);\n    if (utilities.isEqual(newArea, 0)) {\n        canvasPoints.splice(crossingIndex + 1);\n        return;\n    }\n    canvasPoints.splice(0, crossingIndex);\n    const options = { contourHoleProcessingEnabled, minPointsToSave: 3 };\n    if (this.completeDrawClosedContour(element, options)) {\n        this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n    }\n}\nfunction cancelDrawing(element) {\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;\n    const firstPoint = canvasPoints[0];\n    const lastPoint = canvasPoints[canvasPoints.length - 1];\n    if (allowOpenContours &&\n        !pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n        this.completeDrawOpenContour(element, { contourHoleProcessingEnabled });\n    }\n    else {\n        this.completeDrawClosedContour(element, { contourHoleProcessingEnabled });\n    }\n}\nfunction shouldHaltDrawing(canvasPoints, subPixelResolution) {\n    const minPoints = Math.max(subPixelResolution * 3, 3);\n    return canvasPoints.length < minPoints;\n}\nfunction haltDrawing(element, canvasPoints) {\n    const { subPixelResolution } = this.configuration;\n    if (shouldHaltDrawing(canvasPoints, subPixelResolution)) {\n        const { annotation, viewportIdsToRender } = this.commonData;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        removeAnnotation(annotation.annotationUID);\n        this.isDrawing = false;\n        this.drawData = undefined;\n        this.commonData = undefined;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        this.deactivateDraw(element);\n        return true;\n    }\n    return false;\n}\nfunction registerDrawLoop(toolInstance) {\n    toolInstance.activateDraw = activateDraw.bind(toolInstance);\n    toolInstance.deactivateDraw = deactivateDraw.bind(toolInstance);\n    toolInstance.applyCreateOnCross = applyCreateOnCross.bind(toolInstance);\n    toolInstance.findCrossingIndexDuringCreate =\n        findCrossingIndexDuringCreate.bind(toolInstance);\n    toolInstance.completeDrawOpenContour =\n        completeDrawOpenContour.bind(toolInstance);\n    toolInstance.removeCrossedLinesOnCompleteDraw =\n        removeCrossedLinesOnCompleteDraw.bind(toolInstance);\n    toolInstance.mouseDragDrawCallback = mouseDragDrawCallback.bind(toolInstance);\n    toolInstance.mouseUpDrawCallback = mouseUpDrawCallback.bind(toolInstance);\n    toolInstance.completeDrawClosedContour =\n        completeDrawClosedContour.bind(toolInstance);\n    toolInstance.cancelDrawing = cancelDrawing.bind(toolInstance);\n    toolInstance.haltDrawing = haltDrawing.bind(toolInstance);\n}\nexport default registerDrawLoop;\n", "import { vec2 } from 'gl-matrix';\nimport { polyline } from '../../../utilities/math';\nconst { addCanvasPointsToArray, getFirstLineSegmentIntersectionIndexes } = polyline;\nfunction checkForFirstCrossing(evt, isClosedContour) {\n    const eventDetail = evt.detail;\n    const { element, currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { editCanvasPoints, prevCanvasPoints } = this.editData;\n    const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, canvasPos, lastCanvasPoint, isClosedContour);\n    if (crossedLineSegment) {\n        this.editData.startCrossingIndex = crossedLineSegment[0];\n        this.removePointsUpUntilFirstCrossing(isClosedContour);\n    }\n    else if (prevCanvasPoints.length >= 2) {\n        if (editCanvasPoints.length >\n            this.configuration.checkCanvasEditFallbackProximity) {\n            const firstEditCanvasPoint = editCanvasPoints[0];\n            const distanceIndexPairs = [];\n            for (let i = 0; i < prevCanvasPoints.length; i++) {\n                const prevCanvasPoint = prevCanvasPoints[i];\n                const distance = vec2.distance(prevCanvasPoint, firstEditCanvasPoint);\n                distanceIndexPairs.push({ distance, index: i });\n            }\n            distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n            const twoClosestDistanceIndexPairs = [\n                distanceIndexPairs[0],\n                distanceIndexPairs[1],\n            ];\n            const lowestIndex = Math.min(twoClosestDistanceIndexPairs[0].index, twoClosestDistanceIndexPairs[1].index);\n            this.editData.startCrossingIndex = lowestIndex;\n        }\n        else {\n            const dir = vec2.create();\n            vec2.subtract(dir, editCanvasPoints[1], editCanvasPoints[0]);\n            vec2.normalize(dir, dir);\n            const proximity = 6;\n            const extendedPoint = [\n                editCanvasPoints[0][0] - dir[0] * proximity,\n                editCanvasPoints[0][1] - dir[1] * proximity,\n            ];\n            const crossedLineSegmentFromExtendedPoint = getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, extendedPoint, editCanvasPoints[0], isClosedContour);\n            if (crossedLineSegmentFromExtendedPoint) {\n                const pointsToPrepend = [extendedPoint];\n                addCanvasPointsToArray(element, pointsToPrepend, editCanvasPoints[0], this.commonData);\n                editCanvasPoints.unshift(...pointsToPrepend);\n                this.removePointsUpUntilFirstCrossing(isClosedContour);\n                this.editData.editIndex = editCanvasPoints.length - 1;\n                this.editData.startCrossingIndex =\n                    crossedLineSegmentFromExtendedPoint[0];\n            }\n        }\n    }\n}\nfunction removePointsUpUntilFirstCrossing(isClosedContour) {\n    const { editCanvasPoints, prevCanvasPoints } = this.editData;\n    let numPointsToRemove = 0;\n    for (let i = 0; i < editCanvasPoints.length - 1; i++) {\n        const firstLine = [editCanvasPoints[i], editCanvasPoints[i + 1]];\n        const didCrossLine = !!getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, firstLine[0], firstLine[1], isClosedContour);\n        numPointsToRemove++;\n        if (didCrossLine) {\n            break;\n        }\n    }\n    editCanvasPoints.splice(0, numPointsToRemove);\n    this.editData.editIndex = editCanvasPoints.length - 1;\n}\nfunction checkForSecondCrossing(evt, isClosedContour) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { prevCanvasPoints } = this.editData;\n    const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, canvasPos, lastCanvasPoint, isClosedContour);\n    if (!crossedLineSegment) {\n        return false;\n    }\n    return true;\n}\nfunction removePointsAfterSecondCrossing(isClosedContour) {\n    const { prevCanvasPoints, editCanvasPoints } = this.editData;\n    for (let i = editCanvasPoints.length - 1; i > 0; i--) {\n        const lastLine = [editCanvasPoints[i], editCanvasPoints[i - 1]];\n        const didCrossLine = !!getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, lastLine[0], lastLine[1], isClosedContour);\n        editCanvasPoints.pop();\n        if (didCrossLine) {\n            break;\n        }\n    }\n}\nfunction findSnapIndex() {\n    const { editCanvasPoints, prevCanvasPoints, startCrossingIndex } = this.editData;\n    if (startCrossingIndex === undefined) {\n        return;\n    }\n    const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const distanceIndexPairs = [];\n    for (let i = 0; i < prevCanvasPoints.length; i++) {\n        const prevCanvasPoint = prevCanvasPoints[i];\n        const distance = vec2.distance(prevCanvasPoint, lastEditCanvasPoint);\n        distanceIndexPairs.push({ distance, index: i });\n    }\n    distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n    const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -1);\n    for (let i = 0; i < distanceIndexPairs.length; i++) {\n        const { index } = distanceIndexPairs[i];\n        const snapCanvasPosition = prevCanvasPoints[index];\n        const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n        const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(editCanvasPointsLessLastOne, snapCanvasPosition, lastEditCanvasPoint, false);\n        if (!crossedLineSegment) {\n            return index;\n        }\n    }\n    return -1;\n}\nfunction checkAndRemoveCrossesOnEditLine(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { editCanvasPoints } = this.editData;\n    const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -2);\n    const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(editCanvasPointsLessLastOne, canvasPos, lastCanvasPoint, false);\n    if (!crossedLineSegment) {\n        return;\n    }\n    const editIndexCrossed = crossedLineSegment[0];\n    const numPointsToRemove = editCanvasPoints.length - editIndexCrossed;\n    for (let i = 0; i < numPointsToRemove; i++) {\n        editCanvasPoints.pop();\n    }\n}\nfunction registerEditLoopCommon(toolInstance) {\n    toolInstance.checkForFirstCrossing = checkForFirstCrossing.bind(toolInstance);\n    toolInstance.removePointsUpUntilFirstCrossing =\n        removePointsUpUntilFirstCrossing.bind(toolInstance);\n    toolInstance.checkForSecondCrossing =\n        checkForSecondCrossing.bind(toolInstance);\n    toolInstance.findSnapIndex = findSnapIndex.bind(toolInstance);\n    toolInstance.removePointsAfterSecondCrossing =\n        removePointsAfterSecondCrossing.bind(toolInstance);\n    toolInstance.checkAndRemoveCrossesOnEditLine =\n        checkAndRemoveCrossesOnEditLine.bind(toolInstance);\n}\nexport default registerEditLoopCommon;\n", "import { vec3, vec2 } from 'gl-matrix';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store/state';\nimport { Events } from '../../../enums';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { polyline } from '../../../utilities/math';\nimport { ContourWindingDirection } from '../../../types/ContourAnnotation';\nimport { getInterpolatedPoints, shouldSmooth, } from '../../../utilities/planarFreehandROITool/smoothPoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport updateContourPolyline from '../../../utilities/contours/updateContourPolyline';\nimport { triggerAnnotationModified } from '../../../stateManagement/annotation/helpers/state';\nconst { getSubPixelSpacingAndXYDirections, addCanvasPointsToArray, getArea } = polyline;\nfunction activateClosedContourEdit(evt, annotation, viewportIdsToRender) {\n    this.isEditingClosed = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    const prevCanvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    this.editData = {\n        prevCanvasPoints,\n        editCanvasPoints: [canvasPos],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n        annotation,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragClosedContourEditCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpClosedContourEditCallback);\n    hideElementCursor(element);\n}\nfunction deactivateClosedContourEdit(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragClosedContourEditCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpClosedContourEditCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragClosedContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n    const { editIndex, editCanvasPoints, startCrossingIndex, annotation } = this.editData;\n    this.createMemo(element, annotation);\n    const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (startCrossingIndex !== undefined) {\n        this.checkAndRemoveCrossesOnEditLine(evt);\n    }\n    const numPointsAdded = addCanvasPointsToArray(element, editCanvasPoints, canvasPos, this.commonData);\n    const currentEditIndex = editIndex + numPointsAdded;\n    this.editData.editIndex = currentEditIndex;\n    if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n        this.checkForFirstCrossing(evt, true);\n    }\n    this.editData.snapIndex = this.findSnapIndex();\n    if (this.editData.snapIndex === -1) {\n        this.finishEditAndStartNewEdit(evt);\n        return;\n    }\n    this.editData.fusedCanvasPoints = this.fuseEditPointsWithClosedContour(evt);\n    if (startCrossingIndex !== undefined &&\n        this.checkForSecondCrossing(evt, true)) {\n        this.removePointsAfterSecondCrossing(true);\n        this.finishEditAndStartNewEdit(evt);\n    }\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction finishEditAndStartNewEdit(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n    updateContourPolyline(annotation, {\n        points: fusedCanvasPoints,\n        closed: true,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n    }, viewport);\n    if (annotation.autoGenerated) {\n        annotation.autoGenerated = false;\n    }\n    triggerAnnotationModified(annotation, element);\n    const lastEditCanvasPoint = editCanvasPoints.pop();\n    this.editData = {\n        prevCanvasPoints: fusedCanvasPoints,\n        editCanvasPoints: [lastEditCanvasPoint],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n        snapIndex: undefined,\n        annotation,\n    };\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction fuseEditPointsWithClosedContour(evt) {\n    const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return;\n    }\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const augmentedEditCanvasPoints = [...editCanvasPoints];\n    addCanvasPointsToArray(element, augmentedEditCanvasPoints, prevCanvasPoints[snapIndex], this.commonData);\n    if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n        augmentedEditCanvasPoints.pop();\n    }\n    let lowIndex;\n    let highIndex;\n    if (startCrossingIndex > snapIndex) {\n        lowIndex = snapIndex;\n        highIndex = startCrossingIndex;\n    }\n    else {\n        lowIndex = startCrossingIndex;\n        highIndex = snapIndex;\n    }\n    const distanceBetweenLowAndFirstPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenLowAndLastPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const distanceBetweenHighAndFirstPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenHighAndLastPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const pointSet1 = [];\n    for (let i = 0; i < lowIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    let inPlaceDistance = distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n    let reverseDistance = distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    const pointSet2 = [];\n    for (let i = lowIndex; i < highIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    inPlaceDistance =\n        distanceBetweenHighAndFirstPoint + distanceBetweenLowAndLastPoint;\n    reverseDistance =\n        distanceBetweenHighAndLastPoint + distanceBetweenLowAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    const areaPointSet1 = getArea(pointSet1);\n    const areaPointSet2 = getArea(pointSet2);\n    const pointsToRender = areaPointSet1 > areaPointSet2 ? pointSet1 : pointSet2;\n    return pointsToRender;\n}\nfunction mouseUpClosedContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    this.completeClosedContourEdit(element);\n}\nfunction completeClosedContourEdit(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    this.doneEditMemo();\n    const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n    if (fusedCanvasPoints) {\n        const updatedPoints = shouldSmooth(this.configuration, annotation)\n            ? getInterpolatedPoints(this.configuration, fusedCanvasPoints, prevCanvasPoints)\n            : fusedCanvasPoints;\n        const decimateConfig = this.configuration?.decimate || {};\n        updateContourPolyline(annotation, {\n            points: updatedPoints,\n            closed: true,\n            targetWindingDirection: ContourWindingDirection.Clockwise,\n        }, viewport, {\n            decimate: {\n                enabled: !!decimateConfig.enabled,\n                epsilon: decimateConfig.epsilon,\n            },\n        });\n        if (annotation.autoGenerated) {\n            annotation.autoGenerated = false;\n        }\n        triggerAnnotationModified(annotation, element);\n    }\n    this.isEditingClosed = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateClosedContourEdit(element);\n}\nfunction cancelClosedContourEdit(element) {\n    this.completeClosedContourEdit(element);\n}\nfunction registerClosedContourEditLoop(toolInstance) {\n    toolInstance.activateClosedContourEdit =\n        activateClosedContourEdit.bind(toolInstance);\n    toolInstance.deactivateClosedContourEdit =\n        deactivateClosedContourEdit.bind(toolInstance);\n    toolInstance.mouseDragClosedContourEditCallback =\n        mouseDragClosedContourEditCallback.bind(toolInstance);\n    toolInstance.mouseUpClosedContourEditCallback =\n        mouseUpClosedContourEditCallback.bind(toolInstance);\n    toolInstance.finishEditAndStartNewEdit =\n        finishEditAndStartNewEdit.bind(toolInstance);\n    toolInstance.fuseEditPointsWithClosedContour =\n        fuseEditPointsWithClosedContour.bind(toolInstance);\n    toolInstance.cancelClosedContourEdit =\n        cancelClosedContourEdit.bind(toolInstance);\n    toolInstance.completeClosedContourEdit =\n        completeClosedContourEdit.bind(toolInstance);\n}\nexport default registerClosedContourEditLoop;\n", "import { vec3, vec2 } from 'gl-matrix';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store/state';\nimport { Events } from '../../../enums';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { polyline } from '../../../utilities/math';\nimport { shouldSmooth, getInterpolatedPoints, } from '../../../utilities/planarFreehandROITool/smoothPoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport updateContourPolyline from '../../../utilities/contours/updateContourPolyline';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\nimport { triggerAnnotationModified } from '../../../stateManagement/annotation/helpers/state';\nconst { addCanvasPointsToArray, getSubPixelSpacingAndXYDirections } = polyline;\nfunction activateOpenContourEdit(evt, annotation, viewportIdsToRender) {\n    this.isEditingOpen = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    this.doneEditMemo();\n    const prevCanvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    this.editData = {\n        prevCanvasPoints,\n        editCanvasPoints: [canvasPos],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragOpenContourEditCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpOpenContourEditCallback);\n    hideElementCursor(element);\n}\nfunction deactivateOpenContourEdit(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragOpenContourEditCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpOpenContourEditCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragOpenContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n    const { editIndex, editCanvasPoints, startCrossingIndex } = this.editData;\n    const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    this.createMemo(element, this.commonData.annotation);\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (startCrossingIndex !== undefined) {\n        this.checkAndRemoveCrossesOnEditLine(evt);\n    }\n    const numPointsAdded = addCanvasPointsToArray(element, editCanvasPoints, canvasPos, this.commonData);\n    const currentEditIndex = editIndex + numPointsAdded;\n    this.editData.editIndex = currentEditIndex;\n    if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n        this.checkForFirstCrossing(evt, false);\n    }\n    this.editData.snapIndex = this.findSnapIndex();\n    this.editData.fusedCanvasPoints = this.fuseEditPointsWithOpenContour(evt);\n    if (startCrossingIndex !== undefined &&\n        this.checkForSecondCrossing(evt, false)) {\n        this.removePointsAfterSecondCrossing(false);\n        this.finishEditOpenOnSecondCrossing(evt);\n    }\n    else if (this.checkIfShouldOverwriteAnEnd(evt)) {\n        this.openContourEditOverwriteEnd(evt);\n    }\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction openContourEditOverwriteEnd(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const fusedCanvasPoints = this.fuseEditPointsForOpenContourEndEdit();\n    updateContourPolyline(annotation, {\n        points: fusedCanvasPoints,\n        closed: false,\n    }, viewport);\n    const worldPoints = annotation.data.contour.polyline;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    annotation.data.handles.activeHandleIndex = 1;\n    triggerAnnotationModified(annotation, element);\n    this.isEditingOpen = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    this.doneEditMemo();\n    this.deactivateOpenContourEdit(element);\n    this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, null);\n}\nfunction checkIfShouldOverwriteAnEnd(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPos = lastPoints.canvas;\n    const { snapIndex, prevCanvasPoints, startCrossingIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return false;\n    }\n    if (snapIndex === -1) {\n        return true;\n    }\n    if (snapIndex !== 0 && snapIndex !== prevCanvasPoints.length - 1) {\n        return false;\n    }\n    const p1 = canvasPos;\n    const p2 = lastCanvasPos;\n    const p3 = prevCanvasPoints[snapIndex];\n    const a = vec2.create();\n    const b = vec2.create();\n    vec2.set(a, p1[0] - p2[0], p1[1] - p2[1]);\n    vec2.set(b, p1[0] - p3[0], p1[1] - p3[1]);\n    const aDotb = vec2.dot(a, b);\n    const magA = Math.sqrt(a[0] * a[0] + a[1] * a[1]);\n    const magB = Math.sqrt(b[0] * b[0] + b[1] * b[1]);\n    const theta = Math.acos(aDotb / (magA * magB));\n    if (theta < Math.PI / 2) {\n        return true;\n    }\n    return false;\n}\nfunction fuseEditPointsForOpenContourEndEdit() {\n    const { snapIndex, prevCanvasPoints, editCanvasPoints, startCrossingIndex } = this.editData;\n    const newCanvasPoints = [];\n    if (snapIndex === 0) {\n        for (let i = prevCanvasPoints.length - 1; i >= startCrossingIndex; i--) {\n            const canvasPoint = prevCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = 0; i < startCrossingIndex; i++) {\n            const canvasPoint = prevCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    const distanceBetweenCrossingIndexAndFirstPoint = vec2.distance(prevCanvasPoints[startCrossingIndex], editCanvasPoints[0]);\n    const distanceBetweenCrossingIndexAndLastPoint = vec2.distance(prevCanvasPoints[startCrossingIndex], editCanvasPoints[editCanvasPoints.length - 1]);\n    if (distanceBetweenCrossingIndexAndFirstPoint <\n        distanceBetweenCrossingIndexAndLastPoint) {\n        for (let i = 0; i < editCanvasPoints.length; i++) {\n            const canvasPoint = editCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = editCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = editCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    return newCanvasPoints;\n}\nfunction fuseEditPointsWithOpenContour(evt) {\n    const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return undefined;\n    }\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const augmentedEditCanvasPoints = [...editCanvasPoints];\n    addCanvasPointsToArray(element, augmentedEditCanvasPoints, prevCanvasPoints[snapIndex], this.commonData);\n    if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n        augmentedEditCanvasPoints.pop();\n    }\n    let lowIndex;\n    let highIndex;\n    if (startCrossingIndex > snapIndex) {\n        lowIndex = snapIndex;\n        highIndex = startCrossingIndex;\n    }\n    else {\n        lowIndex = startCrossingIndex;\n        highIndex = snapIndex;\n    }\n    const distanceBetweenLowAndFirstPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenLowAndLastPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const distanceBetweenHighAndFirstPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenHighAndLastPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const pointsToRender = [];\n    for (let i = 0; i < lowIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    const inPlaceDistance = distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n    const reverseDistance = distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    return pointsToRender;\n}\nfunction finishEditOpenOnSecondCrossing(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n    updateContourPolyline(annotation, {\n        points: fusedCanvasPoints,\n        closed: false,\n    }, viewport);\n    const worldPoints = annotation.data.contour.polyline;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    triggerAnnotationModified(annotation, element);\n    const lastEditCanvasPoint = editCanvasPoints.pop();\n    this.editData = {\n        prevCanvasPoints: fusedCanvasPoints,\n        editCanvasPoints: [lastEditCanvasPoint],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n    };\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction mouseUpOpenContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    this.completeOpenContourEdit(element);\n}\nfunction completeOpenContourEdit(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    this.doneEditMemo();\n    const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n    if (fusedCanvasPoints) {\n        const updatedPoints = shouldSmooth(this.configuration)\n            ? getInterpolatedPoints(this.configuration, fusedCanvasPoints, prevCanvasPoints)\n            : fusedCanvasPoints;\n        const decimateConfig = this.configuration?.decimate || {};\n        updateContourPolyline(annotation, {\n            points: updatedPoints,\n            closed: false,\n        }, viewport, {\n            decimate: {\n                enabled: !!decimateConfig.enabled,\n                epsilon: decimateConfig.epsilon,\n            },\n        });\n        const worldPoints = annotation.data.contour.polyline;\n        annotation.data.handles.points = [\n            worldPoints[0],\n            worldPoints[worldPoints.length - 1],\n        ];\n        if (annotation.data.isOpenUShapeContour) {\n            annotation.data.openUShapeContourVectorToPeak =\n                findOpenUShapedContourVectorToPeak(fusedCanvasPoints, viewport);\n        }\n        triggerAnnotationModified(annotation, element);\n    }\n    this.isEditingOpen = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateOpenContourEdit(element);\n}\nfunction cancelOpenContourEdit(element) {\n    this.completeOpenContourEdit(element);\n}\nfunction registerOpenContourEditLoop(toolInstance) {\n    toolInstance.activateOpenContourEdit =\n        activateOpenContourEdit.bind(toolInstance);\n    toolInstance.deactivateOpenContourEdit =\n        deactivateOpenContourEdit.bind(toolInstance);\n    toolInstance.mouseDragOpenContourEditCallback =\n        mouseDragOpenContourEditCallback.bind(toolInstance);\n    toolInstance.mouseUpOpenContourEditCallback =\n        mouseUpOpenContourEditCallback.bind(toolInstance);\n    toolInstance.fuseEditPointsWithOpenContour =\n        fuseEditPointsWithOpenContour.bind(toolInstance);\n    toolInstance.finishEditOpenOnSecondCrossing =\n        finishEditOpenOnSecondCrossing.bind(toolInstance);\n    toolInstance.checkIfShouldOverwriteAnEnd =\n        checkIfShouldOverwriteAnEnd.bind(toolInstance);\n    toolInstance.fuseEditPointsForOpenContourEndEdit =\n        fuseEditPointsForOpenContourEndEdit.bind(toolInstance);\n    toolInstance.openContourEditOverwriteEnd =\n        openContourEditOverwriteEnd.bind(toolInstance);\n    toolInstance.cancelOpenContourEdit = cancelOpenContourEdit.bind(toolInstance);\n    toolInstance.completeOpenContourEdit =\n        completeOpenContourEdit.bind(toolInstance);\n}\nexport default registerOpenContourEditLoop;\n", "import { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store/state';\nimport { Events } from '../../../enums';\nimport { hideElementCursor } from '../../../cursors/elementCursor';\nimport { polyline } from '../../../utilities/math';\nconst { getSubPixelSpacingAndXYDirections } = polyline;\nfunction activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, handle) {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    const canvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    const handleIndexGrabbed = annotation.data.handles.activeHandleIndex;\n    if (handleIndexGrabbed === 0) {\n        canvasPoints.reverse();\n    }\n    let movingTextBox = false;\n    if (handle?.worldPosition) {\n        movingTextBox = true;\n    }\n    this.drawData = {\n        canvasPoints: canvasPoints,\n        polylineIndex: canvasPoints.length - 1,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    hideElementCursor(element);\n}\nfunction registerOpenContourEndEditLoop(toolInstance) {\n    toolInstance.activateOpenContourEndEdit =\n        activateOpenContourEndEdit.bind(toolInstance);\n}\nexport default registerOpenContourEndEditLoop;\n", "import { getAnnotation } from '../../stateManagement/annotation/annotationState';\nexport default function getContourHolesDataWorld(annotation) {\n    const childAnnotationUIDs = annotation.childAnnotationUIDs ?? [];\n    return childAnnotationUIDs.map((uid) => getAnnotation(uid).data.contour.polyline);\n}\n", "import getContourHolesDataWorld from './getContourHolesDataWorld';\nexport default function getContourHolesDataCanvas(annotation, viewport) {\n    const worldHoleContours = getContourHolesDataWorld(annotation);\n    const canvasHoleContours = [];\n    worldHoleContours.forEach((worldHoleContour) => {\n        const numPoints = worldHoleContour.length;\n        const canvasHoleContour = new Array(numPoints);\n        for (let i = 0; i < numPoints; i++) {\n            canvasHoleContour[i] = viewport.worldToCanvas(worldHoleContour[i]);\n        }\n        canvasHoleContours.push(canvasHoleContour);\n    });\n    return canvasHoleContours;\n}\n", "import { drawHandles as drawHandlesSvg, drawPolyline as drawPolylineSvg, drawPath as drawPathSvg, } from '../../../drawingSvg';\nimport { polyline } from '../../../utilities/math';\nimport { findOpenUShapedContourVectorToPeakOnRender } from './findOpenUShapedContourVectorToPeak';\nimport getContourHolesDataCanvas from '../../../utilities/contours/getContourHolesDataCanvas';\nconst { pointsAreWithinCloseContourProximity } = polyline;\nfunction _getRenderingOptions(enabledElement, annotation) {\n    const styleSpecifier = {\n        toolGroupId: this.toolGroupId,\n        toolName: this.getToolName(),\n        viewportId: enabledElement.viewport.id,\n        annotationUID: annotation.annotationUID,\n    };\n    const { lineWidth, lineDash, color, fillColor, fillOpacity } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n    });\n    const { closed: isClosedContour } = annotation.data.contour;\n    const options = {\n        color,\n        width: lineWidth,\n        lineDash,\n        fillColor,\n        fillOpacity,\n        closePath: isClosedContour,\n    };\n    return options;\n}\nfunction renderContour(enabledElement, svgDrawingHelper, annotation) {\n    if (!enabledElement?.viewport?.getImageData()) {\n        return;\n    }\n    if (annotation.data.contour.closed) {\n        this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n    }\n    else {\n        if (annotation.data.isOpenUShapeContour) {\n            calculateUShapeContourVectorToPeakIfNotPresent(enabledElement, annotation);\n            this.renderOpenUShapedContour(enabledElement, svgDrawingHelper, annotation);\n        }\n        else {\n            this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n        }\n    }\n}\nfunction calculateUShapeContourVectorToPeakIfNotPresent(enabledElement, annotation) {\n    if (!annotation.data.openUShapeContourVectorToPeak) {\n        annotation.data.openUShapeContourVectorToPeak =\n            findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation);\n    }\n}\nfunction renderClosedContour(enabledElement, svgDrawingHelper, annotation) {\n    if (annotation.parentAnnotationUID) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const canvasPolyline = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));\n    const childContours = getContourHolesDataCanvas(annotation, viewport);\n    const allContours = [canvasPolyline, ...childContours];\n    const polylineUID = '1';\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID, allContours, options);\n}\nfunction renderOpenContour(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const canvasPoints = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));\n    const polylineUID = '1';\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, polylineUID, canvasPoints, options);\n    const activeHandleIndex = annotation.data.handles.activeHandleIndex;\n    if (this.configuration.alwaysRenderOpenContourHandles?.enabled === true) {\n        const radius = this.configuration.alwaysRenderOpenContourHandles.radius;\n        const handleGroupUID = '0';\n        const handlePoints = [\n            canvasPoints[0],\n            canvasPoints[canvasPoints.length - 1],\n        ];\n        if (activeHandleIndex === 0) {\n            handlePoints.shift();\n        }\n        else if (activeHandleIndex === 1) {\n            handlePoints.pop();\n        }\n        drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, handlePoints, {\n            color: options.color,\n            handleRadius: radius,\n        });\n    }\n    if (activeHandleIndex !== null) {\n        const handleGroupUID = '1';\n        const indexOfCanvasPoints = activeHandleIndex === 0 ? 0 : canvasPoints.length - 1;\n        const handlePoint = canvasPoints[indexOfCanvasPoints];\n        drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, [handlePoint], { color: options.color });\n    }\n}\nfunction renderOpenUShapedContour(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const { openUShapeContourVectorToPeak } = annotation.data;\n    const { polyline } = annotation.data.contour;\n    this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n    if (!openUShapeContourVectorToPeak) {\n        return;\n    }\n    const firstCanvasPoint = viewport.worldToCanvas(polyline[0]);\n    const lastCanvasPoint = viewport.worldToCanvas(polyline[polyline.length - 1]);\n    const openUShapeContourVectorToPeakCanvas = [\n        viewport.worldToCanvas(openUShapeContourVectorToPeak[0]),\n        viewport.worldToCanvas(openUShapeContourVectorToPeak[1]),\n    ];\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, 'first-to-last', [firstCanvasPoint, lastCanvasPoint], {\n        color: options.color,\n        width: options.width,\n        closePath: false,\n        lineDash: '2,2',\n    });\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, 'midpoint-to-open-contour', [\n        openUShapeContourVectorToPeakCanvas[0],\n        openUShapeContourVectorToPeakCanvas[1],\n    ], {\n        color: options.color,\n        width: options.width,\n        closePath: false,\n        lineDash: '2,2',\n    });\n}\nfunction renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation) {\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints } = this.drawData;\n    options.closePath = false;\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, '1', canvasPoints, options);\n    if (allowOpenContours) {\n        const firstPoint = canvasPoints[0];\n        const lastPoint = canvasPoints[canvasPoints.length - 1];\n        if (pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n            drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, '2', [lastPoint, firstPoint], options);\n        }\n        else {\n            const handleGroupUID = '0';\n            drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, [firstPoint], { color: options.color, handleRadius: 2 });\n        }\n    }\n}\nfunction renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const { fusedCanvasPoints } = this.editData;\n    if (fusedCanvasPoints === undefined) {\n        this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n        return;\n    }\n    const childContours = getContourHolesDataCanvas(annotation, viewport);\n    const allContours = [fusedCanvasPoints, ...childContours];\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const polylineUIDToRender = 'preview-1';\n    if (annotation.parentAnnotationUID && options.fillOpacity) {\n        options.fillOpacity = 0;\n    }\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUIDToRender, allContours, options);\n}\nfunction renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation) {\n    const { fusedCanvasPoints } = this.editData;\n    if (fusedCanvasPoints === undefined) {\n        this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n        return;\n    }\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const polylineUIDToRender = 'preview-1';\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, polylineUIDToRender, fusedCanvasPoints, options);\n}\nfunction renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation) {\n    if (annotation.parentAnnotationUID) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const canvasPolyline = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));\n    const childContours = getContourHolesDataCanvas(annotation, viewport);\n    const polylineUID = '1';\n    const center = canvasPolyline[0];\n    const radius = 6;\n    const numberOfPoints = 100;\n    const circlePoints = [];\n    for (let i = 0; i < numberOfPoints; i++) {\n        const angle = (i / numberOfPoints) * 2 * Math.PI;\n        const x = center[0] + radius * Math.cos(angle);\n        const y = center[1] + radius * Math.sin(angle);\n        circlePoints.push([x, y]);\n    }\n    const crosshair = [\n        [center[0] - radius * 2, center[1]],\n        [center[0] + radius * 2, center[1]],\n        [center[0], center[1] - radius * 2],\n        [center[0], center[1] + radius * 2],\n    ];\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID + '-crosshair_v', [crosshair[0], crosshair[1]], options);\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID + '-crosshair_h', [crosshair[2], crosshair[3]], options);\n    const allContours = [circlePoints, ...childContours];\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID, allContours, options);\n}\nfunction registerRenderMethods(toolInstance) {\n    toolInstance.renderContour = renderContour.bind(toolInstance);\n    toolInstance.renderClosedContour = renderClosedContour.bind(toolInstance);\n    toolInstance.renderOpenContour = renderOpenContour.bind(toolInstance);\n    toolInstance.renderPointContourWithMarker =\n        renderPointContourWithMarker.bind(toolInstance);\n    toolInstance.renderOpenUShapedContour =\n        renderOpenUShapedContour.bind(toolInstance);\n    toolInstance.renderContourBeingDrawn =\n        renderContourBeingDrawn.bind(toolInstance);\n    toolInstance.renderClosedContourBeingEdited =\n        renderClosedContourBeingEdited.bind(toolInstance);\n    toolInstance.renderOpenContourBeingEdited =\n        renderOpenContourBeingEdited.bind(toolInstance);\n    toolInstance._getRenderingOptions = _getRenderingOptions.bind(toolInstance);\n}\nexport default registerRenderMethods;\n", "import getTextBoxCoordsCanvas from './getTextBoxCoordsCanvas';\nexport { getTextBoxCoordsCanvas };\n", "export default function getTextBoxCoordsCanvas(annotationCanvasPoints) {\n    const corners = _determineCorners(annotationCanvasPoints);\n    const centerY = (corners.top[1] + corners.bottom[1]) / 2;\n    const textBoxCanvas = [corners.right[0], centerY];\n    return textBoxCanvas;\n}\nfunction _determineCorners(canvasPoints) {\n    const handlesLeftToRight = [canvasPoints[0], canvasPoints[1]].sort(_compareX);\n    const handlesTopToBottom = [canvasPoints[0], canvasPoints[1]].sort(_compareY);\n    const right = handlesLeftToRight[handlesLeftToRight.length - 1];\n    const top = handlesTopToBottom[0];\n    const bottom = handlesTopToBottom[handlesTopToBottom.length - 1];\n    return {\n        top,\n        bottom,\n        right,\n    };\n    function _compareX(a, b) {\n        return a[0] < b[0] ? -1 : 1;\n    }\n    function _compareY(a, b) {\n        return a[1] < b[1] ? -1 : 1;\n    }\n}\n", "import { cache, StackViewport, BaseVolumeViewport, utilities, } from '@cornerstonejs/core';\nfunction isViewportPreScaled(viewport, targetId) {\n    if (viewport instanceof BaseVolumeViewport) {\n        const volumeId = utilities.getVolumeId(targetId);\n        const volume = cache.getVolume(volumeId);\n        return !!volume?.scaling && Object.keys(volume.scaling).length > 0;\n    }\n    else if (viewport instanceof StackViewport) {\n        const { preScale } = viewport.getImageData() || {};\n        return !!preScale?.scaled;\n    }\n    else {\n        return false;\n    }\n}\nexport { isViewportPreScaled };\n", "function calculatePerimeter(polyline, closed) {\n    let perimeter = 0;\n    for (let i = 0; i < polyline.length - 1; i++) {\n        const point1 = polyline[i];\n        const point2 = polyline[i + 1];\n        perimeter += Math.sqrt(Math.pow(point2[0] - point1[0], 2) + Math.pow(point2[1] - point1[1], 2));\n    }\n    if (closed) {\n        const firstPoint = polyline[0];\n        const lastPoint = polyline[polyline.length - 1];\n        perimeter += Math.sqrt(Math.pow(lastPoint[0] - firstPoint[0], 2) +\n            Math.pow(lastPoint[1] - firstPoint[1], 2));\n    }\n    return perimeter;\n}\nexport default calculatePerimeter;\n", "import { getEnabledElement } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, getChildAnnotations, } from '../../stateManagement/annotation/annotationState';\nimport { drawPath as drawPathSvg } from '../../drawingSvg';\nimport AnnotationTool from './AnnotationTool';\nimport updateContourPolyline from '../../utilities/contours/updateContourPolyline';\nimport getContourHolesDataCanvas from '../../utilities/contours/getContourHolesDataCanvas';\nclass ContourBaseTool extends AnnotationTool {\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        let renderStatus = false;\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        if (!viewport.getRenderingEngine()) {\n            console.warn('Rendering Engine has been destroyed');\n            return renderStatus;\n        }\n        let annotations = getAnnotations(this.getToolName(), element);\n        if (!annotations?.length) {\n            return renderStatus;\n        }\n        annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n        if (!annotations?.length) {\n            return renderStatus;\n        }\n        const targetId = this.getTargetId(viewport);\n        const styleSpecifier = {\n            toolGroupId: this.toolGroupId,\n            toolName: this.getToolName(),\n            viewportId: enabledElement.viewport.id,\n        };\n        for (let i = 0; i < annotations.length; i++) {\n            const annotation = annotations[i];\n            styleSpecifier.annotationUID = annotation.annotationUID;\n            const annotationStyle = this.getAnnotationStyle({\n                annotation,\n                styleSpecifier,\n            });\n            if (!annotationStyle.visibility) {\n                continue;\n            }\n            const annotationRendered = this.renderAnnotationInstance({\n                enabledElement,\n                targetId,\n                annotation,\n                annotationStyle,\n                svgDrawingHelper,\n            });\n            renderStatus ||= annotationRendered;\n            annotation.invalidated = false;\n        }\n        return renderStatus;\n    }\n    createAnnotation(evt) {\n        const annotation = super.createAnnotation(evt);\n        Object.assign(annotation.data, {\n            contour: {\n                polyline: [],\n                closed: false,\n            },\n        });\n        Object.assign(annotation, {\n            interpolationUID: '',\n            autoGenerated: false,\n        });\n        return annotation;\n    }\n    addAnnotation(annotation, element) {\n        return addAnnotation(annotation, element);\n    }\n    cancelAnnotation(annotation) {\n    }\n    moveAnnotation(annotation, worldPosDelta) {\n        const { points } = annotation.data.handles;\n        for (let i = 0, numPoints = points.length; i < numPoints; i++) {\n            const point = points[i];\n            point[0] += worldPosDelta[0];\n            point[1] += worldPosDelta[1];\n            point[2] += worldPosDelta[2];\n        }\n        annotation.invalidated = true;\n        getChildAnnotations(annotation).forEach((childAnnotation) => this.moveAnnotation(childAnnotation, worldPosDelta));\n    }\n    updateContourPolyline(annotation, polylineData, transforms, options) {\n        const decimateConfig = this.configuration?.decimate || {};\n        updateContourPolyline(annotation, polylineData, transforms, {\n            decimate: {\n                enabled: !!decimateConfig.enabled,\n                epsilon: decimateConfig.epsilon,\n            },\n            updateWindingDirection: options?.updateWindingDirection,\n        });\n    }\n    getPolylinePoints(annotation) {\n        return annotation.data.contour?.polyline ?? annotation.data.polyline;\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, annotationStyle, svgDrawingHelper } = renderContext;\n        const annotation = renderContext.annotation;\n        if (annotation.parentAnnotationUID) {\n            return;\n        }\n        const { annotationUID } = annotation;\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const polylineCanvasPoints = this.getPolylinePoints(annotation).map((point) => worldToCanvas(point));\n        const { lineWidth, lineDash, color, fillColor, fillOpacity } = annotationStyle;\n        const childContours = getContourHolesDataCanvas(annotation, viewport);\n        const allContours = [polylineCanvasPoints, ...childContours];\n        drawPathSvg(svgDrawingHelper, annotationUID, 'contourPolyline', allContours, {\n            color: color,\n            lineDash: lineDash,\n            lineWidth: Math.max(0.1, lineWidth),\n            fillColor: fillColor,\n            fillOpacity: fillOpacity,\n        });\n        return true;\n    }\n}\nexport { ContourBaseTool as default, ContourBaseTool };\n", "import * as config from './config';\nimport * as locking from './annotationLocking';\nimport * as selection from './annotationSelection';\nimport * as annotationState from './annotationState';\nimport * as annotationStateHelpers from './helpers/state';\nimport * as visibility from './annotationVisibility';\nimport FrameOfReferenceSpecificAnnotationManager from './FrameOfReferenceSpecificAnnotationManager';\nimport AnnotationGroup from './AnnotationGroup';\nimport { resetAnnotationManager } from './resetAnnotationManager';\nconst state = {\n    ...annotationState,\n    ...annotationStateHelpers,\n    resetAnnotationManager,\n};\nexport { config, locking, selection, state, visibility, FrameOfReferenceSpecificAnnotationManager, AnnotationGroup, };\n", "import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport { getAnnotation } from './annotationState';\nexport default class AnnotationGroup {\n    constructor() {\n        this.annotationUIDs = new Set();\n        this._isVisible = true;\n        this.visibleFilter = this.unboundVisibleFilter.bind(this);\n    }\n    unboundVisibleFilter(uid) {\n        return !this._isVisible || !this.annotationUIDs.has(uid);\n    }\n    has(uid) {\n        return this.annotationUIDs.has(uid);\n    }\n    setVisible(isVisible = true, baseEvent, filter) {\n        if (this._isVisible === isVisible) {\n            return;\n        }\n        this._isVisible = isVisible;\n        this.annotationUIDs.forEach((uid) => {\n            const annotation = getAnnotation(uid);\n            if (!annotation) {\n                this.annotationUIDs.delete(uid);\n                return;\n            }\n            if (annotation.isVisible === isVisible) {\n                return;\n            }\n            if (!isVisible && filter?.(uid) === false) {\n                return;\n            }\n            annotation.isVisible = isVisible;\n            const eventDetail = {\n                ...baseEvent,\n                annotation,\n            };\n            triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);\n        });\n    }\n    get isVisible() {\n        return this._isVisible;\n    }\n    findNearby(uid, direction) {\n        const uids = [...this.annotationUIDs];\n        if (uids.length === 0) {\n            return null;\n        }\n        if (!uid) {\n            return uids[direction === 1 ? 0 : uids.length - 1];\n        }\n        const index = uids.indexOf(uid);\n        if (index === -1 ||\n            index + direction < 0 ||\n            index + direction >= uids.length) {\n            return null;\n        }\n        return uids[index + direction];\n    }\n    add(...annotationUIDs) {\n        annotationUIDs.forEach((annotationUID) => this.annotationUIDs.add(annotationUID));\n    }\n    remove(...annotationUIDs) {\n        annotationUIDs.forEach((annotationUID) => this.annotationUIDs.delete(annotationUID));\n    }\n    clear() {\n        this.annotationUIDs.clear();\n    }\n}\n", "import { getAnnotations } from '../../../stateManagement/annotation/annotationState';\nconst DEFAULT_CONTOUR_SEG_TOOLNAME = 'PlanarFreehandContourSegmentationTool';\nexport default function getInterpolationData(viewportData, filterParams = []) {\n    const { viewport, sliceData, annotation } = viewportData;\n    const interpolationDatas = new Map();\n    const { toolName, originalToolName } = annotation.metadata;\n    const testToolName = originalToolName || toolName;\n    const annotations = (getAnnotations(testToolName, viewport.element) || []).filter((annotation) => !annotation.metadata.originalToolName ||\n        annotation.metadata.originalToolName === testToolName);\n    if (testToolName !== DEFAULT_CONTOUR_SEG_TOOLNAME) {\n        const modifiedAnnotations = getAnnotations(DEFAULT_CONTOUR_SEG_TOOLNAME, viewport.element);\n        if (modifiedAnnotations?.length) {\n            modifiedAnnotations.forEach((annotation) => {\n                const { metadata } = annotation;\n                if (metadata.originalToolName === testToolName &&\n                    metadata.originalToolName !== metadata.toolName) {\n                    annotations.push(annotation);\n                }\n            });\n        }\n    }\n    if (!annotations?.length) {\n        return interpolationDatas;\n    }\n    for (let i = 0; i < sliceData.numberOfSlices; i++) {\n        const imageAnnotations = annotations.filter((x) => x.metadata.sliceIndex === i);\n        if (!imageAnnotations?.length) {\n            continue;\n        }\n        const filteredInterpolatedAnnotations = imageAnnotations.filter((imageAnnotation) => {\n            return filterParams.every((x) => {\n                const parent = x.parentKey\n                    ? x.parentKey(imageAnnotation)\n                    : imageAnnotation;\n                const value = parent?.[x.key];\n                if (Array.isArray(value)) {\n                    return value.every((item, index) => item === x.value[index]);\n                }\n                return value === x.value;\n            });\n        });\n        if (filteredInterpolatedAnnotations.length) {\n            interpolationDatas.set(i, filteredInterpolatedAnnotations);\n        }\n    }\n    return interpolationDatas;\n}\n", "import getInterpolationData from './getInterpolationData';\nexport default function getInterpolationDataCollection(viewportData, filterParams) {\n    const imageAnnotations = getInterpolationData(viewportData, filterParams);\n    const interpolatedDataCollection = [];\n    if (!imageAnnotations?.size) {\n        return interpolatedDataCollection;\n    }\n    for (const annotations of imageAnnotations.values()) {\n        annotations.forEach((annotation) => {\n            interpolatedDataCollection.push(annotation);\n        });\n    }\n    return interpolatedDataCollection;\n}\n", "import { utilities as csUtils } from '@cornerstonejs/core';\nexport default function createPolylineToolData(polyline, handlePoints, referencedToolData) {\n    const annotation = csUtils.deepMerge({\n        data: {},\n        metadata: {},\n    }, referencedToolData);\n    Object.assign(annotation, {\n        highlighted: false,\n        invalidated: true,\n        autoGenerated: true,\n        annotationUID: undefined,\n        cachedStats: {},\n        childAnnotationUIDs: [],\n        parentAnnotationUID: undefined,\n    });\n    Object.assign(annotation.data, {\n        handles: {\n            points: handlePoints.points || handlePoints || [],\n            interpolationSources: handlePoints.sources,\n            activeHandleIndex: null,\n            textBox: {\n                hasMoved: false,\n                worldPosition: [0, 0, 0],\n                worldBoundingBox: {\n                    topLeft: [0, 0, 0],\n                    topRight: [0, 0, 0],\n                    bottomLeft: [0, 0, 0],\n                    bottomRight: [0, 0, 0],\n                },\n            },\n        },\n        contour: {\n            ...referencedToolData.data.contour,\n            polyline,\n        },\n    });\n    return annotation;\n}\n", "import getInterpolationData from './getInterpolationData';\nfunction findAnnotationsForInterpolation(toolData, viewportData) {\n    const interpolationData = getInterpolationData(viewportData, [\n        {\n            key: 'interpolationUID',\n            value: viewportData.interpolationUID,\n        },\n    ]);\n    const rangeToInterpolate = getRangeToInterpolate(interpolationData);\n    if (!rangeToInterpolate) {\n        console.warn('No annotations found to interpolate', interpolationData);\n        return;\n    }\n    const sliceEdited = _getSlicePositionOfToolData(interpolationData, toolData.annotationUID);\n    const interpolationList = [];\n    for (let i = rangeToInterpolate[0] + 1; i < rangeToInterpolate[1]; i++) {\n        if (_sliceNeedsInterpolating(interpolationData, i)) {\n            const contourPair = _getBoundingPair(i, rangeToInterpolate, interpolationData);\n            if (contourPair?.[0] === sliceEdited ||\n                contourPair?.[1] === sliceEdited) {\n                _appendInterpolationList(contourPair, interpolationList, i);\n            }\n        }\n    }\n    return {\n        interpolationData,\n        interpolationList,\n    };\n}\nfunction getRangeToInterpolate(interpolationData) {\n    let first = Infinity;\n    let last = -Infinity;\n    let found = false;\n    for (const [sliceIndex, annotations] of interpolationData.entries()) {\n        if (annotations.length) {\n            first = Math.min(sliceIndex, first);\n            last = Math.max(sliceIndex, last);\n            found = true;\n        }\n    }\n    if (!found) {\n        return;\n    }\n    return [first, last];\n}\nfunction _getSlicePositionOfToolData(interpolationData, annotationUID) {\n    for (const [sliceIndex, annotations] of interpolationData) {\n        for (let j = 0; j < annotations.length; j++) {\n            if (annotations[j].annotationUID === annotationUID) {\n                return sliceIndex;\n            }\n        }\n    }\n    return;\n}\nfunction _sliceNeedsInterpolating(interpolationData, sliceIndex) {\n    const annotations = interpolationData.get(sliceIndex);\n    return (!annotations?.length ||\n        (annotations.length === 1 && annotations[0].autoGenerated));\n}\nfunction _appendInterpolationList(contourPair, interpolationList, itemIndex) {\n    const [startIndex] = contourPair;\n    interpolationList[startIndex] ||= {\n        pair: contourPair,\n        list: [],\n    };\n    interpolationList[startIndex].list.push(itemIndex);\n}\nfunction _getBoundingPair(sliceIndex, sliceRange, interpolationData) {\n    const annotationPair = [];\n    let canInterpolate = true;\n    for (let i = sliceIndex - 1; i >= sliceRange[0]; i--) {\n        const annotations = interpolationData.get(i);\n        if (annotations?.length) {\n            if (annotations[0].autoGenerated) {\n                continue;\n            }\n            if (annotations.length > 1) {\n                canInterpolate = false;\n            }\n            annotationPair.push(i);\n            break;\n        }\n    }\n    if (!canInterpolate || !annotationPair.length) {\n        return;\n    }\n    for (let i = sliceIndex + 1; i <= sliceRange[1]; i++) {\n        const annotations = interpolationData.get(i);\n        if (annotations?.length) {\n            if (annotations[0].autoGenerated) {\n                continue;\n            }\n            if (annotations.length > 1) {\n                canInterpolate = false;\n            }\n            annotationPair.push(i);\n            break;\n        }\n    }\n    if (!canInterpolate || annotationPair.length < 2) {\n        return;\n    }\n    return annotationPair;\n}\nexport default findAnnotationsForInterpolation;\n", "import { vec3 } from 'gl-matrix';\nimport { utilities } from '@cornerstonejs/core';\nconst { PointsManager } = utilities;\nexport default function selectHandles(polyline, handleCount = 12) {\n    const handles = PointsManager.create3(handleCount);\n    handles.sources = [];\n    const { sources: destPoints } = handles;\n    const { length, sources: sourcePoints = [] } = polyline;\n    const distance = 5;\n    if (length < distance * 3) {\n        return polyline.subselect(handleCount);\n    }\n    const interval = Math.floor(Math.max((2 * length) / handleCount, distance * 2));\n    sourcePoints.forEach(() => destPoints.push(PointsManager.create3(handleCount)));\n    const dotValues = createDotValues(polyline, distance);\n    const minimumRegions = findMinimumRegions(dotValues, handleCount);\n    const indices = [];\n    if (minimumRegions?.length > 2) {\n        let lastHandle = -1;\n        const thirdInterval = interval / 3;\n        minimumRegions.forEach((region) => {\n            const [start, , end] = region;\n            const midIndex = Math.ceil((start + end) / 2);\n            if (end - lastHandle < thirdInterval) {\n                return;\n            }\n            if (midIndex - start > 2 * thirdInterval) {\n                addInterval(indices, lastHandle, start, interval, length);\n                lastHandle = addInterval(indices, start, midIndex, interval, length);\n            }\n            else {\n                lastHandle = addInterval(indices, lastHandle, midIndex, interval, length);\n            }\n            if (end - lastHandle > thirdInterval) {\n                lastHandle = addInterval(indices, lastHandle, end, interval, length);\n            }\n        });\n        const firstHandle = indices[0];\n        const lastDistance = indexValue(firstHandle + length - lastHandle, length);\n        if (lastDistance > 2 * thirdInterval) {\n            addInterval(indices, lastHandle, firstHandle - thirdInterval, interval, length);\n        }\n    }\n    else {\n        const interval = Math.floor(length / handleCount);\n        addInterval(indices, -1, length - interval, interval, length);\n    }\n    indices.forEach((index) => {\n        const point = polyline.getPointArray(index);\n        handles.push(point);\n        sourcePoints.forEach((source, destSourceIndex) => destPoints[destSourceIndex].push(source.getPoint(index)));\n    });\n    return handles;\n}\nexport function createDotValues(polyline, distance = 6) {\n    const { length } = polyline;\n    const prevVec3 = vec3.create();\n    const nextVec3 = vec3.create();\n    const dotValues = new Float32Array(length);\n    for (let i = 0; i < length; i++) {\n        const point = polyline.getPoint(i);\n        const prevPoint = polyline.getPoint(i - distance);\n        const nextPoint = polyline.getPoint((i + distance) % length);\n        vec3.sub(prevVec3, point, prevPoint);\n        vec3.sub(nextVec3, nextPoint, point);\n        const dot = vec3.dot(prevVec3, nextVec3) / (vec3.len(prevVec3) * vec3.len(nextVec3));\n        dotValues[i] = dot;\n    }\n    return dotValues;\n}\nfunction findMinimumRegions(dotValues, handleCount) {\n    const { max, deviation } = getStats(dotValues);\n    const { length } = dotValues;\n    if (deviation < 0.01 || length < handleCount * 3) {\n        return [];\n    }\n    const inflection = [];\n    let pair = null;\n    let minValue;\n    let minIndex = 0;\n    for (let i = 0; i < length; i++) {\n        const dot = dotValues[i];\n        if (dot < max - deviation) {\n            if (pair) {\n                pair[2] = i;\n                if (dot < minValue) {\n                    minValue = dot;\n                    minIndex = i;\n                }\n                pair[1] = minIndex;\n            }\n            else {\n                minValue = dot;\n                minIndex = i;\n                pair = [i, i, i];\n            }\n        }\n        else {\n            if (pair) {\n                inflection.push(pair);\n                pair = null;\n            }\n        }\n    }\n    if (pair) {\n        if (inflection[0][0] === 0) {\n            inflection[0][0] = pair[0];\n        }\n        else {\n            pair[1] = minIndex;\n            pair[2] = length - 1;\n            inflection.push(pair);\n        }\n    }\n    return inflection;\n}\nexport function addInterval(indices, start, finish, interval, length) {\n    if (finish < start) {\n        finish += length;\n    }\n    const distance = finish - start;\n    const count = Math.ceil(distance / interval);\n    if (count <= 0) {\n        if (indices[indices.length - 1] !== finish) {\n            indices.push(indexValue(finish, length));\n        }\n        return finish;\n    }\n    for (let i = 1; i <= count; i++) {\n        const index = indexValue(start + (i * distance) / count, length);\n        indices.push(index);\n    }\n    return indices[indices.length - 1];\n}\nfunction indexValue(v, length) {\n    return (Math.round(v) + length) % length;\n}\nfunction getStats(dotValues) {\n    const { length } = dotValues;\n    let sum = 0;\n    let min = Infinity;\n    let max = -Infinity;\n    let sumSq = 0;\n    for (let i = 0; i < length; i++) {\n        const dot = dotValues[i];\n        sum += dot;\n        min = Math.min(min, dot);\n        max = Math.max(max, dot);\n    }\n    const mean = sum / length;\n    for (let i = 0; i < length; i++) {\n        const valueDiff = dotValues[i] - mean;\n        sumSq += valueDiff * valueDiff;\n    }\n    return {\n        mean,\n        max,\n        min,\n        sumSq,\n        deviation: Math.sqrt(sumSq / length),\n    };\n}\n", "import * as annotationState from '../../../stateManagement/annotation';\nexport default function updateChildInterpolationUID(annotation) {\n    const { parentAnnotationUID, annotationUID } = annotation;\n    if (!parentAnnotationUID) {\n        return annotation.interpolationUID;\n    }\n    const parentAnnotation = annotationState.state.getAnnotation(parentAnnotationUID);\n    const { interpolationUID } = parentAnnotation;\n    const index = parentAnnotation.childAnnotationUIDs.indexOf(annotationUID);\n    annotation.interpolationUID = `${interpolationUID}-${index}`;\n    return annotation.interpolationUID;\n}\n", "import { triggerEvent, utilities } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport createPolylineToolData from './createPolylineToolData';\nimport findAnnotationsForInterpolation from './findAnnotationForInterpolation';\nimport EventTypes from '../../../enums/Events';\nimport * as annotationState from '../../../stateManagement/annotation';\nimport selectHandles from './selectHandles';\nimport updateChildInterpolationUID from './updateChildInterpolationUID';\nimport { createPolylineHole } from '../../contourSegmentation';\nconst { PointsManager } = utilities;\nconst dP = 0.2;\nfunction interpolate(viewportData) {\n    if (!viewportData.annotation) {\n        return;\n    }\n    const { isInterpolationUpdate, annotation } = viewportData;\n    queueMicrotask(() => {\n        try {\n            if (isInterpolationUpdate) {\n                annotation.isInterpolationUpdate = true;\n                annotation.autoGenerated = false;\n            }\n            startInterpolation(viewportData);\n        }\n        finally {\n            if (isInterpolationUpdate) {\n                annotation.autoGenerated = true;\n            }\n        }\n    });\n}\nfunction startInterpolation(viewportData) {\n    const { annotation: toolData } = viewportData;\n    updateChildInterpolationUID(toolData);\n    const { interpolationData, interpolationList } = findAnnotationsForInterpolation(toolData, viewportData) || {};\n    if (!interpolationData || !interpolationList) {\n        return;\n    }\n    const eventData = {\n        toolName: toolData.metadata.toolName,\n        toolType: toolData.metadata.toolName,\n        viewport: viewportData.viewport,\n    };\n    for (let i = 0; i < interpolationList.length; i++) {\n        if (interpolationList[i]) {\n            _linearlyInterpolateBetween(interpolationList[i].list, interpolationList[i].pair, interpolationData, eventData);\n        }\n    }\n    const { id, renderingEngineId, element } = viewportData.viewport;\n    const eventDetails = {\n        annotation: toolData,\n        element,\n        viewportId: id,\n        renderingEngineId,\n    };\n    if (interpolationList.length) {\n        triggerEvent(viewportData.viewport.element, EventTypes.ANNOTATION_INTERPOLATION_PROCESS_COMPLETED, eventDetails);\n    }\n}\nfunction _linearlyInterpolateBetween(indices, annotationPair, interpolationData, eventData) {\n    const annotation0 = interpolationData.get(annotationPair[0])[0];\n    const annotation1 = interpolationData.get(annotationPair[1])[0];\n    const c1 = _generateClosedContour(annotation0.data.contour.polyline);\n    const c2 = _generateClosedContour(annotation1.data.contour.polyline);\n    const { c1Interp, c2Interp } = _generateInterpolationContourPair(c1, c2);\n    c1Interp.kIndex = annotationPair[0];\n    c2Interp.kIndex = annotationPair[1];\n    indices.forEach(function (index) {\n        _linearlyInterpolateContour(c1Interp, c2Interp, index, annotationPair, interpolationData, c1.x.length > c2.x.length, eventData);\n    });\n}\nfunction getPointCount(pointArray) {\n    let sum = 0;\n    for (let i = 0; i < pointArray.I.length; i++) {\n        if (pointArray.I[i]) {\n            sum++;\n        }\n    }\n    return sum;\n}\nfunction _linearlyInterpolateContour(c1Interp, c2Interp, sliceIndex, annotationPair, interpolationData, c1HasMoreNodes, eventData) {\n    const [startIndex, endIndex] = annotationPair;\n    const zInterp = (sliceIndex - startIndex) / (endIndex - startIndex);\n    const annotation0 = interpolationData.get(startIndex)[0];\n    const annotation1 = interpolationData.get(endIndex)[0];\n    const interpolated3DPoints = _generateInterpolatedOpenContour(c1Interp, c2Interp, zInterp, c1HasMoreNodes);\n    const nearestAnnotation = zInterp > 0.5 ? annotation1 : annotation0;\n    const handlePoints = selectHandles(interpolated3DPoints);\n    if (interpolationData.has(sliceIndex)) {\n        _editInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, nearestAnnotation, eventData);\n    }\n    else {\n        _addInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, nearestAnnotation, eventData);\n    }\n}\nfunction _addInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, referencedToolData, eventData) {\n    const points = interpolated3DPoints.points;\n    const { viewport } = eventData;\n    const interpolatedAnnotation = createPolylineToolData(points, handlePoints, referencedToolData);\n    const viewRef = viewport.getViewReference({ sliceIndex });\n    if (!viewRef) {\n        throw new Error(`Can't find slice ${sliceIndex}`);\n    }\n    Object.assign(interpolatedAnnotation.metadata, viewRef);\n    annotationState.state.addAnnotation(interpolatedAnnotation, viewport.element);\n    referencedToolData.onInterpolationComplete?.(interpolatedAnnotation, referencedToolData);\n    const { parentAnnotationUID } = referencedToolData;\n    if (parentAnnotationUID) {\n        const parentReferenced = annotationState.state.getAnnotation(parentAnnotationUID);\n        const parentAnnotation = _findExistingAnnotation(parentReferenced, sliceIndex, eventData);\n        createPolylineHole(viewport, parentAnnotation, interpolatedAnnotation);\n    }\n}\nfunction _findExistingAnnotation(referencedToolData, sliceIndex, eventData) {\n    const { viewport } = eventData;\n    const annotations = annotationState.state.getAnnotations(referencedToolData.metadata.toolName, viewport.element);\n    for (let i = 0; i < annotations.length; i++) {\n        const annotation = annotations[i];\n        if (annotation.interpolationUID === referencedToolData.interpolationUID &&\n            annotation.metadata.sliceIndex === sliceIndex) {\n            return annotation;\n        }\n    }\n}\nfunction _editInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, referencedToolData, eventData) {\n    const oldAnnotationData = _findExistingAnnotation(referencedToolData, sliceIndex, eventData);\n    const points = interpolated3DPoints.points;\n    const interpolatedAnnotation = createPolylineToolData(points, handlePoints, oldAnnotationData);\n    Object.assign(oldAnnotationData, {\n        metadata: interpolatedAnnotation.metadata,\n        data: interpolatedAnnotation.data,\n    });\n}\nfunction _generateInterpolatedOpenContour(c1ir, c2ir, zInterp, c1HasMoreNodes) {\n    const indices = c1HasMoreNodes ? c1ir.I : c2ir.I;\n    const c1 = PointsManager.fromXYZ(c1ir);\n    const c2 = PointsManager.fromXYZ(c2ir);\n    const { length } = c1;\n    const cInterp = PointsManager.create3(length);\n    const vecSubtract = vec3.create();\n    const vecResult = vec3.create();\n    const c1Source = PointsManager.create3(length);\n    c1Source.kIndex = c1ir.kIndex;\n    const c2Source = PointsManager.create3(length);\n    c2Source.kIndex = c2ir.kIndex;\n    for (let i = 0; i < c1ir.x.length; i++) {\n        if (indices[i]) {\n            const c1point = c1.getPoint(i);\n            const c2point = c2.getPoint(i);\n            c1Source.push(c1point);\n            c2Source.push(c2point);\n            vec3.sub(vecSubtract, c2point, c1point);\n            cInterp.push(vec3.scaleAndAdd(vecResult, c1point, vecSubtract, zInterp));\n        }\n    }\n    cInterp.sources = [c1Source, c2Source];\n    return cInterp;\n}\nfunction _generateInterpolationContourPair(c1, c2) {\n    const cumPerim1 = _getCumulativePerimeter(c1);\n    const cumPerim2 = _getCumulativePerimeter(c2);\n    const interpNodes = Math.max(Math.ceil(cumPerim1[cumPerim1.length - 1] / dP), Math.ceil(cumPerim2[cumPerim2.length - 1] / dP));\n    const cumPerim1Norm = _normalisedCumulativePerimeter(cumPerim1);\n    const cumPerim2Norm = _normalisedCumulativePerimeter(cumPerim2);\n    const numNodes1 = interpNodes + c2.x.length;\n    const numNodes2 = interpNodes + c1.x.length;\n    const perim1Interp = _getInterpolatedPerim(numNodes1, cumPerim1Norm);\n    const perim2Interp = _getInterpolatedPerim(numNodes2, cumPerim2Norm);\n    const perim1Ind = _getIndicatorArray(numNodes1 - 2, c1.x.length);\n    const perim2Ind = _getIndicatorArray(numNodes2 - 2, c2.x.length);\n    const nodesPerSegment1 = _getNodesPerSegment(perim1Interp, perim1Ind);\n    const nodesPerSegment2 = _getNodesPerSegment(perim2Interp, perim2Ind);\n    const c1i = _getSuperSampledContour(c1, nodesPerSegment1);\n    const c2i = _getSuperSampledContour(c2, nodesPerSegment2);\n    _shiftSuperSampledContourInPlace(c1i, c2i);\n    return _reduceContoursToOriginNodes(c1i, c2i);\n}\nfunction _reduceContoursToOriginNodes(c1i, c2i) {\n    const c1Interp = {\n        x: [],\n        y: [],\n        z: [],\n        I: [],\n    };\n    const c2Interp = {\n        x: [],\n        y: [],\n        z: [],\n        I: [],\n    };\n    for (let i = 0; i < c1i.x.length; i++) {\n        if (c1i.I[i] || c2i.I[i]) {\n            c1Interp.x.push(c1i.x[i]);\n            c1Interp.y.push(c1i.y[i]);\n            c1Interp.z.push(c1i.z[i]);\n            c1Interp.I.push(c1i.I[i]);\n            c2Interp.x.push(c2i.x[i]);\n            c2Interp.y.push(c2i.y[i]);\n            c2Interp.z.push(c2i.z[i]);\n            c2Interp.I.push(c2i.I[i]);\n        }\n    }\n    return {\n        c1Interp,\n        c2Interp,\n    };\n}\nfunction _shiftSuperSampledContourInPlace(c1i, c2i) {\n    const c1iLength = c1i.x.length;\n    const optimal = {\n        startingNode: 0,\n        totalSquaredXYLengths: Infinity,\n    };\n    for (let startingNode = 0; startingNode < c1iLength; startingNode++) {\n        let node = startingNode;\n        let totalSquaredXYLengths = 0;\n        for (let iteration = 0; iteration < c1iLength; iteration++) {\n            totalSquaredXYLengths +=\n                (c1i.x[node] - c2i.x[iteration]) ** 2 +\n                    (c1i.y[node] - c2i.y[iteration]) ** 2 +\n                    (c1i.z[node] - c2i.z[iteration]) ** 2;\n            node++;\n            if (node === c1iLength) {\n                node = 0;\n            }\n        }\n        if (totalSquaredXYLengths < optimal.totalSquaredXYLengths) {\n            optimal.totalSquaredXYLengths = totalSquaredXYLengths;\n            optimal.startingNode = startingNode;\n        }\n    }\n    const node = optimal.startingNode;\n    _shiftCircularArray(c1i.x, node);\n    _shiftCircularArray(c1i.y, node);\n    _shiftCircularArray(c1i.z, node);\n    _shiftCircularArray(c1i.I, node);\n}\nfunction _shiftCircularArray(arr, count) {\n    count -= arr.length * Math.floor(count / arr.length);\n    const slicedArray = arr.splice(0, count);\n    arr.push(...slicedArray);\n    return arr;\n}\nfunction _getSuperSampledContour(c, nodesPerSegment) {\n    const ci = {\n        x: [],\n        y: [],\n        z: [],\n        I: [],\n    };\n    for (let n = 0; n < c.x.length - 1; n++) {\n        ci.x.push(c.x[n]);\n        ci.y.push(c.y[n]);\n        ci.z.push(c.z[n]);\n        ci.I.push(true);\n        const xSpacing = (c.x[n + 1] - c.x[n]) / (nodesPerSegment[n] + 1);\n        const ySpacing = (c.y[n + 1] - c.y[n]) / (nodesPerSegment[n] + 1);\n        const zSpacing = (c.z[n + 1] - c.z[n]) / (nodesPerSegment[n] + 1);\n        for (let i = 0; i < nodesPerSegment[n] - 1; i++) {\n            ci.x.push(ci.x[ci.x.length - 1] + xSpacing);\n            ci.y.push(ci.y[ci.y.length - 1] + ySpacing);\n            ci.z.push(ci.z[ci.z.length - 1] + zSpacing);\n            ci.I.push(false);\n        }\n    }\n    return ci;\n}\nfunction _getNodesPerSegment(perimInterp, perimInd) {\n    const idx = [];\n    for (let i = 0; i < perimInterp.length; ++i) {\n        idx[i] = i;\n    }\n    idx.sort(function (a, b) {\n        return perimInterp[a] < perimInterp[b] ? -1 : 1;\n    });\n    const perimIndSorted = [];\n    for (let i = 0; i < perimInd.length; i++) {\n        perimIndSorted.push(perimInd[idx[i]]);\n    }\n    const indicesOfOriginNodes = perimIndSorted.reduce(function (arr, elementValue, i) {\n        if (elementValue) {\n            arr.push(i);\n        }\n        return arr;\n    }, []);\n    const nodesPerSegment = [];\n    for (let i = 0; i < indicesOfOriginNodes.length - 1; i++) {\n        nodesPerSegment.push(indicesOfOriginNodes[i + 1] - indicesOfOriginNodes[i]);\n    }\n    return nodesPerSegment;\n}\nfunction _getIndicatorArray(numFalse, numTrue) {\n    const perimInd = new Array(numFalse + numTrue);\n    perimInd.fill(false, 0, numFalse);\n    perimInd.fill(true, numFalse, numFalse + numTrue);\n    return perimInd;\n}\nfunction _getInterpolatedPerim(numNodes, cumPerimNorm) {\n    const diff = 1 / (numNodes - 1);\n    const linspace = [diff];\n    for (let i = 1; i < numNodes - 2; i++) {\n        linspace.push(linspace[linspace.length - 1] + diff);\n    }\n    return linspace.concat(cumPerimNorm);\n}\nfunction _normalisedCumulativePerimeter(cumPerim) {\n    const cumPerimNorm = [];\n    for (let i = 0; i < cumPerim.length; i++) {\n        cumPerimNorm.push(cumPerim[i] / cumPerim[cumPerim.length - 1]);\n    }\n    return cumPerimNorm;\n}\nfunction _getCumulativePerimeter(contour) {\n    const cumulativePerimeter = [0];\n    for (let i = 1; i < contour.x.length; i++) {\n        const lengthOfSegment = Math.sqrt((contour.x[i] - contour.x[i - 1]) ** 2 +\n            (contour.y[i] - contour.y[i - 1]) ** 2 +\n            (contour.z[i] - contour.z[i - 1]) ** 2);\n        cumulativePerimeter.push(cumulativePerimeter[i - 1] + lengthOfSegment);\n    }\n    return cumulativePerimeter;\n}\nfunction _generateClosedContour(points) {\n    const c = {\n        x: [],\n        y: [],\n        z: [],\n    };\n    for (let i = 0; i < points.length; i++) {\n        c.x[i] = points[i][0];\n        c.y[i] = points[i][1];\n        c.z[i] = points[i][2];\n    }\n    c.x.push(c.x[0]);\n    c.y.push(c.y[0]);\n    c.z.push(c.z[0]);\n    return c;\n}\nexport default interpolate;\n", "import { triggerEvent } from '@cornerstonejs/core';\nimport * as annotationStateManagement from '../../../stateManagement/annotation';\nimport interpolate from '../../contours/interpolation/interpolate';\nimport getInterpolationData from '../../contours/interpolation/getInterpolationData';\nimport EventTypes from '../../../enums/Events';\nexport default function deleteRelatedAnnotations(viewportData) {\n    const { annotation } = viewportData;\n    const interpolationAnnotations = getInterpolationData(viewportData, [\n        { key: 'interpolationUID', value: viewportData.interpolationUID },\n    ]);\n    const referencedSliceIndex = annotation.metadata.sliceIndex;\n    let minInterpolation = -1;\n    let maxInterpolation = viewportData.sliceData.numberOfSlices;\n    for (const [sliceIndex, annotations] of interpolationAnnotations.entries()) {\n        if (sliceIndex === referencedSliceIndex) {\n            continue;\n        }\n        const nonInterpolated = annotations.find((annotation) => !annotation.autoGenerated);\n        if (!nonInterpolated) {\n            continue;\n        }\n        if (sliceIndex < referencedSliceIndex) {\n            minInterpolation = Math.max(sliceIndex, minInterpolation);\n        }\n        else {\n            maxInterpolation = Math.min(sliceIndex, maxInterpolation);\n        }\n    }\n    const removedAnnotations = [];\n    for (const [sliceIndex, annotations] of interpolationAnnotations.entries()) {\n        if (sliceIndex <= minInterpolation ||\n            sliceIndex >= maxInterpolation ||\n            sliceIndex === referencedSliceIndex) {\n            continue;\n        }\n        annotations.forEach((annotationToDelete) => {\n            if (annotationToDelete.autoGenerated) {\n                annotationStateManagement.state.removeAnnotation(annotationToDelete.annotationUID);\n                removedAnnotations.push(annotationToDelete);\n            }\n        });\n    }\n    if (removedAnnotations.length) {\n        const eventDetails = {\n            annotations: removedAnnotations,\n            element: viewportData.viewport.element,\n            viewportId: viewportData.viewport.id,\n            renderingEngineId: viewportData.viewport.getRenderingEngine().id,\n        };\n        triggerEvent(viewportData.viewport.element, EventTypes.INTERPOLATED_ANNOTATIONS_REMOVED, eventDetails);\n    }\n    if (minInterpolation >= 0 &&\n        maxInterpolation < viewportData.sliceData.numberOfSlices) {\n        const nextAnnotation = interpolationAnnotations.get(maxInterpolation)[0];\n        const viewportNewData = {\n            viewport: viewportData.viewport,\n            sliceData: {\n                numberOfSlices: viewportData.sliceData.numberOfSlices,\n                imageIndex: nextAnnotation.metadata.sliceIndex,\n            },\n            annotation: nextAnnotation,\n            interpolationUID: nextAnnotation.interpolationUID,\n        };\n        interpolate(viewportNewData);\n    }\n}\n", "import getViewportsForAnnotation from './getViewportsForAnnotation';\nexport default function getViewportForAnnotation(annotation) {\n    const viewports = getViewportsForAnnotation(annotation);\n    if (!viewports?.length) {\n        return undefined;\n    }\n    const viewport = viewports.find((viewport) => viewport\n        .getImageIds()\n        .some((imageId) => imageId === annotation.metadata.referencedImageId));\n    return viewport ?? viewports[0];\n}\n", "import { utilities as csUtils } from '@cornerstonejs/core';\nimport { state as annotationState } from '../../../stateManagement/annotation';\nimport getInterpolationDataCollection from '../../contours/interpolation/getInterpolationDataCollection';\nimport interpolate from '../../contours/interpolation/interpolate';\nimport deleteRelatedAnnotations from './deleteRelatedAnnotations';\nimport ChangeTypes from '../../../enums/ChangeTypes';\nimport getViewportForAnnotation from '../../getViewportForAnnotation';\nimport { addContourSegmentationAnnotation } from '../../contourSegmentation/addContourSegmentationAnnotation';\nconst { uuidv4 } = csUtils;\nconst ChangeTypesForInterpolation = [\n    ChangeTypes.HandlesUpdated,\n    ChangeTypes.InterpolationUpdated,\n];\nexport default class InterpolationManager {\n    static { this.toolNames = []; }\n    static addTool(toolName) {\n        if (!this.toolNames.includes(toolName)) {\n            this.toolNames.push(toolName);\n        }\n    }\n    static removeTool(toolName) {\n        if (this.toolNames.includes(toolName)) {\n            this.toolNames = this.toolNames.filter((name) => name !== toolName);\n        }\n    }\n    static acceptAutoGenerated(annotationGroupSelector, selector = {}) {\n        const { toolNames, segmentationId, segmentIndex, sliceIndex } = selector;\n        for (const toolName of toolNames || InterpolationManager.toolNames) {\n            const annotations = annotationState.getAnnotations(toolName, annotationGroupSelector);\n            if (!annotations?.length) {\n                continue;\n            }\n            for (const annotation of annotations) {\n                const { interpolationUID, data, autoGenerated, metadata } = annotation;\n                if (interpolationUID) {\n                    annotation.interpolationCompleted = true;\n                }\n                if (!autoGenerated) {\n                    continue;\n                }\n                if (segmentIndex && segmentIndex !== data.segmentation.segmentIndex) {\n                    continue;\n                }\n                if (sliceIndex !== undefined &&\n                    metadata &&\n                    sliceIndex !== metadata.sliceIndex) {\n                    continue;\n                }\n                if (segmentationId &&\n                    segmentationId !== data.segmentation.segmentationId) {\n                    continue;\n                }\n                addContourSegmentationAnnotation(annotation);\n                annotation.autoGenerated = false;\n            }\n        }\n    }\n    static { this.handleAnnotationCompleted = (evt) => {\n        const annotation = evt.detail.annotation;\n        if (!annotation?.metadata) {\n            return;\n        }\n        const { toolName, originalToolName } = annotation.metadata;\n        if (!this.toolNames.includes(toolName) &&\n            !this.toolNames.includes(originalToolName)) {\n            return;\n        }\n        const viewport = getViewportForAnnotation(annotation);\n        if (!viewport) {\n            console.warn('Unable to find viewport for', annotation);\n            return;\n        }\n        const sliceData = getSliceData(viewport);\n        const viewportData = {\n            viewport,\n            sliceData,\n            annotation,\n            interpolationUID: annotation.interpolationUID,\n        };\n        const hasInterpolationUID = !!annotation.interpolationUID;\n        annotation.autoGenerated = false;\n        if (hasInterpolationUID) {\n            deleteRelatedAnnotations(viewportData);\n            interpolate(viewportData);\n            return;\n        }\n        const filterData = [\n            {\n                key: 'segmentIndex',\n                value: annotation.data.segmentation.segmentIndex,\n                parentKey: (annotation) => annotation.data.segmentation,\n            },\n            {\n                key: 'viewPlaneNormal',\n                value: annotation.metadata.viewPlaneNormal,\n                parentKey: (annotation) => annotation.metadata,\n            },\n            {\n                key: 'viewUp',\n                value: annotation.metadata.viewUp,\n                parentKey: (annotation) => annotation.metadata,\n            },\n        ];\n        let interpolationAnnotations = getInterpolationDataCollection(viewportData, filterData);\n        const { sliceIndex } = annotation.metadata;\n        const skipUIDs = new Set();\n        interpolationAnnotations.forEach((interpolationAnnotation) => {\n            if (interpolationAnnotation.interpolationCompleted ||\n                interpolationAnnotation.metadata.sliceIndex === sliceIndex) {\n                const { interpolationUID } = interpolationAnnotation;\n                skipUIDs.add(interpolationUID);\n            }\n        });\n        interpolationAnnotations = interpolationAnnotations.filter((interpolationAnnotation) => !skipUIDs.has(interpolationAnnotation.interpolationUID));\n        annotation.interpolationUID =\n            interpolationAnnotations[0]?.interpolationUID || uuidv4();\n        viewportData.interpolationUID = annotation.interpolationUID;\n        interpolate(viewportData);\n    }; }\n    static { this.handleAnnotationUpdate = (evt) => {\n        const annotation = evt.detail.annotation;\n        const { changeType = ChangeTypes.HandlesUpdated } = evt.detail;\n        if (!annotation?.metadata) {\n            return;\n        }\n        const { toolName, originalToolName } = annotation.metadata;\n        if ((!this.toolNames.includes(toolName) &&\n            !this.toolNames.includes(originalToolName)) ||\n            !ChangeTypesForInterpolation.includes(changeType)) {\n            return;\n        }\n        const viewport = getViewportForAnnotation(annotation);\n        if (!viewport) {\n            console.warn('Unable to find matching viewport for annotation interpolation', annotation);\n            return;\n        }\n        if (annotation.autoGenerated) {\n            addContourSegmentationAnnotation(annotation);\n            annotation.autoGenerated = false;\n        }\n        const sliceData = getSliceData(viewport);\n        const viewportData = {\n            viewport,\n            sliceData,\n            annotation,\n            interpolationUID: annotation.interpolationUID,\n            isInterpolationUpdate: changeType === ChangeTypes.InterpolationUpdated,\n        };\n        interpolate(viewportData);\n    }; }\n    static { this.handleAnnotationDelete = (evt) => {\n        const annotation = evt.detail.annotation;\n        if (!annotation?.metadata) {\n            return;\n        }\n        const { toolName } = annotation.metadata;\n        if (!this.toolNames.includes(toolName) || annotation.autoGenerated) {\n            return;\n        }\n        const viewport = getViewportForAnnotation(annotation);\n        if (!viewport) {\n            console.warn(\"No viewport, can't delete interpolated results\", annotation);\n            return;\n        }\n        const sliceData = getSliceData(viewport);\n        const viewportData = {\n            viewport,\n            sliceData,\n            annotation,\n            interpolationUID: annotation.interpolationUID,\n        };\n        annotation.autoGenerated = false;\n        deleteRelatedAnnotations(viewportData);\n    }; }\n}\nfunction getSliceData(viewport) {\n    const sliceData = {\n        numberOfSlices: viewport.getNumberOfSlices(),\n        imageIndex: viewport.getCurrentImageIdIndex(),\n    };\n    return sliceData;\n}\n", "import { getRenderingEngine } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport { getToolGroup } from '../store/ToolGroupManager';\nexport function triggerAnnotationRenderForToolGroupIds(toolGroupIds) {\n    toolGroupIds.forEach((toolGroupId) => {\n        const toolGroup = getToolGroup(toolGroupId);\n        if (!toolGroup) {\n            console.warn(`ToolGroup not available for ${toolGroupId}`);\n            return;\n        }\n        const viewportsInfo = toolGroup.getViewportsInfo();\n        viewportsInfo.forEach((viewportInfo) => {\n            const { renderingEngineId, viewportId } = viewportInfo;\n            const renderingEngine = getRenderingEngine(renderingEngineId);\n            if (!renderingEngine) {\n                console.warn(`RenderingEngine not available for ${renderingEngineId}`);\n                return;\n            }\n            const viewport = renderingEngine.getViewport(viewportId);\n            triggerAnnotationRender(viewport.element);\n        });\n    });\n}\nexport default triggerAnnotationRenderForToolGroupIds;\n", "import { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nfunction isSegmentIndexLocked(segmentationId, segmentIndex) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segments } = segmentation;\n    return segments[segmentIndex].locked;\n}\nfunction setSegmentIndexLocked(segmentationId, segmentIndex, locked = true) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segments } = segmentation;\n    segments[segmentIndex].locked = locked;\n    triggerSegmentationModified(segmentationId);\n}\nfunction getLockedSegmentIndices(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segments } = segmentation;\n    const lockedSegmentIndices = Object.keys(segments).filter((segmentIndex) => segments[segmentIndex].locked);\n    return lockedSegmentIndices.map((segmentIndex) => parseInt(segmentIndex));\n}\nexport { isSegmentIndexLocked, setSegmentIndexLocked, getLockedSegmentIndices };\n", "import { addColorLUT as _addColorLUT } from '../addColorLUT';\nimport { getColorLUT as _getColorLUT } from '../getColorLUT';\nimport { getSegmentationRepresentations } from '../getSegmentationRepresentation';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\nfunction addColorLUT(colorLUT, colorLUTIndex) {\n    if (!colorLUT) {\n        throw new Error('addColorLUT: colorLUT is required');\n    }\n    return _addColorLUT(colorLUT, colorLUTIndex);\n}\nfunction setColorLUT(viewportId, segmentationId, colorLUTsIndex) {\n    if (!_getColorLUT(colorLUTsIndex)) {\n        throw new Error(`setColorLUT: could not find colorLUT with index ${colorLUTsIndex}`);\n    }\n    const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });\n    if (!segmentationRepresentations) {\n        throw new Error(`viewport specific state for viewport ${viewportId} does not exist`);\n    }\n    segmentationRepresentations.forEach((segmentationRepresentation) => {\n        segmentationRepresentation.colorLUTIndex = colorLUTsIndex;\n    });\n    triggerSegmentationRepresentationModified(viewportId, segmentationId);\n}\nfunction getSegmentIndexColor(viewportId, segmentationId, segmentIndex) {\n    const representations = getSegmentationRepresentations(viewportId, {\n        segmentationId,\n    });\n    if (!representations || representations.length === 0) {\n        return null;\n    }\n    const representation = representations[0];\n    const { colorLUTIndex } = representation;\n    const colorLUT = _getColorLUT(colorLUTIndex);\n    let colorValue = colorLUT[segmentIndex];\n    if (!colorValue) {\n        if (typeof segmentIndex !== 'number') {\n            console.warn(`Can't create colour for LUT index ${segmentIndex}`);\n            return null;\n        }\n        colorValue = colorLUT[segmentIndex] = [0, 0, 0, 0];\n    }\n    return colorValue;\n}\nfunction setSegmentIndexColor(viewportId, segmentationId, segmentIndex, color) {\n    const colorReference = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n    for (let i = 0; i < color.length; i++) {\n        colorReference[i] = color[i];\n    }\n    triggerSegmentationRepresentationModified(viewportId, segmentationId);\n}\nexport { getSegmentIndexColor, addColorLUT, setColorLUT, setSegmentIndexColor };\n", "import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getNextColorLUTIndex() {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getNextColorLUTIndex();\n}\n", "const CORNERSTONE_COLOR_LUT = [\n    [0, 0, 0, 0],\n    [221, 84, 84, 255],\n    [77, 228, 121, 255],\n    [166, 70, 235, 255],\n    [189, 180, 116, 255],\n    [109, 182, 196, 255],\n    [204, 101, 157, 255],\n    [123, 211, 94, 255],\n    [93, 87, 218, 255],\n    [225, 128, 80, 255],\n    [73, 232, 172, 255],\n    [181, 119, 186, 255],\n    [176, 193, 112, 255],\n    [105, 153, 200, 255],\n    [208, 97, 120, 255],\n    [90, 215, 101, 255],\n    [135, 83, 222, 255],\n    [229, 178, 76, 255],\n    [122, 183, 181, 255],\n    [190, 115, 171, 255],\n    [149, 197, 108, 255],\n    [100, 118, 205, 255],\n    [212, 108, 93, 255],\n    [86, 219, 141, 255],\n    [183, 79, 226, 255],\n    [233, 233, 72, 255],\n    [118, 167, 187, 255],\n    [194, 111, 146, 255],\n    [116, 201, 104, 255],\n    [115, 96, 209, 255],\n    [216, 147, 89, 255],\n    [82, 223, 188, 255],\n    [230, 75, 224, 255],\n    [163, 184, 121, 255],\n    [114, 143, 191, 255],\n    [198, 107, 114, 255],\n    [99, 206, 122, 255],\n    [153, 92, 213, 255],\n    [220, 192, 85, 255],\n    [78, 215, 227, 255],\n    [234, 71, 173, 255],\n    [141, 188, 117, 255],\n    [110, 113, 195, 255],\n    [202, 128, 103, 255],\n    [95, 210, 157, 255],\n    [195, 88, 217, 255],\n    [206, 224, 81, 255],\n    [74, 166, 231, 255],\n    [185, 120, 139, 255],\n    [113, 192, 113, 255],\n    [133, 106, 199, 255],\n    [207, 162, 98, 255],\n    [91, 214, 198, 255],\n    [221, 84, 198, 255],\n    [159, 228, 77, 255],\n    [70, 111, 235, 255],\n    [189, 119, 116, 255],\n    [109, 196, 138, 255],\n    [165, 101, 204, 255],\n    [211, 201, 94, 255],\n    [87, 191, 218, 255],\n    [225, 80, 153, 255],\n    [106, 232, 73, 255],\n    [124, 119, 186, 255],\n    [193, 142, 112, 255],\n    [105, 200, 168, 255],\n    [203, 97, 208, 255],\n    [184, 215, 90, 255],\n    [83, 147, 222, 255],\n    [229, 76, 101, 255],\n    [122, 183, 130, 255],\n    [146, 115, 190, 255],\n    [197, 171, 108, 255],\n    [100, 205, 205, 255],\n    [212, 93, 177, 255],\n    [141, 219, 86, 255],\n    [79, 97, 226, 255],\n    [233, 99, 72, 255],\n    [118, 187, 150, 255],\n    [173, 111, 194, 255],\n    [197, 201, 104, 255],\n    [96, 171, 209, 255],\n    [216, 89, 137, 255],\n    [94, 223, 82, 255],\n    [107, 75, 230, 255],\n    [184, 153, 121, 255],\n    [114, 191, 175, 255],\n    [198, 107, 191, 255],\n    [166, 206, 99, 255],\n    [92, 132, 213, 255],\n    [220, 85, 91, 255],\n    [78, 227, 115, 255],\n    [159, 71, 234, 255],\n    [188, 176, 117, 255],\n    [110, 185, 195, 255],\n    [202, 103, 161, 255],\n    [129, 210, 95, 255],\n    [88, 88, 217, 255],\n    [224, 123, 81, 255],\n    [74, 231, 166, 255],\n    [177, 120, 185, 255],\n    [179, 192, 113, 255],\n    [106, 156, 199, 255],\n    [207, 98, 125, 255],\n    [91, 214, 96, 255],\n    [130, 84, 221, 255],\n    [228, 171, 77, 255],\n    [70, 235, 221, 255],\n    [189, 116, 174, 255],\n    [153, 196, 109, 255],\n    [101, 123, 204, 255],\n    [211, 104, 94, 255],\n    [87, 218, 136, 255],\n    [177, 80, 225, 255],\n    [232, 225, 73, 255],\n    [119, 169, 186, 255],\n    [193, 112, 149, 255],\n    [121, 200, 105, 255],\n    [111, 97, 208, 255],\n    [215, 142, 90, 255],\n    [83, 222, 181, 255],\n    [229, 76, 229, 255],\n    [165, 183, 122, 255],\n    [115, 146, 190, 255],\n    [197, 108, 119, 255],\n    [100, 205, 118, 255],\n    [148, 93, 212, 255],\n    [219, 186, 86, 255],\n    [79, 220, 226, 255],\n    [233, 72, 179, 255],\n    [144, 187, 118, 255],\n    [111, 118, 194, 255],\n    [201, 124, 104, 255],\n    [96, 209, 153, 255],\n    [189, 89, 216, 255],\n    [211, 223, 82, 255],\n    [75, 172, 230, 255],\n    [184, 121, 142, 255],\n    [117, 191, 114, 255],\n    [130, 107, 198, 255],\n    [206, 157, 99, 255],\n    [92, 213, 193, 255],\n    [220, 85, 203, 255],\n    [165, 227, 78, 255],\n    [71, 118, 234, 255],\n    [188, 117, 117, 255],\n    [110, 195, 135, 255],\n    [161, 103, 202, 255],\n    [210, 195, 95, 255],\n    [88, 195, 217, 255],\n    [224, 81, 158, 255],\n    [113, 231, 74, 255],\n    [123, 120, 185, 255],\n    [192, 139, 113, 255],\n    [106, 199, 164, 255],\n    [198, 98, 207, 255],\n    [188, 214, 91, 255],\n    [84, 153, 221, 255],\n    [228, 77, 108, 255],\n    [70, 235, 84, 255],\n    [143, 116, 189, 255],\n    [196, 167, 109, 255],\n    [101, 204, 199, 255],\n    [211, 94, 182, 255],\n    [147, 218, 87, 255],\n    [80, 104, 225, 255],\n    [232, 93, 73, 255],\n    [119, 186, 147, 255],\n    [170, 112, 193, 255],\n    [200, 200, 105, 255],\n    [97, 175, 208, 255],\n    [215, 90, 142, 255],\n    [100, 222, 83, 255],\n    [101, 76, 229, 255],\n    [183, 150, 122, 255],\n    [115, 190, 171, 255],\n    [197, 108, 194, 255],\n    [170, 205, 100, 255],\n    [93, 138, 212, 255],\n    [219, 86, 97, 255],\n    [79, 226, 110, 255],\n    [153, 72, 233, 255],\n    [187, 173, 118, 255],\n    [111, 187, 194, 255],\n    [201, 104, 165, 255],\n    [134, 209, 96, 255],\n    [89, 95, 216, 255],\n    [223, 117, 82, 255],\n    [75, 230, 159, 255],\n    [174, 121, 184, 255],\n    [182, 191, 114, 255],\n    [107, 160, 198, 255],\n    [206, 99, 130, 255],\n    [92, 213, 92, 255],\n    [124, 85, 220, 255],\n    [227, 165, 78, 255],\n    [71, 234, 214, 255],\n    [188, 117, 176, 255],\n    [156, 195, 110, 255],\n    [103, 128, 202, 255],\n    [210, 100, 95, 255],\n    [88, 217, 131, 255],\n    [170, 81, 224, 255],\n    [231, 218, 74, 255],\n    [120, 172, 185, 255],\n    [192, 113, 153, 255],\n    [125, 199, 106, 255],\n    [107, 98, 207, 255],\n    [214, 137, 91, 255],\n    [84, 221, 175, 255],\n    [222, 77, 228, 255],\n    [194, 235, 70, 255],\n    [116, 149, 189, 255],\n    [196, 109, 123, 255],\n    [101, 204, 114, 255],\n    [143, 94, 211, 255],\n    [218, 180, 87, 255],\n    [80, 225, 225, 255],\n    [232, 73, 186, 255],\n    [147, 186, 119, 255],\n    [112, 122, 193, 255],\n    [200, 121, 105, 255],\n    [97, 208, 148, 255],\n    [184, 90, 215, 255],\n    [216, 222, 83, 255],\n    [76, 178, 229, 255],\n    [183, 122, 145, 255],\n    [121, 190, 115, 255],\n    [126, 108, 197, 255],\n    [205, 153, 100, 255],\n    [93, 212, 187, 255],\n    [219, 86, 208, 255],\n    [171, 226, 79, 255],\n    [72, 126, 233, 255],\n    [187, 118, 121, 255],\n    [111, 194, 132, 255],\n    [157, 104, 201, 255],\n    [209, 190, 96, 255],\n    [89, 200, 216, 255],\n    [223, 82, 164, 255],\n    [120, 230, 75, 255],\n    [121, 121, 184, 255],\n    [191, 136, 114, 255],\n    [107, 198, 160, 255],\n    [192, 99, 206, 255],\n    [193, 213, 92, 255],\n    [85, 158, 220, 255],\n    [227, 78, 115, 255],\n    [71, 234, 78, 255],\n    [141, 117, 188, 255],\n    [195, 163, 110, 255],\n    [103, 202, 194, 255],\n    [210, 95, 186, 255],\n    [153, 217, 88, 255],\n    [81, 111, 224, 255],\n];\nexport default CORNERSTONE_COLOR_LUT;\n", "import { utilities } from '@cornerstonejs/core';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { getNextColorLUTIndex } from './getNextColorLUTIndex';\nimport CORNERSTONE_COLOR_LUT from '../../constants/COLOR_LUT';\nexport function addColorLUT(colorLUT, index) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const indexToUse = index ?? getNextColorLUTIndex();\n    let colorLUTToUse = [...colorLUT];\n    if (!utilities.isEqual(colorLUTToUse[0], [0, 0, 0, 0])) {\n        console.warn('addColorLUT: [0, 0, 0, 0] color is not provided for the background color (segmentIndex =0), automatically adding it');\n        colorLUTToUse = [[0, 0, 0, 0], ...colorLUTToUse];\n    }\n    colorLUTToUse = colorLUTToUse.map((color) => {\n        if (color.length === 3) {\n            return [color[0], color[1], color[2], 255];\n        }\n        return color;\n    });\n    if (colorLUTToUse.length < 255) {\n        const missingColorLUTs = CORNERSTONE_COLOR_LUT.slice(colorLUTToUse.length);\n        colorLUTToUse = [...colorLUTToUse, ...missingColorLUTs];\n    }\n    segmentationStateManager.addColorLUT(colorLUTToUse, indexToUse);\n    return indexToUse;\n}\n", "import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getSegmentationRepresentationVisibility(viewportId, specifier) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentationRepresentationVisibility(viewportId, specifier);\n}\n", "import { SegmentationRepresentations } from '../../enums';\nimport { getSegmentIndexColor } from '../../stateManagement/segmentation/config/segmentationColor';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/getActiveSegmentation';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { getSegmentationRepresentationVisibility } from '../../stateManagement/segmentation/getSegmentationRepresentationVisibility';\nimport { internalGetHiddenSegmentIndices } from '../../stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices';\nimport { segmentationStyle } from '../../stateManagement/segmentation/SegmentationStyle';\nexport function getSVGStyleForSegment({ segmentationId, segmentIndex, viewportId, autoGenerated = false, }) {\n    const segmentColor = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n    const segmentationVisible = getSegmentationRepresentationVisibility(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Contour,\n    });\n    const activeSegmentation = getActiveSegmentation(viewportId);\n    const isActive = activeSegmentation?.segmentationId === segmentationId;\n    const style = segmentationStyle.getStyle({\n        viewportId,\n        segmentationId,\n        type: SegmentationRepresentations.Contour,\n        segmentIndex,\n    });\n    const mergedConfig = style;\n    let lineWidth = 1;\n    let lineDash = undefined;\n    let lineOpacity = 1;\n    let fillOpacity = 0;\n    if (autoGenerated) {\n        lineWidth = mergedConfig.outlineWidthAutoGenerated ?? lineWidth;\n        lineDash = mergedConfig.outlineDashAutoGenerated ?? lineDash;\n        lineOpacity = mergedConfig.outlineOpacity ?? lineOpacity;\n        fillOpacity = mergedConfig.fillAlphaAutoGenerated ?? fillOpacity;\n    }\n    else if (isActive) {\n        lineWidth = mergedConfig.outlineWidth ?? lineWidth;\n        lineDash = mergedConfig.outlineDash ?? lineDash;\n        lineOpacity = mergedConfig.outlineOpacity ?? lineOpacity;\n        fillOpacity = mergedConfig.fillAlpha ?? fillOpacity;\n    }\n    else {\n        lineWidth = mergedConfig.outlineWidthInactive ?? lineWidth;\n        lineDash = mergedConfig.outlineDashInactive ?? lineDash;\n        lineOpacity = mergedConfig.outlineOpacityInactive ?? lineOpacity;\n        fillOpacity = mergedConfig.fillAlphaInactive ?? fillOpacity;\n    }\n    if (getActiveSegmentIndex(segmentationId) === segmentIndex) {\n        lineWidth += mergedConfig.activeSegmentOutlineWidthDelta;\n    }\n    lineWidth = mergedConfig.renderOutline ? lineWidth : 0;\n    fillOpacity = mergedConfig.renderFill ? fillOpacity : 0;\n    const color = `rgba(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]}, ${lineOpacity})`;\n    const fillColor = `rgb(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]})`;\n    const hiddenSegments = internalGetHiddenSegmentIndices(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Contour,\n    });\n    const isVisible = !hiddenSegments.has(segmentIndex);\n    return {\n        color,\n        fillColor,\n        lineWidth,\n        fillOpacity,\n        lineDash,\n        textbox: {\n            color,\n        },\n        visibility: segmentationVisible && isVisible,\n    };\n}\n", "import { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport ContourBaseTool from './ContourBaseTool';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport InterpolationManager from '../../utilities/segmentation/InterpolationManager/InterpolationManager';\nimport { addContourSegmentationAnnotation, removeContourSegmentationAnnotation, } from '../../utilities/contourSegmentation';\nimport { triggerAnnotationRenderForToolGroupIds } from '../../utilities/triggerAnnotationRenderForToolGroupIds';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nimport { getSegmentationRepresentations } from '../../stateManagement/segmentation/getSegmentationRepresentation';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/getActiveSegmentation';\nimport { getViewportIdsWithSegmentation } from '../../stateManagement/segmentation/getViewportIdsWithSegmentation';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { getLockedSegmentIndices } from '../../stateManagement/segmentation/segmentLocking';\nimport { getSVGStyleForSegment } from '../../utilities/segmentation/getSVGStyleForSegment';\nclass ContourSegmentationBaseTool extends ContourBaseTool {\n    static { this.PreviewSegmentIndex = 255; }\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n        if (this.configuration.interpolation?.enabled) {\n            InterpolationManager.addTool(this.getToolName());\n        }\n    }\n    onSetToolConfiguration() {\n        if (this.configuration.interpolation?.enabled) {\n            InterpolationManager.addTool(this.getToolName());\n        }\n        else {\n            InterpolationManager.removeTool(this.getToolName());\n        }\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n    createAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const contourAnnotation = super.createAnnotation(evt);\n        if (!this.isContourSegmentationTool()) {\n            return contourAnnotation;\n        }\n        const activeSeg = getActiveSegmentation(viewport.id);\n        if (!activeSeg) {\n            throw new Error('No active segmentation detected, create one before using scissors tool');\n        }\n        if (!activeSeg.representationData.Contour) {\n            throw new Error(`A contour segmentation must be active`);\n        }\n        const { segmentationId } = activeSeg;\n        const segmentIndex = getActiveSegmentIndex(segmentationId);\n        return utilities.deepMerge(contourAnnotation, {\n            data: {\n                segmentation: {\n                    segmentationId,\n                    segmentIndex,\n                },\n            },\n        });\n    }\n    addAnnotation(annotation, element) {\n        const annotationUID = super.addAnnotation(annotation, element);\n        if (this.isContourSegmentationTool()) {\n            const contourSegAnnotation = annotation;\n            addContourSegmentationAnnotation(contourSegAnnotation);\n        }\n        return annotationUID;\n    }\n    cancelAnnotation(annotation) {\n        if (this.isContourSegmentationTool()) {\n            removeContourSegmentationAnnotation(annotation);\n        }\n        super.cancelAnnotation(annotation);\n    }\n    getAnnotationStyle(context) {\n        const annotationStyle = super.getAnnotationStyle(context);\n        if (!this.isContourSegmentationTool()) {\n            return annotationStyle;\n        }\n        const contourSegmentationStyle = this._getContourSegmentationStyle(context);\n        return utilities.deepMerge(annotationStyle, contourSegmentationStyle);\n    }\n    renderAnnotationInstance(renderContext) {\n        const { annotation } = renderContext;\n        const { invalidated } = annotation;\n        const renderResult = super.renderAnnotationInstance(renderContext);\n        if (invalidated && this.isContourSegmentationTool()) {\n            const { segmentationId } = (annotation).data.segmentation;\n            triggerSegmentationDataModified(segmentationId);\n            const viewportIds = getViewportIdsWithSegmentation(segmentationId);\n            const toolGroupIds = viewportIds.map((viewportId) => {\n                const toolGroup = getToolGroupForViewport(viewportId);\n                return toolGroup.id;\n            });\n            triggerAnnotationRenderForToolGroupIds(toolGroupIds);\n        }\n        return renderResult;\n    }\n    _getContourSegmentationStyle(context) {\n        const annotation = context.annotation;\n        const { segmentationId, segmentIndex } = annotation.data.segmentation;\n        const { viewportId } = context.styleSpecifier;\n        const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });\n        if (!segmentationRepresentations?.length) {\n            return {};\n        }\n        let segmentationRepresentation;\n        if (segmentationRepresentations.length > 1) {\n            segmentationRepresentation = segmentationRepresentations.find((rep) => rep.segmentationId === segmentationId &&\n                rep.type === SegmentationRepresentations.Contour);\n        }\n        else {\n            segmentationRepresentation = segmentationRepresentations[0];\n        }\n        const { autoGenerated } = annotation;\n        const segmentsLocked = getLockedSegmentIndices(segmentationId);\n        const annotationLocked = segmentsLocked.includes(segmentIndex);\n        const { color, fillColor, lineWidth, fillOpacity, lineDash, visibility } = getSVGStyleForSegment({\n            segmentationId,\n            segmentIndex,\n            viewportId,\n            autoGenerated,\n        });\n        return {\n            color,\n            fillColor,\n            lineWidth,\n            fillOpacity,\n            lineDash,\n            textbox: {\n                color,\n            },\n            visibility,\n            locked: annotationLocked,\n        };\n    }\n}\nexport { ContourSegmentationBaseTool as default, ContourSegmentationBaseTool };\n", "import { metaData } from '@cornerstonejs/core';\nfunction getPixelValueUnitsImageId(imageId, options) {\n    const generalSeriesModule = metaData.get('generalSeriesModule', imageId);\n    return getPixelValueUnits(generalSeriesModule.modality, imageId, options);\n}\nfunction getPixelValueUnits(modality, imageId, options) {\n    if (modality === 'CT') {\n        return 'HU';\n    }\n    else if (modality === 'PT') {\n        return _handlePTModality(imageId, options);\n    }\n    else {\n        return '';\n    }\n}\nfunction _handlePTModality(imageId, options) {\n    if (!options.isPreScaled) {\n        return 'raw';\n    }\n    if (options.isSuvScaled) {\n        return 'SUV';\n    }\n    const generalSeriesModule = metaData.get('generalSeriesModule', imageId);\n    if (generalSeriesModule?.modality === 'PT') {\n        const petSeriesModule = metaData.get('petSeriesModule', imageId);\n        return petSeriesModule?.units || 'unitless';\n    }\n    return 'unknown';\n}\nexport { getPixelValueUnits, getPixelValueUnitsImageId };\n", "import { AnnotationTool } from '../base';\nimport { CONSTANTS, getEnabledElement, VolumeViewport, utilities as csUtils, metaData, } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport * as math from '../../utilities/math';\nimport { polyline } from '../../utilities/math';\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\nimport throttle from '../../utilities/throttle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport registerDrawLoop from './planarFreehandROITool/drawLoop';\nimport registerEditLoopCommon from './planarFreehandROITool/editLoopCommon';\nimport registerClosedContourEditLoop from './planarFreehandROITool/closedContourEditLoop';\nimport registerOpenContourEditLoop from './planarFreehandROITool/openContourEditLoop';\nimport registerOpenContourEndEditLoop from './planarFreehandROITool/openContourEndEditLoop';\nimport registerRenderMethods from './planarFreehandROITool/renderMethods';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport { drawLinkedTextBox } from '../../drawingSvg';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { getLineSegmentIntersectionsCoordinates } from '../../utilities/math/polyline';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport calculatePerimeter from '../../utilities/contours/calculatePerimeter';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\nimport { KeyboardBindings, ChangeTypes } from '../../enums';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nconst { pointCanProjectOnLine } = polyline;\nconst { EPSILON } = CONSTANTS;\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\nclass PlanarFreehandROITool extends ContourSegmentationBaseTool {\n    static { this.toolName = 'PlanarFreehandROI'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            storePointData: false,\n            shadow: true,\n            preventHandleOutsideImage: false,\n            contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n            alwaysRenderOpenContourHandles: {\n                enabled: false,\n                radius: 2,\n            },\n            allowOpenContours: true,\n            closeContourProximity: 10,\n            checkCanvasEditFallbackProximity: 6,\n            makeClockWise: true,\n            subPixelResolution: 4,\n            smoothing: {\n                smoothOnAdd: false,\n                smoothOnEdit: false,\n                knotsRatioPercentageOnAdd: 40,\n                knotsRatioPercentageOnEdit: 40,\n            },\n            interpolation: {\n                enabled: false,\n                onInterpolationComplete: null,\n            },\n            decimate: {\n                enabled: false,\n                epsilon: 0.1,\n            },\n            displayOnePointAsCrosshairs: false,\n            calculateStats: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isDrawing = false;\n        this.isEditingClosed = false;\n        this.isEditingOpen = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const annotation = this.createAnnotation(evt);\n            this.addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.activateDraw(evt, annotation, viewportIdsToRender);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, handle);\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            if (annotation.data.contour.closed) {\n                this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n            }\n            else {\n                this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);\n            }\n            evt.preventDefault();\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { polyline: points } = annotation.data.contour;\n            let previousPoint = viewport.worldToCanvas(points[0]);\n            for (let i = 1; i < points.length; i++) {\n                const p1 = previousPoint;\n                const p2 = viewport.worldToCanvas(points[i]);\n                const canProject = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);\n                if (canProject) {\n                    return true;\n                }\n                previousPoint = p2;\n            }\n            if (!annotation.data.contour.closed) {\n                return false;\n            }\n            const pStart = viewport.worldToCanvas(points[0]);\n            const pEnd = viewport.worldToCanvas(points[points.length - 1]);\n            return pointCanProjectOnLine(canvasCoords, pStart, pEnd, proximity);\n        };\n        this.cancel = (element) => {\n            const isDrawing = this.isDrawing;\n            const isEditingOpen = this.isEditingOpen;\n            const isEditingClosed = this.isEditingClosed;\n            if (isDrawing) {\n                this.cancelDrawing(element);\n            }\n            else if (isEditingOpen) {\n                this.cancelOpenContourEdit(element);\n            }\n            else if (isEditingClosed) {\n                this.cancelClosedContourEdit(element);\n            }\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { cachedStats } = data;\n            const { polyline: points, closed } = data.contour;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { imageData, metadata } = image;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const modalityUnitOptions = {\n                    isPreScaled: isViewportPreScaled(viewport, targetId),\n                    isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                };\n                const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);\n                const calibratedScale = getCalibratedLengthUnitsAndScale(image, () => {\n                    const polyline = data.contour.polyline;\n                    const numPoints = polyline.length;\n                    const projectedPolyline = new Array(numPoints);\n                    for (let i = 0; i < numPoints; i++) {\n                        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n                    }\n                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = math.polyline.getAABB(projectedPolyline);\n                    const topLeftBBWorld = viewport.canvasToWorld([canvasMinX, canvasMinY]);\n                    const topLeftBBIndex = csUtils.transformWorldToIndex(imageData, topLeftBBWorld);\n                    const bottomRightBBWorld = viewport.canvasToWorld([\n                        canvasMaxX,\n                        canvasMaxY,\n                    ]);\n                    const bottomRightBBIndex = csUtils.transformWorldToIndex(imageData, bottomRightBBWorld);\n                    return [topLeftBBIndex, bottomRightBBIndex];\n                });\n                const canvasPoint = canvasCoordinates[0];\n                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n                const deltaXPoint = viewport.canvasToWorld([\n                    canvasPoint[0] + 1,\n                    canvasPoint[1],\n                ]);\n                const deltaYPoint = viewport.canvasToWorld([\n                    canvasPoint[0],\n                    canvasPoint[1] + 1,\n                ]);\n                const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n                const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n                if (closed) {\n                    this.updateClosedCachedStats({\n                        targetId,\n                        viewport,\n                        canvasCoordinates,\n                        points,\n                        imageData,\n                        metadata,\n                        cachedStats,\n                        modalityUnit,\n                        calibratedScale,\n                        deltaInX,\n                        deltaInY,\n                    });\n                }\n                else {\n                    this.updateOpenCachedStats({\n                        metadata,\n                        canvasCoordinates,\n                        targetId,\n                        cachedStats,\n                        modalityUnit,\n                        calibratedScale,\n                        deltaInX,\n                        deltaInY,\n                    });\n                }\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                triggerAnnotationModified(annotation, enabledElement.viewport.element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._renderStats = (annotation, viewport, enabledElement, svgDrawingHelper) => {\n            const { data } = annotation;\n            const targetId = this.getTargetId(viewport);\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n                annotationUID: annotation.annotationUID,\n            };\n            const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n            if (!options.visibility) {\n                return;\n            }\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (!textLines || textLines.length === 0) {\n                return;\n            }\n            const canvasCoordinates = data.contour.polyline.map((p) => viewport.worldToCanvas(p));\n            if (!data.handles.textBox.hasMoved) {\n                const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                data.handles.textBox.worldPosition =\n                    viewport.canvasToWorld(canvasTextBoxCoords);\n            }\n            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n            const textBoxUID = '1';\n            const boundingBox = drawLinkedTextBox(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n            const { x: left, y: top, width, height } = boundingBox;\n            data.handles.textBox.worldBoundingBox = {\n                topLeft: viewport.canvasToWorld([left, top]),\n                topRight: viewport.canvasToWorld([left + width, top]),\n                bottomLeft: viewport.canvasToWorld([left, top + height]),\n                bottomRight: viewport.canvasToWorld([left + width, top + height]),\n            };\n        };\n        registerDrawLoop(this);\n        registerEditLoopCommon(this);\n        registerClosedContourEditLoop(this);\n        registerOpenContourEditLoop(this);\n        registerOpenContourEndEditLoop(this);\n        registerRenderMethods(this);\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    filterInteractableAnnotationsForElement(element, annotations) {\n        if (!annotations || !annotations.length) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        let annotationsToDisplay;\n        if (viewport instanceof VolumeViewport) {\n            const camera = viewport.getCamera();\n            const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n            annotationsToDisplay = this.filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection);\n        }\n        else {\n            annotationsToDisplay = filterAnnotationsForDisplay(viewport, annotations);\n        }\n        return annotationsToDisplay;\n    }\n    filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {\n        const { viewPlaneNormal } = camera;\n        const annotationsWithParallelNormals = annotations.filter((td) => {\n            let annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n            if (!td.metadata.referencedImageId &&\n                !annotationViewPlaneNormal &&\n                td.metadata.FrameOfReferenceUID) {\n                for (const point of td.data.contour.polyline) {\n                    const vector = vec3.sub(vec3.create(), point, camera.focalPoint);\n                    const dotProduct = vec3.dot(vector, camera.viewPlaneNormal);\n                    if (!csUtils.isEqual(dotProduct, 0)) {\n                        return false;\n                    }\n                }\n                td.metadata.viewPlaneNormal = camera.viewPlaneNormal;\n                td.metadata.cameraFocalPoint = camera.focalPoint;\n                return true;\n            }\n            if (!annotationViewPlaneNormal) {\n                const { referencedImageId } = td.metadata;\n                const { imageOrientationPatient } = metaData.get('imagePlaneModule', referencedImageId);\n                const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n                const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n                annotationViewPlaneNormal = vec3.create();\n                vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);\n                td.metadata.viewPlaneNormal = annotationViewPlaneNormal;\n            }\n            const isParallel = Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n                PARALLEL_THRESHOLD;\n            return annotationViewPlaneNormal && isParallel;\n        });\n        if (!annotationsWithParallelNormals.length) {\n            return [];\n        }\n        const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n        const { focalPoint } = camera;\n        const annotationsWithinSlice = [];\n        for (const annotation of annotationsWithParallelNormals) {\n            const data = annotation.data;\n            const point = data.contour.polyline[0];\n            if (!annotation.isVisible) {\n                continue;\n            }\n            const dir = vec3.create();\n            vec3.sub(dir, focalPoint, point);\n            const dot = vec3.dot(dir, viewPlaneNormal);\n            if (Math.abs(dot) < halfSpacingInNormalDirection) {\n                annotationsWithinSlice.push(annotation);\n            }\n        }\n        return annotationsWithinSlice;\n    }\n    isContourSegmentationTool() {\n        return false;\n    }\n    createAnnotation(evt) {\n        const worldPos = evt.detail.currentPoints.world;\n        const contourAnnotation = super.createAnnotation(evt);\n        const onInterpolationComplete = (annotation) => {\n            annotation.data.handles.points.length = 0;\n        };\n        const annotation = csUtils.deepMerge(contourAnnotation, {\n            data: {\n                contour: {\n                    polyline: [[...worldPos]],\n                },\n                label: '',\n                cachedStats: {},\n            },\n            onInterpolationComplete,\n        });\n        return annotation;\n    }\n    getAnnotationStyle(context) {\n        return super.getAnnotationStyle(context);\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, targetId, svgDrawingHelper } = renderContext;\n        const annotation = renderContext.annotation;\n        let renderStatus = false;\n        const { viewport, renderingEngine } = enabledElement;\n        const isDrawing = this.isDrawing;\n        const isEditingOpen = this.isEditingOpen;\n        const isEditingClosed = this.isEditingClosed;\n        if (!(isDrawing || isEditingOpen || isEditingClosed)) {\n            if (this.configuration.displayOnePointAsCrosshairs &&\n                annotation.data.contour.polyline.length === 1) {\n                this.renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation);\n            }\n            else {\n                this.renderContour(enabledElement, svgDrawingHelper, annotation);\n            }\n        }\n        else {\n            const activeAnnotationUID = this.commonData.annotation.annotationUID;\n            if (annotation.annotationUID === activeAnnotationUID) {\n                if (isDrawing) {\n                    this.renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation);\n                }\n                else if (isEditingClosed) {\n                    this.renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation);\n                }\n                else if (isEditingOpen) {\n                    this.renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation);\n                }\n                else {\n                    throw new Error(`Unknown ${this.getToolName()} annotation rendering state`);\n                }\n            }\n            else {\n                if (this.configuration.displayOnePointAsCrosshairs &&\n                    annotation.data.contour.polyline.length === 1) {\n                    this.renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation);\n                }\n                else {\n                    this.renderContour(enabledElement, svgDrawingHelper, annotation);\n                }\n            }\n            renderStatus = true;\n        }\n        if (!this.configuration.calculateStats) {\n            return;\n        }\n        this._calculateStatsIfActive(annotation, targetId, viewport, renderingEngine, enabledElement);\n        this._renderStats(annotation, viewport, enabledElement, svgDrawingHelper);\n        return renderStatus;\n    }\n    _calculateStatsIfActive(annotation, targetId, viewport, renderingEngine, enabledElement) {\n        const activeAnnotationUID = this.commonData?.annotation.annotationUID;\n        if (annotation.annotationUID === activeAnnotationUID &&\n            !this.commonData?.movingTextBox) {\n            return;\n        }\n        if (!this.commonData?.movingTextBox) {\n            const { data } = annotation;\n            if (!data.cachedStats[targetId]?.unit) {\n                data.cachedStats[targetId] = {\n                    Modality: null,\n                    area: null,\n                    max: null,\n                    mean: null,\n                    stdDev: null,\n                    areaUnit: null,\n                    unit: null,\n                };\n                this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n            }\n            else if (annotation.invalidated) {\n                this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n            }\n        }\n    }\n    updateClosedCachedStats({ viewport, points, imageData, metadata, cachedStats, targetId, modalityUnit, canvasCoordinates, calibratedScale, deltaInX, deltaInY, }) {\n        const { scale, areaUnit, unit } = calibratedScale;\n        const { voxelManager } = viewport.getImageData();\n        const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[0]);\n        worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n        worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n        worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n        let iMin = worldPosIndex[0];\n        let iMax = worldPosIndex[0];\n        let jMin = worldPosIndex[1];\n        let jMax = worldPosIndex[1];\n        let kMin = worldPosIndex[2];\n        let kMax = worldPosIndex[2];\n        for (let j = 1; j < points.length; j++) {\n            const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[j]);\n            worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n            worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n            worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n            iMin = Math.min(iMin, worldPosIndex[0]);\n            iMax = Math.max(iMax, worldPosIndex[0]);\n            jMin = Math.min(jMin, worldPosIndex[1]);\n            jMax = Math.max(jMax, worldPosIndex[1]);\n            kMin = Math.min(kMin, worldPosIndex[2]);\n            kMax = Math.max(kMax, worldPosIndex[2]);\n        }\n        const worldPosIndex2 = csUtils.transformWorldToIndex(imageData, points[1]);\n        worldPosIndex2[0] = Math.floor(worldPosIndex2[0]);\n        worldPosIndex2[1] = Math.floor(worldPosIndex2[1]);\n        worldPosIndex2[2] = Math.floor(worldPosIndex2[2]);\n        let area = polyline.getArea(canvasCoordinates) / scale / scale;\n        area *= deltaInX * deltaInY;\n        let perimeter = calculatePerimeter(canvasCoordinates, closed) / scale;\n        perimeter *= Math.sqrt(Math.pow(deltaInX, 2) + Math.pow(deltaInY, 2));\n        const iDelta = 0.01 * (iMax - iMin);\n        const jDelta = 0.01 * (jMax - jMin);\n        const kDelta = 0.01 * (kMax - kMin);\n        iMin = Math.floor(iMin - iDelta);\n        iMax = Math.ceil(iMax + iDelta);\n        jMin = Math.floor(jMin - jDelta);\n        jMax = Math.ceil(jMax + jDelta);\n        kMin = Math.floor(kMin - kDelta);\n        kMax = Math.ceil(kMax + kDelta);\n        const boundsIJK = [\n            [iMin, iMax],\n            [jMin, jMax],\n            [kMin, kMax],\n        ];\n        const worldPosEnd = imageData.indexToWorld([iMax, jMax, kMax]);\n        const canvasPosEnd = viewport.worldToCanvas(worldPosEnd);\n        let curRow = 0;\n        let intersections = [];\n        let intersectionCounter = 0;\n        let pointsInShape;\n        if (voxelManager) {\n            pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                imageData,\n                isInObject: (pointLPS, _pointIJK) => {\n                    let result = true;\n                    const point = viewport.worldToCanvas(pointLPS);\n                    if (point[1] != curRow) {\n                        intersectionCounter = 0;\n                        curRow = point[1];\n                        intersections = getLineSegmentIntersectionsCoordinates(canvasCoordinates, point, [canvasPosEnd[0], point[1]]);\n                        intersections.sort((function (index) {\n                            return function (a, b) {\n                                return a[index] === b[index]\n                                    ? 0\n                                    : a[index] < b[index]\n                                        ? -1\n                                        : 1;\n                            };\n                        })(0));\n                    }\n                    if (intersections.length && point[0] > intersections[0][0]) {\n                        intersections.shift();\n                        intersectionCounter++;\n                    }\n                    if (intersectionCounter % 2 === 0) {\n                        result = false;\n                    }\n                    return result;\n                },\n                boundsIJK,\n                returnPoints: this.configuration.storePointData,\n            });\n        }\n        const stats = this.configuration.statsCalculator.getStatistics();\n        cachedStats[targetId] = {\n            Modality: metadata.Modality,\n            area,\n            perimeter,\n            mean: stats.mean?.value,\n            max: stats.max?.value,\n            min: stats.min?.value,\n            stdDev: stats.stdDev?.value,\n            statsArray: stats.array,\n            pointsInShape: pointsInShape,\n            areaUnit,\n            modalityUnit,\n            unit,\n        };\n    }\n    updateOpenCachedStats({ targetId, metadata, canvasCoordinates, cachedStats, modalityUnit, calibratedScale, deltaInX, deltaInY, }) {\n        const { scale, unit } = calibratedScale;\n        let length = calculatePerimeter(canvasCoordinates, closed) / scale;\n        length *= Math.sqrt(Math.pow(deltaInX, 2) + Math.pow(deltaInY, 2));\n        cachedStats[targetId] = {\n            Modality: metadata.Modality,\n            length,\n            modalityUnit,\n            unit,\n        };\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, mean, stdDev, length, perimeter, max, min, isEmptyArea, unit, areaUnit, modalityUnit, } = cachedVolumeStats || {};\n    const textLines = [];\n    if (csUtils.isNumber(area)) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    if (csUtils.isNumber(mean)) {\n        textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(max)) {\n        textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(min)) {\n        textLines.push(`Min: ${csUtils.roundNumber(min)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(stdDev)) {\n        textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(perimeter)) {\n        textLines.push(`Perimeter: ${csUtils.roundNumber(perimeter)} ${unit}`);\n    }\n    if (csUtils.isNumber(length)) {\n        textLines.push(`${csUtils.roundNumber(length)} ${unit}`);\n    }\n    return textLines;\n}\nexport default PlanarFreehandROITool;\n", "import { utilities } from '@cornerstonejs/core';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport PlanarFreehandROITool from './PlanarFreehandROITool';\nclass PlanarFreehandContourSegmentationTool extends PlanarFreehandROITool {\n    static { this.toolName = 'PlanarFreehandContourSegmentationTool'; }\n    constructor(toolProps) {\n        const initialProps = utilities.deepMerge({\n            configuration: {\n                calculateStats: false,\n                allowOpenContours: false,\n            },\n        }, toolProps);\n        super(initialProps);\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n    renderAnnotationInstance(renderContext) {\n        const annotation = renderContext.annotation;\n        const { invalidated } = annotation;\n        const renderResult = super.renderAnnotationInstance(renderContext);\n        if (invalidated) {\n            const { segmentationId } = annotation.data.segmentation;\n            triggerSegmentationDataModified(segmentationId);\n        }\n        return renderResult;\n    }\n}\nexport default PlanarFreehandContourSegmentationTool;\n", "import { triggerEvent, eventTarget, Enums, getRenderingEngines, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { SegmentationRepresentations, Events as csToolsEvents, } from '../../enums';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport { getSegmentationRepresentations } from './getSegmentationRepresentation';\nimport surfaceDisplay from '../../tools/displayTools/Surface/surfaceDisplay';\nimport contourDisplay from '../../tools/displayTools/Contour/contourDisplay';\nimport labelmapDisplay from '../../tools/displayTools/Labelmap/labelmapDisplay';\nimport { addTool } from '../../store/addTool';\nimport { state } from '../../store/state';\nimport PlanarFreehandContourSegmentationTool from '../../tools/annotation/PlanarFreehandContourSegmentationTool';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nconst renderers = {\n    [Representations.Labelmap]: labelmapDisplay,\n    [Representations.Contour]: contourDisplay,\n    [Representations.Surface]: surfaceDisplay,\n};\nconst planarContourToolName = PlanarFreehandContourSegmentationTool.toolName;\nclass SegmentationRenderingEngine {\n    constructor() {\n        this._needsRender = new Set();\n        this._pendingRenderQueue = [];\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        this._getAllViewports = () => {\n            const renderingEngine = getRenderingEngines();\n            return renderingEngine.flatMap((renderingEngine) => renderingEngine.getViewports());\n        };\n        this._renderFlaggedSegmentations = () => {\n            this._throwIfDestroyed();\n            const viewportIds = Array.from(this._needsRender);\n            viewportIds.forEach((viewportId) => {\n                this._triggerRender(viewportId);\n            });\n            this._needsRender.clear();\n            this._animationFrameSet = false;\n            this._animationFrameHandle = null;\n            if (this._pendingRenderQueue.length > 0) {\n                const nextViewportIds = this._pendingRenderQueue.shift();\n                if (nextViewportIds && nextViewportIds.length > 0) {\n                    this._setViewportsToBeRenderedNextFrame(nextViewportIds);\n                }\n            }\n        };\n    }\n    renderSegmentationsForViewport(viewportId) {\n        const viewportIds = viewportId\n            ? [viewportId]\n            : this._getViewportIdsForSegmentation();\n        this._setViewportsToBeRenderedNextFrame(viewportIds);\n    }\n    renderSegmentation(segmentationId) {\n        const viewportIds = this._getViewportIdsForSegmentation(segmentationId);\n        this._setViewportsToBeRenderedNextFrame(viewportIds);\n    }\n    _getViewportIdsForSegmentation(segmentationId) {\n        const viewports = this._getAllViewports();\n        const viewportIds = [];\n        for (const viewport of viewports) {\n            const viewportId = viewport.id;\n            if (segmentationId) {\n                const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });\n                if (segmentationRepresentations?.length > 0) {\n                    viewportIds.push(viewportId);\n                }\n            }\n            else {\n                const segmentationRepresentations = getSegmentationRepresentations(viewportId);\n                if (segmentationRepresentations?.length > 0) {\n                    viewportIds.push(viewportId);\n                }\n            }\n        }\n        return viewportIds;\n    }\n    _throwIfDestroyed() {\n        if (this.hasBeenDestroyed) {\n            throw new Error('this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.');\n        }\n    }\n    _setViewportsToBeRenderedNextFrame(viewportIds) {\n        if (this._animationFrameSet) {\n            this._pendingRenderQueue.push(viewportIds);\n            return;\n        }\n        viewportIds.forEach((viewportId) => {\n            this._needsRender.add(viewportId);\n        });\n        this._render();\n    }\n    _render() {\n        if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n            this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedSegmentations);\n            this._animationFrameSet = true;\n        }\n    }\n    _triggerRender(viewportId) {\n        const segmentationRepresentations = getSegmentationRepresentations(viewportId);\n        if (!segmentationRepresentations?.length) {\n            return;\n        }\n        const { viewport } = getEnabledElementByViewportId(viewportId) || {};\n        if (!viewport) {\n            return;\n        }\n        const viewportRenderList = [];\n        const segmentationRenderList = segmentationRepresentations.map((representation) => {\n            if (representation.type === SegmentationRepresentations.Contour) {\n                this._addPlanarFreeHandToolIfAbsent(viewport);\n            }\n            const display = renderers[representation.type];\n            try {\n                const viewportId = display.render(viewport, representation);\n                viewportRenderList.push(viewportId);\n            }\n            catch (error) {\n                console.error(error);\n            }\n            return Promise.resolve({\n                segmentationId: representation.segmentationId,\n                type: representation.type,\n            });\n        });\n        Promise.allSettled(segmentationRenderList).then((results) => {\n            const segmentationDetails = results\n                .filter((r) => r.status === 'fulfilled')\n                .map((r) => r.value);\n            function onSegmentationRender(evt) {\n                const { element, viewportId } = evt.detail;\n                element.removeEventListener(Enums.Events.IMAGE_RENDERED, onSegmentationRender);\n                segmentationDetails.forEach((detail) => {\n                    const eventDetail = {\n                        viewportId,\n                        segmentationId: detail.segmentationId,\n                        type: detail.type,\n                    };\n                    triggerEvent(eventTarget, csToolsEvents.SEGMENTATION_RENDERED, {\n                        ...eventDetail,\n                    });\n                });\n            }\n            const element = viewport.element;\n            element.addEventListener(Enums.Events.IMAGE_RENDERED, onSegmentationRender);\n            viewport.render();\n        });\n    }\n    _addPlanarFreeHandToolIfAbsent(viewport) {\n        if (!(planarContourToolName in state.tools)) {\n            addTool(PlanarFreehandContourSegmentationTool);\n        }\n        const toolGroup = getToolGroupForViewport(viewport.id);\n        if (!toolGroup.hasTool(planarContourToolName)) {\n            toolGroup.addTool(planarContourToolName);\n            toolGroup.setToolPassive(planarContourToolName);\n        }\n    }\n}\nfunction triggerSegmentationRender(viewportId) {\n    segmentationRenderingEngine.renderSegmentationsForViewport(viewportId);\n}\nfunction triggerSegmentationRenderBySegmentationId(segmentationId) {\n    segmentationRenderingEngine.renderSegmentation(segmentationId);\n}\nconst segmentationRenderingEngine = new SegmentationRenderingEngine();\nexport { triggerSegmentationRender, triggerSegmentationRenderBySegmentationId, segmentationRenderingEngine, };\n", "import { cache } from '@cornerstonejs/core';\nexport function performVolumeLabelmapUpdate({ modifiedSlicesToUse, representationData, type, }) {\n    const segmentationVolume = cache.getVolume(representationData[type].volumeId);\n    if (!segmentationVolume) {\n        console.warn('segmentation not found in cache');\n        return;\n    }\n    const { imageData, vtkOpenGLTexture } = segmentationVolume;\n    let slicesToUpdate;\n    if (modifiedSlicesToUse?.length > 0) {\n        slicesToUpdate = modifiedSlicesToUse;\n    }\n    else {\n        const numSlices = imageData.getDimensions()[2];\n        slicesToUpdate = [...Array(numSlices).keys()];\n    }\n    slicesToUpdate.forEach((i) => {\n        vtkOpenGLTexture.setUpdatedFrame(i);\n    });\n    imageData.modified();\n}\n", "import { cache, utilities as csUtils, VolumeViewport, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../../enums';\nimport { getLabelmapActorEntries } from '../../../stateManagement/segmentation/helpers/getSegmentationActor';\nimport { getSegmentationRepresentations } from '../../../stateManagement/segmentation/getSegmentationRepresentation';\nimport { getCurrentLabelmapImageIdsForViewport } from '../../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nexport function performStackLabelmapUpdate({ viewportIds, segmentationId, }) {\n    viewportIds.forEach((viewportId) => {\n        let representations = getSegmentationRepresentations(viewportId, {\n            segmentationId,\n        });\n        representations = representations.filter((representation) => representation.type === SegmentationRepresentations.Labelmap);\n        representations.forEach((representation) => {\n            if (representation.segmentationId !== segmentationId) {\n                return;\n            }\n            const enabledElement = getEnabledElementByViewportId(viewportId);\n            if (!enabledElement) {\n                return;\n            }\n            const { viewport } = enabledElement;\n            if (viewport instanceof VolumeViewport) {\n                return;\n            }\n            const actorEntries = getLabelmapActorEntries(viewportId, segmentationId);\n            if (!actorEntries?.length) {\n                return;\n            }\n            actorEntries.forEach((actorEntry, i) => {\n                const segImageData = actorEntry.actor.getMapper().getInputData();\n                const currentSegmentationImageIds = getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId);\n                const segmentationImage = cache.getImage(currentSegmentationImageIds[i]);\n                segImageData.modified();\n                csUtils.updateVTKImageDataWithCornerstoneImage(segImageData, segmentationImage);\n            });\n        });\n    });\n}\n", "import { VolumeViewport, getEnabledElementByViewportId, StackViewport, } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../../enums';\nimport { performVolumeLabelmapUpdate } from './performVolumeLabelmapUpdate';\nimport { performStackLabelmapUpdate } from './performStackLabelmapUpdate';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport { getViewportIdsWithSegmentation } from '../../../stateManagement/segmentation/getViewportIdsWithSegmentation';\nconst onLabelmapSegmentationDataModified = function (evt) {\n    const { segmentationId, modifiedSlicesToUse } = evt.detail;\n    const { representationData } = getSegmentation(segmentationId);\n    const viewportIds = getViewportIdsWithSegmentation(segmentationId);\n    const hasVolumeViewport = viewportIds.some((viewportId) => {\n        const { viewport } = getEnabledElementByViewportId(viewportId);\n        return viewport instanceof VolumeViewport;\n    });\n    const hasStackViewport = viewportIds.some((viewportId) => {\n        const { viewport } = getEnabledElementByViewportId(viewportId);\n        return viewport instanceof StackViewport;\n    });\n    const hasBothStackAndVolume = hasVolumeViewport && hasStackViewport;\n    viewportIds.forEach((viewportId) => {\n        const { viewport } = getEnabledElementByViewportId(viewportId);\n        if (viewport instanceof VolumeViewport) {\n            performVolumeLabelmapUpdate({\n                modifiedSlicesToUse: hasBothStackAndVolume ? [] : modifiedSlicesToUse,\n                representationData,\n                type: SegmentationRepresentations.Labelmap,\n            });\n        }\n        if (viewport instanceof StackViewport) {\n            performStackLabelmapUpdate({\n                viewportIds,\n                segmentationId,\n            });\n        }\n    });\n};\nexport default onLabelmapSegmentationDataModified;\n", "import { triggerSegmentationRenderBySegmentationId } from '../../stateManagement/segmentation/SegmentationRenderingEngine';\nimport onLabelmapSegmentationDataModified from './labelmap/onLabelmapSegmentationDataModified';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nconst onSegmentationDataModified = function (evt) {\n    const { segmentationId } = evt.detail;\n    const { representationData } = getSegmentation(segmentationId);\n    if (representationData.Labelmap) {\n        onLabelmapSegmentationDataModified(evt);\n    }\n    triggerSegmentationRenderBySegmentationId(segmentationId);\n};\nexport default onSegmentationDataModified;\n", "import { triggerSegmentationRenderBySegmentationId } from '../../stateManagement/segmentation/SegmentationRenderingEngine';\nconst segmentationModifiedListener = function (evt) {\n    const { segmentationId } = evt.detail;\n    triggerSegmentationRenderBySegmentationId(segmentationId);\n};\nexport default segmentationModifiedListener;\n", "import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function updateLabelmapSegmentationImageReferences(viewportId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.updateLabelmapSegmentationImageReferences(viewportId, segmentationId);\n}\n", "import vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { BaseVolumeViewport, getEnabledElement, Enums, getEnabledElementByIds, cache, utilities, } from '@cornerstonejs/core';\nimport { triggerSegmentationRender } from '../../stateManagement/segmentation/SegmentationRenderingEngine';\nimport { updateLabelmapSegmentationImageReferences } from '../../stateManagement/segmentation/updateLabelmapSegmentationImageReferences';\nimport { getCurrentLabelmapImageIdsForViewport } from '../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nimport { SegmentationRepresentations } from '../../enums';\nimport { getLabelmapActorEntries } from '../../stateManagement/segmentation/helpers/getSegmentationActor';\nimport { getSegmentationRepresentations } from '../../stateManagement/segmentation/getSegmentationRepresentation';\nconst enable = function (element) {\n    if (!element) {\n        return;\n    }\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    if (viewport instanceof BaseVolumeViewport) {\n        return;\n    }\n    element.addEventListener(Enums.Events.PRE_STACK_NEW_IMAGE, _imageChangeEventListener);\n    element.addEventListener(Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.PRE_STACK_NEW_IMAGE, _imageChangeEventListener);\n    element.removeEventListener(Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);\n};\nconst perViewportManualTriggers = new Map();\nfunction _imageChangeEventListener(evt) {\n    const eventData = evt.detail;\n    const { viewportId, renderingEngineId } = eventData;\n    const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n    const representations = getSegmentationRepresentations(viewportId);\n    if (!representations?.length) {\n        return;\n    }\n    const labelmapRepresentations = representations.filter((representation) => representation.type === SegmentationRepresentations.Labelmap);\n    const actors = viewport.getActors();\n    labelmapRepresentations.forEach((representation) => {\n        const { segmentationId } = representation;\n        updateLabelmapSegmentationImageReferences(viewportId, segmentationId);\n    });\n    const labelmapActors = labelmapRepresentations\n        .flatMap((representation) => {\n        return getLabelmapActorEntries(viewportId, representation.segmentationId);\n    })\n        .filter((actor) => actor !== undefined);\n    if (!labelmapActors.length) {\n        return;\n    }\n    labelmapActors.forEach((actor) => {\n        const validActor = labelmapRepresentations.find((representation) => {\n            const derivedImageIds = getCurrentLabelmapImageIdsForViewport(viewportId, representation.segmentationId);\n            return derivedImageIds?.includes(actor.referencedId);\n        });\n        if (!validActor) {\n            viewport.removeActors([actor.uid]);\n        }\n    });\n    labelmapRepresentations.forEach((representation) => {\n        const { segmentationId } = representation;\n        const currentImageId = viewport.getCurrentImageId();\n        const derivedImageIds = getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId);\n        if (!derivedImageIds) {\n            return;\n        }\n        let shouldTriggerSegmentationRender = false;\n        const updateSegmentationActor = (derivedImageId) => {\n            const derivedImage = cache.getImage(derivedImageId);\n            if (!derivedImage) {\n                console.warn('No derived image found in the cache for segmentation representation', representation);\n                return;\n            }\n            const segmentationActorInput = actors.find((actor) => actor.referencedId === derivedImageId);\n            if (!segmentationActorInput) {\n                const { dimensions, spacing, direction } = viewport.getImageDataMetadata(derivedImage);\n                const currentImage = cache.getImage(currentImageId) ||\n                    {\n                        imageId: currentImageId,\n                    };\n                const { origin: currentOrigin } = viewport.getImageDataMetadata(currentImage);\n                const originToUse = currentOrigin;\n                const constructor = derivedImage.voxelManager.getConstructor();\n                const newPixelData = derivedImage.voxelManager.getScalarData();\n                const scalarArray = vtkDataArray.newInstance({\n                    name: 'Pixels',\n                    numberOfComponents: 1,\n                    values: new constructor(newPixelData),\n                });\n                const imageData = vtkImageData.newInstance();\n                imageData.setDimensions(dimensions[0], dimensions[1], 1);\n                imageData.setSpacing(spacing);\n                imageData.setDirection(direction);\n                imageData.setOrigin(originToUse);\n                imageData.getPointData().setScalars(scalarArray);\n                imageData.modified();\n                viewport.addImages([\n                    {\n                        imageId: derivedImageId,\n                        representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}-${derivedImage.imageId}`,\n                        callback: ({ imageActor }) => {\n                            imageActor.getMapper().setInputData(imageData);\n                        },\n                    },\n                ]);\n                shouldTriggerSegmentationRender = true;\n                return;\n            }\n            else {\n                const segmentationImageData = segmentationActorInput.actor\n                    .getMapper()\n                    .getInputData();\n                if (segmentationImageData.setDerivedImage) {\n                    segmentationImageData.setDerivedImage(derivedImage);\n                }\n                else {\n                    utilities.updateVTKImageDataWithCornerstoneImage(segmentationImageData, derivedImage);\n                }\n            }\n        };\n        derivedImageIds.forEach(updateSegmentationActor);\n        if (shouldTriggerSegmentationRender) {\n            triggerSegmentationRender(viewportId);\n        }\n        viewport.render();\n        if (evt.type === Enums.Events.IMAGE_RENDERED) {\n            viewport.element.removeEventListener(Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);\n        }\n    });\n}\nexport default {\n    enable,\n    disable,\n};\n", "import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport getViewportsForAnnotation from '../../../utilities/getViewportsForAnnotation';\nimport { getAllAnnotations } from '../../../stateManagement/annotation/annotationState';\nimport { areSameSegment, isContourSegmentationAnnotation, } from '../../../utilities/contourSegmentation';\nimport { getToolGroupForViewport } from '../../../store/ToolGroupManager';\nimport { findAllIntersectingContours } from '../../../utilities/contourSegmentation/getIntersectingAnnotations';\nimport { processMultipleIntersections } from '../../../utilities/contourSegmentation/mergeMultipleAnnotations';\nimport { convertContourPolylineToCanvasSpace, createPolylineHole, combinePolylines, } from '../../../utilities/contourSegmentation/sharedOperations';\nimport { Events } from '../../../enums';\nconst DEFAULT_CONTOUR_SEG_TOOL_NAME = 'PlanarFreehandContourSegmentationTool';\nexport default async function contourSegmentationCompletedListener(evt) {\n    const sourceAnnotation = evt.detail\n        .annotation;\n    if (!isContourSegmentationAnnotation(sourceAnnotation)) {\n        return;\n    }\n    const viewport = getViewport(sourceAnnotation);\n    const contourSegmentationAnnotations = getValidContourSegmentationAnnotations(viewport, sourceAnnotation);\n    if (!contourSegmentationAnnotations.length) {\n        triggerEvent(eventTarget, Events.ANNOTATION_CUT_MERGE_PROCESS_COMPLETED, {\n            element: viewport.element,\n            sourceAnnotation,\n        });\n        return;\n    }\n    const sourcePolyline = convertContourPolylineToCanvasSpace(sourceAnnotation.data.contour.polyline, viewport);\n    const intersectingContours = findAllIntersectingContours(viewport, sourcePolyline, contourSegmentationAnnotations);\n    if (!intersectingContours.length) {\n        triggerEvent(eventTarget, Events.ANNOTATION_CUT_MERGE_PROCESS_COMPLETED, {\n            element: viewport.element,\n            sourceAnnotation,\n        });\n        return;\n    }\n    if (intersectingContours.length > 1) {\n        processMultipleIntersections(viewport, sourceAnnotation, sourcePolyline, intersectingContours);\n        return;\n    }\n    const { targetAnnotation, targetPolyline, isContourHole } = intersectingContours[0];\n    if (isContourHole) {\n        const { contourHoleProcessingEnabled = false } = evt.detail;\n        if (!contourHoleProcessingEnabled) {\n            return;\n        }\n        createPolylineHole(viewport, targetAnnotation, sourceAnnotation);\n    }\n    else {\n        combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline);\n    }\n}\nfunction isFreehandContourSegToolRegisteredForViewport(viewport, silent = false) {\n    const toolName = 'PlanarFreehandContourSegmentationTool';\n    const toolGroup = getToolGroupForViewport(viewport.id, viewport.renderingEngineId);\n    let errorMessage;\n    if (!toolGroup) {\n        errorMessage = `ToolGroup not found for viewport ${viewport.id}`;\n    }\n    else if (!toolGroup.hasTool(toolName)) {\n        errorMessage = `Tool ${toolName} not added to ${toolGroup.id} toolGroup`;\n    }\n    else if (!toolGroup.getToolOptions(toolName)) {\n        errorMessage = `Tool ${toolName} must be in active/passive state in ${toolGroup.id} toolGroup`;\n    }\n    if (errorMessage && !silent) {\n        console.warn(errorMessage);\n    }\n    return !errorMessage;\n}\nfunction getViewport(annotation) {\n    const viewports = getViewportsForAnnotation(annotation);\n    const viewportWithToolRegistered = viewports.find((viewport) => isFreehandContourSegToolRegisteredForViewport(viewport, true));\n    return viewportWithToolRegistered ?? viewports[0];\n}\nfunction getValidContourSegmentationAnnotations(viewport, sourceAnnotation) {\n    const { annotationUID: sourceAnnotationUID } = sourceAnnotation;\n    const allAnnotations = getAllAnnotations();\n    return allAnnotations.filter((targetAnnotation) => targetAnnotation.annotationUID &&\n        targetAnnotation.annotationUID !== sourceAnnotationUID &&\n        isContourSegmentationAnnotation(targetAnnotation) &&\n        areSameSegment(targetAnnotation, sourceAnnotation) &&\n        viewport.isReferenceViewable(targetAnnotation.metadata));\n}\n", "import { removeContourSegmentationAnnotation } from '../../../utilities/contourSegmentation';\nexport default function contourSegmentationRemovedListener(evt) {\n    const annotation = evt.detail.annotation;\n    removeContourSegmentationAnnotation(annotation);\n}\n", "import * as contourSegUtils from '../../utilities/contourSegmentation';\nimport { contourSegmentationCompleted } from './contourSegmentation';\nexport default function annotationCompletedListener(evt) {\n    const annotation = evt.detail.annotation;\n    if (contourSegUtils.isContourSegmentationAnnotation(annotation)) {\n        contourSegmentationCompleted(evt);\n    }\n}\n", "import { getRenderingEngines } from '@cornerstonejs/core';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities/triggerAnnotationRenderForViewportIds';\nfunction annotationSelectionListener(evt) {\n    const deselectedAnnotation = evt.detail.removed;\n    if (!deselectedAnnotation.length) {\n        return;\n    }\n    const renderingEngines = getRenderingEngines();\n    renderingEngines.forEach((renderingEngine) => {\n        const viewports = renderingEngine.getViewports();\n        const viewportIds = viewports.map((vp) => vp.id);\n        triggerAnnotationRenderForViewportIds(viewportIds);\n    });\n}\nexport default annotationSelectionListener;\n", "import triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nfunction annotationModifiedListener(evt) {\n    const { viewportId } = evt.detail;\n    triggerAnnotationRenderForViewportIds([viewportId]);\n}\nexport default annotationModifiedListener;\n", "import * as contourSegUtils from '../../utilities/contourSegmentation';\nimport { contourSegmentationRemoved } from './contourSegmentation';\nexport default function annotationRemovedListener(evt) {\n    const annotation = evt.detail.annotation;\n    if (contourSegUtils.isContourSegmentationAnnotation(annotation)) {\n        contourSegmentationRemoved(evt);\n    }\n}\n", "import { Enums } from '@cornerstonejs/core';\nimport triggerAnnotationRender from '../utilities/triggerAnnotationRender';\nconst onImageRendered = function (evt) {\n    triggerAnnotationRender(evt.detail.element);\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.IMAGE_RENDERED, onImageRendered);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.IMAGE_RENDERED, onImageRendered);\n};\nexport default {\n    enable,\n    disable,\n};\n", "import { state } from '../../store/state';\nimport ToolModes from '../../enums/ToolModes';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nconst { Active } = ToolModes;\nexport default function customCallbackHandler(handlerType, customFunction, evt) {\n    if (state.isInteractingWithTool) {\n        return false;\n    }\n    const { renderingEngineId, viewportId } = evt.detail;\n    const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n    if (!toolGroup) {\n        return false;\n    }\n    let activeTool;\n    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n    for (let j = 0; j < toolGroupToolNames.length; j++) {\n        const toolName = toolGroupToolNames[j];\n        const tool = toolGroup.toolOptions[toolName];\n        const toolInstance = toolGroup.getToolInstance(toolName);\n        if (tool.mode === Active &&\n            typeof toolInstance[customFunction] === 'function') {\n            activeTool = toolGroup.getToolInstance(toolName);\n            break;\n        }\n    }\n    if (!activeTool) {\n        return;\n    }\n    activeTool[customFunction](evt);\n}\n", "import customCallbackHandler from '../shared/customCallbackHandler';\nconst mouseClick = customCallbackHandler.bind(null, 'Mouse', 'mouseClickCallback');\nexport default mouseClick;\n", "import customCallbackHandler from '../shared/customCallbackHandler';\nconst mouseDoubleClick = customCallbackHandler.bind(null, 'Mouse', 'doubleClickCallback');\nexport default mouseDoubleClick;\n", "export default function filterToolsWithMoveableHandles(element, ToolAndAnnotations, canvasCoords, interactionType = 'mouse') {\n    const proximity = interactionType === 'touch' ? 36 : 6;\n    const toolsWithMoveableHandles = [];\n    ToolAndAnnotations.forEach(({ tool, annotations }) => {\n        for (const annotation of annotations) {\n            if (annotation.isLocked || !annotation.isVisible) {\n                continue;\n            }\n            const handle = tool.getHandleNearImagePoint(element, annotation, canvasCoords, proximity);\n            if (handle) {\n                toolsWithMoveableHandles.push({\n                    tool,\n                    annotation,\n                    handle,\n                });\n                break;\n            }\n        }\n    });\n    return toolsWithMoveableHandles;\n}\n", "import { getAnnotations } from '../stateManagement/annotation/annotationState';\nexport default function filterToolsWithAnnotationsForElement(element, tools) {\n    const result = [];\n    for (let i = 0; i < tools.length; i++) {\n        const tool = tools[i];\n        if (!tool) {\n            console.warn('undefined tool in filterToolsWithAnnotationsForElement');\n            continue;\n        }\n        let annotations = getAnnotations(tool.constructor.toolName, element);\n        if (!annotations?.length) {\n            continue;\n        }\n        if (typeof tool.filterInteractableAnnotationsForElement === 'function') {\n            annotations = tool.filterInteractableAnnotationsForElement(element, annotations);\n        }\n        if (annotations?.length > 0) {\n            result.push({ tool, annotations });\n        }\n    }\n    return result;\n}\n", "export default function filterMoveableAnnotationTools(element, ToolAndAnnotations, canvasCoords, interactionType = 'mouse') {\n    const proximity = interactionType === 'touch' ? 36 : 6;\n    const moveableAnnotationTools = [];\n    ToolAndAnnotations.forEach(({ tool, annotations }) => {\n        for (const annotation of annotations) {\n            if (annotation.isLocked || !annotation.isVisible) {\n                continue;\n            }\n            const near = tool.isPointNearTool(element, annotation, canvasCoords, proximity, interactionType);\n            if (near) {\n                moveableAnnotationTools.push({\n                    tool,\n                    annotation,\n                });\n                break;\n            }\n        }\n    });\n    return moveableAnnotationTools;\n}\n", "import { ToolModes } from '../../enums';\nimport { keyEventListener } from '../../eventListeners';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nimport getMouseModifier from './getMouseModifier';\nconst { Active } = ToolModes;\nexport default function getActiveToolForMouseEvent(evt) {\n    const { renderingEngineId, viewportId, event: mouseEvent } = evt.detail;\n    const modifierKey = getMouseModifier(mouseEvent) || keyEventListener.getModifierKey();\n    const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n    if (!toolGroup) {\n        return null;\n    }\n    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n    const defaultMousePrimary = toolGroup.getDefaultMousePrimary();\n    const mouseButton = evt.detail.buttons ?? mouseEvent?.buttons ?? defaultMousePrimary;\n    for (let j = 0; j < toolGroupToolNames.length; j++) {\n        const toolName = toolGroupToolNames[j];\n        const toolOptions = toolGroup.toolOptions[toolName];\n        const correctBinding = toolOptions.bindings.length &&\n            toolOptions.bindings.some((binding) => {\n                return (binding.mouseButton === mouseButton &&\n                    binding.modifierKey === modifierKey);\n            });\n        if (toolOptions.mode === Active && correctBinding) {\n            return toolGroup.getToolInstance(toolName);\n        }\n    }\n}\n", "import { getToolGroupForViewport } from '../../store/ToolGroupManager';\nexport default function getToolsWithModesForMouseEvent(evt, modesFilter, evtButton) {\n    const { renderingEngineId, viewportId } = evt.detail;\n    const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n    if (!toolGroup) {\n        return [];\n    }\n    const enabledTools = [];\n    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n    for (let j = 0; j < toolGroupToolNames.length; j++) {\n        const toolName = toolGroupToolNames[j];\n        const tool = toolGroup.toolOptions[toolName];\n        const correctBinding = evtButton != null &&\n            tool.bindings.length &&\n            tool.bindings.some((binding) => binding.mouseButton === evtButton);\n        if (modesFilter.includes(tool.mode) &&\n            (!evtButton || correctBinding)) {\n            const toolInstance = toolGroup.getToolInstance(toolName);\n            enabledTools.push(toolInstance);\n        }\n    }\n    return enabledTools;\n}\n", "import { keyEventListener } from '../../eventListeners';\nimport getMouseModifier from './getMouseModifier';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nexport default function getToolsWithActionsForMouseEvent(evt, toolModes) {\n    const toolsWithActions = new Map();\n    const { renderingEngineId, viewportId } = evt.detail;\n    const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n    if (!toolGroup) {\n        return toolsWithActions;\n    }\n    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n    const defaultMousePrimary = toolGroup.getDefaultMousePrimary();\n    const mouseEvent = evt.detail.event;\n    const mouseButton = mouseEvent?.buttons ?? defaultMousePrimary;\n    const modifierKey = getMouseModifier(mouseEvent) || keyEventListener.getModifierKey();\n    for (let j = 0; j < toolGroupToolNames.length; j++) {\n        const toolName = toolGroupToolNames[j];\n        const tool = toolGroup.getToolInstance(toolName);\n        const actionsConfig = tool.configuration?.actions ?? {};\n        const actions = Object.values(actionsConfig);\n        if (!actions?.length || !toolModes.includes(tool.mode)) {\n            continue;\n        }\n        const action = actions.find((action) => action.bindings?.length &&\n            action.bindings.some((binding) => binding.mouseButton === mouseButton &&\n                binding.modifierKey === modifierKey));\n        if (action) {\n            toolsWithActions.set(tool, action);\n        }\n    }\n    return toolsWithActions;\n}\n", "import { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../store/state';\nimport { ToolModes } from '../../enums';\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport filterMoveableAnnotationTools from '../../store/filterMoveableAnnotationTools';\nimport getToolsWithActionsForMouseEvent from '../shared/getToolsWithActionsForMouseEvent';\nconst { Active, Passive } = ToolModes;\nexport default function mouseDownAnnotationAction(evt) {\n    if (state.isInteractingWithTool) {\n        return false;\n    }\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { canvas: canvasCoords } = eventDetail.currentPoints;\n    if (!enabledElement) {\n        return false;\n    }\n    const toolsWithActions = getToolsWithActionsForMouseEvent(evt, [\n        Active,\n        Passive,\n    ]);\n    const tools = Array.from(toolsWithActions.keys());\n    const annotationToolsWithAnnotations = filterToolsWithAnnotationsForElement(element, tools);\n    const moveableAnnotationTools = filterMoveableAnnotationTools(element, annotationToolsWithAnnotations, canvasCoords);\n    if (moveableAnnotationTools.length > 0) {\n        const { tool, annotation } = moveableAnnotationTools[0];\n        const action = toolsWithActions.get(tool);\n        const method = typeof action.method === 'string' ? tool[action.method] : action.method;\n        method.call(tool, evt, annotation);\n        return true;\n    }\n    return false;\n}\n", "import { state } from '../../store/state';\nimport { ToolModes } from '../../enums';\nimport { setAnnotationSelected, isAnnotationSelected, } from '../../stateManagement/annotation/annotationSelection';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport filterToolsWithMoveableHandles from '../../store/filterToolsWithMoveableHandles';\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport filterMoveableAnnotationTools from '../../store/filterMoveableAnnotationTools';\nimport getActiveToolForMouseEvent from '../shared/getActiveToolForMouseEvent';\nimport getToolsWithModesForMouseEvent from '../shared/getToolsWithModesForMouseEvent';\nimport mouseDownAnnotationAction from './mouseDownAnnotationAction';\nconst { Active, Passive } = ToolModes;\nexport default function mouseDown(evt) {\n    if (state.isInteractingWithTool) {\n        return;\n    }\n    const activeTool = getActiveToolForMouseEvent(evt);\n    if (activeTool && typeof activeTool.preMouseDownCallback === 'function') {\n        const consumedEvent = activeTool.preMouseDownCallback(evt);\n        if (consumedEvent) {\n            return;\n        }\n    }\n    const isPrimaryClick = evt.detail.event.buttons === 1;\n    const activeToolsWithEventBinding = getToolsWithModesForMouseEvent(evt, [Active], evt.detail.event.buttons);\n    const passiveToolsIfEventWasPrimaryMouseButton = isPrimaryClick\n        ? getToolsWithModesForMouseEvent(evt, [Passive])\n        : undefined;\n    const applicableTools = [\n        ...(activeToolsWithEventBinding || []),\n        ...(passiveToolsIfEventWasPrimaryMouseButton || []),\n    ];\n    const actionExecuted = mouseDownAnnotationAction(evt);\n    if (actionExecuted) {\n        return;\n    }\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const annotationToolsWithAnnotations = filterToolsWithAnnotationsForElement(element, applicableTools);\n    const canvasCoords = eventDetail.currentPoints.canvas;\n    const annotationToolsWithMoveableHandles = filterToolsWithMoveableHandles(element, annotationToolsWithAnnotations, canvasCoords, 'mouse');\n    const isMultiSelect = !!evt.detail.event.shiftKey;\n    if (annotationToolsWithMoveableHandles.length > 0) {\n        const { tool, annotation, handle } = getAnnotationForSelection(annotationToolsWithMoveableHandles);\n        toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n        tool.handleSelectedCallback(evt, annotation, handle, 'Mouse');\n        return;\n    }\n    const moveableAnnotationTools = filterMoveableAnnotationTools(element, annotationToolsWithAnnotations, canvasCoords, 'mouse');\n    if (moveableAnnotationTools.length > 0) {\n        const { tool, annotation } = getAnnotationForSelection(moveableAnnotationTools);\n        toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n        tool.toolSelectedCallback(evt, annotation, 'Mouse', canvasCoords);\n        return;\n    }\n    if (activeTool && typeof activeTool.postMouseDownCallback === 'function') {\n        const consumedEvent = activeTool.postMouseDownCallback(evt);\n        if (consumedEvent) {\n            return;\n        }\n    }\n}\nfunction getAnnotationForSelection(toolsWithMovableHandles) {\n    if (toolsWithMovableHandles.length > 1) {\n        const unlockAndVisibleAnnotation = toolsWithMovableHandles.find((item) => {\n            const isUnlocked = !isAnnotationLocked(item.annotation.annotationUID);\n            const isVisible = isAnnotationVisible(item.annotation.annotationUID);\n            return isUnlocked && isVisible;\n        });\n        if (unlockAndVisibleAnnotation) {\n            return unlockAndVisibleAnnotation;\n        }\n    }\n    return toolsWithMovableHandles[0];\n}\nfunction toggleAnnotationSelection(annotationUID, isMultiSelect = false) {\n    if (isMultiSelect) {\n        if (isAnnotationSelected(annotationUID)) {\n            setAnnotationSelected(annotationUID, false);\n        }\n        else {\n            const preserveSelected = true;\n            setAnnotationSelected(annotationUID, true, preserveSelected);\n        }\n    }\n    else {\n        const preserveSelected = false;\n        setAnnotationSelected(annotationUID, true, preserveSelected);\n    }\n}\n", "import { state } from '../../store/state';\nimport getActiveToolForMouseEvent from '../shared/getActiveToolForMouseEvent';\nimport { setAnnotationSelected } from '../../stateManagement/annotation/annotationSelection';\nexport default function mouseDownActivate(evt) {\n    if (state.isInteractingWithTool) {\n        return;\n    }\n    const activeTool = getActiveToolForMouseEvent(evt);\n    if (!activeTool) {\n        return;\n    }\n    if (state.isMultiPartToolActive) {\n        return;\n    }\n    if (activeTool.addNewAnnotation) {\n        const annotation = activeTool.addNewAnnotation(evt, 'mouse');\n        setAnnotationSelected(annotation.annotationUID);\n    }\n}\n", "import getActiveToolForMouseEvent from '../shared/getActiveToolForMouseEvent';\nimport { state } from '../../store/state';\nexport default function mouseDrag(evt) {\n    if (state.isInteractingWithTool) {\n        return;\n    }\n    const activeTool = getActiveToolForMouseEvent(evt);\n    const noFoundToolOrDoesNotHaveMouseDragCallback = !activeTool || typeof activeTool.mouseDragCallback !== 'function';\n    if (noFoundToolOrDoesNotHaveMouseDragCallback) {\n        return;\n    }\n    activeTool.mouseDragCallback(evt);\n}\n", "import { state } from '../../store/state';\nimport { ToolModes } from '../../enums';\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport getToolsWithModesForMouseEvent from '../shared/getToolsWithModesForMouseEvent';\nimport triggerAnnotationRender from '../../utilities/triggerAnnotationRender';\nconst { Active, Passive } = ToolModes;\nexport default function mouseMove(evt) {\n    if (state.isInteractingWithTool || state.isMultiPartToolActive) {\n        return;\n    }\n    const activeAndPassiveTools = getToolsWithModesForMouseEvent(evt, [\n        Active,\n        Passive,\n    ]);\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const toolsWithAnnotations = filterToolsWithAnnotationsForElement(element, activeAndPassiveTools);\n    const toolsWithoutAnnotations = activeAndPassiveTools.filter((tool) => {\n        const doesNotHaveAnnotations = !toolsWithAnnotations.some((toolAndAnnotation) => toolAndAnnotation.tool.getToolName() === tool.getToolName());\n        return doesNotHaveAnnotations;\n    });\n    let annotationsNeedToBeRedrawn = false;\n    for (const { tool, annotations } of toolsWithAnnotations) {\n        if (typeof tool.mouseMoveCallback === 'function') {\n            annotationsNeedToBeRedrawn =\n                tool.mouseMoveCallback(evt, annotations) || annotationsNeedToBeRedrawn;\n        }\n    }\n    toolsWithoutAnnotations.forEach((tool) => {\n        if (typeof tool.mouseMoveCallback === 'function') {\n            tool.mouseMoveCallback(evt);\n        }\n    });\n    if (annotationsNeedToBeRedrawn === true) {\n        triggerAnnotationRender(element);\n    }\n}\n", "import customCallbackHandler from '../shared/customCallbackHandler';\nconst mouseUp = customCallbackHandler.bind(null, 'Mouse', 'mouseUpCallback');\nexport default mouseUp;\n", "import { state } from '../../store/state';\nimport getActiveToolForMouseEvent from '../shared/getActiveToolForMouseEvent';\nimport { MouseBindings } from '../../enums/ToolBindings';\nfunction mouseWheel(evt) {\n    if (state.isInteractingWithTool) {\n        return;\n    }\n    evt.detail.buttons =\n        MouseBindings.Wheel | (evt.detail.event.buttons || 0);\n    const activeTool = getActiveToolForMouseEvent(evt);\n    if (!activeTool) {\n        return;\n    }\n    return activeTool.mouseWheelCallback(evt);\n}\nexport default mouseWheel;\n", "import Events from '../enums/Events';\nimport { mouseClick, mouseDown, mouseDownActivate, mouseDoubleClick, mouseDrag, mouseMove, mouseUp, mouseWheel, } from './mouseEventHandlers';\nconst enable = function (element) {\n    element.addEventListener(Events.MOUSE_CLICK, mouseClick);\n    element.addEventListener(Events.MOUSE_DOWN, mouseDown);\n    element.addEventListener(Events.MOUSE_DOWN_ACTIVATE, mouseDownActivate);\n    element.addEventListener(Events.MOUSE_DOUBLE_CLICK, mouseDoubleClick);\n    element.addEventListener(Events.MOUSE_DRAG, mouseDrag);\n    element.addEventListener(Events.MOUSE_MOVE, mouseMove);\n    element.addEventListener(Events.MOUSE_UP, mouseUp);\n    element.addEventListener(Events.MOUSE_WHEEL, mouseWheel);\n};\nconst disable = function (element) {\n    element.removeEventListener(Events.MOUSE_CLICK, mouseClick);\n    element.removeEventListener(Events.MOUSE_DOWN, mouseDown);\n    element.removeEventListener(Events.MOUSE_DOWN_ACTIVATE, mouseDownActivate);\n    element.removeEventListener(Events.MOUSE_DOUBLE_CLICK, mouseDoubleClick);\n    element.removeEventListener(Events.MOUSE_DRAG, mouseDrag);\n    element.removeEventListener(Events.MOUSE_MOVE, mouseMove);\n    element.removeEventListener(Events.MOUSE_UP, mouseUp);\n    element.removeEventListener(Events.MOUSE_WHEEL, mouseWheel);\n};\nconst mouseToolEventDispatcher = {\n    enable,\n    disable,\n};\nexport default mouseToolEventDispatcher;\n", "import { ToolModes } from '../../enums';\nimport { keyEventListener } from '../../eventListeners';\nimport { getMouseButton } from '../../eventListeners/mouse/mouseDownListener';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nconst { Active } = ToolModes;\nexport default function getActiveToolForKeyboardEvent(evt) {\n    const { renderingEngineId, viewportId } = evt.detail;\n    const mouseButton = getMouseButton();\n    const modifierKey = keyEventListener.getModifierKey();\n    const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n    if (!toolGroup) {\n        return null;\n    }\n    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n    const defaultMousePrimary = toolGroup.getDefaultMousePrimary();\n    for (let j = 0; j < toolGroupToolNames.length; j++) {\n        const toolName = toolGroupToolNames[j];\n        const toolOptions = toolGroup.toolOptions[toolName];\n        if (toolOptions.mode !== Active) {\n            continue;\n        }\n        const correctBinding = toolOptions.bindings.length &&\n            toolOptions.bindings.some((binding) => binding.mouseButton === (mouseButton ?? defaultMousePrimary) &&\n                binding.modifierKey === modifierKey);\n        if (correctBinding) {\n            return toolGroup.getToolInstance(toolName);\n        }\n    }\n}\n", "import { getToolGroupForViewport } from '../../store/ToolGroupManager';\nexport default function getToolsWithModesForKeyboardEvent(evt, toolModes) {\n    const toolsWithActions = new Map();\n    const { renderingEngineId, viewportId } = evt.detail;\n    const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n    if (!toolGroup) {\n        return toolsWithActions;\n    }\n    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n    const key = evt.detail.key;\n    for (let j = 0; j < toolGroupToolNames.length; j++) {\n        const toolName = toolGroupToolNames[j];\n        const tool = toolGroup.getToolInstance(toolName);\n        const actionsConfig = tool.configuration?.actions;\n        if (!actionsConfig) {\n            continue;\n        }\n        const actions = Object.values(actionsConfig);\n        if (!actions?.length || !toolModes.includes(tool.mode)) {\n            continue;\n        }\n        const action = actions.find((action) => action.bindings?.some((binding) => binding.key === key));\n        if (action) {\n            toolsWithActions.set(tool, action);\n        }\n    }\n    return toolsWithActions;\n}\n", "import getActiveToolForKeyboardEvent from '../shared/getActiveToolForKeyboardEvent';\nimport getToolsWithActionsForKeyboardEvent from '../shared/getToolsWithActionsForKeyboardEvents';\nimport ToolModes from '../../enums/ToolModes';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nexport default function keyDown(evt) {\n    const activeTool = getActiveToolForKeyboardEvent(evt);\n    if (activeTool) {\n        const { renderingEngineId, viewportId } = evt.detail;\n        const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n        const toolName = activeTool.getToolName();\n        if (Object.keys(toolGroup.toolOptions).includes(toolName)) {\n            toolGroup.setViewportsCursorByToolName(toolName);\n        }\n    }\n    const activeToolsWithEventBinding = getToolsWithActionsForKeyboardEvent(evt, [\n        ToolModes.Active,\n    ]);\n    if (activeToolsWithEventBinding?.size) {\n        const { element } = evt.detail;\n        for (const [key, value] of [...activeToolsWithEventBinding.entries()]) {\n            const method = typeof value.method === 'function' ? value.method : key[value.method];\n            method.call(key, element, value, evt);\n        }\n    }\n}\n", "import { resetModifierKey } from '../../eventListeners/keyboard/keyDownListener';\nimport getActiveToolForKeyboardEvent from '../shared/getActiveToolForKeyboardEvent';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nexport default function keyUp(evt) {\n    const activeTool = getActiveToolForKeyboardEvent(evt);\n    if (!activeTool) {\n        return;\n    }\n    const { renderingEngineId, viewportId } = evt.detail;\n    const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n    resetModifierKey();\n    const toolName = activeTool.getToolName();\n    if (Object.keys(toolGroup.toolOptions).includes(toolName)) {\n        toolGroup.setViewportsCursorByToolName(toolName);\n    }\n}\n", "import Events from '../enums/Events';\nimport { keyDown, keyUp } from './keyboardEventHandlers';\nconst enable = function (element) {\n    element.addEventListener(Events.KEY_DOWN, keyDown);\n    element.addEventListener(Events.KEY_UP, keyUp);\n};\nconst disable = function (element) {\n    element.removeEventListener(Events.KEY_DOWN, keyDown);\n    element.removeEventListener(Events.KEY_UP, keyUp);\n};\nconst keyboardToolEventDispatcher = {\n    enable,\n    disable,\n};\nexport default keyboardToolEventDispatcher;\n", "import { Enums } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\nconst { Active, Passive, Enabled } = ToolModes;\nconst onCameraModified = function (evt) {\n    const enabledTools = getToolsWithModesForMouseEvent(evt, [\n        Active,\n        Passive,\n        Enabled,\n    ]);\n    enabledTools.forEach((tool) => {\n        if (tool.onCameraModified) {\n            tool.onCameraModified(evt);\n        }\n    });\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\nexport default {\n    enable,\n    disable,\n};\n", "import { Enums } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\nconst { Active, Passive, Enabled } = ToolModes;\nconst onImageSpacingCalibrated = function (evt) {\n    const enabledTools = getToolsWithModesForMouseEvent(evt, [\n        Active,\n        Passive,\n        Enabled,\n    ]);\n    enabledTools.forEach((tool) => {\n        if (tool.onImageSpacingCalibrated) {\n            tool.onImageSpacingCalibrated(evt);\n        }\n    });\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);\n};\nexport default {\n    enable,\n    disable,\n};\n", "import { ToolModes } from '../../enums';\nimport getMouseModifier from './getMouseModifier';\nimport { keyEventListener } from '../../eventListeners';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nconst { Active } = ToolModes;\nexport default function getActiveToolForTouchEvent(evt) {\n    const { renderingEngineId, viewportId } = evt.detail;\n    const touchEvent = evt.detail.event;\n    const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n    if (!toolGroup) {\n        return null;\n    }\n    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n    const numTouchPoints = Object.keys(touchEvent.touches).length;\n    const modifierKey = getMouseModifier(touchEvent) || keyEventListener.getModifierKey();\n    const defaultMousePrimary = toolGroup.getDefaultMousePrimary();\n    for (let j = 0; j < toolGroupToolNames.length; j++) {\n        const toolName = toolGroupToolNames[j];\n        const toolOptions = toolGroup.toolOptions[toolName];\n        const correctBinding = toolOptions.bindings.length &&\n            toolOptions.bindings.some((binding) => (binding.numTouchPoints === numTouchPoints ||\n                (numTouchPoints === 1 &&\n                    binding.mouseButton === defaultMousePrimary)) &&\n                binding.modifierKey === modifierKey);\n        if (toolOptions.mode === Active && correctBinding) {\n            return toolGroup.getToolInstance(toolName);\n        }\n    }\n}\n", "import { getToolGroupForViewport } from '../../store/ToolGroupManager';\nexport default function getToolsWithModesForTouchEvent(evt, modesFilter, numTouchPoints) {\n    const { renderingEngineId, viewportId } = evt.detail;\n    const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n    if (!toolGroup) {\n        return [];\n    }\n    const enabledTools = [];\n    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n    for (let j = 0; j < toolGroupToolNames.length; j++) {\n        const toolName = toolGroupToolNames[j];\n        const tool = toolGroup.toolOptions[toolName];\n        const correctBinding = numTouchPoints != null &&\n            tool.bindings.length &&\n            tool.bindings.some((binding) => binding.numTouchPoints === numTouchPoints);\n        if (modesFilter.includes(tool.mode) &&\n            (!numTouchPoints || correctBinding)) {\n            const toolInstance = toolGroup.getToolInstance(toolName);\n            enabledTools.push(toolInstance);\n        }\n    }\n    return enabledTools;\n}\n", "import { state } from '../../store/state';\nimport { ToolModes } from '../../enums';\nimport { setAnnotationSelected, isAnnotationSelected, } from '../../stateManagement/annotation/annotationSelection';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport filterToolsWithMoveableHandles from '../../store/filterToolsWithMoveableHandles';\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport filterMoveableAnnotationTools from '../../store/filterMoveableAnnotationTools';\nimport getActiveToolForTouchEvent from '../shared/getActiveToolForTouchEvent';\nimport getToolsWithModesForTouchEvent from '../shared/getToolsWithModesForTouchEvent';\nconst { Active, Passive } = ToolModes;\nexport default function touchStart(evt) {\n    if (state.isInteractingWithTool) {\n        return;\n    }\n    const activeTool = getActiveToolForTouchEvent(evt);\n    if (activeTool && typeof activeTool.preTouchStartCallback === 'function') {\n        const consumedEvent = activeTool.preTouchStartCallback(evt);\n        if (consumedEvent) {\n            return;\n        }\n    }\n    const isPrimaryClick = Object.keys(evt.detail.event.touches).length === 1;\n    const activeToolsWithEventBinding = getToolsWithModesForTouchEvent(evt, [Active], Object.keys(evt.detail.event.touches).length);\n    const passiveToolsIfEventWasPrimaryTouchButton = isPrimaryClick\n        ? getToolsWithModesForTouchEvent(evt, [Passive])\n        : undefined;\n    const applicableTools = [\n        ...(activeToolsWithEventBinding || []),\n        ...(passiveToolsIfEventWasPrimaryTouchButton || []),\n        activeTool,\n    ];\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const annotationToolsWithAnnotations = filterToolsWithAnnotationsForElement(element, applicableTools);\n    const canvasCoords = eventDetail.currentPoints.canvas;\n    const annotationToolsWithMoveableHandles = filterToolsWithMoveableHandles(element, annotationToolsWithAnnotations, canvasCoords, 'touch');\n    const isMultiSelect = false;\n    if (annotationToolsWithMoveableHandles.length > 0) {\n        const { tool, annotation, handle } = getAnnotationForSelection(annotationToolsWithMoveableHandles);\n        toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n        tool.handleSelectedCallback(evt, annotation, handle, 'Touch');\n        return;\n    }\n    const moveableAnnotationTools = filterMoveableAnnotationTools(element, annotationToolsWithAnnotations, canvasCoords, 'touch');\n    if (moveableAnnotationTools.length > 0) {\n        const { tool, annotation } = getAnnotationForSelection(moveableAnnotationTools);\n        toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n        tool.toolSelectedCallback(evt, annotation, 'Touch', canvasCoords);\n        return;\n    }\n    if (activeTool && typeof activeTool.postTouchStartCallback === 'function') {\n        const consumedEvent = activeTool.postTouchStartCallback(evt);\n        if (consumedEvent) {\n            return;\n        }\n    }\n}\nfunction getAnnotationForSelection(toolsWithMovableHandles) {\n    return ((toolsWithMovableHandles.length > 1 &&\n        toolsWithMovableHandles.find((item) => !isAnnotationLocked(item.annotation.annotationUID) &&\n            isAnnotationVisible(item.annotation.annotationUID))) ||\n        toolsWithMovableHandles[0]);\n}\nfunction toggleAnnotationSelection(annotationUID, isMultiSelect = false) {\n    if (isMultiSelect) {\n        if (isAnnotationSelected(annotationUID)) {\n            setAnnotationSelected(annotationUID, false);\n        }\n        else {\n            const preserveSelected = true;\n            setAnnotationSelected(annotationUID, true, preserveSelected);\n        }\n    }\n    else {\n        const preserveSelected = false;\n        setAnnotationSelected(annotationUID, true, preserveSelected);\n    }\n}\n", "import { state } from '../../store/state';\nimport { setAnnotationSelected } from '../../stateManagement/annotation/annotationSelection';\nimport getActiveToolForTouchEvent from '../shared/getActiveToolForTouchEvent';\nexport default function touchStartActivate(evt) {\n    if (state.isInteractingWithTool) {\n        return;\n    }\n    const activeTool = getActiveToolForTouchEvent(evt);\n    if (!activeTool) {\n        return;\n    }\n    if (state.isMultiPartToolActive) {\n        return;\n    }\n    if (activeTool.addNewAnnotation) {\n        const annotation = activeTool.addNewAnnotation(evt, 'touch');\n        setAnnotationSelected(annotation.annotationUID);\n    }\n}\n", "import getActiveToolForTouchEvent from '../shared/getActiveToolForTouchEvent';\nimport { state } from '../../store/state';\nexport default function touchDrag(evt) {\n    if (state.isInteractingWithTool) {\n        return;\n    }\n    const activeTool = getActiveToolForTouchEvent(evt);\n    const noFoundToolOrDoesNotHaveTouchDragCallback = !activeTool || typeof activeTool.touchDragCallback !== 'function';\n    if (noFoundToolOrDoesNotHaveTouchDragCallback) {\n        return;\n    }\n    activeTool.touchDragCallback(evt);\n}\n", "import customCallbackHandler from '../shared/customCallbackHandler';\nconst touchEnd = customCallbackHandler.bind(null, 'Touch', 'touchEndCallback');\nexport default touchEnd;\n", "import customCallbackHandler from '../shared/customCallbackHandler';\nconst touchTap = customCallbackHandler.bind(null, 'Touch', 'touchTapCallback');\nexport default touchTap;\n", "import customCallbackHandler from '../shared/customCallbackHandler';\nconst touchPress = customCallbackHandler.bind(null, 'Touch', 'touchPressCallback');\nexport default touchPress;\n", "import Events from '../enums/Events';\nimport { touchStart, touchStartActivate, touchDrag, touchEnd, touchTap, touchPress, } from './touchEventHandlers';\nconst enable = function (element) {\n    element.addEventListener(Events.TOUCH_START, touchStart);\n    element.addEventListener(Events.TOUCH_START_ACTIVATE, touchStartActivate);\n    element.addEventListener(Events.TOUCH_DRAG, touchDrag);\n    element.addEventListener(Events.TOUCH_END, touchEnd);\n    element.addEventListener(Events.TOUCH_TAP, touchTap);\n    element.addEventListener(Events.TOUCH_PRESS, touchPress);\n};\nconst disable = function (element) {\n    element.removeEventListener(Events.TOUCH_START, touchStart);\n    element.removeEventListener(Events.TOUCH_START_ACTIVATE, touchStartActivate);\n    element.removeEventListener(Events.TOUCH_DRAG, touchDrag);\n    element.removeEventListener(Events.TOUCH_END, touchEnd);\n    element.removeEventListener(Events.TOUCH_PRESS, touchPress);\n};\nconst touchToolEventDispatcher = {\n    enable,\n    disable,\n};\nexport default touchToolEventDispatcher;\n", "import { eventTarget } from '@cornerstonejs/core';\nimport Events from '../enums/Events';\nimport InterpolationManager from '../utilities/segmentation/InterpolationManager/InterpolationManager';\nconst enable = function () {\n    eventTarget.addEventListener(Events.ANNOTATION_COMPLETED, InterpolationManager.handleAnnotationCompleted);\n    eventTarget.addEventListener(Events.ANNOTATION_MODIFIED, InterpolationManager.handleAnnotationUpdate);\n    eventTarget.addEventListener(Events.ANNOTATION_REMOVED, InterpolationManager.handleAnnotationDelete);\n};\nconst disable = function () {\n    eventTarget.removeEventListener(Events.ANNOTATION_COMPLETED, InterpolationManager.handleAnnotationCompleted);\n    eventTarget.removeEventListener(Events.ANNOTATION_MODIFIED, InterpolationManager.handleAnnotationUpdate);\n    eventTarget.removeEventListener(Events.ANNOTATION_REMOVED, InterpolationManager.handleAnnotationDelete);\n};\nexport default {\n    enable,\n    disable,\n};\n", "import { Enums } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\nconst { Active, Passive, Enabled } = ToolModes;\nconst onCameraReset = function (evt) {\n    const enabledTools = getToolsWithModesForMouseEvent(evt, [\n        Active,\n        Passive,\n        Enabled,\n    ]);\n    enabledTools.forEach((tool) => {\n        if (tool.onResetCamera) {\n            tool.onResetCamera(evt);\n        }\n    });\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.CAMERA_RESET, onCameraReset);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.CAMERA_RESET, onCameraReset);\n};\nexport default {\n    enable,\n    disable,\n};\n", "import { mouseEventListeners, wheelEventListener, touchEventListeners, keyEventListener, imageChangeEventListener, } from '../eventListeners';\nimport { imageRenderedEventDispatcher, cameraModifiedEventDispatcher, mouseToolEventDispatcher, touchToolEventDispatcher, keyboardToolEventDispatcher, imageSpacingCalibratedEventDispatcher, cameraResetEventDispatcher, } from '../eventDispatchers';\nimport { state } from './state';\nimport { annotationRenderingEngine } from '../stateManagement/annotation/AnnotationRenderingEngine';\nexport default function addEnabledElement(evt) {\n    const { element, viewportId } = evt.detail;\n    const svgLayer = _createSvgAnnotationLayer(viewportId);\n    _setSvgNodeCache(element);\n    _appendChild(svgLayer, element);\n    annotationRenderingEngine.addViewportElement(viewportId, element);\n    mouseEventListeners.enable(element);\n    wheelEventListener.enable(element);\n    touchEventListeners.enable(element);\n    keyEventListener.enable(element);\n    imageChangeEventListener.enable(element);\n    imageRenderedEventDispatcher.enable(element);\n    cameraModifiedEventDispatcher.enable(element);\n    imageSpacingCalibratedEventDispatcher.enable(element);\n    cameraResetEventDispatcher.enable(element);\n    mouseToolEventDispatcher.enable(element);\n    keyboardToolEventDispatcher.enable(element);\n    touchToolEventDispatcher.enable(element);\n    state.enabledElements.push(element);\n}\nfunction _createSvgAnnotationLayer(viewportId) {\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgLayer = document.createElementNS(svgns, 'svg');\n    const svgLayerId = `svg-layer-${viewportId}`;\n    svgLayer.classList.add('svg-layer');\n    svgLayer.setAttribute('id', svgLayerId);\n    svgLayer.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n    svgLayer.style.width = '100%';\n    svgLayer.style.height = '100%';\n    svgLayer.style.pointerEvents = 'none';\n    svgLayer.style.position = 'absolute';\n    const defs = document.createElementNS(svgns, 'defs');\n    const filter = document.createElementNS(svgns, 'filter');\n    const feOffset = document.createElementNS(svgns, 'feOffset');\n    const feColorMatrix = document.createElementNS(svgns, 'feColorMatrix');\n    const feBlend = document.createElementNS(svgns, 'feBlend');\n    filter.setAttribute('id', `shadow-${svgLayerId}`);\n    filter.setAttribute('filterUnits', 'userSpaceOnUse');\n    feOffset.setAttribute('result', 'offOut');\n    feOffset.setAttribute('in', 'SourceGraphic');\n    feOffset.setAttribute('dx', '0.5');\n    feOffset.setAttribute('dy', '0.5');\n    feColorMatrix.setAttribute('result', 'matrixOut');\n    feColorMatrix.setAttribute('in', 'offOut');\n    feColorMatrix.setAttribute('in2', 'matrix');\n    feColorMatrix.setAttribute('values', '0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1 0');\n    feBlend.setAttribute('in', 'SourceGraphic');\n    feBlend.setAttribute('in2', 'matrixOut');\n    feBlend.setAttribute('mode', 'normal');\n    filter.appendChild(feOffset);\n    filter.appendChild(feColorMatrix);\n    filter.appendChild(feBlend);\n    defs.appendChild(filter);\n    svgLayer.appendChild(defs);\n    return svgLayer;\n}\nfunction _setSvgNodeCache(element) {\n    const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } = element.dataset;\n    const elementHash = `${viewportId}:${renderingEngineId}`;\n    state.svgNodeCache[elementHash] = {};\n}\nfunction _appendChild(newNode, referenceNode) {\n    referenceNode.querySelector('div.viewport-element').appendChild(newNode);\n}\n", "import { state } from '../state';\nfunction getSynchronizersForViewport(viewportId, renderingEngineId) {\n    const synchronizersFilteredByIds = [];\n    if (!renderingEngineId && !viewportId) {\n        throw new Error('At least one of renderingEngineId or viewportId should be given');\n    }\n    for (let i = 0; i < state.synchronizers.length; i++) {\n        const synchronizer = state.synchronizers[i];\n        const notDisabled = !synchronizer.isDisabled();\n        const hasSourceViewport = synchronizer.hasSourceViewport(renderingEngineId, viewportId);\n        const hasTargetViewport = synchronizer.hasTargetViewport(renderingEngineId, viewportId);\n        if (notDisabled && (hasSourceViewport || hasTargetViewport)) {\n            synchronizersFilteredByIds.push(synchronizer);\n        }\n    }\n    return synchronizersFilteredByIds;\n}\nexport default getSynchronizersForViewport;\n", "import { getEnabledElement } from '@cornerstonejs/core';\nimport { mouseEventListeners, wheelEventListener, touchEventListeners, keyEventListener, imageChangeEventListener, } from '../eventListeners';\nimport { imageRenderedEventDispatcher, cameraModifiedEventDispatcher, mouseToolEventDispatcher, keyboardToolEventDispatcher, imageSpacingCalibratedEventDispatcher, touchToolEventDispatcher, cameraResetEventDispatcher, } from '../eventDispatchers';\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\nimport { state } from './state';\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\nimport { ToolModes } from '../enums';\nimport { removeAnnotation } from '../stateManagement';\nimport getSynchronizersForViewport from './SynchronizerManager/getSynchronizersForViewport';\nimport getToolGroupForViewport from './ToolGroupManager/getToolGroupForViewport';\nimport { annotationRenderingEngine } from '../stateManagement/annotation/AnnotationRenderingEngine';\nconst VIEWPORT_ELEMENT = 'viewport-element';\nfunction removeEnabledElement(elementDisabledEvt) {\n    const { element, viewportId } = elementDisabledEvt.detail;\n    _resetSvgNodeCache(element);\n    _removeSvgNode(element);\n    annotationRenderingEngine.removeViewportElement(viewportId, element);\n    mouseEventListeners.disable(element);\n    wheelEventListener.disable(element);\n    touchEventListeners.disable(element);\n    keyEventListener.disable(element);\n    imageChangeEventListener.disable(element);\n    imageRenderedEventDispatcher.disable(element);\n    cameraModifiedEventDispatcher.disable(element);\n    imageSpacingCalibratedEventDispatcher.disable(element);\n    cameraResetEventDispatcher.disable(element);\n    mouseToolEventDispatcher.disable(element);\n    keyboardToolEventDispatcher.disable(element);\n    touchToolEventDispatcher.disable(element);\n    _removeViewportFromSynchronizers(element);\n    _removeViewportFromToolGroup(element);\n    _removeEnabledElement(element);\n}\nconst _removeViewportFromSynchronizers = (element) => {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        return;\n    }\n    const synchronizers = getSynchronizersForViewport(enabledElement.viewportId, enabledElement.renderingEngineId);\n    synchronizers.forEach((sync) => {\n        sync.remove(enabledElement);\n    });\n};\nconst _removeViewportFromToolGroup = (element) => {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        return;\n    }\n    const { renderingEngineId, viewportId } = enabledElement;\n    const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n    if (toolGroup) {\n        toolGroup.removeViewports(renderingEngineId, viewportId);\n    }\n};\nconst _removeAllToolsForElement = function (element) {\n    const tools = getToolsWithModesForElement(element, [\n        ToolModes.Active,\n        ToolModes.Passive,\n    ]);\n    const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\n    toolsWithData.forEach(({ annotations }) => {\n        annotations.forEach((annotation) => {\n            removeAnnotation(annotation.annotationUID);\n        });\n    });\n};\nfunction _resetSvgNodeCache(element) {\n    const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } = element.dataset;\n    const elementHash = `${viewportId}:${renderingEngineId}`;\n    delete state.svgNodeCache[elementHash];\n}\nfunction _removeSvgNode(element) {\n    const internalViewportNode = element.querySelector(`div.${VIEWPORT_ELEMENT}`);\n    const svgLayer = internalViewportNode.querySelector('svg');\n    if (svgLayer) {\n        internalViewportNode.removeChild(svgLayer);\n    }\n}\nconst _removeEnabledElement = function (element) {\n    const foundElementIndex = state.enabledElements.findIndex((el) => el === element);\n    if (foundElementIndex > -1) {\n        state.enabledElements.splice(foundElementIndex, 1);\n    }\n};\nexport default removeEnabledElement;\n", "import { ToolModes } from '../enums';\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\nexport default function cancelActiveManipulations(element) {\n    const tools = getToolsWithModesForElement(element, [\n        ToolModes.Active,\n        ToolModes.Passive,\n    ]);\n    const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\n    for (const { tool } of toolsWithData) {\n        const annotationUID = tool.cancel(element);\n        if (annotationUID) {\n            return annotationUID;\n        }\n    }\n}\n", "import { getRenderingEngine, getEnabledElement, eventTarget, Enums, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nclass Synchronizer {\n    constructor(synchronizerId, eventName, eventHandler, options) {\n        this._viewportOptions = {};\n        this._onEvent = (evt) => {\n            if (this._ignoreFiredEvents === true) {\n                return;\n            }\n            if (!this._targetViewports.length) {\n                return;\n            }\n            const enabledElement = this._eventSource === 'element'\n                ? getEnabledElement(evt.currentTarget)\n                : getEnabledElementByViewportId(evt.detail?.viewportId);\n            if (!enabledElement) {\n                return;\n            }\n            const { renderingEngineId, viewportId } = enabledElement;\n            if (!this._sourceViewports.find((s) => s.viewportId === viewportId)) {\n                return;\n            }\n            this.fireEvent({\n                renderingEngineId,\n                viewportId,\n            }, evt);\n        };\n        this._enabled = true;\n        this._eventName = eventName;\n        this._eventHandler = eventHandler;\n        this._ignoreFiredEvents = false;\n        this._sourceViewports = [];\n        this._targetViewports = [];\n        this._options = options || {};\n        this._eventSource = this._options.eventSource || 'element';\n        this._auxiliaryEvents = this._options.auxiliaryEvents || [];\n        this.id = synchronizerId;\n    }\n    isDisabled() {\n        return !this._enabled || !this._hasSourceElements();\n    }\n    setOptions(viewportId, options = {}) {\n        this._viewportOptions[viewportId] = options;\n    }\n    setEnabled(enabled) {\n        this._enabled = enabled;\n    }\n    getOptions(viewportId) {\n        return this._viewportOptions[viewportId];\n    }\n    add(viewportInfo) {\n        this.addTarget(viewportInfo);\n        this.addSource(viewportInfo);\n    }\n    addSource(viewportInfo) {\n        if (_containsViewport(this._sourceViewports, viewportInfo)) {\n            return;\n        }\n        const { renderingEngineId, viewportId } = viewportInfo;\n        const viewport = getRenderingEngine(renderingEngineId).getViewport(viewportId);\n        if (!viewport) {\n            console.warn(`Synchronizer.addSource: No viewport for ${renderingEngineId} ${viewportId}`);\n            return;\n        }\n        const eventSource = this._eventSource === 'element' ? viewport.element : eventTarget;\n        eventSource.addEventListener(this._eventName, this._onEvent.bind(this));\n        this._auxiliaryEvents.forEach(({ name, source }) => {\n            const target = source === 'element' ? viewport.element : eventTarget;\n            target.addEventListener(name, this._onEvent.bind(this));\n        });\n        this._updateDisableHandlers();\n        this._sourceViewports.push(viewportInfo);\n    }\n    addTarget(viewportInfo) {\n        if (_containsViewport(this._targetViewports, viewportInfo)) {\n            return;\n        }\n        this._targetViewports.push(viewportInfo);\n        this._updateDisableHandlers();\n    }\n    getSourceViewports() {\n        return this._sourceViewports;\n    }\n    getTargetViewports() {\n        return this._targetViewports;\n    }\n    destroy() {\n        this._sourceViewports.forEach((s) => this.removeSource(s));\n        this._targetViewports.forEach((t) => this.removeTarget(t));\n    }\n    remove(viewportInfo) {\n        this.removeTarget(viewportInfo);\n        this.removeSource(viewportInfo);\n    }\n    removeSource(viewportInfo) {\n        const index = _getViewportIndex(this._sourceViewports, viewportInfo);\n        if (index === -1) {\n            return;\n        }\n        const eventSource = this._eventSource === 'element'\n            ? this.getViewportElement(viewportInfo)\n            : eventTarget;\n        this._sourceViewports.splice(index, 1);\n        eventSource.removeEventListener(this._eventName, this._eventHandler);\n        this._auxiliaryEvents.forEach(({ name, source }) => {\n            const target = source === 'element'\n                ? this.getViewportElement(viewportInfo)\n                : eventTarget;\n            target.removeEventListener(name, this._eventHandler);\n        });\n        this._updateDisableHandlers();\n    }\n    removeTarget(viewportInfo) {\n        const index = _getViewportIndex(this._targetViewports, viewportInfo);\n        if (index === -1) {\n            return;\n        }\n        this._targetViewports.splice(index, 1);\n        this._updateDisableHandlers();\n    }\n    hasSourceViewport(renderingEngineId, viewportId) {\n        return _containsViewport(this._sourceViewports, {\n            renderingEngineId,\n            viewportId,\n        });\n    }\n    hasTargetViewport(renderingEngineId, viewportId) {\n        return _containsViewport(this._targetViewports, {\n            renderingEngineId,\n            viewportId,\n        });\n    }\n    fireEvent(sourceViewport, sourceEvent) {\n        if (this.isDisabled() || this._ignoreFiredEvents) {\n            return;\n        }\n        this._ignoreFiredEvents = true;\n        const promises = [];\n        try {\n            for (let i = 0; i < this._targetViewports.length; i++) {\n                const targetViewport = this._targetViewports[i];\n                const targetIsSource = sourceViewport.viewportId === targetViewport.viewportId;\n                if (targetIsSource) {\n                    continue;\n                }\n                const result = this._eventHandler(this, sourceViewport, targetViewport, sourceEvent, this._options);\n                if (result instanceof Promise) {\n                    promises.push(result);\n                }\n            }\n        }\n        catch (ex) {\n            console.warn(`Synchronizer, for: ${this._eventName}`, ex);\n        }\n        finally {\n            if (promises.length) {\n                Promise.allSettled(promises).then(() => {\n                    this._ignoreFiredEvents = false;\n                });\n            }\n            else {\n                this._ignoreFiredEvents = false;\n            }\n        }\n    }\n    _hasSourceElements() {\n        return this._sourceViewports.length !== 0;\n    }\n    _updateDisableHandlers() {\n        const viewports = _getUniqueViewports(this._sourceViewports, this._targetViewports);\n        const _remove = this.remove.bind(this);\n        const disableHandler = (elementDisabledEvent) => {\n            _remove(elementDisabledEvent.detail.element);\n        };\n        viewports.forEach((vp) => {\n            const eventSource = this.getEventSource(vp);\n            if (!eventSource) {\n                return;\n            }\n            eventSource.removeEventListener(Enums.Events.ELEMENT_DISABLED, disableHandler);\n            eventSource.addEventListener(Enums.Events.ELEMENT_DISABLED, disableHandler);\n        });\n    }\n    getEventSource(viewportInfo) {\n        return this._eventSource === 'element'\n            ? this.getViewportElement(viewportInfo)\n            : eventTarget;\n    }\n    getViewportElement(viewportInfo) {\n        const { renderingEngineId, viewportId } = viewportInfo;\n        const renderingEngine = getRenderingEngine(renderingEngineId);\n        if (!renderingEngine) {\n            return null;\n        }\n        const viewport = renderingEngine.getViewport(viewportId);\n        if (!viewport) {\n            return null;\n        }\n        return viewport.element;\n    }\n}\nfunction _getUniqueViewports(vp1, vp2) {\n    const unique = [];\n    const vps = vp1.concat(vp2);\n    for (let i = 0; i < vps.length; i++) {\n        const vp = vps[i];\n        if (!unique.some((u) => vp.renderingEngineId === u.renderingEngineId &&\n            vp.viewportId === u.viewportId)) {\n            unique.push(vp);\n        }\n    }\n    return unique;\n}\nfunction _getViewportIndex(arr, vp) {\n    return arr.findIndex((ar) => vp.renderingEngineId === ar.renderingEngineId &&\n        vp.viewportId === ar.viewportId);\n}\nfunction _containsViewport(arr, vp) {\n    return arr.some((ar) => ar.renderingEngineId === vp.renderingEngineId &&\n        ar.viewportId === vp.viewportId);\n}\nexport default Synchronizer;\n", "import createSynchronizer from './createSynchronizer';\nimport destroy from './destroy';\nimport getSynchronizersForViewport from './getSynchronizersForViewport';\nimport getSynchronizer from './getSynchronizer';\nimport getAllSynchronizers from './getAllSynchronizers';\nimport destroySynchronizer from './destroySynchronizer';\nexport { createSynchronizer, destroy, getSynchronizer, getSynchronizersForViewport, getAllSynchronizers, destroySynchronizer, };\n", "import { state } from '../state';\nimport Synchronizer, {} from './Synchronizer';\nfunction createSynchronizer(synchronizerId, eventName, eventHandler, options) {\n    const synchronizerWithSameIdExists = state.synchronizers.some((sync) => sync.id === synchronizerId);\n    if (synchronizerWithSameIdExists) {\n        throw new Error(`Synchronizer with id '${synchronizerId}' already exists.`);\n    }\n    const synchronizer = new Synchronizer(synchronizerId, eventName, eventHandler, options);\n    state.synchronizers.push(synchronizer);\n    return synchronizer;\n}\nexport default createSynchronizer;\n", "import { state } from '../state';\nfunction destroy() {\n    while (state.synchronizers.length > 0) {\n        const synchronizer = state.synchronizers.pop();\n        synchronizer.destroy();\n    }\n}\nexport default destroy;\n", "import { state } from '../state';\nfunction getSynchronizer(synchronizerId) {\n    return state.synchronizers.find((s) => s.id === synchronizerId);\n}\nexport default getSynchronizer;\n", "import { state } from '../state';\nfunction getAllSynchronizers() {\n    return state.synchronizers;\n}\nexport default getAllSynchronizers;\n", "import { state } from '../state';\nfunction destroySynchronizer(synchronizerId) {\n    const synchronizerIndex = state.synchronizers.findIndex((sync) => sync.id === synchronizerId);\n    if (synchronizerIndex > -1) {\n        const synchronizer = state.synchronizers[synchronizerIndex];\n        synchronizer.destroy();\n        state.synchronizers.splice(synchronizerIndex, 1);\n    }\n}\nexport default destroySynchronizer;\n", "import { triggerSegmentationRender } from '../../stateManagement/segmentation/SegmentationRenderingEngine';\nconst segmentationRepresentationModifiedListener = function (evt) {\n    const { viewportId } = evt.detail;\n    triggerSegmentationRender(viewportId);\n};\nexport default segmentationRepresentationModifiedListener;\n", "import { eventTarget, Enums } from '@cornerstonejs/core';\nimport { getAnnotationManager } from './stateManagement/annotation/annotationState';\nimport { Events as TOOLS_EVENTS } from './enums';\nimport { addEnabledElement, removeEnabledElement } from './store';\nimport { resetCornerstoneToolsState } from './store/state';\nimport { annotationCompletedListener, annotationRemovedListener, annotationSelectionListener, annotationModifiedListener, segmentationDataModifiedEventListener, segmentationModifiedListener, } from './eventListeners';\nimport { annotationInterpolationEventDispatcher } from './eventDispatchers';\nimport * as ToolGroupManager from './store/ToolGroupManager';\nimport { defaultSegmentationStateManager } from './stateManagement/segmentation/SegmentationStateManager';\nimport segmentationRepresentationModifiedListener from './eventListeners/segmentation/segmentationRepresentationModifiedListener';\nimport { setConfig } from './config';\nlet csToolsInitialized = false;\nexport function init(defaultConfiguration = {}) {\n    if (csToolsInitialized) {\n        return;\n    }\n    setConfig(defaultConfiguration);\n    _addCornerstoneEventListeners();\n    _addCornerstoneToolsEventListeners();\n    csToolsInitialized = true;\n}\nexport function destroy() {\n    _removeCornerstoneEventListeners();\n    _removeCornerstoneToolsEventListeners();\n    ToolGroupManager.destroy();\n    resetCornerstoneToolsState();\n    const annotationManager = getAnnotationManager();\n    const segmentationStateManager = defaultSegmentationStateManager;\n    annotationManager.restoreAnnotations({});\n    segmentationStateManager.resetState();\n    csToolsInitialized = false;\n}\nfunction _addCornerstoneEventListeners() {\n    _removeCornerstoneEventListeners();\n    const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\n    const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\n    eventTarget.addEventListener(elementEnabledEvent, addEnabledElement);\n    eventTarget.addEventListener(elementDisabledEvent, removeEnabledElement);\n    annotationInterpolationEventDispatcher.enable();\n}\nfunction _removeCornerstoneEventListeners() {\n    const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\n    const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\n    eventTarget.removeEventListener(elementEnabledEvent, addEnabledElement);\n    eventTarget.removeEventListener(elementDisabledEvent, removeEnabledElement);\n    annotationInterpolationEventDispatcher.disable();\n}\nfunction _addCornerstoneToolsEventListeners() {\n    _removeCornerstoneToolsEventListeners();\n    eventTarget.addEventListener(TOOLS_EVENTS.ANNOTATION_COMPLETED, annotationCompletedListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.ANNOTATION_MODIFIED, annotationModifiedListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.ANNOTATION_REMOVED, annotationRemovedListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.SEGMENTATION_MODIFIED, segmentationModifiedListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED, segmentationDataModifiedEventListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED, segmentationRepresentationModifiedListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_ADDED, segmentationRepresentationModifiedListener);\n}\nfunction _removeCornerstoneToolsEventListeners() {\n    eventTarget.removeEventListener(TOOLS_EVENTS.ANNOTATION_COMPLETED, annotationCompletedListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.ANNOTATION_MODIFIED, annotationModifiedListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.SEGMENTATION_MODIFIED, segmentationModifiedListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED, segmentationDataModifiedEventListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED, segmentationRepresentationModifiedListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_ADDED, segmentationRepresentationModifiedListener);\n}\nexport default init;\n", "import COLOR_LUT from './COLOR_LUT';\nexport { COLOR_LUT };\n", "export const version = '4.5.8';\n", "import createCameraPositionSynchronizer from './synchronizers/createCameraPositionSynchronizer';\nimport createPresentationViewSynchronizer from './synchronizers/createPresentationViewSynchronizer';\nimport createVOISynchronizer from './synchronizers/createVOISynchronizer';\nimport createZoomPanSynchronizer from './synchronizers/createZoomPanSynchronizer';\nimport createImageSliceSynchronizer from './synchronizers/createImageSliceSynchronizer';\nimport createSlabThicknessSynchronizer from './synchronizers/createSlabThicknessSynchronizer';\nconst createStackImageSynchronizer = createImageSliceSynchronizer;\nexport { createCameraPositionSynchronizer, createPresentationViewSynchronizer, createVOISynchronizer, createZoomPanSynchronizer, createImageSliceSynchronizer, createStackImageSynchronizer, createSlabThicknessSynchronizer, };\n", "import { getRenderingEngine } from '@cornerstonejs/core';\nexport default function cameraSyncCallback(synchronizerInstance, sourceViewport, targetViewport, cameraModifiedEvent) {\n    const { camera } = cameraModifiedEvent.detail;\n    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n    if (!renderingEngine) {\n        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);\n    }\n    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n    tViewport.setCamera(camera);\n    tViewport.render();\n}\n", "import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport cameraSyncCallback from '../callbacks/cameraSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createCameraPositionSynchronizer(synchronizerName) {\n    const cameraPositionSynchronizer = createSynchronizer(synchronizerName, CAMERA_MODIFIED, cameraSyncCallback);\n    return cameraPositionSynchronizer;\n}\n", "import { getRenderingEngine } from '@cornerstonejs/core';\nexport default function presentationViewSyncCallback(_synchronizerInstance, sourceViewport, targetViewport, _sourceEvent, options) {\n    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n    if (!renderingEngine) {\n        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);\n    }\n    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n    const presentationView = sViewport.getViewPresentation(options);\n    tViewport.setViewPresentation(presentationView);\n    tViewport.render();\n}\n", "import { Enums } from '@cornerstonejs/core';\nimport { createSynchronizer } from '../../store/SynchronizerManager';\nimport presentationViewSyncCallback from '../callbacks/presentationViewSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createPresentationViewSynchronizer(synchronizerName, options) {\n    const presentationView = createSynchronizer(synchronizerName, CAMERA_MODIFIED, presentationViewSyncCallback, { viewPresentation: options });\n    return presentationView;\n}\n", "import { BaseVolumeViewport, getRenderingEngine, StackViewport, } from '@cornerstonejs/core';\nexport default function voiSyncCallback(synchronizerInstance, sourceViewport, targetViewport, modifiedEvent, options) {\n    const eventDetail = modifiedEvent.detail;\n    const { volumeId, range, invertStateChanged, invert, colormap } = eventDetail;\n    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n    if (!renderingEngine) {\n        throw new Error(`Rendering Engine does not exist: ${targetViewport.renderingEngineId}`);\n    }\n    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n    const tProperties = {\n        voiRange: range,\n    };\n    if (options?.syncInvertState && invertStateChanged) {\n        tProperties.invert = invert;\n    }\n    if (options?.syncColormap && colormap) {\n        tProperties.colormap = colormap;\n    }\n    if (tViewport instanceof BaseVolumeViewport) {\n        const isFusion = tViewport._actors && tViewport._actors.size > 1;\n        if (isFusion) {\n            tViewport.setProperties(tProperties, volumeId);\n        }\n        else {\n            tViewport.setProperties(tProperties);\n        }\n    }\n    else if (tViewport instanceof StackViewport) {\n        tViewport.setProperties(tProperties);\n    }\n    else {\n        throw new Error('Viewport type not supported.');\n    }\n    tViewport.render();\n}\n", "import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport voiSyncCallback from '../callbacks/voiSyncCallback';\nexport default function createVOISynchronizer(synchronizerName, options) {\n    options = Object.assign({ syncInvertState: true, syncColormap: true }, options);\n    const VOISynchronizer = createSynchronizer(synchronizerName, Enums.Events.VOI_MODIFIED, voiSyncCallback, {\n        auxiliaryEvents: [\n            {\n                name: Enums.Events.COLORMAP_MODIFIED,\n            },\n        ],\n        ...options,\n    });\n    return VOISynchronizer;\n}\n", "import { getRenderingEngine } from '@cornerstonejs/core';\nexport default function zoomPanSyncCallback(synchronizerInstance, sourceViewport, targetViewport) {\n    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n    if (!renderingEngine) {\n        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);\n    }\n    const options = synchronizerInstance.getOptions(targetViewport.viewportId);\n    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n    if (options?.syncZoom !== false) {\n        const srcZoom = sViewport.getZoom();\n        tViewport.setZoom(srcZoom);\n    }\n    if (options?.syncPan !== false) {\n        const srcPan = sViewport.getPan();\n        tViewport.setPan(srcPan);\n    }\n    tViewport.render();\n}\n", "import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport zoomPanSyncCallback from '../callbacks/zoomPanSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createZoomPanSynchronizer(synchronizerName) {\n    const zoomPanSynchronizer = createSynchronizer(synchronizerName, CAMERA_MODIFIED, zoomPanSyncCallback);\n    return zoomPanSynchronizer;\n}\n", "import { vec3 } from 'gl-matrix';\nexport default function areViewportsCoplanar(viewport1, viewport2) {\n    const { viewPlaneNormal: viewPlaneNormal1 } = viewport1.getCamera();\n    const { viewPlaneNormal: viewPlaneNormal2 } = viewport2.getCamera();\n    const dotProducts = vec3.dot(viewPlaneNormal1, viewPlaneNormal2);\n    return Math.abs(dotProducts) > 0.9;\n}\n", "import { vec3, mat4 } from 'gl-matrix';\nimport { getRenderingEngine, metaData, utilities, VolumeViewport, } from '@cornerstonejs/core';\nimport areViewportsCoplanar from './areViewportsCoplanar';\nconst getSpatialRegistration = (targetId, sourceId) => utilities.spatialRegistrationMetadataProvider.get('spatialRegistrationModule', targetId, sourceId);\nexport default async function imageSliceSyncCallback(synchronizerInstance, sourceViewport, targetViewport) {\n    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n    if (!renderingEngine) {\n        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);\n    }\n    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n    const options = synchronizerInstance.getOptions(targetViewport.viewportId);\n    if (options?.disabled) {\n        return;\n    }\n    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n    const imageId1 = sViewport.getCurrentImageId();\n    const imagePlaneModule1 = metaData.get('imagePlaneModule', imageId1);\n    const sourceImagePositionPatient = imagePlaneModule1.imagePositionPatient;\n    const targetImageIds = tViewport.getImageIds();\n    if (!areViewportsCoplanar(sViewport, tViewport)) {\n        return;\n    }\n    let registrationMatrixMat4 = getSpatialRegistration(targetViewport.viewportId, sourceViewport.viewportId);\n    if (!registrationMatrixMat4) {\n        const frameOfReferenceUID1 = sViewport.getFrameOfReferenceUID();\n        const frameOfReferenceUID2 = tViewport.getFrameOfReferenceUID();\n        if (frameOfReferenceUID1 === frameOfReferenceUID2 &&\n            options?.useInitialPosition !== false) {\n            registrationMatrixMat4 = mat4.identity(mat4.create());\n        }\n        else {\n            utilities.calculateViewportsSpatialRegistration(sViewport, tViewport);\n            registrationMatrixMat4 = getSpatialRegistration(targetViewport.viewportId, sourceViewport.viewportId);\n        }\n        if (!registrationMatrixMat4) {\n            return;\n        }\n    }\n    const targetImagePositionPatientWithRegistrationMatrix = vec3.transformMat4(vec3.create(), sourceImagePositionPatient, registrationMatrixMat4);\n    const closestImageIdIndex2 = _getClosestImageIdIndex(targetImagePositionPatientWithRegistrationMatrix, targetImageIds);\n    let imageIndexToSet = closestImageIdIndex2.index;\n    if (tViewport instanceof VolumeViewport) {\n        imageIndexToSet = targetImageIds.length - closestImageIdIndex2.index - 1;\n    }\n    if (closestImageIdIndex2.index !== -1 &&\n        tViewport.getCurrentImageIdIndex() !== closestImageIdIndex2.index) {\n        await utilities.jumpToSlice(tViewport.element, {\n            imageIndex: imageIndexToSet,\n        });\n    }\n}\nfunction _getClosestImageIdIndex(targetPoint, imageIds) {\n    return imageIds.reduce((closestImageIdIndex, imageId, index) => {\n        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\n        const distance = vec3.distance(imagePositionPatient, targetPoint);\n        if (distance < closestImageIdIndex.distance) {\n            return {\n                distance,\n                index,\n            };\n        }\n        return closestImageIdIndex;\n    }, {\n        distance: Infinity,\n        index: -1,\n    });\n}\n", "import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport imageSliceSyncCallback from '../callbacks/imageSliceSyncCallback';\nconst { STACK_NEW_IMAGE, VOLUME_NEW_IMAGE } = Enums.Events;\nexport default function createImageSliceSynchronizer(synchronizerName) {\n    const stackImageSynchronizer = createSynchronizer(synchronizerName, STACK_NEW_IMAGE, imageSliceSyncCallback, {\n        auxiliaryEvents: [\n            {\n                name: 'VOLUME_NEW_IMAGE',\n            },\n        ],\n    });\n    return stackImageSynchronizer;\n}\n", "import { getRenderingEngine } from '@cornerstonejs/core';\nexport default function slabThicknessSyncCallback(_synchronizerInstance, sourceViewport, targetViewport) {\n    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n    if (!renderingEngine) {\n        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);\n    }\n    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n    const slabThickness = sViewport.getSlabThickness?.();\n    if (!slabThickness) {\n        return;\n    }\n    tViewport.setSlabThickness?.(slabThickness);\n    tViewport.render();\n}\n", "import { Enums } from '@cornerstonejs/core';\nimport { createSynchronizer } from '../../store/SynchronizerManager';\nimport slabThicknessSyncCallback from '../callbacks/slabThicknessSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createPresentationViewSynchronizer(synchronizerName) {\n    const presentationView = createSynchronizer(synchronizerName, CAMERA_MODIFIED, slabThicknessSyncCallback);\n    return presentationView;\n}\n", "import { utilities, triggerEvent } from '@cornerstonejs/core';\nimport { getAnnotationNearPoint, getAnnotationNearPointOnEnabledElement, } from './getAnnotationNearPoint';\nimport debounce from './debounce';\nimport throttle from './throttle';\nimport isObject from './isObject';\nimport calibrateImageSpacing from './calibrateImageSpacing';\nimport { getCalibratedLengthUnitsAndScale, getCalibratedProbeUnitsAndValue, getCalibratedAspect, } from './getCalibratedUnits';\nimport triggerAnnotationRenderForViewportIds from './triggerAnnotationRenderForViewportIds';\nimport triggerAnnotationRenderForToolGroupIds from './triggerAnnotationRenderForToolGroupIds';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport { getSphereBoundsInfo } from './getSphereBoundsInfo';\nimport { pointToString } from './pointToString';\nimport AnnotationMultiSlice from './AnnotationMultiSlice';\nimport getViewportForAnnotation from './getViewportForAnnotation';\nimport { annotationHydration, getClosestImageIdForStackViewport, } from './annotationHydration';\nimport * as contours from './contours';\nimport * as segmentation from './segmentation';\nimport * as drawing from './drawing';\nimport * as math from './math';\nimport * as planar from './planar';\nimport * as viewportFilters from './viewportFilters';\nimport * as orientation from './orientation';\nimport * as cine from './cine';\nimport * as boundingBox from './boundingBox';\nimport * as planarFreehandROITool from './planarFreehandROITool';\nimport * as rectangleROITool from './rectangleROITool';\nimport { stackPrefetch, stackContextPrefetch } from './stackPrefetch';\nimport * as viewport from './viewport';\nimport * as touch from './touch';\nimport * as dynamicVolume from './dynamicVolume';\nimport * as polyDataUtils from './polyData/utils';\nimport * as voi from './voi';\nimport * as contourSegmentation from './contourSegmentation';\nimport { pointInSurroundingSphereCallback } from './pointInSurroundingSphereCallback';\nconst roundNumber = utilities.roundNumber;\nimport normalizeViewportPlane from './normalizeViewportPlane';\nimport IslandRemoval from './segmentation/islandRemoval';\nimport { getPixelValueUnits, getPixelValueUnitsImageId, } from './getPixelValueUnits';\nimport * as geometricSurfaceUtils from './geometricSurfaceUtils';\nimport setAnnotationLabel from './setAnnotationLabel';\nimport { moveAnnotationToViewPlane } from './moveAnnotationToViewPlane';\nimport getOrCreateImageVolume from './segmentation/getOrCreateImageVolume';\nimport * as usFanExtraction from '../tools/annotation/UltrasoundPleuraBLineTool/utils/fanExtraction';\nexport { math, planar, viewportFilters, drawing, debounce, dynamicVolume, throttle, orientation, isObject, touch, triggerEvent, calibrateImageSpacing, getCalibratedLengthUnitsAndScale, getCalibratedProbeUnitsAndValue, getCalibratedAspect, getPixelValueUnits, getPixelValueUnitsImageId, segmentation, contours, triggerAnnotationRenderForViewportIds, triggerAnnotationRenderForToolGroupIds, triggerAnnotationRender, getSphereBoundsInfo, getAnnotationNearPoint, getViewportForAnnotation, getAnnotationNearPointOnEnabledElement, viewport, cine, boundingBox, rectangleROITool, planarFreehandROITool, stackPrefetch, stackContextPrefetch, roundNumber, pointToString, polyDataUtils, voi, AnnotationMultiSlice, contourSegmentation, annotationHydration, getClosestImageIdForStackViewport, pointInSurroundingSphereCallback, normalizeViewportPlane, IslandRemoval, geometricSurfaceUtils, usFanExtraction, setAnnotationLabel, moveAnnotationToViewPlane, getOrCreateImageVolume, };\n", "import { getEnabledElement } from '@cornerstonejs/core';\nimport { getAnnotations } from '../stateManagement/annotation/annotationState';\nimport * as ToolGroupManager from '../store/ToolGroupManager';\nfunction getAnnotationNearPoint(element, canvasPoint, proximity = 5) {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        throw new Error('getAnnotationNearPoint: enabledElement not found');\n    }\n    return getAnnotationNearPointOnEnabledElement(enabledElement, canvasPoint, proximity);\n}\nfunction getAnnotationNearPointOnEnabledElement(enabledElement, point, proximity) {\n    const { renderingEngineId, viewportId } = enabledElement;\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(viewportId, renderingEngineId);\n    if (!toolGroup) {\n        return null;\n    }\n    const { _toolInstances: tools } = toolGroup;\n    for (const name in tools) {\n        const found = findAnnotationNearPointByTool(tools[name], enabledElement, point, proximity);\n        if (found) {\n            return found;\n        }\n    }\n    return null;\n}\nfunction findAnnotationNearPointByTool(tool, enabledElement, point, proximity) {\n    const { viewport } = enabledElement;\n    const annotations = getAnnotations(tool.constructor.toolName, viewport?.element);\n    const currentId = viewport?.getCurrentImageId?.();\n    if (annotations?.length) {\n        const { element } = enabledElement.viewport;\n        for (const annotation of annotations) {\n            const referencedImageId = annotation.metadata?.referencedImageId;\n            if ((currentId && referencedImageId && currentId !== referencedImageId) ||\n                !tool.isPointNearTool) {\n                continue;\n            }\n            if (tool.isPointNearTool(element, annotation, point, proximity, '') ||\n                tool.getHandleNearImagePoint(element, annotation, point, proximity)) {\n                return annotation;\n            }\n        }\n    }\n    return null;\n}\nexport { getAnnotationNearPoint, getAnnotationNearPointOnEnabledElement };\n", "import { utilities, Enums } from '@cornerstonejs/core';\nconst { calibratedPixelSpacingMetadataProvider } = utilities;\nexport default function calibrateImageSpacing(imageId, renderingEngine, calibrationOrScale) {\n    if (typeof calibrationOrScale === 'number') {\n        calibrationOrScale = {\n            type: Enums.CalibrationTypes.USER,\n            scale: calibrationOrScale,\n        };\n    }\n    calibratedPixelSpacingMetadataProvider.add(imageId, calibrationOrScale);\n    const viewports = renderingEngine.getStackViewports();\n    viewports.forEach((viewport) => {\n        const imageIds = viewport.getImageIds();\n        if (imageIds.includes(imageId)) {\n            viewport.calibrateSpacing(imageId);\n        }\n    });\n}\n", "import extend2DBoundingBoxInViewAxis from './extend2DBoundingBoxInViewAxis';\nimport { getBoundingBoxAroundShapeIJK, getBoundingBoxAroundShapeWorld, } from './getBoundingBoxAroundShape';\nexport { extend2DBoundingBoxInViewAxis, getBoundingBoxAroundShapeIJK, getBoundingBoxAroundShapeWorld, getBoundingBoxAroundShapeIJK as getBoundingBoxAroundShape, };\n", "function extend2DBoundingBoxInViewAxis(boundsIJK, numSlicesToProject) {\n    const sliceNormalIndex = boundsIJK.findIndex(([min, max]) => min === max);\n    if (sliceNormalIndex === -1) {\n        throw new Error('3D bounding boxes not supported in an oblique plane');\n    }\n    boundsIJK[sliceNormalIndex][0] -= numSlicesToProject;\n    boundsIJK[sliceNormalIndex][1] += numSlicesToProject;\n    return boundsIJK;\n}\nexport default extend2DBoundingBoxInViewAxis;\n", "import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { getBoundingBoxAroundShapeIJK } from './boundingBox';\nconst { transformWorldToIndex } = csUtils;\nfunction _getSphereBoundsInfo(circlePoints, imageData, directionVectors) {\n    const [bottom, top] = circlePoints;\n    const centerWorld = vec3.fromValues((bottom[0] + top[0]) / 2, (bottom[1] + top[1]) / 2, (bottom[2] + top[2]) / 2);\n    const radiusWorld = vec3.distance(bottom, top) / 2;\n    const { boundsIJK, topLeftWorld, bottomRightWorld } = _computeBoundsIJK(imageData, directionVectors, circlePoints, centerWorld, radiusWorld);\n    return {\n        boundsIJK,\n        centerWorld: centerWorld,\n        radiusWorld,\n        topLeftWorld: topLeftWorld,\n        bottomRightWorld: bottomRightWorld,\n    };\n}\nfunction getSphereBoundsInfo(circlePoints, imageData) {\n    const direction = imageData.getDirection();\n    const rowCosine = vec3.fromValues(direction[0], direction[1], direction[2]);\n    const columnCosine = vec3.fromValues(direction[3], direction[4], direction[5]);\n    const scanAxis = vec3.fromValues(direction[6], direction[7], direction[8]);\n    const viewPlaneNormal = vec3.negate(vec3.create(), scanAxis);\n    const directionVectors = {\n        row: rowCosine,\n        column: columnCosine,\n        normal: viewPlaneNormal,\n    };\n    return _getSphereBoundsInfo(circlePoints, imageData, directionVectors);\n}\nfunction getSphereBoundsInfoFromViewport(circlePoints, imageData, viewport) {\n    if (!viewport) {\n        throw new Error('viewport is required in order to calculate the sphere bounds');\n    }\n    const camera = viewport.getCamera();\n    const viewUp = vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);\n    const viewPlaneNormal = vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const directionVectors = {\n        row: viewRight,\n        normal: viewPlaneNormal,\n        column: vec3.negate(vec3.create(), viewUp),\n    };\n    return _getSphereBoundsInfo(circlePoints, imageData, directionVectors);\n}\nfunction _computeBoundsIJK(imageData, directionVectors, circlePoints, centerWorld, radiusWorld) {\n    const dimensions = imageData.getDimensions();\n    const { row: rowCosine, column: columnCosine, normal: vecNormal, } = directionVectors;\n    const topLeftWorld = vec3.create();\n    const bottomRightWorld = vec3.create();\n    vec3.scaleAndAdd(topLeftWorld, centerWorld, vecNormal, radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, centerWorld, vecNormal, -radiusWorld);\n    vec3.scaleAndAdd(topLeftWorld, topLeftWorld, columnCosine, -radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, columnCosine, radiusWorld);\n    vec3.scaleAndAdd(topLeftWorld, topLeftWorld, rowCosine, -radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, rowCosine, radiusWorld);\n    const topLeftIJK = transformWorldToIndex(imageData, topLeftWorld);\n    const bottomRightIJK = transformWorldToIndex(imageData, bottomRightWorld);\n    const pointsIJK = circlePoints.map((p) => transformWorldToIndex(imageData, p));\n    const boundsIJK = getBoundingBoxAroundShapeIJK([topLeftIJK, bottomRightIJK, ...pointsIJK], dimensions);\n    return { boundsIJK, topLeftWorld, bottomRightWorld };\n}\nexport { getSphereBoundsInfo, getSphereBoundsInfoFromViewport };\n", "export function pointToString(point, decimals = 5) {\n    return (parseFloat(point[0]).toFixed(decimals) +\n        ',' +\n        parseFloat(point[1]).toFixed(decimals) +\n        ',' +\n        parseFloat(point[2]).toFixed(decimals) +\n        ',');\n}\n", "import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport Events from '../enums/Events';\nimport { ChangeTypes } from '../enums';\nexport default class AnnotationMultiSlice {\n    static setStartRange(viewport, annotation, startRange = viewport.getCurrentImageIdIndex()) {\n        this.setRange(viewport, annotation, startRange);\n    }\n    static setEndRange(viewport, annotation, endRange = viewport.getCurrentImageIdIndex()) {\n        this.setRange(viewport, annotation, undefined, endRange);\n    }\n    static setRange(viewport, annotation, startRange, endRange) {\n        const { metadata } = annotation;\n        if (startRange === undefined) {\n            startRange = metadata.sliceIndex < endRange ? metadata.sliceIndex : 0;\n            if (endRange === undefined) {\n                endRange = viewport.getNumberOfSlices() - 1;\n            }\n        }\n        const rangeEndSliceIndex = viewport.getSliceIndexForImage(metadata.multiSliceReference);\n        if (endRange === undefined) {\n            endRange =\n                rangeEndSliceIndex >= startRange\n                    ? rangeEndSliceIndex\n                    : viewport.getNumberOfSlices() - 1;\n        }\n        endRange = Math.max(startRange, endRange);\n        metadata.sliceIndex = Math.min(startRange, endRange);\n        metadata.referencedImageId = viewport.getCurrentImageId(metadata.sliceIndex);\n        metadata.referencedImageURI = undefined;\n        if (endRange === metadata.sliceIndex) {\n            metadata.multiSliceReference = undefined;\n        }\n        else if (endRange !== metadata.multiSliceReference?.sliceIndex) {\n            metadata.multiSliceReference = {\n                referencedImageId: viewport.getCurrentImageId(endRange),\n                sliceIndex: endRange,\n            };\n        }\n        const eventDetail = {\n            viewportId: viewport.id,\n            renderingEngineId: viewport.renderingEngineId,\n            changeType: ChangeTypes.MetadataReferenceModified,\n            annotation,\n        };\n        triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);\n        this.setViewportFrameRange(viewport, metadata);\n    }\n    static setSingle(viewport, annotation, current = viewport.getCurrentImageIdIndex()) {\n        this.setRange(viewport, annotation, current, current);\n    }\n    static getFrameRange(annotation) {\n        const { metadata } = annotation;\n        const { sliceIndex, multiSliceReference } = metadata;\n        const rangeEndSliceIndex = multiSliceReference?.sliceIndex;\n        return rangeEndSliceIndex\n            ? [sliceIndex + 1, rangeEndSliceIndex + 1]\n            : sliceIndex + 1;\n    }\n    static getFrameRangeStr(annotation) {\n        const range = this.getFrameRange(annotation);\n        return Array.isArray(range) ? `${range[0]}-${range[1]}` : String(range);\n    }\n    static setViewportFrameRange(viewport, specifier) {\n        if (viewport.setFrameRange && specifier.multiSliceReference?.sliceIndex) {\n            viewport.setFrameRange(specifier.sliceIndex + 1, specifier.multiSliceReference.sliceIndex + 1);\n        }\n    }\n}\n", "import areCoplanarContours from './areCoplanarContours';\nimport contourFinder from './contourFinder';\nimport { getDeduplicatedVTKPolyDataPoints } from './getDeduplicatedVTKPolyDataPoints';\nimport detectContourHoles from './detectContourHoles';\nimport findContourHoles from './findContourHoles';\nimport { generateContourSetsFromLabelmap } from './generateContourSetsFromLabelmap';\nimport AnnotationToPointData from './AnnotationToPointData';\nimport getContourHolesDataWorld from './getContourHolesDataWorld';\nimport getContourHolesDataCanvas from './getContourHolesDataCanvas';\nimport updateContourPolyline from './updateContourPolyline';\nimport acceptAutogeneratedInterpolations from './interpolation/acceptAutogeneratedInterpolations';\nimport findHandlePolylineIndex from './findHandlePolylineIndex';\nimport calculatePerimeter from './calculatePerimeter';\nimport findIslands from './findIslands';\nexport { areCoplanarContours, contourFinder, getDeduplicatedVTKPolyDataPoints, detectContourHoles, findContourHoles, generateContourSetsFromLabelmap, AnnotationToPointData, getContourHolesDataWorld, getContourHolesDataCanvas, updateContourPolyline, acceptAutogeneratedInterpolations, findHandlePolylineIndex, calculatePerimeter, findIslands, };\n", "import { glMatrix, vec3 } from 'gl-matrix';\nexport default function areCoplanarContours(firstAnnotation, secondAnnotation) {\n    const { viewPlaneNormal: firstViewPlaneNormal } = firstAnnotation.metadata;\n    const { viewPlaneNormal: secondViewPlaneNormal } = secondAnnotation.metadata;\n    const dot = vec3.dot(firstViewPlaneNormal, secondViewPlaneNormal);\n    const parallelPlanes = glMatrix.equals(1, Math.abs(dot));\n    if (!parallelPlanes) {\n        return false;\n    }\n    const { polyline: firstPolyline } = firstAnnotation.data.contour;\n    const { polyline: secondPolyline } = secondAnnotation.data.contour;\n    const firstDistance = vec3.dot(firstViewPlaneNormal, firstPolyline[0]);\n    const secondDistance = vec3.dot(firstViewPlaneNormal, secondPolyline[0]);\n    return glMatrix.equals(firstDistance, secondDistance);\n}\n", "function findNextLink(line, lines, contourPoints) {\n    let index = -1;\n    lines.forEach((cell, i) => {\n        if (index >= 0) {\n            return;\n        }\n        if (cell.a == line.b) {\n            index = i;\n        }\n    });\n    if (index >= 0) {\n        const nextLine = lines[index];\n        lines.splice(index, 1);\n        contourPoints.push(nextLine.b);\n        if (contourPoints[0] == nextLine.b) {\n            return {\n                remainingLines: lines,\n                contourPoints,\n                type: 'CLOSED_PLANAR',\n            };\n        }\n        return findNextLink(nextLine, lines, contourPoints);\n    }\n    return {\n        remainingLines: lines,\n        contourPoints,\n        type: 'OPEN_PLANAR',\n    };\n}\nexport function findContours(lines) {\n    if (lines.length == 0) {\n        return [];\n    }\n    const contourPoints = [];\n    const firstCell = lines.shift();\n    contourPoints.push(firstCell.a);\n    contourPoints.push(firstCell.b);\n    const result = findNextLink(firstCell, lines, contourPoints);\n    if (result.remainingLines.length == 0) {\n        return [\n            {\n                type: result.type,\n                contourPoints: result.contourPoints,\n            },\n        ];\n    }\n    else {\n        const extraContours = findContours(result.remainingLines);\n        extraContours.push({\n            type: result.type,\n            contourPoints: result.contourPoints,\n        });\n        return extraContours;\n    }\n}\nexport function findContoursFromReducedSet(lines) {\n    return findContours(lines);\n}\nexport default {\n    findContours,\n    findContoursFromReducedSet,\n};\n", "export function getDeduplicatedVTKPolyDataPoints(polyData, bypass = false) {\n    const points = polyData.getPoints();\n    const lines = polyData.getLines();\n    const pointsArray = new Array(points.getNumberOfPoints())\n        .fill(0)\n        .map((_, i) => points.getPoint(i).slice());\n    const linesArray = new Array(lines.getNumberOfCells()).fill(0).map((_, i) => {\n        const cell = lines.getCell(i * 3).slice();\n        return { a: cell[0], b: cell[1] };\n    });\n    if (bypass) {\n        return { points: pointsArray, lines: linesArray };\n    }\n    const newPoints = [];\n    for (const [i, pt] of pointsArray.entries()) {\n        const index = newPoints.findIndex((point) => point[0] === pt[0] && point[1] === pt[1] && point[2] === pt[2]);\n        if (index >= 0) {\n            linesArray.map((line) => {\n                if (line.a === i) {\n                    line.a = index;\n                }\n                if (line.b === i) {\n                    line.b = index;\n                }\n                return line;\n            });\n        }\n        else {\n            const newIndex = newPoints.length;\n            newPoints.push(pt);\n            linesArray.map((line) => {\n                if (line.a === i) {\n                    line.a = newIndex;\n                }\n                if (line.b === i) {\n                    line.b = newIndex;\n                }\n                return line;\n            });\n        }\n    }\n    const newLines = linesArray.filter((line) => line.a !== line.b);\n    return { points: newPoints, lines: newLines };\n}\nexport default { getDeduplicatedVTKPolyDataPoints };\n", "const getIsPointInsidePolygon = (point, vertices) => {\n    const x = point[0];\n    const y = point[1];\n    let inside = false;\n    for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {\n        const xi = vertices[i][0], yi = vertices[i][1];\n        const xj = vertices[j][0], yj = vertices[j][1];\n        const intersect = yi > y != yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;\n        if (intersect) {\n            inside = !inside;\n        }\n    }\n    return inside;\n};\nfunction checkEnclosed(outerContour, innerContour, points) {\n    const vertices = [];\n    outerContour.contourPoints.forEach((point) => {\n        vertices.push([points[point][0], points[point][1]]);\n    });\n    let pointsNotEnclosed = 0;\n    innerContour.contourPoints.forEach((point) => {\n        const result = getIsPointInsidePolygon([points[point][0], points[point][1]], vertices);\n        if (!result) {\n            pointsNotEnclosed++;\n        }\n    });\n    return pointsNotEnclosed === 0;\n}\nexport function processContourHoles(contours, points, useXOR = true) {\n    const retContours = contours.filter((contour) => contour.type !== 'CLOSED_PLANAR');\n    const closedContours = contours.filter((contour) => contour.type === 'CLOSED_PLANAR');\n    const contourWithHoles = [];\n    let contourWithoutHoles = [];\n    closedContours.forEach((contour, index) => {\n        const holes = [];\n        closedContours.forEach((hContour, hIndex) => {\n            if (index != hIndex) {\n                if (checkEnclosed(contour, hContour, points)) {\n                    holes.push(hIndex);\n                }\n            }\n        });\n        if (holes.length > 0) {\n            contourWithHoles.push({\n                contour,\n                holes,\n            });\n        }\n        else {\n            contourWithoutHoles.push(index);\n        }\n    });\n    if (useXOR) {\n        contourWithHoles.forEach((contourHoleSet) => {\n            contourHoleSet.contour.type = 'CLOSEDPLANAR_XOR';\n            retContours.push(contourHoleSet.contour);\n            contourHoleSet.holes.forEach((holeIndex) => {\n                closedContours[holeIndex].type = 'CLOSEDPLANAR_XOR';\n                retContours.push(closedContours[holeIndex]);\n                contourWithoutHoles = contourWithoutHoles.filter((contourIndex) => {\n                    return contourIndex !== holeIndex;\n                });\n            });\n        });\n        contourWithoutHoles.forEach((contourIndex) => {\n            retContours.push(closedContours[contourIndex]);\n        });\n    }\n    else {\n    }\n    return retContours;\n}\nexport default { processContourHoles };\n", "import getSignedArea from '../math/polyline/getSignedArea';\nimport containsPoints from '../math/polyline/containsPoints';\nimport isClosed from '../math/polyline/isClosed';\nfunction isPolygonInsidePolygon(inner, outer) {\n    return containsPoints(outer, inner);\n}\nexport default function findContourHoles(polylines) {\n    const results = [];\n    const closedPolylines = [];\n    polylines.forEach((polyline, index) => {\n        if (isClosed(polyline)) {\n            closedPolylines.push({ polyline, originalIndex: index });\n        }\n    });\n    for (let i = 0; i < closedPolylines.length; i++) {\n        const outerContour = closedPolylines[i];\n        const outerArea = Math.abs(getSignedArea(outerContour.polyline));\n        const holeIndexes = [];\n        for (let j = 0; j < closedPolylines.length; j++) {\n            if (i === j) {\n                continue;\n            }\n            const potentialHole = closedPolylines[j];\n            const holeArea = Math.abs(getSignedArea(potentialHole.polyline));\n            if (holeArea < outerArea &&\n                isPolygonInsidePolygon(potentialHole.polyline, outerContour.polyline)) {\n                holeIndexes.push(potentialHole.originalIndex);\n            }\n        }\n        if (holeIndexes.length > 0) {\n            results.push({\n                contourIndex: outerContour.originalIndex,\n                holeIndexes: holeIndexes.sort((a, b) => a - b),\n            });\n        }\n    }\n    return results.sort((a, b) => a.contourIndex - b.contourIndex);\n}\nexport { findContourHoles };\n", "import { getWebWorkerManager } from '@cornerstonejs/core';\nimport { getConfig } from '../config';\nlet registered = false;\nexport function registerComputeWorker() {\n    if (registered) {\n        return;\n    }\n    registered = true;\n    const workerFn = () => {\n        return new Worker(new URL('../workers/computeWorker.js', import.meta.url), {\n            name: 'compute',\n            type: 'module',\n        });\n    };\n    const workerManager = getWebWorkerManager();\n    const config = getConfig();\n    const computeWorkerConfig = config.computeWorker;\n    const options = {\n        maxWorkerInstances: 1,\n        autoTerminateOnIdle: computeWorkerConfig?.autoTerminateOnIdle ?? {\n            enabled: true,\n            idleTimeThreshold: 2000,\n        },\n    };\n    workerManager.registerWorker('compute', workerFn, options);\n}\n", "import { getSegmentation } from './getSegmentation';\nimport { getSegmentations } from './getSegmentations';\nimport { addSegmentations } from './addSegmentations';\nimport { removeAllSegmentations, removeSegmentation, } from './removeSegmentation';\nimport { removeLabelmapRepresentation, removeContourRepresentation, removeSurfaceRepresentation, removeSegmentationRepresentation, removeAllSegmentationRepresentations, } from './removeSegmentationRepresentations';\nimport { addColorLUT } from './addColorLUT';\nimport { getColorLUT } from './getColorLUT';\nimport { getNextColorLUTIndex } from './getNextColorLUTIndex';\nimport { removeColorLUT } from './removeColorLUT';\nimport { getViewportSegmentations, getViewportSegmentationRepresentations, } from './getViewportSegmentations';\nimport { getViewportIdsWithSegmentation } from './getViewportIdsWithSegmentation';\nimport { getCurrentLabelmapImageIdForViewport, getCurrentLabelmapImageIdsForViewport, } from './getCurrentLabelmapImageIdForViewport';\nimport { updateLabelmapSegmentationImageReferences } from './updateLabelmapSegmentationImageReferences';\nimport { getStackSegmentationImageIdsForViewport } from './getStackSegmentationImageIdsForViewport';\nimport { getSegmentationRepresentation, getSegmentationRepresentations, getSegmentationRepresentationsBySegmentationId, } from './getSegmentationRepresentation';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nfunction destroy() {\n    defaultSegmentationStateManager.resetState();\n}\nexport { getColorLUT, getCurrentLabelmapImageIdForViewport, getCurrentLabelmapImageIdsForViewport, getNextColorLUTIndex, getSegmentation, getSegmentations, getStackSegmentationImageIdsForViewport, getViewportIdsWithSegmentation, getSegmentationRepresentation, getSegmentationRepresentations, getViewportSegmentationRepresentations, removeColorLUT, getViewportSegmentations, removeSegmentation, removeLabelmapRepresentation, removeContourRepresentation, removeSurfaceRepresentation, removeSegmentationRepresentation, removeAllSegmentationRepresentations, removeAllSegmentations, addColorLUT, addSegmentations, updateLabelmapSegmentationImageReferences, getSegmentationRepresentationsBySegmentationId, destroy, };\n", "import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getSegmentations() {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const state = segmentationStateManager.getState();\n    return state.segmentations;\n}\n", "import { SegmentationRepresentations } from '../../../enums';\nimport { cache } from '@cornerstonejs/core';\nfunction normalizeSegmentationInput(segmentationInput) {\n    const { segmentationId, representation, config } = segmentationInput;\n    const { type, data: inputData } = representation;\n    const data = inputData ? { ...inputData } : {};\n    if (!data) {\n        throw new Error('Segmentation representation data may not be undefined');\n    }\n    if (type === SegmentationRepresentations.Contour) {\n        normalizeContourData(data);\n    }\n    const normalizedSegments = normalizeSegments(config?.segments, type, data);\n    delete config?.segments;\n    return {\n        segmentationId,\n        label: config?.label ?? null,\n        cachedStats: config?.cachedStats ?? {},\n        segments: normalizedSegments,\n        representationData: {\n            [type]: {\n                ...data,\n            },\n        },\n    };\n}\nfunction normalizeContourData(contourData) {\n    contourData.geometryIds = contourData.geometryIds ?? [];\n    contourData.annotationUIDsMap = contourData.annotationUIDsMap ?? new Map();\n}\nfunction normalizeSegments(segmentsConfig, type, data) {\n    const normalizedSegments = {};\n    if (segmentsConfig) {\n        Object.entries(segmentsConfig).forEach(([segmentIndex, segment]) => {\n            const { label, locked, cachedStats, active, ...rest } = segment;\n            const normalizedSegment = {\n                segmentIndex: Number(segmentIndex),\n                label: label ?? `Segment ${segmentIndex}`,\n                locked: locked ?? false,\n                cachedStats: cachedStats ?? {},\n                active: active ?? false,\n                ...rest,\n            };\n            normalizedSegments[segmentIndex] = normalizedSegment;\n        });\n    }\n    else if (type === SegmentationRepresentations.Contour) {\n        normalizeContourSegments(normalizedSegments, data);\n    }\n    else if (type === SegmentationRepresentations.Surface) {\n        normalizeSurfaceSegments(normalizedSegments, data);\n    }\n    else {\n        normalizedSegments[1] = createDefaultSegment();\n    }\n    return normalizedSegments;\n}\nfunction normalizeContourSegments(normalizedSegments, contourData) {\n    const { geometryIds } = contourData;\n    geometryIds?.forEach((geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        if (geometry?.data) {\n            const { segmentIndex } = geometry.data;\n            normalizedSegments[segmentIndex] = { segmentIndex };\n        }\n    });\n}\nfunction normalizeSurfaceSegments(normalizedSegments, surfaceData) {\n    const { geometryIds } = surfaceData;\n    geometryIds?.forEach((geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        if (geometry?.data) {\n            const { segmentIndex } = geometry.data;\n            normalizedSegments[segmentIndex] = { segmentIndex };\n        }\n    });\n}\nfunction createDefaultSegment() {\n    return {\n        segmentIndex: 1,\n        label: 'Segment 1',\n        locked: false,\n        cachedStats: {},\n        active: true,\n    };\n}\nexport default normalizeSegmentationInput;\n", "import { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nimport normalizeSegmentationInput from './helpers/normalizeSegmentationInput';\nexport function addSegmentations(segmentationInputArray, suppressEvents) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    segmentationInputArray.forEach((segmentationInput) => {\n        const segmentation = normalizeSegmentationInput(segmentationInput);\n        segmentationStateManager.addSegmentation(segmentation);\n        if (!suppressEvents) {\n            triggerSegmentationModified(segmentation.segmentationId);\n        }\n    });\n}\nexport default addSegmentations;\n", "import SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport labelmapDisplay from '../../tools/displayTools/Labelmap/labelmapDisplay';\nimport contourDisplay from '../../tools/displayTools/Contour/contourDisplay';\nimport { getSegmentationRepresentations } from './getSegmentationRepresentation';\nimport { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { surfaceDisplay } from '../../tools/displayTools/Surface';\nfunction removeSegmentationRepresentation(viewportId, specifier, immediate) {\n    return _removeSegmentationRepresentations(viewportId, specifier, immediate);\n}\nfunction removeSegmentationRepresentations(viewportId, specifier, immediate) {\n    return _removeSegmentationRepresentations(viewportId, specifier, immediate);\n}\nfunction _removeSegmentationRepresentations(viewportId, specifier, immediate) {\n    const { segmentationId, type } = specifier;\n    _removeRepresentationObject(viewportId, segmentationId, type, immediate);\n    return defaultSegmentationStateManager.removeSegmentationRepresentations(viewportId, {\n        segmentationId,\n        type,\n    });\n}\nfunction removeAllSegmentationRepresentations() {\n    const state = defaultSegmentationStateManager.getAllViewportSegmentationRepresentations();\n    state.forEach(({ viewportId, representations }) => {\n        representations.forEach(({ segmentationId, type }) => {\n            removeSegmentationRepresentation(viewportId, {\n                segmentationId,\n                type,\n            });\n        });\n    });\n    defaultSegmentationStateManager.resetState();\n}\nfunction removeLabelmapRepresentation(viewportId, segmentationId, immediate) {\n    removeSegmentationRepresentation(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Labelmap,\n    }, immediate);\n}\nfunction removeContourRepresentation(viewportId, segmentationId, immediate) {\n    removeSegmentationRepresentation(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Contour,\n    }, immediate);\n}\nfunction removeSurfaceRepresentation(viewportId, segmentationId, immediate) {\n    removeSegmentationRepresentation(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Surface,\n    }, immediate);\n}\nfunction _removeRepresentationObject(viewportId, segmentationId, type, immediate) {\n    const representations = getSegmentationRepresentations(viewportId, {\n        segmentationId,\n        type,\n    });\n    representations.forEach((representation) => {\n        if (representation.type === SegmentationRepresentations.Labelmap) {\n            labelmapDisplay.removeRepresentation(viewportId, representation.segmentationId, immediate);\n        }\n        else if (representation.type === SegmentationRepresentations.Contour) {\n            contourDisplay.removeRepresentation(viewportId, representation.segmentationId, immediate);\n        }\n        else if (representation.type === SegmentationRepresentations.Surface) {\n            surfaceDisplay.removeRepresentation(viewportId, representation.segmentationId, immediate);\n        }\n    });\n    const { viewport } = getEnabledElementByViewportId(viewportId) || {};\n    if (viewport) {\n        viewport.render();\n    }\n}\nexport { removeSegmentationRepresentation, removeSegmentationRepresentations, removeAllSegmentationRepresentations, removeLabelmapRepresentation, removeContourRepresentation, removeSurfaceRepresentation, };\n", "import { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { triggerSegmentationRemoved } from './triggerSegmentationEvents';\nimport { removeSegmentationRepresentations } from './removeSegmentationRepresentations';\nexport function removeSegmentation(segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const viewportsWithSegmentation = segmentationStateManager\n        .getAllViewportSegmentationRepresentations()\n        .filter(({ representations }) => representations.some((rep) => rep.segmentationId === segmentationId))\n        .map(({ viewportId }) => viewportId);\n    viewportsWithSegmentation.forEach((viewportId) => {\n        removeSegmentationRepresentations(viewportId, { segmentationId });\n    });\n    segmentationStateManager.removeSegmentation(segmentationId);\n    triggerSegmentationRemoved(segmentationId);\n}\nexport function removeAllSegmentations() {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const segmentations = segmentationStateManager.getState().segmentations;\n    const segmentationIds = segmentations.map((segmentation) => segmentation.segmentationId);\n    segmentationIds.forEach((segmentationId) => {\n        removeSegmentation(segmentationId);\n    });\n    segmentationStateManager.resetState();\n}\n", "import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function removeColorLUT(colorLUTIndex) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    segmentationStateManager.removeColorLUT(colorLUTIndex);\n}\n", "import { getSegmentation } from './getSegmentation';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getViewportSegmentations(viewportId, type) {\n    const viewportRepresentations = getViewportSegmentationRepresentations(viewportId);\n    const segmentations = viewportRepresentations.map((representation) => {\n        if (type && representation.type === type) {\n            return getSegmentation(representation.segmentationId);\n        }\n        return getSegmentation(representation.segmentationId);\n    });\n    const filteredSegmentations = segmentations.filter((segmentation) => segmentation !== undefined);\n    return filteredSegmentations;\n}\nexport function getViewportSegmentationRepresentations(viewportId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const state = segmentationStateManager.getState();\n    const viewportRepresentations = state.viewportSegRepresentations[viewportId];\n    return viewportRepresentations;\n}\n", "import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getStackSegmentationImageIdsForViewport(viewportId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getStackSegmentationImageIdsForViewport(viewportId, segmentationId);\n}\n", "import { cache } from '@cornerstonejs/core';\nfunction validateRepresentationData(segmentationRepresentationData) {\n    if ('volumeId' in segmentationRepresentationData) {\n        segmentationRepresentationData =\n            segmentationRepresentationData;\n        const cachedVolume = cache.getVolume(segmentationRepresentationData.volumeId);\n        if (!cachedVolume) {\n            throw new Error(`volumeId of ${segmentationRepresentationData.volumeId} not found in cache, you should load and cache volume before adding segmentation`);\n        }\n    }\n    else if ('imageIds' in segmentationRepresentationData) {\n        segmentationRepresentationData =\n            segmentationRepresentationData;\n        if (!segmentationRepresentationData.imageIds) {\n            throw new Error('The segmentationInput.representationData.imageIds is undefined, please provide a valid representationData.imageIds for stack data');\n        }\n    }\n    else {\n        throw new Error('The segmentationInput.representationData is undefined, please provide a valid representationData');\n    }\n}\nexport function validatePublic(segmentationInput) {\n    if (!segmentationInput.representation.data) {\n        throw new Error('The segmentationInput.representationData.data is undefined, please provide a valid representationData.data');\n    }\n    const representationData = segmentationInput.representation\n        .data;\n    validateRepresentationData(representationData);\n}\nexport function validate(segmentationRepresentationData) {\n    validateRepresentationData(segmentationRepresentationData);\n}\n", "import { cache } from '@cornerstonejs/core';\nexport function getReferenceVolumeForSegmentationVolume(segmentationVolumeId) {\n    const segmentationVolume = cache.getVolume(segmentationVolumeId);\n    if (!segmentationVolume) {\n        return null;\n    }\n    const referencedVolumeId = segmentationVolume.referencedVolumeId;\n    let imageVolume;\n    if (referencedVolumeId) {\n        imageVolume = cache.getVolume(referencedVolumeId);\n    }\n    else {\n        const imageIds = segmentationVolume.imageIds;\n        const image = cache.getImage(imageIds[0]);\n        const referencedImageId = image.referencedImageId;\n        const volumeInfo = cache.getVolumeContainingImageId(referencedImageId);\n        imageVolume = volumeInfo?.volume;\n    }\n    return imageVolume;\n}\n", "import { cache, Enums, eventTarget } from '@cornerstonejs/core';\nimport { getCurrentLabelmapImageIdForViewport } from '../../../../stateManagement/segmentation/segmentationState';\nimport { getLabelmapActorEntry } from '../../../../stateManagement/segmentation/helpers';\nimport { getReferenceVolumeForSegmentationVolume } from '../../../../utilities/segmentation/getReferenceVolumeForSegmentationVolume';\nfunction getStrategyDataForVolumeViewport({ operationData }) {\n    const { volumeId } = operationData;\n    if (!volumeId) {\n        const event = new CustomEvent(Enums.Events.ERROR_EVENT, {\n            detail: {\n                type: 'Segmentation',\n                message: 'No volume id found for the segmentation',\n            },\n            cancelable: true,\n        });\n        eventTarget.dispatchEvent(event);\n        return null;\n    }\n    const segmentationVolume = cache.getVolume(volumeId);\n    const imageVolume = getReferenceVolumeForSegmentationVolume(volumeId);\n    if (!segmentationVolume || !imageVolume) {\n        return null;\n    }\n    const { imageData: segmentationImageData } = segmentationVolume;\n    const { voxelManager: segmentationVoxelManager } = segmentationVolume;\n    const { voxelManager: imageVoxelManager, imageData } = imageVolume;\n    return {\n        segmentationImageData,\n        segmentationVoxelManager,\n        segmentationScalarData: null,\n        imageScalarData: null,\n        imageVoxelManager,\n        imageData,\n    };\n}\nfunction getStrategyDataForStackViewport({ operationData, viewport, strategy, }) {\n    const { segmentationId } = operationData;\n    let segmentationImageData;\n    let segmentationVoxelManager;\n    let segmentationScalarData;\n    let imageScalarData;\n    let imageVoxelManager;\n    let imageData;\n    if (strategy.ensureSegmentationVolumeFor3DManipulation) {\n        strategy.ensureSegmentationVolumeFor3DManipulation({\n            operationData,\n            viewport,\n        });\n        segmentationVoxelManager = operationData.segmentationVoxelManager;\n        segmentationImageData = operationData.segmentationImageData;\n        segmentationScalarData = null;\n    }\n    else {\n        const labelmapImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n        if (!labelmapImageId) {\n            return null;\n        }\n        const actorEntry = getLabelmapActorEntry(viewport.id, segmentationId);\n        if (!actorEntry) {\n            return null;\n        }\n        const currentSegImage = cache.getImage(labelmapImageId);\n        segmentationImageData = actorEntry.actor.getMapper().getInputData();\n        segmentationVoxelManager = currentSegImage.voxelManager;\n        const currentSegmentationImageId = operationData.imageId;\n        const segmentationImage = cache.getImage(currentSegmentationImageId);\n        if (!segmentationImage) {\n            return null;\n        }\n        segmentationScalarData = segmentationImage.getPixelData?.();\n    }\n    if (strategy.ensureImageVolumeFor3DManipulation) {\n        strategy.ensureImageVolumeFor3DManipulation({\n            operationData,\n            viewport,\n        });\n        imageVoxelManager = operationData.imageVoxelManager;\n        imageScalarData = operationData.imageScalarData;\n        imageData = operationData.imageData;\n    }\n    else {\n        const currentImageId = viewport.getCurrentImageId();\n        if (!currentImageId) {\n            return null;\n        }\n        const image = cache.getImage(currentImageId);\n        imageData = image ? null : viewport.getImageData();\n        imageScalarData = image?.getPixelData() || imageData.getScalarData();\n        imageVoxelManager = image?.voxelManager;\n    }\n    return {\n        segmentationImageData,\n        segmentationScalarData,\n        imageScalarData,\n        segmentationVoxelManager,\n        imageVoxelManager,\n        imageData,\n    };\n}\nfunction getStrategyData({ operationData, viewport, strategy, }) {\n    if (!operationData) {\n        return null;\n    }\n    if (('volumeId' in operationData && operationData.volumeId != null) ||\n        ('referencedVolumeId' in operationData &&\n            operationData.referencedVolumeId != null)) {\n        return getStrategyDataForVolumeViewport({ operationData });\n    }\n    return getStrategyDataForStackViewport({ operationData, viewport, strategy });\n}\nexport { getStrategyData };\n", "import { cache, volumeLoader, utilities, } from '@cornerstonejs/core';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nfunction getOrCreateSegmentationVolume(segmentationId) {\n    const { representationData } = getSegmentation(segmentationId);\n    let { volumeId } = representationData.Labelmap;\n    let segVolume;\n    if (volumeId) {\n        segVolume = cache.getVolume(volumeId);\n        if (segVolume) {\n            return segVolume;\n        }\n    }\n    const { imageIds: labelmapImageIds } = representationData.Labelmap;\n    volumeId = cache.generateVolumeId(labelmapImageIds);\n    if (!labelmapImageIds || labelmapImageIds.length === 1) {\n        return;\n    }\n    const isValidVolume = utilities.isValidVolume(labelmapImageIds);\n    if (!isValidVolume) {\n        return;\n    }\n    segVolume = volumeLoader.createAndCacheVolumeFromImagesSync(volumeId, labelmapImageIds);\n    return segVolume;\n}\nexport default getOrCreateSegmentationVolume;\n", "import { utilities, cache } from '@cornerstonejs/core';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport getOrCreateSegmentationVolume from '../../../../utilities/segmentation/getOrCreateSegmentationVolume';\nexport default {\n    [StrategyCallbacks.EnsureSegmentationVolumeFor3DManipulation]: (data) => {\n        const { operationData, viewport } = data;\n        const { segmentationId, imageIds: segImageIds } = operationData;\n        const referencedImageIds = viewport\n            ? viewport.getImageIds()\n            : segImageIds.map((imageId) => cache.getImage(imageId).referencedImageId);\n        const isValidVolumeForSphere = utilities.isValidVolume(referencedImageIds);\n        if (!isValidVolumeForSphere) {\n            throw new Error('Volume is not reconstructable for sphere manipulation');\n        }\n        const segVolume = getOrCreateSegmentationVolume(segmentationId);\n        if (!segVolume) {\n            return;\n        }\n        operationData.segmentationVoxelManager = segVolume.voxelManager;\n        operationData.segmentationImageData = segVolume.imageData;\n        return;\n    },\n};\n", "import { cache, volumeLoader, utilities as csUtils, } from '@cornerstonejs/core';\nfunction getOrCreateImageVolume(referencedImageIds) {\n    if (!referencedImageIds || referencedImageIds.length <= 1) {\n        return;\n    }\n    const isValidVolume = csUtils.isValidVolume(referencedImageIds);\n    if (!isValidVolume) {\n        return;\n    }\n    const volumeId = cache.generateVolumeId(referencedImageIds);\n    let imageVolume = cache.getVolume(volumeId);\n    if (imageVolume) {\n        return imageVolume;\n    }\n    imageVolume = volumeLoader.createAndCacheVolumeFromImagesSync(volumeId, referencedImageIds);\n    return imageVolume;\n}\nexport default getOrCreateImageVolume;\n", "import { cache, utilities as csUtils } from '@cornerstonejs/core';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport { getSegmentation } from '../../../../stateManagement/segmentation/getSegmentation';\nimport getOrCreateImageVolume from '../../../../utilities/segmentation/getOrCreateImageVolume';\nexport default {\n    [StrategyCallbacks.EnsureImageVolumeFor3DManipulation]: (data) => {\n        const { operationData, viewport } = data;\n        let referencedImageIds;\n        if (viewport) {\n            referencedImageIds = viewport.getImageIds();\n            const isValidVolumeForSphere = csUtils.isValidVolume(referencedImageIds);\n            if (!isValidVolumeForSphere) {\n                throw new Error('Volume is not reconstructable for sphere manipulation');\n            }\n        }\n        else {\n            const segmentation = getSegmentation(operationData.segmentationId);\n            const imageIds = segmentation.representationData\n                .Labelmap.imageIds;\n            referencedImageIds = imageIds.map((imageId) => {\n                const image = cache.getImage(imageId);\n                return image.referencedImageId;\n            });\n        }\n        const imageVolume = getOrCreateImageVolume(referencedImageIds);\n        if (!imageVolume) {\n            throw new Error('Failed to create or get image volume');\n        }\n        operationData.imageVoxelManager = imageVolume.voxelManager;\n        operationData.imageData = imageVolume.imageData;\n    },\n};\n", "import { cache, utilities, eventTarget, Enums, triggerEvent, metaData, } from '@cornerstonejs/core';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport { getStrategyData } from '../../tools/segmentation/strategies/utils/getStrategyData';\nimport ensureSegmentationVolume from '../../tools/segmentation/strategies/compositions/ensureSegmentationVolume';\nimport ensureImageVolume from '../../tools/segmentation/strategies/compositions/ensureImageVolume';\nexport const triggerWorkerProgress = (workerType, progress) => {\n    triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\n        progress,\n        type: workerType,\n    });\n};\nexport const getSegmentationDataForWorker = (segmentationId, segmentIndices) => {\n    const segmentation = getSegmentation(segmentationId);\n    const { representationData } = segmentation;\n    const { Labelmap } = representationData;\n    if (!Labelmap) {\n        console.debug('No labelmap found for segmentation', segmentationId);\n        return null;\n    }\n    const segVolumeId = Labelmap.volumeId;\n    const segImageIds = Labelmap.imageIds;\n    const operationData = {\n        segmentationId,\n        volumeId: segVolumeId,\n        imageIds: segImageIds,\n    };\n    let reconstructableVolume = false;\n    if (segImageIds) {\n        const refImageIds = segImageIds.map((imageId) => {\n            const image = cache.getImage(imageId);\n            return image.referencedImageId;\n        });\n        reconstructableVolume = utilities.isValidVolume(refImageIds);\n    }\n    let indices = segmentIndices;\n    if (!indices) {\n        indices = [getActiveSegmentIndex(segmentationId)];\n    }\n    else if (!Array.isArray(indices)) {\n        indices = [indices, 255];\n    }\n    return {\n        operationData,\n        segVolumeId,\n        segImageIds,\n        reconstructableVolume,\n        indices,\n    };\n};\nexport const prepareVolumeStrategyDataForWorker = (operationData) => {\n    return getStrategyData({\n        operationData,\n        strategy: {\n            ensureSegmentationVolumeFor3DManipulation: ensureSegmentationVolume.ensureSegmentationVolumeFor3DManipulation,\n            ensureImageVolumeFor3DManipulation: ensureImageVolume.ensureImageVolumeFor3DManipulation,\n        },\n    });\n};\nexport const prepareImageInfo = (imageVoxelManager, imageData) => {\n    const imageScalarData = imageVoxelManager.getCompleteScalarDataArray();\n    return {\n        scalarData: imageScalarData,\n        dimensions: imageData.getDimensions(),\n        spacing: imageData.getSpacing(),\n        origin: imageData.getOrigin(),\n        direction: imageData.getDirection(),\n    };\n};\nexport const prepareStackDataForWorker = (segImageIds) => {\n    const segmentationInfo = [];\n    const imageInfo = [];\n    for (const segImageId of segImageIds) {\n        const segImage = cache.getImage(segImageId);\n        const segPixelData = segImage.getPixelData();\n        const { origin, direction, spacing, dimensions } = utilities.getImageDataMetadata(segImage);\n        segmentationInfo.push({\n            scalarData: segPixelData,\n            dimensions,\n            spacing,\n            origin,\n            direction,\n        });\n        const refImageId = segImage.referencedImageId;\n        if (refImageId) {\n            const refImage = cache.getImage(refImageId);\n            if (!refImage) {\n                continue;\n            }\n            const refPixelData = refImage.getPixelData();\n            const refVoxelManager = refImage.voxelManager;\n            const refSpacing = [\n                refImage.rowPixelSpacing,\n                refImage.columnPixelSpacing,\n            ];\n            imageInfo.push({\n                scalarData: refPixelData,\n                dimensions: refVoxelManager\n                    ? refVoxelManager.dimensions\n                    : [refImage.columns, refImage.rows, 1],\n                spacing: refSpacing,\n            });\n        }\n    }\n    return { segmentationInfo, imageInfo };\n};\nexport const getImageReferenceInfo = (segVolumeId, segImageIds) => {\n    let refImageId;\n    if (segVolumeId) {\n        const segmentationVolume = cache.getVolume(segVolumeId);\n        const imageIds = segmentationVolume.imageIds;\n        const cachedImage = cache.getImage(imageIds[0]);\n        if (cachedImage) {\n            refImageId = cachedImage.referencedImageId;\n        }\n    }\n    else if (segImageIds?.length) {\n        const segImage = cache.getImage(segImageIds[0]);\n        refImageId = segImage.referencedImageId;\n    }\n    const refImage = cache.getImage(refImageId);\n    const scalingModule = metaData.get('scalingModule', refImageId);\n    const modalityUnitOptions = {\n        isPreScaled: Boolean(refImage?.preScale?.scaled),\n        isSuvScaled: typeof scalingModule?.suvbw === 'number',\n    };\n    return { refImageId, modalityUnitOptions };\n};\n", "import { cache as cornerstoneCache, getWebWorkerManager, cache, utilities, } from '@cornerstonejs/core';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport { WorkerTypes } from '../../enums';\nimport { registerComputeWorker } from '../registerComputeWorker';\nimport { triggerWorkerProgress } from '../segmentation/utilsForWorker';\nimport getOrCreateSegmentationVolume from '../segmentation/getOrCreateSegmentationVolume';\nconst { Labelmap } = SegmentationRepresentations;\nasync function generateContourSetsFromLabelmap({ segmentations }) {\n    registerComputeWorker();\n    triggerWorkerProgress(WorkerTypes.GENERATE_CONTOUR_SETS, 0);\n    const { representationData, segments = [0, 1], segmentationId, } = segmentations;\n    let { volumeId: segVolumeId } = representationData[Labelmap];\n    if (!segVolumeId) {\n        const segVolume = getOrCreateSegmentationVolume(segmentationId);\n        if (segVolume) {\n            segVolumeId = segVolume.volumeId;\n        }\n    }\n    const vol = cornerstoneCache.getVolume(segVolumeId);\n    if (!vol) {\n        console.warn(`No volume found for ${segVolumeId}`);\n        return;\n    }\n    const voxelManager = vol.voxelManager;\n    const segScalarData = voxelManager.getCompleteScalarDataArray();\n    const segmentationInfo = {\n        scalarData: segScalarData,\n        dimensions: vol.dimensions,\n        spacing: vol.imageData.getSpacing(),\n        origin: vol.imageData.getOrigin(),\n        direction: vol.imageData.getDirection(),\n    };\n    const indices = Array.isArray(segments)\n        ? segments\n            .filter((segment) => segment !== null)\n            .map((segment) => segment.segmentIndex || segment)\n        : Object.values(segments)\n            .filter((segment) => segment !== null)\n            .map((segment) => segment.segmentIndex || segment);\n    const contourSets = await getWebWorkerManager().executeTask('compute', 'generateContourSetsFromLabelmapVolume', {\n        segmentation: segmentationInfo,\n        indices,\n        mode: 'individual',\n    });\n    const refImages = vol.imageIds.map((imageId) => {\n        const refImageId = cache.getImage(imageId)?.referencedImageId;\n        return refImageId ? cache.getImage(refImageId) : undefined;\n    });\n    const refImageDataMetadata = refImages.map((image) => {\n        return utilities.getImageDataMetadata(image);\n    });\n    const processedContourSets = contourSets\n        .map((contourSet) => {\n        const segment = segments[contourSet.segment.segmentIndex] || {};\n        if (!contourSet.sliceContours.length) {\n            return null;\n        }\n        const p1 = contourSet.sliceContours[0].polyData.points[0];\n        let refImageId;\n        if (p1) {\n            const refImageIndex = refImageDataMetadata.findIndex((imageDataMetadata) => {\n                const { scanAxisNormal, origin } = imageDataMetadata;\n                const plane = utilities.planar.planeEquation(scanAxisNormal, origin);\n                return utilities.planar.isPointOnPlane(p1, plane);\n            });\n            if (refImageIndex !== -1) {\n                refImageId = refImages[refImageIndex].imageId;\n            }\n        }\n        return {\n            label: segment.label,\n            color: segment.color,\n            metadata: {\n                FrameOfReferenceUID: vol.metadata.FrameOfReferenceUID,\n                referencedImageId: refImageId,\n            },\n            sliceContours: contourSet.sliceContours.map((contourData) => ({\n                contours: contourData.contours,\n                polyData: contourData.polyData,\n                FrameNumber: contourData.sliceIndex + 1,\n                sliceIndex: contourData.sliceIndex,\n                FrameOfReferenceUID: vol.metadata.FrameOfReferenceUID,\n                referencedImageId: refImageId,\n            })),\n        };\n    })\n        .filter((contourSet) => contourSet !== null);\n    triggerWorkerProgress(WorkerTypes.GENERATE_CONTOUR_SETS, 100);\n    return processedContourSets;\n}\nexport { generateContourSetsFromLabelmap };\n", "class RectangleROIStartEndThreshold {\n    constructor() {\n    }\n    static getContourSequence(toolData, metadataProvider) {\n        const { data } = toolData;\n        const { projectionPoints, projectionPointsImageIds } = data.cachedStats;\n        return projectionPoints.map((point, index) => {\n            const ContourData = getPointData(point);\n            const ContourImageSequence = getContourImageSequence(projectionPointsImageIds[index], metadataProvider);\n            return {\n                NumberOfContourPoints: ContourData.length / 3,\n                ContourImageSequence,\n                ContourGeometricType: 'CLOSED_PLANAR',\n                ContourData,\n            };\n        });\n    }\n}\nRectangleROIStartEndThreshold.toolName = 'RectangleROIStartEndThreshold';\nfunction getPointData(points) {\n    const orderedPoints = [\n        ...points[0],\n        ...points[1],\n        ...points[3],\n        ...points[2],\n    ];\n    const pointsArray = orderedPoints.flat();\n    const pointsArrayWithPrecision = pointsArray.map((point) => {\n        return point.toFixed(2);\n    });\n    return pointsArrayWithPrecision;\n}\nfunction getContourImageSequence(imageId, metadataProvider) {\n    const sopCommon = metadataProvider.get('sopCommonModule', imageId);\n    return {\n        ReferencedSOPClassUID: sopCommon.sopClassUID,\n        ReferencedSOPInstanceUID: sopCommon.sopInstanceUID,\n    };\n}\nexport default RectangleROIStartEndThreshold;\n", "import RectangleROIStartEndThreshold from './RectangleROIStartEndThreshold';\nfunction validateAnnotation(annotation) {\n    if (!annotation?.data) {\n        throw new Error('Tool data is empty');\n    }\n    if (!annotation.metadata || annotation.metadata.referencedImageId) {\n        throw new Error('Tool data is not associated with any imageId');\n    }\n}\nclass AnnotationToPointData {\n    static { this.TOOL_NAMES = {}; }\n    constructor() {\n    }\n    static convert(annotation, index, metadataProvider) {\n        validateAnnotation(annotation);\n        const { toolName } = annotation.metadata;\n        const toolClass = AnnotationToPointData.TOOL_NAMES[toolName];\n        if (!toolClass) {\n            throw new Error(`Unknown tool type: ${toolName}, cannot convert to RTSSReport`);\n        }\n        const ContourSequence = toolClass.getContourSequence(annotation, metadataProvider);\n        const color = [\n            Math.floor(Math.random() * 255),\n            Math.floor(Math.random() * 255),\n            Math.floor(Math.random() * 255),\n        ];\n        return {\n            ReferencedROINumber: index + 1,\n            ROIDisplayColor: color,\n            ContourSequence,\n        };\n    }\n    static register(toolClass) {\n        AnnotationToPointData.TOOL_NAMES[toolClass.toolName] = toolClass;\n    }\n}\nAnnotationToPointData.register(RectangleROIStartEndThreshold);\nexport default AnnotationToPointData;\n", "import InterpolationManager from '../../segmentation/InterpolationManager/InterpolationManager';\nexport default function acceptAutogeneratedInterpolations(annotationGroupSelector, selector) {\n    InterpolationManager.acceptAutoGenerated(annotationGroupSelector, selector);\n}\n", "import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nconst { isEqual } = csUtils;\nexport default function findHandlePolylineIndex(annotation, handleIndex) {\n    const { polyline } = annotation.data.contour;\n    const { points } = annotation.data.handles;\n    const { length } = points;\n    if (handleIndex === length) {\n        return polyline.length;\n    }\n    if (handleIndex < 0) {\n        handleIndex = (handleIndex + length) % length;\n    }\n    if (handleIndex === 0) {\n        return 0;\n    }\n    const handle = points[handleIndex];\n    const index = polyline.findIndex((point) => isEqual(handle, point));\n    if (index !== -1) {\n        return index;\n    }\n    let closestDistance = Infinity;\n    return polyline.reduce((closestIndex, point, testIndex) => {\n        const distance = vec3.squaredDistance(point, handle);\n        if (distance < closestDistance) {\n            closestDistance = distance;\n            return testIndex;\n        }\n        return closestIndex;\n    }, -1);\n}\n", "import isClosed from '../math/polyline/isClosed';\nimport { getSignedArea } from '../math/polyline';\nexport default function findIslands(polylines, threshold) {\n    if (!polylines || polylines.length === 0) {\n        return [];\n    }\n    if (threshold <= 0) {\n        return [];\n    }\n    const islandIndexes = [];\n    for (let i = 0; i < polylines.length; i++) {\n        const polyline = polylines[i];\n        if (!polyline || polyline.length < 3) {\n            continue;\n        }\n        const isClosedPolyline = isClosed(polyline);\n        if (isClosedPolyline) {\n            const area = Math.abs(getSignedArea(polyline)) / 100;\n            if (area < threshold) {\n                islandIndexes.push(i);\n            }\n        }\n    }\n    return islandIndexes;\n}\n", "import thresholdVolumeByRange from './thresholdVolumeByRange';\nimport rectangleROIThresholdVolumeByRange from './rectangleROIThresholdVolumeByRange';\nimport createMergedLabelmapForIndex from './createMergedLabelmapForIndex';\nimport createLabelmapVolumeForViewport from './createLabelmapVolumeForViewport';\nimport { triggerSegmentationRender, triggerSegmentationRenderBySegmentationId, } from '../../stateManagement/segmentation/SegmentationRenderingEngine';\nimport floodFill from './floodFill';\nimport { getBrushSizeForToolGroup, setBrushSizeForToolGroup, } from './brushSizeForToolGroup';\nimport { getBrushThresholdForToolGroup, setBrushThresholdForToolGroup, } from './brushThresholdForToolGroup';\nimport VolumetricCalculator from './VolumetricCalculator';\nimport SegmentStatsCalculator from './SegmentStatsCalculator';\nimport thresholdSegmentationByRange from './thresholdSegmentationByRange';\nimport contourAndFindLargestBidirectional from './contourAndFindLargestBidirectional';\nimport createBidirectionalToolData from './createBidirectionalToolData';\nimport segmentContourAction from './segmentContourAction';\nimport { invalidateBrushCursor } from './invalidateBrushCursor';\nimport { getUniqueSegmentIndices } from './getUniqueSegmentIndices';\nimport { getSegmentIndexAtWorldPoint } from './getSegmentIndexAtWorldPoint';\nimport { getSegmentIndexAtLabelmapBorder } from './getSegmentIndexAtLabelmapBorder';\nimport { getHoveredContourSegmentationAnnotation } from './getHoveredContourSegmentationAnnotation';\nimport { getBrushToolInstances } from './getBrushToolInstances';\nimport * as growCut from './growCut';\nimport * as LabelmapMemo from './createLabelmapMemo';\nimport IslandRemoval from './islandRemoval';\nimport getOrCreateSegmentationVolume from './getOrCreateSegmentationVolume';\nimport getOrCreateImageVolume from './getOrCreateImageVolume';\nimport getStatistics from './getStatistics';\nimport * as validateLabelmap from './validateLabelmap';\nimport { computeStackLabelmapFromVolume } from '../../stateManagement/segmentation/helpers/computeStackLabelmapFromVolume';\nimport { computeVolumeLabelmapFromStack } from '../../stateManagement/segmentation/helpers/computeVolumeLabelmapFromStack';\nimport { getReferenceVolumeForSegmentationVolume } from './getReferenceVolumeForSegmentationVolume';\nimport { getSegmentLargestBidirectional } from './getSegmentLargestBidirectional';\nimport { computeMetabolicStats } from './computeMetabolicStats';\nexport { thresholdVolumeByRange, createMergedLabelmapForIndex, createLabelmapVolumeForViewport, rectangleROIThresholdVolumeByRange, triggerSegmentationRender, triggerSegmentationRenderBySegmentationId, floodFill, getBrushSizeForToolGroup, setBrushSizeForToolGroup, getBrushThresholdForToolGroup, setBrushThresholdForToolGroup, VolumetricCalculator, SegmentStatsCalculator, thresholdSegmentationByRange, contourAndFindLargestBidirectional, createBidirectionalToolData, segmentContourAction, invalidateBrushCursor, getUniqueSegmentIndices, getSegmentIndexAtWorldPoint, getSegmentIndexAtLabelmapBorder, getHoveredContourSegmentationAnnotation, getBrushToolInstances, growCut, LabelmapMemo, IslandRemoval, getOrCreateSegmentationVolume, getOrCreateImageVolume, getStatistics, validateLabelmap, computeStackLabelmapFromVolume, computeVolumeLabelmapFromStack, getReferenceVolumeForSegmentationVolume, getSegmentLargestBidirectional, computeMetabolicStats, };\n", "import { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { getVoxelOverlap, processVolumes } from './utilities';\nfunction thresholdVolumeByRange(segmentationVolume, thresholdVolumeInformation, options) {\n    const { imageData: segmentationImageData } = segmentationVolume;\n    const { overwrite, boundsIJK, segmentationId } = options;\n    if (!segmentationId) {\n        throw new Error('Segmentation ID is required to be passed inside thresholdVolumeByRange as options');\n    }\n    const overlapType = options?.overlapType || 0;\n    const segVoxelManager = segmentationVolume.voxelManager;\n    const scalarDataLength = segmentationVolume.voxelManager.getScalarDataLength();\n    if (overwrite) {\n        for (let i = 0; i < scalarDataLength; i++) {\n            segVoxelManager.setAtIndex(i, 0);\n        }\n    }\n    const { baseVolumeIdx, volumeInfoList } = processVolumes(segmentationVolume, thresholdVolumeInformation);\n    let overlaps, total, range;\n    const testOverlapRange = (volumeInfo, voxelSpacing, voxelCenter) => {\n        const callbackOverlap = ({ value }) => {\n            total = total + 1;\n            if (value >= range.lower && value <= range.upper) {\n                overlaps = overlaps + 1;\n            }\n        };\n        const { imageData, dimensions, lower, upper } = volumeInfo;\n        const overlapBounds = getVoxelOverlap(imageData, dimensions, voxelSpacing, voxelCenter);\n        total = 0;\n        overlaps = 0;\n        range = { lower, upper };\n        let overlapTest = false;\n        const { voxelManager } = imageData.get('voxelManager');\n        voxelManager.forEach(callbackOverlap, {\n            imageData,\n            boundsIJK: overlapBounds,\n        });\n        if (overlapType === 0) {\n            overlapTest = overlaps > 0;\n        }\n        else if (overlapType == 1) {\n            overlapTest = overlaps === total;\n        }\n        return overlapTest;\n    };\n    const testRange = (volumeInfo, pointIJK) => {\n        const { imageData, lower, upper } = volumeInfo;\n        const voxelManager = imageData.get('voxelManager').voxelManager;\n        const offset = voxelManager.toIndex(pointIJK);\n        const value = voxelManager.getAtIndex(offset);\n        if (value <= lower || value >= upper) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    };\n    const callback = ({ index, pointIJK, pointLPS }) => {\n        let insert = volumeInfoList.length > 0;\n        for (let i = 0; i < volumeInfoList.length; i++) {\n            if (volumeInfoList[i].volumeSize === scalarDataLength) {\n                insert = testRange(volumeInfoList[i], pointIJK);\n            }\n            else {\n                insert = testOverlapRange(volumeInfoList[i], volumeInfoList[baseVolumeIdx].spacing, pointLPS);\n            }\n            if (!insert) {\n                break;\n            }\n        }\n        if (insert) {\n            segVoxelManager.setAtIndex(index, options.segmentIndex || 1);\n        }\n    };\n    const voxelManager = segmentationVolume.voxelManager;\n    voxelManager.forEach(callback, {\n        imageData: segmentationImageData,\n        boundsIJK,\n    });\n    triggerSegmentationDataModified(options.segmentationId);\n    return segmentationVolume;\n}\nexport default thresholdVolumeByRange;\n", "import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, drawRectByCoordinates as drawRectSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromCorners from '../../utilities/planar/getWorldWidthAndHeightFromCorners';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nconst { transformWorldToIndex } = csUtils;\nclass RectangleROITool extends AnnotationTool {\n    static { this.toolName = 'RectangleROI'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            storePointData: false,\n            shadow: true,\n            preventHandleOutsideImage: false,\n            calculateStats: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const annotation = (this.constructor).createAnnotationForViewport(viewport, {\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    cachedStats: {},\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasPoint1 = viewport.worldToCanvas(points[0]);\n            const canvasPoint2 = viewport.worldToCanvas(points[3]);\n            const rect = this._getRectangleImageCoordinates([\n                canvasPoint1,\n                canvasPoint2,\n            ]);\n            const point = [canvasCoords[0], canvasCoords[1]];\n            const { left, top, width, height } = rect;\n            const distanceToPoint = rectangle.distanceToPoint([left, top, width, height], point);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                handleIndex = data.handles.points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.doneEditMemo();\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { points } = data.handles;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const enabledElement = getEnabledElement(element);\n                const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n                const worldPos = currentPoints.world;\n                const { points } = data.handles;\n                points[handleIndex] = [...worldPos];\n                let bottomLeftCanvas;\n                let bottomRightCanvas;\n                let topLeftCanvas;\n                let topRightCanvas;\n                let bottomLeftWorld;\n                let bottomRightWorld;\n                let topLeftWorld;\n                let topRightWorld;\n                switch (handleIndex) {\n                    case 0:\n                    case 3:\n                        bottomLeftCanvas = worldToCanvas(points[0]);\n                        topRightCanvas = worldToCanvas(points[3]);\n                        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n                        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n                        bottomRightWorld = canvasToWorld(bottomRightCanvas);\n                        topLeftWorld = canvasToWorld(topLeftCanvas);\n                        points[1] = bottomRightWorld;\n                        points[2] = topLeftWorld;\n                        break;\n                    case 1:\n                    case 2:\n                        bottomRightCanvas = worldToCanvas(points[1]);\n                        topLeftCanvas = worldToCanvas(points[2]);\n                        bottomLeftCanvas = [\n                            topLeftCanvas[0],\n                            bottomRightCanvas[1],\n                        ];\n                        topRightCanvas = [\n                            bottomRightCanvas[0],\n                            topLeftCanvas[1],\n                        ];\n                        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n                        topRightWorld = canvasToWorld(topRightCanvas);\n                        points[0] = bottomLeftWorld;\n                        points[3] = topRightWorld;\n                        break;\n                }\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const { viewPlaneNormal, viewUp } = viewport.getCamera();\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit == null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                    };\n                    this._calculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null &&\n                    activeHandleIndex !== undefined) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, showHandlesAlways ? canvasCoordinates : activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-rect`;\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._getRectangleImageCoordinates = (points) => {\n            const [point0, point1] = points;\n            return {\n                left: Math.min(point0[0], point1[0]),\n                top: Math.min(point0[1], point1[1]),\n                width: Math.abs(point0[0] - point1[0]),\n                height: Math.abs(point0[1] - point1[1]),\n            };\n        };\n        this._calculateCachedStats = (annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const { data } = annotation;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[3];\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, voxelManager } = image;\n                const pos1Index = transformWorldToIndex(imageData, worldPos1);\n                pos1Index[0] = Math.floor(pos1Index[0]);\n                pos1Index[1] = Math.floor(pos1Index[1]);\n                pos1Index[2] = Math.floor(pos1Index[2]);\n                const pos2Index = transformWorldToIndex(imageData, worldPos2);\n                pos2Index[0] = Math.floor(pos2Index[0]);\n                pos2Index[1] = Math.floor(pos2Index[1]);\n                pos2Index[2] = Math.floor(pos2Index[2]);\n                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {\n                    this.isHandleOutsideImage = false;\n                    const iMin = Math.min(pos1Index[0], pos2Index[0]);\n                    const iMax = Math.max(pos1Index[0], pos2Index[0]);\n                    const jMin = Math.min(pos1Index[1], pos2Index[1]);\n                    const jMax = Math.max(pos1Index[1], pos2Index[1]);\n                    const kMin = Math.min(pos1Index[2], pos2Index[2]);\n                    const kMax = Math.max(pos1Index[2], pos2Index[2]);\n                    const boundsIJK = [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ];\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const handles = [pos1Index, pos2Index];\n                    const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, handles);\n                    const area = Math.abs(worldWidth * worldHeight) / (scale * scale);\n                    const pixelUnitsOptions = {\n                        isPreScaled: isViewportPreScaled(viewport, targetId),\n                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                    };\n                    const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                    let pointsInShape;\n                    if (voxelManager) {\n                        pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                            boundsIJK,\n                            imageData,\n                            returnPoints: this.configuration.storePointData,\n                        });\n                    }\n                    const stats = this.configuration.statsCalculator.getStatistics();\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean: stats.mean?.value,\n                        stdDev: stats.stdDev?.value,\n                        max: stats.max?.value,\n                        min: stats.min?.value,\n                        statsArray: stats.array,\n                        pointsInShape: pointsInShape,\n                        areaUnit,\n                        modalityUnit,\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(RectangleROITool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, mean, max, stdDev, areaUnit, modalityUnit, min } = cachedVolumeStats;\n    if (mean === undefined || mean === null) {\n        return;\n    }\n    const textLines = [];\n    if (csUtils.isNumber(area)) {\n        textLines.push(`Area: ${csUtils.roundNumber(area)} ${areaUnit}`);\n    }\n    if (csUtils.isNumber(mean)) {\n        textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(max)) {\n        textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(min)) {\n        textLines.push(`Min: ${csUtils.roundNumber(min)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(stdDev)) {\n        textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    }\n    return textLines;\n}\nexport default RectangleROITool;\n", "import { getEnabledElement, cache, StackViewport, utilities as csUtils, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { vec3 } from 'gl-matrix';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { drawHandles as drawHandlesSvg, drawRect as drawRectSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport throttle from '../../utilities/throttle';\nimport debounce from '../../utilities/debounce';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromCorners from '../../utilities/planar/getWorldWidthAndHeightFromCorners';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { hideElementCursor, resetElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport { filterAnnotationsWithinSamePlane } from '../../utilities/planar';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nconst { transformWorldToIndex } = csUtils;\nclass RectangleROIStartEndThresholdTool extends RectangleROITool {\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            storePointData: false,\n            numSlicesToPropagate: 10,\n            calculatePointsInsideVolume: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n            showTextBox: false,\n            throttleTimeout: 100,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            let referencedImageId, imageVolume, volumeId;\n            if (viewport instanceof StackViewport) {\n                throw new Error('Stack Viewport Not implemented');\n            }\n            else {\n                const targetId = this.getTargetId(viewport);\n                volumeId = csUtils.getVolumeId(targetId);\n                imageVolume = cache.getVolume(volumeId);\n                referencedImageId = csUtils.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n            }\n            const spacingInNormal = csUtils.getSpacingInNormalDirection(imageVolume, viewPlaneNormal);\n            const startCoord = this._getStartCoordinate(worldPos, viewPlaneNormal);\n            const endCoord = this._getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    enabledElement,\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    toolName: this.getToolName(),\n                    volumeId,\n                    spacingInNormal,\n                },\n                data: {\n                    label: '',\n                    startCoordinate: startCoord,\n                    endCoordinate: endCoord,\n                    cachedStats: {\n                        pointsInVolume: [],\n                        projectionPoints: [],\n                        projectionPointsImageIds: [referencedImageId],\n                        statistics: [],\n                    },\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    labelmapUID: null,\n                },\n            };\n            this._computeProjectionPoints(annotation, imageVolume);\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 3,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const { metadata } = annotation;\n            const { enabledElement } = metadata;\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            const targetId = this.getTargetId(enabledElement.viewport);\n            const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n            this._computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            else {\n                triggerAnnotationModified(annotation, element);\n            }\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            let annotations = getAnnotations(this.getToolName(), viewport.element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = filterAnnotationsWithinSamePlane(annotations, viewport.getCamera());\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data, metadata } = annotation;\n                const { startCoordinate, endCoordinate } = data;\n                const { points, activeHandleIndex } = data.handles;\n                const { enabledElement: annotationEnabledElement } = metadata;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const focalPoint = viewport.getCamera().focalPoint;\n                const viewplaneNormal = viewport.getCamera().viewPlaneNormal;\n                let startCoord = startCoordinate;\n                let endCoord = endCoordinate;\n                if (Array.isArray(startCoordinate)) {\n                    startCoord = this._getCoordinateForViewplaneNormal(startCoord, viewplaneNormal);\n                    const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewplaneNormal);\n                    data.handles.points.forEach((point) => {\n                        point[indexOfDirection] = startCoord;\n                    });\n                    data.startCoordinate = startCoord;\n                }\n                if (Array.isArray(endCoordinate)) {\n                    endCoord = this._getCoordinateForViewplaneNormal(endCoord, viewplaneNormal);\n                    data.endCoordinate = endCoord;\n                    data.endCoordinate = endCoord;\n                }\n                const roundedStartCoord = csUtils.roundToPrecision(startCoord);\n                const roundedEndCoord = csUtils.roundToPrecision(endCoord);\n                const coord = this._getCoordinateForViewplaneNormal(focalPoint, viewplaneNormal);\n                const roundedCoord = csUtils.roundToPrecision(coord);\n                if (roundedCoord < Math.min(roundedStartCoord, roundedEndCoord) ||\n                    roundedCoord > Math.max(roundedStartCoord, roundedEndCoord)) {\n                    continue;\n                }\n                const iteratorVolumeIDs = annotationEnabledElement.viewport?.volumeIds.values();\n                for (const volumeId of iteratorVolumeIDs) {\n                    if (annotation.invalidated &&\n                        annotation.metadata.volumeId === volumeId) {\n                        this._throttledCalculateCachedStats(annotation, annotationEnabledElement);\n                    }\n                }\n                let firstOrLastSlice = false;\n                if (roundedCoord === roundedStartCoord ||\n                    roundedCoord === roundedEndCoord) {\n                    firstOrLastSlice = true;\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null &&\n                    firstOrLastSlice) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                let lineDashToUse = lineDash;\n                if (!firstOrLastSlice) {\n                    lineDashToUse = 2;\n                }\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                    color,\n                    lineDash: lineDashToUse,\n                    lineWidth,\n                });\n                renderStatus = true;\n                if (this.configuration.showTextBox) {\n                    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                    if (!options.visibility) {\n                        data.handles.textBox = {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        };\n                        continue;\n                    }\n                    const textLines = this.configuration.getTextLines(data, { metadata });\n                    if (!textLines || textLines.length === 0) {\n                        continue;\n                    }\n                    if (!data.handles.textBox.hasMoved) {\n                        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                        data.handles.textBox.worldPosition =\n                            viewport.canvasToWorld(canvasTextBoxCoords);\n                    }\n                    const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                    const textBoxUID = '1';\n                    const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                    const { x: left, y: top, width, height } = boundingBox;\n                    data.handles.textBox.worldBoundingBox = {\n                        topLeft: viewport.canvasToWorld([left, top]),\n                        topRight: viewport.canvasToWorld([left + width, top]),\n                        bottomLeft: viewport.canvasToWorld([left, top + height]),\n                        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                    };\n                }\n            }\n            return renderStatus;\n        };\n        if (this.configuration.calculatePointsInsideVolume) {\n            this._throttledCalculateCachedStats = throttle(this._calculateCachedStatsTool, this.configuration.throttleTimeout, { trailing: true });\n        }\n        else {\n            this._throttledCalculateCachedStats = debounce(this._calculateCachedStatsTool, this.configuration.throttleTimeout);\n        }\n    }\n    _computeProjectionPoints(annotation, imageVolume) {\n        const { data, metadata } = annotation;\n        const { viewPlaneNormal, spacingInNormal } = metadata;\n        const { imageData } = imageVolume;\n        const { startCoordinate, endCoordinate } = data;\n        const { points } = data.handles;\n        const startIJK = transformWorldToIndex(imageData, points[0]);\n        const endIJK = transformWorldToIndex(imageData, points[0]);\n        const startWorld = vec3.create();\n        imageData.indexToWorldVec3(startIJK, startWorld);\n        const endWorld = vec3.create();\n        imageData.indexToWorldVec3(endIJK, endWorld);\n        const projectionAxisIndex = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n        if (projectionAxisIndex == 2) {\n            startWorld[2] = startCoordinate;\n            endWorld[2] = endCoordinate;\n        }\n        else if (projectionAxisIndex == 0) {\n            startWorld[0] = startCoordinate;\n            endWorld[0] = endCoordinate;\n        }\n        else if (projectionAxisIndex == 1) {\n            startWorld[1] = startCoordinate;\n            endWorld[1] = endCoordinate;\n        }\n        const direction = vec3.create();\n        vec3.subtract(direction, endWorld, startWorld);\n        const distance = vec3.length(direction);\n        vec3.normalize(direction, direction);\n        const newProjectionPoints = [];\n        for (let dist = 0; dist < distance; dist += spacingInNormal) {\n            newProjectionPoints.push(points.map((point) => {\n                const newPoint = vec3.create();\n                vec3.scaleAndAdd(newPoint, point, direction, dist);\n                return Array.from(newPoint);\n            }));\n        }\n        data.cachedStats.projectionPoints = newProjectionPoints;\n    }\n    _computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement) {\n        const { data, metadata } = annotation;\n        const { viewPlaneNormal, viewUp } = metadata;\n        const { viewport } = enabledElement;\n        const projectionPoints = data.cachedStats.projectionPoints;\n        const pointsInsideVolume = [[]];\n        const image = this.getTargetImageData(targetId);\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[3];\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n        const measureInfo = getCalibratedLengthUnitsAndScale(image, data.habdles);\n        const area = Math.abs(worldWidth * worldHeight) /\n            (measureInfo.scale * measureInfo.scale);\n        const modalityUnitOptions = {\n            isPreScaled: isViewportPreScaled(viewport, targetId),\n            isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n        };\n        const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);\n        for (let i = 0; i < projectionPoints.length; i++) {\n            if (!imageVolume) {\n                continue;\n            }\n            const projectionPoint = projectionPoints[i][0];\n            const { dimensions, imageData, voxelManager } = imageVolume;\n            const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n            const worldProjectionPointIndex = transformWorldToIndex(imageData, projectionPoint);\n            const indexOfProjection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n            worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n            worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n            worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n            worldPos1Index[indexOfProjection] =\n                worldProjectionPointIndex[indexOfProjection];\n            const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n            worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n            worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n            worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n            worldPos2Index[indexOfProjection] =\n                worldProjectionPointIndex[indexOfProjection];\n            if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n                this.isHandleOutsideImage = false;\n                const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n                const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n                const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n                const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n                const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n                const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n                const boundsIJK = [\n                    [iMin, iMax],\n                    [jMin, jMax],\n                    [kMin, kMax],\n                ];\n                const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                    boundsIJK,\n                    imageData,\n                    returnPoints: this.configuration.storePointData,\n                });\n                pointsInsideVolume.push(pointsInShape);\n            }\n        }\n        const stats = this.configuration.statsCalculator.getStatistics();\n        data.cachedStats.pointsInVolume = pointsInsideVolume;\n        data.cachedStats.statistics = {\n            Modality: metadata.Modality,\n            area,\n            mean: stats.mean?.value,\n            stdDev: stats.stdDev?.value,\n            max: stats.max?.value,\n            statsArray: stats.array,\n            areaUnit: measureInfo.areaUnit,\n            modalityUnit,\n        };\n    }\n    _calculateCachedStatsTool(annotation, enabledElement) {\n        const data = annotation.data;\n        const { viewport } = enabledElement;\n        const { cachedStats } = data;\n        const targetId = this.getTargetId(viewport);\n        const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n        this._computeProjectionPoints(annotation, imageVolume);\n        this._computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement);\n        annotation.invalidated = false;\n        triggerAnnotationModified(annotation, viewport.element);\n        return cachedStats;\n    }\n    _getStartCoordinate(worldPos, viewPlaneNormal) {\n        const startPos = worldPos;\n        const startCoord = this._getCoordinateForViewplaneNormal(startPos, viewPlaneNormal);\n        return startCoord;\n    }\n    _getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {\n        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n        const endPos = vec3.create();\n        vec3.scaleAndAdd(endPos, worldPos, viewPlaneNormal, numSlicesToPropagate * spacingInNormal);\n        const endCoord = this._getCoordinateForViewplaneNormal(endPos, viewPlaneNormal);\n        return endCoord;\n    }\n    _getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) {\n        const viewplaneNormalAbs = [\n            Math.abs(viewPlaneNormal[0]),\n            Math.abs(viewPlaneNormal[1]),\n            Math.abs(viewPlaneNormal[2]),\n        ];\n        const indexOfDirection = viewplaneNormalAbs.indexOf(Math.max(...viewplaneNormalAbs));\n        return indexOfDirection;\n    }\n    _getCoordinateForViewplaneNormal(pos, viewPlaneNormal) {\n        const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n        return pos[indexOfDirection];\n    }\n}\nfunction defaultGetTextLines(data, _context = {}) {\n    const cachedVolumeStats = data.cachedStats.statistics;\n    const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;\n    if (mean === undefined) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`Area: ${csUtils.roundNumber(area)} ${areaUnit}`);\n    textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    return textLines;\n}\nRectangleROIStartEndThresholdTool.toolName = 'RectangleROIStartEndThreshold';\nexport default RectangleROIStartEndThresholdTool;\n", "import { getEnabledElement, cache, StackViewport, utilities as csUtils, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { drawHandles as drawHandlesSvg, drawRect as drawRectSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport RectangleROITool from '../annotation/RectangleROITool';\nclass RectangleROIThresholdTool extends RectangleROITool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const targetId = this.getTargetId(viewport);\n            let referencedImageId, volumeId;\n            if (viewport instanceof StackViewport) {\n                referencedImageId = targetId.split('imageId:')[1];\n            }\n            else {\n                volumeId = csUtils.getVolumeId(targetId);\n                const imageVolume = cache.getVolume(volumeId);\n                referencedImageId = csUtils.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n            }\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    enabledElement,\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    toolName: this.getToolName(),\n                    volumeId,\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: null,\n                            worldBoundingBox: null,\n                        },\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    segmentationId: null,\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 3,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                triggerAnnotationModified(annotation, element);\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                });\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n    }\n}\nRectangleROIThresholdTool.toolName = 'RectangleROIThreshold';\nexport default RectangleROIThresholdTool;\n", "import { utilities as csUtils } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShapeIJK } from '../boundingBox/getBoundingBoxAroundShape';\nimport extend2DBoundingBoxInViewAxis from '../boundingBox/extend2DBoundingBoxInViewAxis';\nfunction getBoundsIJKFromRectangleAnnotations(annotations, referenceVolume, options = {}) {\n    const AllBoundsIJK = [];\n    annotations.forEach((annotation) => {\n        const { data } = annotation;\n        const { points } = data.handles;\n        const { imageData, dimensions } = referenceVolume;\n        let pointsToUse = points;\n        if (data.cachedStats?.projectionPoints) {\n            const { projectionPoints } = data.cachedStats;\n            pointsToUse = [].concat(...projectionPoints);\n        }\n        const rectangleCornersIJK = pointsToUse.map((world) => csUtils.transformWorldToIndex(imageData, world));\n        let boundsIJK = getBoundingBoxAroundShapeIJK(rectangleCornersIJK, dimensions);\n        if (options.numSlicesToProject && !data.cachedStats?.projectionPoints) {\n            boundsIJK = extend2DBoundingBoxInViewAxis(boundsIJK, options.numSlicesToProject);\n        }\n        AllBoundsIJK.push(boundsIJK);\n    });\n    if (AllBoundsIJK.length === 1) {\n        return AllBoundsIJK[0];\n    }\n    const boundsIJK = AllBoundsIJK.reduce((accumulator, currentValue) => {\n        return {\n            iMin: Math.min(accumulator.iMin, currentValue.iMin),\n            jMin: Math.min(accumulator.jMin, currentValue.jMin),\n            kMin: Math.min(accumulator.kMin, currentValue.kMin),\n            iMax: Math.max(accumulator.iMax, currentValue.iMax),\n            jMax: Math.max(accumulator.jMax, currentValue.jMax),\n            kMax: Math.max(accumulator.kMax, currentValue.kMax),\n        };\n    }, {\n        iMin: Infinity,\n        jMin: Infinity,\n        kMin: Infinity,\n        iMax: -Infinity,\n        jMax: -Infinity,\n        kMax: -Infinity,\n    });\n    return boundsIJK;\n}\nexport default getBoundsIJKFromRectangleAnnotations;\n", "import { state } from '../../stateManagement/annotation';\nimport RectangleROIStartEndThresholdTool from '../../tools/segmentation/RectangleROIStartEndThresholdTool';\nimport RectangleROIThresholdTool from '../../tools/segmentation/RectangleROIThresholdTool';\nimport thresholdVolumeByRange from './thresholdVolumeByRange';\nimport getBoundsIJKFromRectangleAnnotations from '../rectangleROITool/getBoundsIJKFromRectangleAnnotations';\nfunction rectangleROIThresholdVolumeByRange(annotationUIDs, segmentationVolume, thresholdVolumeInformation, options) {\n    const annotations = annotationUIDs.map((annotationUID) => {\n        return state.getAnnotation(annotationUID);\n    });\n    _validateAnnotations(annotations);\n    let boundsIJK;\n    for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n        const volumeSize = thresholdVolumeInformation[i].volume.voxelManager.getScalarDataLength();\n        if (volumeSize === segmentationVolume.voxelManager.getScalarDataLength() ||\n            i === 0) {\n            boundsIJK = getBoundsIJKFromRectangleAnnotations(annotations, thresholdVolumeInformation[i].volume, options);\n        }\n    }\n    const outputSegmentationVolume = thresholdVolumeByRange(segmentationVolume, thresholdVolumeInformation, { ...options, boundsIJK, segmentationId: options.segmentationId });\n    outputSegmentationVolume.modified();\n    return outputSegmentationVolume;\n}\nfunction _validateAnnotations(annotations) {\n    const validToolNames = [\n        RectangleROIThresholdTool.toolName,\n        RectangleROIStartEndThresholdTool.toolName,\n    ];\n    for (const annotation of annotations) {\n        const name = annotation.metadata.toolName;\n        if (!validToolNames.includes(name)) {\n            throw new Error('rectangleROIThresholdVolumeByRange only supports RectangleROIThreshold and RectangleROIStartEndThreshold annotations');\n        }\n    }\n}\nexport default rectangleROIThresholdVolumeByRange;\n", "import { volumeLoader, utilities as csUtils, cache } from '@cornerstonejs/core';\nfunction createMergedLabelmapForIndex(labelmaps, segmentIndex = 1, volumeId = 'mergedLabelmap') {\n    labelmaps.forEach(({ direction, dimensions, origin, spacing }) => {\n        if (!csUtils.isEqual(dimensions, labelmaps[0].dimensions) ||\n            !csUtils.isEqual(direction, labelmaps[0].direction) ||\n            !csUtils.isEqual(spacing, labelmaps[0].spacing) ||\n            !csUtils.isEqual(origin, labelmaps[0].origin)) {\n            throw new Error('labelmaps must have the same size and shape');\n        }\n    });\n    const labelmap = labelmaps[0];\n    const arrayType = labelmap.voxelManager.getConstructor();\n    const outputData = new arrayType(labelmap.voxelManager.getScalarDataLength());\n    labelmaps.forEach((labelmap) => {\n        const voxelManager = labelmap.voxelManager;\n        const scalarDataLength = voxelManager.getScalarDataLength();\n        for (let i = 0; i < scalarDataLength; i++) {\n            if (voxelManager.getAtIndex(i) === segmentIndex) {\n                outputData[i] = segmentIndex;\n            }\n        }\n    });\n    const options = {\n        scalarData: outputData,\n        metadata: labelmap.metadata,\n        spacing: labelmap.spacing,\n        origin: labelmap.origin,\n        direction: labelmap.direction,\n        dimensions: labelmap.dimensions,\n    };\n    const cachedVolume = cache.getVolume(volumeId);\n    let mergedVolume;\n    if (cachedVolume) {\n        mergedVolume = cachedVolume;\n        mergedVolume.voxelManager.setCompleteScalarDataArray(outputData);\n    }\n    else {\n        mergedVolume = volumeLoader.createLocalVolume(volumeId, options);\n    }\n    return mergedVolume;\n}\nexport default createMergedLabelmapForIndex;\n", "import { getEnabledElementByIds, volumeLoader, VolumeViewport, utilities as csUtils, } from '@cornerstonejs/core';\nexport default async function createLabelmapVolumeForViewport(input) {\n    const { viewportId, renderingEngineId, options } = input;\n    let { segmentationId } = input;\n    const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n    if (!enabledElement) {\n        throw new Error('element disabled');\n    }\n    const { viewport } = enabledElement;\n    if (!(viewport instanceof VolumeViewport)) {\n        throw new Error('Segmentation only supports VolumeViewport');\n    }\n    const { uid } = viewport.getDefaultActor();\n    if (segmentationId === undefined) {\n        segmentationId = `${uid}-based-segmentation-${options?.volumeId ?? csUtils.uuidv4().slice(0, 8)}`;\n    }\n    if (options) {\n        const properties = structuredClone(options);\n        await volumeLoader.createLocalVolume(segmentationId, properties);\n    }\n    else {\n        const volumeId = viewport.getVolumeId();\n        volumeLoader.createAndCacheDerivedLabelmapVolume(volumeId, {\n            volumeId: segmentationId,\n        });\n    }\n    return segmentationId;\n}\n", "function floodFill(getter, seed, options = {}) {\n    const onFlood = options.onFlood;\n    const onBoundary = options.onBoundary;\n    const equals = options.equals;\n    const filter = options.filter;\n    const diagonals = options.diagonals || false;\n    const startNode = get(seed);\n    const permutations = prunedPermutations();\n    const stack = [];\n    const flooded = [];\n    const visits = new Set();\n    const bounds = options.bounds;\n    stack.push({ currentArgs: seed });\n    while (stack.length > 0) {\n        flood(stack.pop());\n    }\n    return {\n        flooded,\n    };\n    function flood(job) {\n        const getArgs = job.currentArgs;\n        const prevArgs = job.previousArgs;\n        if (visited(getArgs)) {\n            return;\n        }\n        markAsVisited(getArgs);\n        if (member(getArgs)) {\n            markAsFlooded(getArgs);\n            pushAdjacent(getArgs);\n        }\n        else {\n            markAsBoundary(prevArgs);\n        }\n    }\n    function visited(key) {\n        const [x, y, z = 0] = key;\n        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n        return visits.has(iKey);\n    }\n    function markAsVisited(key) {\n        const [x, y, z = 0] = key;\n        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n        visits.add(iKey);\n    }\n    function member(getArgs) {\n        const node = get(getArgs);\n        return equals ? equals(node, startNode) : node === startNode;\n    }\n    function markAsFlooded(getArgs) {\n        flooded.push(getArgs);\n        if (onFlood) {\n            onFlood(...getArgs);\n        }\n    }\n    function markAsBoundary(prevArgs) {\n        const [x, y, z = 0] = prevArgs;\n        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n        bounds?.set(iKey, prevArgs);\n        if (onBoundary) {\n            onBoundary(...prevArgs);\n        }\n    }\n    function pushAdjacent(getArgs) {\n        for (let i = 0; i < permutations.length; i += 1) {\n            const perm = permutations[i];\n            const nextArgs = getArgs.slice(0);\n            for (let j = 0; j < getArgs.length; j += 1) {\n                nextArgs[j] += perm[j];\n            }\n            if (filter?.(nextArgs) === false) {\n                continue;\n            }\n            if (visited(nextArgs)) {\n                continue;\n            }\n            stack.push({\n                currentArgs: nextArgs,\n                previousArgs: getArgs,\n            });\n        }\n    }\n    function get(getArgs) {\n        return getter(...getArgs);\n    }\n    function prunedPermutations() {\n        const permutations = permute(seed.length);\n        return permutations.filter(function (perm) {\n            const count = countNonZeroes(perm);\n            return count !== 0 && (count === 1 || diagonals);\n        });\n    }\n    function permute(length) {\n        const perms = [];\n        const permutation = function (string) {\n            return string.split('').map(function (c) {\n                return parseInt(c, 10) - 1;\n            });\n        };\n        for (let i = 0; i < Math.pow(3, length); i += 1) {\n            const string = lpad(i.toString(3), '0', length);\n            perms.push(permutation(string));\n        }\n        return perms;\n    }\n}\nfunction countNonZeroes(array) {\n    let count = 0;\n    for (let i = 0; i < array.length; i += 1) {\n        if (array[i] !== 0) {\n            count += 1;\n        }\n    }\n    return count;\n}\nfunction lpad(string, character, length) {\n    const array = new Array(length + 1);\n    const pad = array.join(character);\n    return (pad + string).slice(-length);\n}\nexport default floodFill;\n", "import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.OnInteractionStart]: (operationData) => {\n        const { segmentIndex, previewSegmentIndex, segmentationVoxelManager, centerIJK, viewPlaneNormal, segmentationImageData, configuration, } = operationData;\n        if (!configuration?.useCenterSegmentIndex) {\n            operationData.centerSegmentIndexInfo.segmentIndex = null;\n            operationData.centerSegmentIndexInfo.hasSegmentIndex = false;\n            operationData.centerSegmentIndexInfo.hasPreviewIndex = false;\n            return;\n        }\n        let hasSegmentIndex = false;\n        let hasPreviewIndex = false;\n        const nestedBounds = [\n            ...segmentationVoxelManager.getBoundsIJK(),\n        ];\n        if (Math.abs(viewPlaneNormal[0]) > 0.8) {\n            nestedBounds[0] = [centerIJK[0], centerIJK[0]];\n        }\n        else if (Math.abs(viewPlaneNormal[1]) > 0.8) {\n            nestedBounds[1] = [centerIJK[1], centerIJK[1]];\n        }\n        else if (Math.abs(viewPlaneNormal[2]) > 0.8) {\n            nestedBounds[2] = [centerIJK[2], centerIJK[2]];\n        }\n        const callback = ({ value }) => {\n            hasSegmentIndex ||= value === segmentIndex;\n            hasPreviewIndex ||= value === previewSegmentIndex;\n        };\n        segmentationVoxelManager.forEach(callback, {\n            imageData: segmentationImageData,\n            isInObject: operationData.isInObject,\n            boundsIJK: nestedBounds,\n        });\n        if (!hasSegmentIndex && !hasPreviewIndex) {\n            operationData.centerSegmentIndexInfo.segmentIndex = null;\n            return;\n        }\n        const existingValue = segmentationVoxelManager.getAtIJKPoint(centerIJK);\n        operationData.centerSegmentIndexInfo.segmentIndex = existingValue;\n        operationData.centerSegmentIndexInfo.hasSegmentIndex = hasSegmentIndex;\n        operationData.centerSegmentIndexInfo.hasPreviewIndex = hasPreviewIndex;\n    },\n};\n", "import { vec3 } from 'gl-matrix';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { operationName, centerIJK, segmentationVoxelManager, imageVoxelManager, configuration, segmentIndex, viewport, } = operationData;\n        if (!configuration?.threshold?.isDynamic || !centerIJK || !segmentIndex) {\n            return;\n        }\n        if (operationName === StrategyCallbacks.RejectPreview ||\n            operationName === StrategyCallbacks.OnInteractionEnd) {\n            return;\n        }\n        const boundsIJK = segmentationVoxelManager.getBoundsIJK();\n        const { range: oldThreshold, dynamicRadius = 0 } = configuration.threshold;\n        const useDelta = oldThreshold ? 0 : dynamicRadius;\n        const { viewPlaneNormal } = viewport.getCamera();\n        const nestedBounds = boundsIJK.map((ijk, idx) => {\n            const [min, max] = ijk;\n            return [\n                Math.max(min, centerIJK[idx] - useDelta),\n                Math.min(max, centerIJK[idx] + useDelta),\n            ];\n        });\n        if (Math.abs(viewPlaneNormal[0]) > 0.8) {\n            nestedBounds[0] = [centerIJK[0], centerIJK[0]];\n        }\n        else if (Math.abs(viewPlaneNormal[1]) > 0.8) {\n            nestedBounds[1] = [centerIJK[1], centerIJK[1]];\n        }\n        else if (Math.abs(viewPlaneNormal[2]) > 0.8) {\n            nestedBounds[2] = [centerIJK[2], centerIJK[2]];\n        }\n        const threshold = oldThreshold || [Infinity, -Infinity];\n        const useDeltaSqr = useDelta * useDelta;\n        const callback = ({ value, pointIJK }) => {\n            const distance = vec3.sqrDist(centerIJK, pointIJK);\n            if (distance > useDeltaSqr) {\n                return;\n            }\n            const gray = Array.isArray(value) ? vec3.len(value) : value;\n            threshold[0] = Math.min(gray, threshold[0]);\n            threshold[1] = Math.max(gray, threshold[1]);\n        };\n        imageVoxelManager.forEach(callback, { boundsIJK: nestedBounds });\n        configuration.threshold.range = threshold;\n    },\n    [StrategyCallbacks.OnInteractionStart]: (operationData) => {\n        const { configuration } = operationData;\n        if (!configuration?.threshold?.isDynamic) {\n            return;\n        }\n        configuration.threshold.range = null;\n    },\n    [StrategyCallbacks.ComputeInnerCircleRadius]: (operationData) => {\n        const { configuration, viewport } = operationData;\n        const { dynamicRadius = 0, isDynamic } = configuration.threshold;\n        if (!isDynamic) {\n            configuration.threshold.dynamicRadiusInCanvas = 0;\n            return;\n        }\n        if (dynamicRadius === 0) {\n            return;\n        }\n        const imageData = viewport.getImageData();\n        if (!imageData) {\n            return;\n        }\n        const { spacing } = imageData;\n        const centerCanvas = [\n            viewport.element.clientWidth / 2,\n            viewport.element.clientHeight / 2,\n        ];\n        const radiusInWorld = dynamicRadius * spacing[0];\n        const centerCursorInWorld = viewport.canvasToWorld(centerCanvas);\n        const offSetCenterInWorld = centerCursorInWorld.map((coord) => coord + radiusInWorld);\n        const offSetCenterCanvas = viewport.worldToCanvas(offSetCenterInWorld);\n        const dynamicRadiusInCanvas = Math.abs(centerCanvas[0] - offSetCenterCanvas[0]);\n        if (!configuration.threshold.dynamicRadiusInCanvas) {\n            configuration.threshold.dynamicRadiusInCanvas = 0;\n        }\n        configuration.threshold.dynamicRadiusInCanvas = 3 + dynamicRadiusInCanvas;\n    },\n};\n", "import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        operationData.segmentIndex = 0;\n    },\n};\n", "import { BaseVolumeViewport, utilities } from '@cornerstonejs/core';\nconst { isEqual } = utilities;\nconst acquisitionMapping = {\n    toIJK: (ijkPrime) => ijkPrime,\n    fromIJK: (ijk) => ijk,\n    type: 'acquistion',\n};\nconst jkMapping = {\n    toIJK: ([j, k, i]) => [i, j, k],\n    fromIJK: ([i, j, k]) => [j, k, i],\n    type: 'jk',\n};\nconst ikMapping = {\n    toIJK: ([i, k, j]) => [i, j, k],\n    fromIJK: ([i, j, k]) => [i, k, j],\n    type: 'ik',\n};\nexport default function normalizeViewportPlane(viewport, boundsIJK) {\n    if (!(viewport instanceof BaseVolumeViewport)) {\n        return { ...acquisitionMapping, boundsIJKPrime: boundsIJK };\n    }\n    const { viewPlaneNormal } = viewport.getCamera();\n    const mapping = (isEqual(Math.abs(viewPlaneNormal[0]), 1) && jkMapping) ||\n        (isEqual(Math.abs(viewPlaneNormal[1]), 1) && ikMapping) ||\n        (isEqual(Math.abs(viewPlaneNormal[2]), 1) && acquisitionMapping);\n    if (!mapping) {\n        return {\n            toIJK: null,\n            boundsIJKPrime: null,\n            fromIJK: null,\n            error: `Only mappings orthogonal to acquisition plane are permitted, but requested ${viewPlaneNormal}`,\n        };\n    }\n    return { ...mapping, boundsIJKPrime: mapping.fromIJK(boundsIJK) };\n}\n", "import { utilities } from '@cornerstonejs/core';\nimport normalizeViewportPlane from '../normalizeViewportPlane';\nconst { RLEVoxelMap, VoxelManager } = utilities;\nconst MAX_IMAGE_SIZE = 65535;\nexport var SegmentationEnum;\n(function (SegmentationEnum) {\n    SegmentationEnum[SegmentationEnum[\"SEGMENT\"] = -1] = \"SEGMENT\";\n    SegmentationEnum[SegmentationEnum[\"ISLAND\"] = -2] = \"ISLAND\";\n    SegmentationEnum[SegmentationEnum[\"INTERIOR\"] = -3] = \"INTERIOR\";\n    SegmentationEnum[SegmentationEnum[\"EXTERIOR\"] = -4] = \"EXTERIOR\";\n    SegmentationEnum[SegmentationEnum[\"INTERIOR_SMALL\"] = -5] = \"INTERIOR_SMALL\";\n    SegmentationEnum[SegmentationEnum[\"INTERIOR_TEST\"] = -6] = \"INTERIOR_TEST\";\n})(SegmentationEnum || (SegmentationEnum = {}));\nexport default class IslandRemoval {\n    constructor(options) {\n        this.fillInternalEdge = false;\n        this.maxInternalRemove = 128;\n        this.maxInternalRemove =\n            options?.maxInternalRemove ?? this.maxInternalRemove;\n        this.fillInternalEdge = options?.fillInternalEdge ?? this.fillInternalEdge;\n    }\n    initialize(viewport, segmentationVoxels, options) {\n        const hasSource = !!segmentationVoxels.sourceVoxelManager;\n        const segmentationVoxelManager = hasSource\n            ? segmentationVoxels.sourceVoxelManager\n            : segmentationVoxels;\n        const previewVoxelManager = hasSource\n            ? segmentationVoxels\n            : VoxelManager.createRLEHistoryVoxelManager(segmentationVoxelManager);\n        const { segmentIndex = 1, previewSegmentIndex = 1 } = options;\n        const clickedPoints = options.points || segmentationVoxelManager.getPoints();\n        if (!clickedPoints?.length) {\n            return;\n        }\n        const boundsIJK = segmentationVoxelManager\n            .getBoundsIJK()\n            .map((bound, i) => [\n            Math.min(bound[0], ...clickedPoints.map((point) => point[i])),\n            Math.max(bound[1], ...clickedPoints.map((point) => point[i])),\n        ]);\n        if (boundsIJK.find((it) => it[0] < 0 || it[1] > MAX_IMAGE_SIZE)) {\n            return;\n        }\n        const { toIJK, fromIJK, boundsIJKPrime, error } = normalizeViewportPlane(viewport, boundsIJK);\n        if (error) {\n            console.warn('Not performing island removal for planes not orthogonal to acquisition plane', error);\n            return;\n        }\n        const [width, height, depth] = fromIJK(segmentationVoxelManager.dimensions);\n        const segmentSet = new RLEVoxelMap(width, height, depth);\n        const getter = (i, j, k) => {\n            const index = segmentationVoxelManager.toIndex(toIJK([i, j, k]));\n            const oldVal = segmentationVoxelManager.getAtIndex(index);\n            if (oldVal === previewSegmentIndex || oldVal === segmentIndex) {\n                return SegmentationEnum.SEGMENT;\n            }\n        };\n        segmentSet.fillFrom(getter, boundsIJKPrime);\n        segmentSet.normalizer = { toIJK, fromIJK, boundsIJKPrime };\n        this.segmentSet = segmentSet;\n        this.previewVoxelManager = previewVoxelManager;\n        this.segmentIndex = segmentIndex;\n        this.previewSegmentIndex = previewSegmentIndex ?? segmentIndex;\n        this.selectedPoints = clickedPoints;\n        return true;\n    }\n    floodFillSegmentIsland() {\n        const { selectedPoints: clickedPoints, segmentSet } = this;\n        let floodedCount = 0;\n        const { fromIJK } = segmentSet.normalizer;\n        clickedPoints.forEach((clickedPoint) => {\n            const ijkPrime = fromIJK(clickedPoint);\n            const index = segmentSet.toIndex(ijkPrime);\n            const [iPrime, jPrime, kPrime] = ijkPrime;\n            if (segmentSet.get(index) === SegmentationEnum.SEGMENT) {\n                floodedCount += segmentSet.floodFill(iPrime, jPrime, kPrime, SegmentationEnum.ISLAND);\n            }\n        });\n        return floodedCount;\n    }\n    removeExternalIslands() {\n        const { previewVoxelManager, segmentSet } = this;\n        const { toIJK } = segmentSet.normalizer;\n        const callback = (index, rle) => {\n            const [, jPrime, kPrime] = segmentSet.toIJK(index);\n            if (rle.value !== SegmentationEnum.ISLAND) {\n                for (let iPrime = rle.start; iPrime < rle.end; iPrime++) {\n                    const clearPoint = toIJK([iPrime, jPrime, kPrime]);\n                    const v = previewVoxelManager.getAtIJKPoint(clearPoint);\n                    previewVoxelManager.setAtIJKPoint(clearPoint, v === undefined ? 0 : null);\n                }\n            }\n        };\n        segmentSet.forEach(callback, { rowModified: true });\n    }\n    removeInternalIslands() {\n        const { segmentSet, previewVoxelManager, previewSegmentIndex } = this;\n        const { height, normalizer, width } = segmentSet;\n        const { toIJK } = normalizer;\n        segmentSet.forEachRow((baseIndex, row) => {\n            let lastRle;\n            for (const rle of [...row]) {\n                if (rle.value !== SegmentationEnum.ISLAND) {\n                    continue;\n                }\n                if (!lastRle) {\n                    if (this.fillInternalEdge && rle.start > 0) {\n                        for (let iPrime = 0; iPrime < rle.start; iPrime++) {\n                            segmentSet.set(baseIndex + iPrime, SegmentationEnum.INTERIOR);\n                        }\n                    }\n                    lastRle = rle;\n                    continue;\n                }\n                for (let iPrime = lastRle.end; iPrime < rle.start; iPrime++) {\n                    segmentSet.set(baseIndex + iPrime, SegmentationEnum.INTERIOR);\n                }\n                lastRle = rle;\n            }\n            if (this.fillInternalEdge && lastRle?.end < width) {\n                for (let iPrime = lastRle.end; iPrime < width; iPrime++) {\n                    segmentSet.set(baseIndex + iPrime, SegmentationEnum.INTERIOR);\n                }\n            }\n        });\n        segmentSet.forEach((baseIndex, rle) => {\n            if (rle.value !== SegmentationEnum.INTERIOR) {\n                return;\n            }\n            const [, jPrime, kPrime] = segmentSet.toIJK(baseIndex);\n            const rowPrev = jPrime > 0 ? segmentSet.getRun(jPrime - 1, kPrime) : null;\n            const rowNext = jPrime + 1 < height ? segmentSet.getRun(jPrime + 1, kPrime) : null;\n            const isLast = jPrime === height - 1;\n            const isFirst = jPrime === 0;\n            const prevCovers = IslandRemoval.covers(rle, rowPrev) ||\n                (isFirst && this.fillInternalEdge);\n            const nextCovers = IslandRemoval.covers(rle, rowNext) || (isLast && this.fillInternalEdge);\n            if (rle.end - rle.start > 2 && (!prevCovers || !nextCovers)) {\n                segmentSet.floodFill(rle.start, jPrime, kPrime, SegmentationEnum.EXTERIOR, { singlePlane: true });\n            }\n        });\n        segmentSet.forEach((baseIndex, rle) => {\n            if (rle.value !== SegmentationEnum.INTERIOR) {\n                return;\n            }\n            const [, jPrime, kPrime] = segmentSet.toIJK(baseIndex);\n            const size = segmentSet.floodFill(rle.start, jPrime, kPrime, SegmentationEnum.INTERIOR_TEST);\n            const isBig = size > this.maxInternalRemove;\n            const newType = isBig\n                ? SegmentationEnum.EXTERIOR\n                : SegmentationEnum.INTERIOR_SMALL;\n            segmentSet.floodFill(rle.start, jPrime, kPrime, newType);\n        });\n        segmentSet.forEach((baseIndex, rle) => {\n            if (rle.value !== SegmentationEnum.INTERIOR_SMALL) {\n                return;\n            }\n            for (let iPrime = rle.start; iPrime < rle.end; iPrime++) {\n                const clearPoint = toIJK(segmentSet.toIJK(baseIndex + iPrime));\n                previewVoxelManager.setAtIJKPoint(clearPoint, previewSegmentIndex);\n            }\n        });\n        return previewVoxelManager.getArrayOfModifiedSlices();\n    }\n    static covers(rle, row) {\n        if (!row) {\n            return false;\n        }\n        let { start } = rle;\n        const { end } = rle;\n        for (const rowRle of row) {\n            if (start >= rowRle.start && start < rowRle.end) {\n                start = rowRle.end;\n                if (start >= end) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n", "import { triggerSegmentationDataModified } from '../../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport IslandRemoval from '../../../../utilities/segmentation/islandRemoval';\nexport default {\n    [StrategyCallbacks.OnInteractionEnd]: (operationData) => {\n        const { previewSegmentIndex, segmentIndex, viewport, segmentationVoxelManager, activeStrategy, memo, } = operationData;\n        if (activeStrategy !== 'THRESHOLD_INSIDE_SPHERE_WITH_ISLAND_REMOVAL' ||\n            segmentIndex === null) {\n            return;\n        }\n        const islandRemoval = new IslandRemoval();\n        const voxelManager = memo?.voxelManager || segmentationVoxelManager;\n        if (!islandRemoval.initialize(viewport, voxelManager, {\n            previewSegmentIndex,\n            segmentIndex,\n        })) {\n            return;\n        }\n        islandRemoval.floodFillSegmentIsland();\n        islandRemoval.removeExternalIslands();\n        islandRemoval.removeInternalIslands();\n        const arrayOfSlices = voxelManager.getArrayOfModifiedSlices();\n        if (!arrayOfSlices) {\n            return;\n        }\n        triggerSegmentationDataModified(operationData.segmentationId, arrayOfSlices, previewSegmentIndex);\n    },\n};\n", "import { utilities } from '@cornerstonejs/core';\nimport { triggerSegmentationDataModified } from '../../../../stateManagement/segmentation/events/triggerSegmentationDataModified';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport { setSegmentIndexColor } from '../../../../stateManagement/segmentation/config/segmentationColor';\nimport { getViewportIdsWithSegmentation } from '../../../../stateManagement/segmentation/getViewportIdsWithSegmentation';\nexport default {\n    [StrategyCallbacks.Preview]: function (operationData) {\n        const { previewSegmentIndex, configuration, enabledElement } = operationData;\n        if (!previewSegmentIndex || !configuration) {\n            return;\n        }\n        this.onInteractionStart?.(enabledElement, operationData);\n        const preview = this.fill(enabledElement, operationData);\n        if (preview) {\n            this.onInteractionEnd?.(enabledElement, operationData);\n        }\n        return preview;\n    },\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { segmentIndex, previewColor, previewSegmentIndex } = operationData;\n        operationData.modified = false;\n        if (previewSegmentIndex == null || segmentIndex == null) {\n            return;\n        }\n        const viewportIds = getViewportIdsWithSegmentation(operationData.segmentationId);\n        viewportIds?.forEach((viewportId) => {\n            setSegmentIndexColor(viewportId, operationData.segmentationId, previewSegmentIndex, previewColor);\n        });\n        operationData.modified = true;\n    },\n    [StrategyCallbacks.AcceptPreview]: (operationData) => {\n        const { previewSegmentIndex, segmentationVoxelManager, memo, segmentIndex, centerSegmentIndexInfo, } = operationData || {};\n        const { changedIndices } = centerSegmentIndexInfo || {};\n        const labelmapMemo = memo;\n        const callback = ({ index }) => {\n            const oldValue = segmentationVoxelManager.getAtIndex(index);\n            if (changedIndices?.length > 0) {\n                if (changedIndices.includes(index)) {\n                    labelmapMemo.voxelManager.setAtIndex(index, 0);\n                }\n            }\n            else {\n                if (oldValue === previewSegmentIndex) {\n                    labelmapMemo.voxelManager.setAtIndex(index, segmentIndex);\n                }\n            }\n        };\n        segmentationVoxelManager.forEach(callback);\n        triggerSegmentationDataModified(operationData.segmentationId, segmentationVoxelManager.getArrayOfModifiedSlices(), segmentIndex);\n        operationData.centerSegmentIndexInfo.changedIndices = [];\n    },\n    [StrategyCallbacks.RejectPreview]: (operationData) => {\n        if (!operationData) {\n            return;\n        }\n        utilities.HistoryMemo.DefaultHistoryMemo.undoIf((memo) => {\n            const labelmapMemo = memo;\n            if (!labelmapMemo?.voxelManager) {\n                return false;\n            }\n            const { segmentationVoxelManager } = labelmapMemo;\n            let hasPreviewSegmentIndex = false;\n            const callback = ({ value }) => {\n                if (value === operationData.previewSegmentIndex) {\n                    hasPreviewSegmentIndex = true;\n                }\n            };\n            segmentationVoxelManager.forEach(callback);\n            return hasPreviewSegmentIndex;\n        });\n    },\n};\n", "import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.Fill]: (operationData) => {\n        const { segmentsLocked, segmentationImageData, segmentationVoxelManager, brushStrategy, centerIJK, } = operationData;\n        const isWithinThreshold = brushStrategy.createIsInThreshold?.(operationData);\n        const { setValue } = brushStrategy;\n        const callback = isWithinThreshold\n            ? (data) => {\n                const { value, index } = data;\n                if (segmentsLocked.includes(value) || !isWithinThreshold(index)) {\n                    return;\n                }\n                setValue(operationData, data);\n            }\n            : (data) => setValue(operationData, data);\n        segmentationVoxelManager.forEach(callback, {\n            imageData: segmentationImageData,\n            isInObject: operationData.isInObject,\n            boundsIJK: operationData.isInObjectBoundsIJK,\n        });\n        segmentationVoxelManager.addPoint(centerIJK);\n    },\n};\n", "export function handleUseSegmentCenterIndex({ operationData, existingValue, index, }) {\n    const { previewSegmentIndex, memo, centerSegmentIndexInfo, previewOnHover, segmentIndex, } = operationData;\n    const { hasPreviewIndex, hasSegmentIndex, segmentIndex: centerSegmentIndex, } = centerSegmentIndexInfo;\n    if (centerSegmentIndex === 0 && hasSegmentIndex && hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        if (previewOnHover) {\n            return;\n        }\n        if (existingValue === previewSegmentIndex) {\n            memo.voxelManager.setAtIndex(index, 0);\n            return;\n        }\n        return;\n    }\n    if (centerSegmentIndex === 0 && hasSegmentIndex && !hasPreviewIndex) {\n        if (existingValue === 0 || existingValue !== segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        centerSegmentIndexInfo.changedIndices.push(index);\n        return;\n    }\n    if (centerSegmentIndex === 0 && !hasSegmentIndex && hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        if (previewOnHover) {\n            return;\n        }\n        if (existingValue === previewSegmentIndex) {\n            memo.voxelManager.setAtIndex(index, 0);\n            return;\n        }\n        return;\n    }\n    if (centerSegmentIndex === 0 && !hasSegmentIndex && !hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        if (existingValue === previewSegmentIndex) {\n            memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n            return;\n        }\n        return;\n    }\n    if (centerSegmentIndex === previewSegmentIndex &&\n        hasSegmentIndex &&\n        hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n    if (centerSegmentIndex === previewSegmentIndex &&\n        !hasSegmentIndex &&\n        hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n    if (centerSegmentIndex === segmentIndex &&\n        hasSegmentIndex &&\n        hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n    if (centerSegmentIndex === segmentIndex &&\n        hasSegmentIndex &&\n        !hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n}\n", "import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport { handleUseSegmentCenterIndex } from '../utils/handleUseSegmentCenterIndex';\nexport default {\n    [StrategyCallbacks.INTERNAL_setValue]: (operationData, { value, index }) => {\n        const { segmentsLocked, previewSegmentIndex, memo, segmentationVoxelManager, centerSegmentIndexInfo, segmentIndex, } = operationData;\n        const existingValue = segmentationVoxelManager.getAtIndex(index);\n        if (segmentsLocked.includes(value)) {\n            return;\n        }\n        if (!centerSegmentIndexInfo && existingValue === segmentIndex) {\n            return;\n        }\n        if (centerSegmentIndexInfo?.segmentIndex !== 0 &&\n            existingValue === segmentIndex) {\n            return;\n        }\n        if (centerSegmentIndexInfo?.segmentIndex === null) {\n            memo.voxelManager.setAtIndex(index, previewSegmentIndex ?? segmentIndex);\n            return;\n        }\n        if (!previewSegmentIndex) {\n            let useSegmentIndex = segmentIndex;\n            if (centerSegmentIndexInfo) {\n                useSegmentIndex = centerSegmentIndexInfo.segmentIndex;\n            }\n            memo.voxelManager.setAtIndex(index, useSegmentIndex);\n            return;\n        }\n        handleUseSegmentCenterIndex({\n            operationData,\n            existingValue,\n            index,\n        });\n    },\n};\n", "import { vec3 } from 'gl-matrix';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.CreateIsInThreshold]: (operationData) => {\n        const { imageVoxelManager, segmentIndex, configuration } = operationData;\n        if (!configuration || !segmentIndex) {\n            return;\n        }\n        return (index) => {\n            const voxelValue = imageVoxelManager.getAtIndex(index);\n            const gray = Array.isArray(voxelValue)\n                ? vec3.length(voxelValue)\n                : voxelValue;\n            const { threshold } = configuration || {};\n            if (!threshold?.range?.length) {\n                return true;\n            }\n            return threshold.range[0] <= gray && gray <= threshold.range[1];\n        };\n    },\n};\n", "import { BasicStatsCalculator, InstanceBasicStatsCalculator, } from '../math/basic/BasicStatsCalculator';\nimport { getCalibratedLengthUnitsAndScale } from '../getCalibratedUnits';\nconst TEST_MAX_LOCATIONS = 10;\nfunction createVolumetricState() {\n    return {\n        maxIJKs: [],\n    };\n}\nfunction volumetricStatsCallback(state, data) {\n    const { value } = data;\n    const { maxIJKs } = state;\n    const length = maxIJKs.length;\n    if (typeof value !== 'number' ||\n        (length >= TEST_MAX_LOCATIONS && value < maxIJKs[0].value)) {\n        return;\n    }\n    const dataCopy = {\n        value: data.value,\n        pointLPS: data.pointLPS\n            ? [data.pointLPS[0], data.pointLPS[1], data.pointLPS[2]]\n            : undefined,\n        pointIJK: data.pointIJK\n            ? [data.pointIJK[0], data.pointIJK[1], data.pointIJK[2]]\n            : undefined,\n    };\n    if (!length || value >= maxIJKs[length - 1].value) {\n        maxIJKs.push(dataCopy);\n    }\n    else {\n        for (let i = 0; i < length; i++) {\n            if (value <= maxIJKs[i].value) {\n                maxIJKs.splice(i, 0, dataCopy);\n                break;\n            }\n        }\n    }\n    if (length >= TEST_MAX_LOCATIONS) {\n        maxIJKs.splice(0, 1);\n    }\n}\nfunction volumetricGetStatistics(state, stats, options) {\n    const { spacing, calibration } = options;\n    const { volumeUnit } = getCalibratedLengthUnitsAndScale({\n        calibration,\n        hasPixelSpacing: true,\n    }, []);\n    const volumeScale = spacing ? spacing[0] * spacing[1] * spacing[2] : 1;\n    stats.volume = {\n        value: Array.isArray(stats.count.value)\n            ? stats.count.value.map((v) => v * volumeScale)\n            : stats.count.value * volumeScale,\n        unit: volumeUnit,\n        name: 'volume',\n        label: 'Volume',\n    };\n    stats.maxIJKs = state.maxIJKs.filter((entry) => entry.pointIJK !== undefined);\n    stats.array.push(stats.volume);\n    state.maxIJKs = [];\n    return stats;\n}\nexport class VolumetricCalculator extends BasicStatsCalculator {\n    static { this.volumetricState = createVolumetricState(); }\n    static statsInit(options) {\n        super.statsInit(options);\n        this.volumetricState = createVolumetricState();\n    }\n    static statsCallback(data) {\n        super.statsCallback(data);\n        volumetricStatsCallback(this.volumetricState, data);\n    }\n    static getStatistics(options) {\n        const optionsWithUnit = {\n            ...options,\n            unit: options?.unit || 'none',\n            calibration: options?.calibration,\n            hasPixelSpacing: options?.hasPixelSpacing,\n        };\n        const stats = super.getStatistics(optionsWithUnit);\n        return volumetricGetStatistics(this.volumetricState, stats, optionsWithUnit);\n    }\n}\nexport class InstanceVolumetricCalculator extends InstanceBasicStatsCalculator {\n    constructor(options) {\n        super(options);\n        this.volumetricState = createVolumetricState();\n    }\n    statsInit(options) {\n        super.statsInit(options);\n        this.volumetricState = createVolumetricState();\n    }\n    statsCallback(data) {\n        super.statsCallback(data);\n        volumetricStatsCallback(this.volumetricState, data);\n    }\n    getStatistics(options) {\n        const optionsWithUnit = {\n            ...options,\n            unit: options?.unit || 'none',\n            calibration: options?.calibration,\n            hasPixelSpacing: options?.hasPixelSpacing,\n        };\n        const stats = super.getStatistics(optionsWithUnit);\n        return volumetricGetStatistics(this.volumetricState, stats, optionsWithUnit);\n    }\n}\nexport default VolumetricCalculator;\n", "import { utilities, getWebWorkerManager } from '@cornerstonejs/core';\nimport { triggerWorkerProgress, getSegmentationDataForWorker, prepareVolumeStrategyDataForWorker, prepareStackDataForWorker, getImageReferenceInfo, } from './utilsForWorker';\nimport { getPixelValueUnitsImageId } from '../getPixelValueUnits';\nimport VolumetricCalculator from './VolumetricCalculator';\nimport { WorkerTypes } from '../../enums';\nimport { registerComputeWorker } from '../registerComputeWorker';\nconst radiusForVol1 = Math.pow((3 * 1000) / (4 * Math.PI), 1 / 3);\nasync function getStatistics({ segmentationId, segmentIndices, mode = 'collective', }) {\n    registerComputeWorker();\n    triggerWorkerProgress(WorkerTypes.COMPUTE_STATISTICS, 0);\n    const segData = getSegmentationDataForWorker(segmentationId, segmentIndices);\n    if (!segData) {\n        return;\n    }\n    const { operationData, segVolumeId, segImageIds, reconstructableVolume, indices, } = segData;\n    const { refImageId, modalityUnitOptions } = getImageReferenceInfo(segVolumeId, segImageIds);\n    const unit = getPixelValueUnitsImageId(refImageId, modalityUnitOptions);\n    const stats = reconstructableVolume\n        ? await calculateVolumeStatistics({\n            operationData,\n            indices,\n            unit,\n            mode,\n        })\n        : await calculateStackStatistics({\n            segImageIds,\n            indices,\n            unit,\n            mode,\n        });\n    return stats;\n}\nasync function calculateVolumeStatistics({ operationData, indices, unit, mode, }) {\n    const strategyData = prepareVolumeStrategyDataForWorker(operationData);\n    const { segmentationVoxelManager, imageVoxelManager, segmentationImageData, imageData, } = strategyData;\n    if (!segmentationVoxelManager || !segmentationImageData) {\n        return;\n    }\n    const spacing = segmentationImageData.getSpacing();\n    const { boundsIJK: boundsOrig } = segmentationVoxelManager;\n    if (!boundsOrig) {\n        return VolumetricCalculator.getStatistics({ spacing });\n    }\n    const segmentationScalarData = segmentationVoxelManager.getCompleteScalarDataArray();\n    const segmentationInfo = {\n        scalarData: segmentationScalarData,\n        dimensions: segmentationImageData.getDimensions(),\n        spacing: segmentationImageData.getSpacing(),\n        origin: segmentationImageData.getOrigin(),\n        direction: segmentationImageData.getDirection(),\n    };\n    const imageInfo = {\n        scalarData: imageVoxelManager.getCompleteScalarDataArray(),\n        dimensions: imageData.getDimensions(),\n        spacing: imageData.getSpacing(),\n        origin: imageData.getOrigin(),\n        direction: imageData.getDirection(),\n    };\n    if (!imageInfo.scalarData?.length) {\n        return;\n    }\n    const stats = await getWebWorkerManager().executeTask('compute', 'calculateSegmentsStatisticsVolume', {\n        segmentationInfo,\n        imageInfo,\n        indices,\n        unit,\n        mode,\n    });\n    triggerWorkerProgress(WorkerTypes.COMPUTE_STATISTICS, 100);\n    if (mode === 'collective') {\n        return processSegmentationStatistics({\n            stats,\n            unit,\n            spacing,\n            segmentationImageData,\n            imageVoxelManager,\n        });\n    }\n    else {\n        const finalStats = {};\n        Object.entries(stats).forEach(([segmentIndex, stat]) => {\n            finalStats[segmentIndex] = processSegmentationStatistics({\n                stats: stat,\n                unit,\n                spacing,\n                segmentationImageData,\n                imageVoxelManager,\n            });\n        });\n        return finalStats;\n    }\n}\nconst updateStatsArray = (stats, newStat) => {\n    if (!stats.array) {\n        return;\n    }\n    const existingIndex = stats.array.findIndex((stat) => stat.name === newStat.name);\n    if (existingIndex !== -1) {\n        stats.array[existingIndex] = newStat;\n    }\n    else {\n        stats.array.push(newStat);\n    }\n};\nconst processSegmentationStatistics = ({ stats, unit, spacing, segmentationImageData, imageVoxelManager, }) => {\n    stats.mean.unit = unit;\n    stats.max.unit = unit;\n    stats.min.unit = unit;\n    if (unit !== 'SUV') {\n        return stats;\n    }\n    const radiusIJK = spacing.map((s) => Math.max(1, Math.round((1.1 * radiusForVol1) / s)));\n    for (const testMax of stats.maxIJKs) {\n        const testStats = getSphereStats(testMax, radiusIJK, segmentationImageData, imageVoxelManager, spacing);\n        if (!testStats) {\n            continue;\n        }\n        const { mean } = testStats;\n        if (!stats.peakValue || stats.peakValue.value <= mean.value) {\n            stats.peakValue = {\n                name: 'peakValue',\n                label: 'Peak Value',\n                value: mean.value,\n                unit,\n            };\n            stats.peakPoint = {\n                name: 'peakLPS',\n                label: 'Peak SUV Point',\n                value: testMax.pointLPS ? [...testMax.pointLPS] : null,\n                unit: null,\n            };\n            updateStatsArray(stats, stats.peakValue);\n            updateStatsArray(stats, stats.peakPoint);\n        }\n    }\n    if (stats.volume && stats.mean) {\n        const mtv = stats.volume.value;\n        const suvMean = stats.mean.value;\n        stats.lesionGlycolysis = {\n            name: 'lesionGlycolysis',\n            label: 'Lesion Glycolysis',\n            value: mtv * suvMean,\n            unit: `${stats.volume.unit}·${unit}`,\n        };\n        updateStatsArray(stats, stats.lesionGlycolysis);\n    }\n    return stats;\n};\nasync function calculateStackStatistics({ segImageIds, indices, unit, mode }) {\n    triggerWorkerProgress(WorkerTypes.COMPUTE_STATISTICS, 0);\n    const { segmentationInfo, imageInfo } = prepareStackDataForWorker(segImageIds);\n    const stats = await getWebWorkerManager().executeTask('compute', 'calculateSegmentsStatisticsStack', {\n        segmentationInfo,\n        imageInfo,\n        indices,\n        mode,\n    });\n    triggerWorkerProgress(WorkerTypes.COMPUTE_STATISTICS, 100);\n    const spacing = segmentationInfo[0].spacing;\n    const segmentationImageData = segmentationInfo[0];\n    const imageVoxelManager = imageInfo[0].voxelManager;\n    if (mode === 'collective') {\n        return processSegmentationStatistics({\n            stats,\n            unit,\n            spacing,\n            segmentationImageData,\n            imageVoxelManager,\n        });\n    }\n    else {\n        const finalStats = {};\n        Object.entries(stats).forEach(([segmentIndex, stat]) => {\n            finalStats[segmentIndex] = processSegmentationStatistics({\n                stats: stat,\n                unit,\n                spacing,\n                segmentationImageData,\n                imageVoxelManager,\n            });\n        });\n        return finalStats;\n    }\n}\nfunction getSphereStats(testMax, radiusIJK, segData, imageVoxels, spacing) {\n    const { pointIJK: centerIJK, pointLPS: centerLPS } = testMax;\n    if (!centerIJK) {\n        return;\n    }\n    const boundsIJK = centerIJK.map((ijk, idx) => [\n        ijk - radiusIJK[idx],\n        ijk + radiusIJK[idx],\n    ]);\n    const testFunction = (_pointLPS, pointIJK) => {\n        const i = (pointIJK[0] - centerIJK[0]) / radiusIJK[0];\n        const j = (pointIJK[1] - centerIJK[1]) / radiusIJK[1];\n        const k = (pointIJK[2] - centerIJK[2]) / radiusIJK[2];\n        const radius = i * i + j * j + k * k;\n        return radius <= 1;\n    };\n    const statsFunction = ({ pointIJK, pointLPS }) => {\n        const value = imageVoxels.getAtIJKPoint(pointIJK);\n        if (value === undefined) {\n            return;\n        }\n        VolumetricCalculator.statsCallback({ value, pointLPS, pointIJK });\n    };\n    VolumetricCalculator.statsInit({ storePointData: false });\n    utilities.pointInShapeCallback(segData, {\n        pointInShapeFn: testFunction,\n        callback: statsFunction,\n        boundsIJK,\n    });\n    return VolumetricCalculator.getStatistics({ spacing });\n}\nexport default getStatistics;\n", "import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport getStatistics from '../../../../utilities/segmentation/getStatistics';\nexport default {\n    [StrategyCallbacks.GetStatistics]: function (enabledElement, operationData, options) {\n        const { indices } = options;\n        const { segmentationId, viewport } = operationData;\n        getStatistics({\n            segmentationId,\n            segmentIndices: indices,\n        });\n    },\n};\n", "import determineSegmentIndex from './determineSegmentIndex';\nimport dynamicThreshold from './dynamicThreshold';\nimport erase from './erase';\nimport islandRemoval from './islandRemovalComposition';\nimport preview from './preview';\nimport regionFill from './regionFill';\nimport setValue from './setValue';\nimport threshold from './threshold';\nimport labelmapStatistics from './labelmapStatistics';\nimport ensureSegmentationVolumeFor3DManipulation from './ensureSegmentationVolume';\nimport ensureImageVolumeFor3DManipulation from './ensureImageVolume';\nexport default {\n    determineSegmentIndex,\n    dynamicThreshold,\n    erase,\n    islandRemoval,\n    preview,\n    regionFill,\n    setValue,\n    threshold,\n    labelmapStatistics,\n    ensureSegmentationVolumeFor3DManipulation,\n    ensureImageVolumeFor3DManipulation,\n};\n", "import { utilities as csUtils } from '@cornerstonejs/core';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport compositions from './compositions';\nimport { getStrategyData } from './utils/getStrategyData';\nimport { StrategyCallbacks } from '../../../enums';\nexport default class BrushStrategy {\n    static { this.COMPOSITIONS = compositions; }\n    static { this.childFunctions = {\n        [StrategyCallbacks.OnInteractionStart]: addListMethod(StrategyCallbacks.OnInteractionStart, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.OnInteractionEnd]: addListMethod(StrategyCallbacks.OnInteractionEnd, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.Fill]: addListMethod(StrategyCallbacks.Fill),\n        [StrategyCallbacks.Initialize]: addListMethod(StrategyCallbacks.Initialize),\n        [StrategyCallbacks.CreateIsInThreshold]: addSingletonMethod(StrategyCallbacks.CreateIsInThreshold),\n        [StrategyCallbacks.Interpolate]: addListMethod(StrategyCallbacks.Interpolate, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.AcceptPreview]: addListMethod(StrategyCallbacks.AcceptPreview, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.RejectPreview]: addListMethod(StrategyCallbacks.RejectPreview, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.INTERNAL_setValue]: addSingletonMethod(StrategyCallbacks.INTERNAL_setValue),\n        [StrategyCallbacks.Preview]: addSingletonMethod(StrategyCallbacks.Preview, false),\n        [StrategyCallbacks.ComputeInnerCircleRadius]: addListMethod(StrategyCallbacks.ComputeInnerCircleRadius),\n        [StrategyCallbacks.EnsureSegmentationVolumeFor3DManipulation]: addListMethod(StrategyCallbacks.EnsureSegmentationVolumeFor3DManipulation),\n        [StrategyCallbacks.EnsureImageVolumeFor3DManipulation]: addListMethod(StrategyCallbacks.EnsureImageVolumeFor3DManipulation),\n        [StrategyCallbacks.AddPreview]: addListMethod(StrategyCallbacks.AddPreview),\n        [StrategyCallbacks.GetStatistics]: addSingletonMethod(StrategyCallbacks.GetStatistics),\n        compositions: null,\n    }; }\n    constructor(name, ...initializers) {\n        this._initialize = [];\n        this._fill = [];\n        this._onInteractionStart = [];\n        this.fill = (enabledElement, operationData) => {\n            const initializedData = this.initialize(enabledElement, operationData, StrategyCallbacks.Fill);\n            if (!initializedData) {\n                return;\n            }\n            this._fill.forEach((func) => func(initializedData));\n            const { segmentationVoxelManager, segmentIndex } = initializedData;\n            triggerSegmentationDataModified(initializedData.segmentationId, segmentationVoxelManager.getArrayOfModifiedSlices(), segmentIndex);\n            return initializedData;\n        };\n        this.onInteractionStart = (enabledElement, operationData) => {\n            const initializedData = this.initialize(enabledElement, operationData);\n            if (!initializedData) {\n                return;\n            }\n            this._onInteractionStart.forEach((func) => func.call(this, initializedData));\n        };\n        this.addPreview = (enabledElement, operationData) => {\n            const initializedData = this.initialize(enabledElement, operationData, StrategyCallbacks.AddPreview);\n            if (!initializedData) {\n                return;\n            }\n            return initializedData;\n        };\n        this.configurationName = name;\n        this.compositions = initializers;\n        initializers.forEach((initializer) => {\n            const result = typeof initializer === 'function' ? initializer() : initializer;\n            if (!result) {\n                return;\n            }\n            for (const key in result) {\n                if (!BrushStrategy.childFunctions[key]) {\n                    throw new Error(`Didn't find ${key} as a brush strategy`);\n                }\n                BrushStrategy.childFunctions[key](this, result[key]);\n            }\n        });\n        this.strategyFunction = (enabledElement, operationData) => {\n            return this.fill(enabledElement, operationData);\n        };\n        for (const key of Object.keys(BrushStrategy.childFunctions)) {\n            this.strategyFunction[key] = this[key];\n        }\n    }\n    initialize(enabledElement, operationData, operationName) {\n        const { viewport } = enabledElement;\n        const data = getStrategyData({ operationData, viewport, strategy: this });\n        if (!data) {\n            return null;\n        }\n        const { imageVoxelManager, segmentationVoxelManager, segmentationImageData, } = data;\n        const memo = operationData.createMemo(operationData.segmentationId, segmentationVoxelManager);\n        const initializedData = {\n            operationName,\n            ...operationData,\n            segmentIndex: operationData.segmentIndex,\n            enabledElement,\n            imageVoxelManager,\n            segmentationVoxelManager,\n            segmentationImageData,\n            viewport,\n            centerWorld: null,\n            isInObject: null,\n            isInObjectBoundsIJK: null,\n            brushStrategy: this,\n            memo,\n        };\n        this._initialize.forEach((func) => func(initializedData));\n        return initializedData;\n    }\n}\nfunction addListMethod(name, createInitialized) {\n    const listName = `_${name}`;\n    return (brushStrategy, func) => {\n        brushStrategy[listName] ||= [];\n        brushStrategy[listName].push(func);\n        brushStrategy[name] ||= createInitialized\n            ? (enabledElement, operationData, ...args) => {\n                const initializedData = brushStrategy[createInitialized](enabledElement, operationData, name);\n                let returnValue;\n                brushStrategy[listName].forEach((func) => {\n                    const value = func.call(brushStrategy, initializedData, ...args);\n                    returnValue ||= value;\n                });\n                return returnValue;\n            }\n            : (operationData, ...args) => {\n                brushStrategy[listName].forEach((func) => func.call(brushStrategy, operationData, ...args));\n            };\n    };\n}\nfunction addSingletonMethod(name, isInitialized = true) {\n    return (brushStrategy, func) => {\n        if (brushStrategy[name]) {\n            throw new Error(`The singleton method ${name} already exists`);\n        }\n        brushStrategy[name] = isInitialized\n            ? func\n            : (enabledElement, operationData, ...args) => {\n                operationData.enabledElement = enabledElement;\n                return func.call(brushStrategy, operationData, ...args);\n            };\n    };\n}\n", "export default function pointInSphere(sphere, pointLPS) {\n    const { center, radius } = sphere;\n    const radius2 = sphere.radius2 || radius * radius;\n    return ((pointLPS[0] - center[0]) * (pointLPS[0] - center[0]) +\n        (pointLPS[1] - center[1]) * (pointLPS[1] - center[1]) +\n        (pointLPS[2] - center[2]) * (pointLPS[2] - center[2]) <=\n        radius2);\n}\n", "import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShapeIJK } from '../../../utilities/boundingBox';\nimport BrushStrategy from './BrushStrategy';\nimport { StrategyCallbacks } from '../../../enums';\nimport compositions from './compositions';\nimport { pointInSphere } from '../../../utilities/math/sphere';\nconst { transformWorldToIndex, transformIndexToWorld, isEqual } = csUtils;\nexport function getEllipseCornersFromCanvasCoordinates(canvasCoordinates) {\n    const [bottom, top, left, right] = canvasCoordinates;\n    const topLeft = [left[0], top[1]];\n    const bottomRight = [right[0], bottom[1]];\n    const bottomLeft = [left[0], bottom[1]];\n    const topRight = [right[0], top[1]];\n    return [topLeft, bottomRight, bottomLeft, topRight];\n}\nfunction createCircleCornersForCenter(center, viewUp, viewRight, radius) {\n    const centerVec = vec3.fromValues(center[0], center[1], center[2]);\n    const top = vec3.create();\n    vec3.scaleAndAdd(top, centerVec, viewUp, radius);\n    const bottom = vec3.create();\n    vec3.scaleAndAdd(bottom, centerVec, viewUp, -radius);\n    const right = vec3.create();\n    vec3.scaleAndAdd(right, centerVec, viewRight, radius);\n    const left = vec3.create();\n    vec3.scaleAndAdd(left, centerVec, viewRight, -radius);\n    return [\n        bottom,\n        top,\n        left,\n        right,\n    ];\n}\nfunction createStrokePredicate(centers, radius) {\n    if (!centers.length || radius <= 0) {\n        return null;\n    }\n    const radiusSquared = radius * radius;\n    const centerVecs = centers.map((point) => [point[0], point[1], point[2]]);\n    const segments = [];\n    for (let i = 1; i < centerVecs.length; i++) {\n        const start = centerVecs[i - 1];\n        const end = centerVecs[i];\n        const dx = end[0] - start[0];\n        const dy = end[1] - start[1];\n        const dz = end[2] - start[2];\n        const lengthSquared = dx * dx + dy * dy + dz * dz;\n        segments.push({ start, vector: [dx, dy, dz], lengthSquared });\n    }\n    return (worldPoint) => {\n        if (!worldPoint) {\n            return false;\n        }\n        for (const centerVec of centerVecs) {\n            const dx = worldPoint[0] - centerVec[0];\n            const dy = worldPoint[1] - centerVec[1];\n            const dz = worldPoint[2] - centerVec[2];\n            if (dx * dx + dy * dy + dz * dz <= radiusSquared) {\n                return true;\n            }\n        }\n        for (const { start, vector, lengthSquared } of segments) {\n            if (lengthSquared === 0) {\n                const dx = worldPoint[0] - start[0];\n                const dy = worldPoint[1] - start[1];\n                const dz = worldPoint[2] - start[2];\n                if (dx * dx + dy * dy + dz * dz <= radiusSquared) {\n                    return true;\n                }\n                continue;\n            }\n            const dx = worldPoint[0] - start[0];\n            const dy = worldPoint[1] - start[1];\n            const dz = worldPoint[2] - start[2];\n            const dot = dx * vector[0] + dy * vector[1] + dz * vector[2];\n            const t = Math.max(0, Math.min(1, dot / lengthSquared));\n            const projX = start[0] + vector[0] * t;\n            const projY = start[1] + vector[1] * t;\n            const projZ = start[2] + vector[2] * t;\n            const distX = worldPoint[0] - projX;\n            const distY = worldPoint[1] - projY;\n            const distZ = worldPoint[2] - projZ;\n            if (distX * distX + distY * distY + distZ * distZ <= radiusSquared) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nconst initializeCircle = {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { points, viewport, segmentationImageData, viewUp, viewPlaneNormal, } = operationData;\n        if (!points) {\n            return;\n        }\n        const center = vec3.create();\n        if (points.length >= 2) {\n            vec3.add(center, points[0], points[1]);\n            vec3.scale(center, center, 0.5);\n        }\n        else {\n            vec3.copy(center, points[0]);\n        }\n        operationData.centerWorld = center;\n        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);\n        const brushRadius = points.length >= 2 ? vec3.distance(points[0], points[1]) / 2 : 0;\n        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n        const corners = getEllipseCornersFromCanvasCoordinates(canvasCoordinates);\n        const cornersInWorld = corners.map((corner) => viewport.canvasToWorld(corner));\n        const normalizedViewUp = vec3.fromValues(viewUp[0], viewUp[1], viewUp[2]);\n        vec3.normalize(normalizedViewUp, normalizedViewUp);\n        const normalizedPlaneNormal = vec3.fromValues(viewPlaneNormal[0], viewPlaneNormal[1], viewPlaneNormal[2]);\n        vec3.normalize(normalizedPlaneNormal, normalizedPlaneNormal);\n        const viewRight = vec3.create();\n        vec3.cross(viewRight, normalizedViewUp, normalizedPlaneNormal);\n        vec3.normalize(viewRight, viewRight);\n        const strokeCentersSource = operationData.strokePointsWorld &&\n            operationData.strokePointsWorld.length > 0\n            ? operationData.strokePointsWorld\n            : [operationData.centerWorld];\n        const strokeCenters = strokeCentersSource.map((point) => vec3.clone(point));\n        const strokeCornersWorld = strokeCenters.flatMap((centerPoint) => createCircleCornersForCenter(centerPoint, normalizedViewUp, viewRight, brushRadius));\n        const circleCornersIJK = strokeCornersWorld.map((world) => transformWorldToIndex(segmentationImageData, world));\n        const boundsIJK = getBoundingBoxAroundShapeIJK(circleCornersIJK, segmentationImageData.getDimensions());\n        operationData.strokePointsWorld = strokeCenters;\n        operationData.isInObject = createPointInEllipse(cornersInWorld, {\n            strokePointsWorld: strokeCenters,\n            segmentationImageData,\n            radius: brushRadius,\n        });\n        operationData.isInObjectBoundsIJK = boundsIJK;\n    },\n};\nfunction createPointInEllipse(cornersInWorld = [], options = {}) {\n    if (!cornersInWorld || cornersInWorld.length !== 4) {\n        throw new Error('createPointInEllipse: cornersInWorld must have 4 points');\n    }\n    const [topLeft, bottomRight, bottomLeft, topRight] = cornersInWorld;\n    const center = vec3.create();\n    vec3.add(center, topLeft, bottomRight);\n    vec3.scale(center, center, 0.5);\n    const majorAxisVec = vec3.create();\n    vec3.subtract(majorAxisVec, topRight, topLeft);\n    const xRadius = vec3.length(majorAxisVec) / 2;\n    vec3.normalize(majorAxisVec, majorAxisVec);\n    const minorAxisVec = vec3.create();\n    vec3.subtract(minorAxisVec, bottomLeft, topLeft);\n    const yRadius = vec3.length(minorAxisVec) / 2;\n    vec3.normalize(minorAxisVec, minorAxisVec);\n    const normal = vec3.create();\n    vec3.cross(normal, majorAxisVec, minorAxisVec);\n    vec3.normalize(normal, normal);\n    const radiusForStroke = options.radius ?? Math.max(xRadius, yRadius);\n    const strokePredicate = createStrokePredicate(options.strokePointsWorld || [], radiusForStroke);\n    if (isEqual(xRadius, yRadius)) {\n        const radius = xRadius;\n        const sphereObj = {\n            center,\n            radius,\n            radius2: radius * radius,\n        };\n        return (pointLPS, pointIJK) => {\n            let worldPoint = pointLPS;\n            if (!worldPoint && pointIJK && options.segmentationImageData) {\n                worldPoint = transformIndexToWorld(options.segmentationImageData, pointIJK);\n            }\n            if (!worldPoint) {\n                return false;\n            }\n            if (strokePredicate?.(worldPoint)) {\n                return true;\n            }\n            return pointInSphere(sphereObj, worldPoint);\n        };\n    }\n    return (pointLPS, pointIJK) => {\n        let worldPoint = pointLPS;\n        if (!worldPoint && pointIJK && options.segmentationImageData) {\n            worldPoint = transformIndexToWorld(options.segmentationImageData, pointIJK);\n        }\n        if (!worldPoint) {\n            return false;\n        }\n        if (strokePredicate?.(worldPoint)) {\n            return true;\n        }\n        const pointVec = vec3.create();\n        vec3.subtract(pointVec, worldPoint, center);\n        const distToPlane = vec3.dot(pointVec, normal);\n        const proj = vec3.create();\n        vec3.scaleAndAdd(proj, pointVec, normal, -distToPlane);\n        const fromTopLeft = vec3.create();\n        const centerToTopLeft = vec3.create();\n        vec3.subtract(centerToTopLeft, center, topLeft);\n        vec3.subtract(fromTopLeft, proj, centerToTopLeft);\n        const x = vec3.dot(fromTopLeft, majorAxisVec);\n        const y = vec3.dot(fromTopLeft, minorAxisVec);\n        return (x * x) / (xRadius * xRadius) + (y * y) / (yRadius * yRadius) <= 1;\n    };\n}\nconst CIRCLE_STRATEGY = new BrushStrategy('Circle', compositions.regionFill, compositions.setValue, initializeCircle, compositions.determineSegmentIndex, compositions.preview, compositions.labelmapStatistics);\nconst CIRCLE_THRESHOLD_STRATEGY = new BrushStrategy('CircleThreshold', compositions.regionFill, compositions.setValue, initializeCircle, compositions.determineSegmentIndex, compositions.dynamicThreshold, compositions.threshold, compositions.preview, compositions.islandRemoval, compositions.labelmapStatistics);\nconst fillInsideCircle = CIRCLE_STRATEGY.strategyFunction;\nconst thresholdInsideCircle = CIRCLE_THRESHOLD_STRATEGY.strategyFunction;\nexport function fillOutsideCircle() {\n    throw new Error('Not yet implemented');\n}\nexport { CIRCLE_STRATEGY, CIRCLE_THRESHOLD_STRATEGY, fillInsideCircle, thresholdInsideCircle, createPointInEllipse, createPointInEllipse as createEllipseInPoint, };\n", "import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport BrushStrategy from './BrushStrategy';\nimport compositions from './compositions';\nimport StrategyCallbacks from '../../../enums/StrategyCallbacks';\nimport { createEllipseInPoint, getEllipseCornersFromCanvasCoordinates, } from './fillCircle';\nconst { transformWorldToIndex } = csUtils;\nimport { getSphereBoundsInfoFromViewport } from '../../../utilities/getSphereBoundsInfo';\nconst sphereComposition = {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { points, viewport, segmentationImageData } = operationData;\n        if (!points) {\n            return;\n        }\n        const center = vec3.create();\n        if (points.length >= 2) {\n            vec3.add(center, points[0], points[1]);\n            vec3.scale(center, center, 0.5);\n        }\n        else {\n            vec3.copy(center, points[0]);\n        }\n        operationData.centerWorld = center;\n        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);\n        const baseExtent = getSphereBoundsInfoFromViewport(points.slice(0, 2), segmentationImageData, viewport);\n        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n        const corners = getEllipseCornersFromCanvasCoordinates(canvasCoordinates);\n        const cornersInWorld = corners.map((corner) => viewport.canvasToWorld(corner));\n        const strokeRadius = points.length >= 2 ? vec3.distance(points[0], points[1]) / 2 : undefined;\n        const strokeCenters = operationData.strokePointsWorld &&\n            operationData.strokePointsWorld.length > 0\n            ? operationData.strokePointsWorld\n            : [operationData.centerWorld];\n        const baseBounds = baseExtent.boundsIJK;\n        const baseCenterIJK = operationData.centerIJK;\n        const boundsForStroke = strokeCenters.reduce((acc, centerPoint) => {\n            if (!centerPoint) {\n                return acc;\n            }\n            const translatedCenterIJK = transformWorldToIndex(segmentationImageData, centerPoint);\n            const deltaIJK = [\n                translatedCenterIJK[0] - baseCenterIJK[0],\n                translatedCenterIJK[1] - baseCenterIJK[1],\n                translatedCenterIJK[2] - baseCenterIJK[2],\n            ];\n            const translatedBounds = [\n                [baseBounds[0][0] + deltaIJK[0], baseBounds[0][1] + deltaIJK[0]],\n                [baseBounds[1][0] + deltaIJK[1], baseBounds[1][1] + deltaIJK[1]],\n                [baseBounds[2][0] + deltaIJK[2], baseBounds[2][1] + deltaIJK[2]],\n            ];\n            if (!acc) {\n                return translatedBounds;\n            }\n            return [\n                [\n                    Math.min(acc[0][0], translatedBounds[0][0]),\n                    Math.max(acc[0][1], translatedBounds[0][1]),\n                ],\n                [\n                    Math.min(acc[1][0], translatedBounds[1][0]),\n                    Math.max(acc[1][1], translatedBounds[1][1]),\n                ],\n                [\n                    Math.min(acc[2][0], translatedBounds[2][0]),\n                    Math.max(acc[2][1], translatedBounds[2][1]),\n                ],\n            ];\n        }, null);\n        const boundsToUse = boundsForStroke ?? baseExtent.boundsIJK;\n        if (segmentationImageData) {\n            const dimensions = segmentationImageData.getDimensions();\n            operationData.isInObjectBoundsIJK = [\n                [\n                    Math.max(0, Math.min(boundsToUse[0][0], dimensions[0] - 1)),\n                    Math.max(0, Math.min(boundsToUse[0][1], dimensions[0] - 1)),\n                ],\n                [\n                    Math.max(0, Math.min(boundsToUse[1][0], dimensions[1] - 1)),\n                    Math.max(0, Math.min(boundsToUse[1][1], dimensions[1] - 1)),\n                ],\n                [\n                    Math.max(0, Math.min(boundsToUse[2][0], dimensions[2] - 1)),\n                    Math.max(0, Math.min(boundsToUse[2][1], dimensions[2] - 1)),\n                ],\n            ];\n        }\n        else {\n            operationData.isInObjectBoundsIJK = boundsToUse;\n        }\n        operationData.isInObject = createEllipseInPoint(cornersInWorld, {\n            strokePointsWorld: operationData.strokePointsWorld,\n            segmentationImageData,\n            radius: strokeRadius,\n        });\n    },\n};\nconst SPHERE_STRATEGY = new BrushStrategy('Sphere', compositions.regionFill, compositions.setValue, sphereComposition, compositions.determineSegmentIndex, compositions.preview, compositions.labelmapStatistics, compositions.ensureSegmentationVolumeFor3DManipulation);\nconst fillInsideSphere = SPHERE_STRATEGY.strategyFunction;\nconst SPHERE_THRESHOLD_STRATEGY = new BrushStrategy('SphereThreshold', ...SPHERE_STRATEGY.compositions, compositions.dynamicThreshold, compositions.threshold, compositions.ensureSegmentationVolumeFor3DManipulation, compositions.ensureImageVolumeFor3DManipulation);\nconst SPHERE_THRESHOLD_STRATEGY_ISLAND = new BrushStrategy('SphereThreshold', ...SPHERE_STRATEGY.compositions, compositions.dynamicThreshold, compositions.threshold, compositions.islandRemoval, compositions.ensureSegmentationVolumeFor3DManipulation, compositions.ensureImageVolumeFor3DManipulation);\nconst thresholdInsideSphere = SPHERE_THRESHOLD_STRATEGY.strategyFunction;\nconst thresholdInsideSphereIsland = SPHERE_THRESHOLD_STRATEGY_ISLAND.strategyFunction;\nexport function fillOutsideSphere() {\n    throw new Error('fill outside sphere not implemented');\n}\nexport { fillInsideSphere, thresholdInsideSphere, SPHERE_STRATEGY, thresholdInsideSphereIsland, };\n", "import BrushStrategy from './BrushStrategy';\nimport { SPHERE_STRATEGY } from './fillSphere';\nimport compositions from './compositions';\nconst ERASE_SPHERE_STRATEGY = new BrushStrategy('EraseSphere', compositions.erase, ...SPHERE_STRATEGY.compositions);\nconst eraseInsideSphere = ERASE_SPHERE_STRATEGY.strategyFunction;\nexport { eraseInsideSphere };\n", "import BrushStrategy from './BrushStrategy';\nimport { CIRCLE_STRATEGY } from './fillCircle';\nimport compositions from './compositions';\nconst ERASE_CIRCLE_STRATEGY = new BrushStrategy('EraseCircle', compositions.erase, ...CIRCLE_STRATEGY.compositions);\nconst eraseInsideCircle = ERASE_CIRCLE_STRATEGY.strategyFunction;\nexport { eraseInsideCircle };\n", "import { utilities, eventTarget } from '@cornerstonejs/core';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport Events from '../../enums/Events';\nconst { VoxelManager, RLEVoxelMap } = utilities;\nexport function createLabelmapMemo(segmentationId, segmentationVoxelManager) {\n    return createRleMemo(segmentationId, segmentationVoxelManager);\n}\nexport function restoreMemo(isUndo) {\n    const { segmentationVoxelManager, undoVoxelManager, redoVoxelManager } = this;\n    const useVoxelManager = isUndo === false ? redoVoxelManager : undoVoxelManager;\n    useVoxelManager.forEach(({ value, pointIJK }) => {\n        segmentationVoxelManager.setAtIJKPoint(pointIJK, value);\n    });\n    const slices = useVoxelManager.getArrayOfModifiedSlices();\n    triggerSegmentationDataModified(this.segmentationId, slices);\n}\nexport function createRleMemo(segmentationId, segmentationVoxelManager) {\n    const voxelManager = VoxelManager.createRLEHistoryVoxelManager(segmentationVoxelManager);\n    const state = {\n        segmentationId,\n        restoreMemo,\n        commitMemo,\n        segmentationVoxelManager,\n        voxelManager,\n        id: utilities.uuidv4(),\n        operationType: 'labelmap',\n    };\n    return state;\n}\nfunction commitMemo() {\n    if (this.redoVoxelManager) {\n        return true;\n    }\n    if (!this.voxelManager.modifiedSlices.size) {\n        return false;\n    }\n    const { segmentationVoxelManager } = this;\n    const undoVoxelManager = VoxelManager.createRLEHistoryVoxelManager(segmentationVoxelManager);\n    RLEVoxelMap.copyMap(undoVoxelManager.map, this.voxelManager.map);\n    for (const key of this.voxelManager.modifiedSlices.keys()) {\n        undoVoxelManager.modifiedSlices.add(key);\n    }\n    this.undoVoxelManager = undoVoxelManager;\n    const redoVoxelManager = VoxelManager.createRLEVolumeVoxelManager({\n        dimensions: this.segmentationVoxelManager.dimensions,\n    });\n    this.redoVoxelManager = redoVoxelManager;\n    undoVoxelManager.forEach(({ index, pointIJK, value }) => {\n        const currentValue = segmentationVoxelManager.getAtIJKPoint(pointIJK);\n        if (currentValue === value) {\n            return;\n        }\n        redoVoxelManager.setAtIndex(index, currentValue);\n    });\n    return true;\n}\n", "import { fillInsideRectangle, thresholdInsideRectangle } from './fillRectangle';\nimport { fillInsideCircle, fillOutsideCircle } from './fillCircle';\nexport { fillInsideRectangle, thresholdInsideRectangle, fillInsideCircle, fillOutsideCircle, };\n", "import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils, StackViewport } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShapeIJK } from '../../../utilities/boundingBox';\nimport BrushStrategy from './BrushStrategy';\nimport { StrategyCallbacks } from '../../../enums';\nimport compositions from './compositions';\nconst { transformWorldToIndex } = csUtils;\nconst initializeRectangle = {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { points, viewport, segmentationImageData, } = operationData;\n        if (!points) {\n            return;\n        }\n        const center = vec3.fromValues(0, 0, 0);\n        points.forEach((point) => {\n            vec3.add(center, center, point);\n        });\n        vec3.scale(center, center, 1 / points.length);\n        operationData.centerWorld = center;\n        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);\n        const { boundsIJK, pointInShapeFn } = createPointInRectangle(viewport, points, segmentationImageData);\n        operationData.isInObject = pointInShapeFn;\n        operationData.isInObjectBoundsIJK = boundsIJK;\n    },\n};\nfunction createPointInRectangle(viewport, points, segmentationImageData) {\n    let rectangleCornersIJK = points.map((world) => {\n        return transformWorldToIndex(segmentationImageData, world);\n    });\n    rectangleCornersIJK = rectangleCornersIJK.map((point) => {\n        return point.map((coord) => {\n            return Math.round(coord);\n        });\n    });\n    const boundsIJK = getBoundingBoxAroundShapeIJK(rectangleCornersIJK, segmentationImageData.getDimensions());\n    const [p0, p1, p2, p3] = points;\n    const axisU = vec3.create();\n    const axisV = vec3.create();\n    vec3.subtract(axisU, p1, p0);\n    vec3.subtract(axisV, p3, p0);\n    const uLen = vec3.length(axisU);\n    const vLen = vec3.length(axisV);\n    vec3.normalize(axisU, axisU);\n    vec3.normalize(axisV, axisV);\n    const normal = vec3.create();\n    vec3.cross(normal, axisU, axisV);\n    vec3.normalize(normal, normal);\n    const direction = segmentationImageData.getDirection();\n    const spacing = segmentationImageData.getSpacing();\n    const { viewPlaneNormal } = viewport.getCamera();\n    const EPS = csUtils.getSpacingInNormalDirection({\n        direction,\n        spacing,\n    }, viewPlaneNormal);\n    const pointInShapeFn = (pointLPS) => {\n        const v = vec3.create();\n        vec3.subtract(v, pointLPS, p0);\n        const u = vec3.dot(v, axisU);\n        const vproj = vec3.dot(v, axisV);\n        const d = Math.abs(vec3.dot(v, normal));\n        return (u >= -EPS &&\n            u <= uLen + EPS &&\n            vproj >= -EPS &&\n            vproj <= vLen + EPS &&\n            d <= EPS);\n    };\n    return { boundsIJK, pointInShapeFn };\n}\nconst RECTANGLE_STRATEGY = new BrushStrategy('Rectangle', compositions.regionFill, compositions.setValue, initializeRectangle, compositions.determineSegmentIndex, compositions.preview, compositions.labelmapStatistics);\nconst RECTANGLE_THRESHOLD_STRATEGY = new BrushStrategy('RectangleThreshold', compositions.regionFill, compositions.setValue, initializeRectangle, compositions.determineSegmentIndex, compositions.dynamicThreshold, compositions.threshold, compositions.preview, compositions.islandRemoval, compositions.labelmapStatistics);\nconst fillInsideRectangle = RECTANGLE_STRATEGY.strategyFunction;\nconst thresholdInsideRectangle = RECTANGLE_THRESHOLD_STRATEGY.strategyFunction;\nexport { RECTANGLE_STRATEGY, RECTANGLE_THRESHOLD_STRATEGY, fillInsideRectangle, thresholdInsideRectangle, };\n", "import { getEnabledElement, cache, utilities as csUtils, Enums, eventTarget, BaseVolumeViewport, StackViewport, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/getActiveSegmentation';\nimport { getLockedSegmentIndices } from '../../stateManagement/segmentation/segmentLocking';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport { getCurrentLabelmapImageIdForViewport } from '../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nimport { getSegmentIndexColor } from '../../stateManagement/segmentation/config/segmentationColor';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { StrategyCallbacks } from '../../enums';\nimport * as LabelmapMemo from '../../utilities/segmentation/createLabelmapMemo';\nimport { getAllAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\nimport { isPointInsidePolyline3D } from '../../utilities/math/polyline';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { fillInsideCircle } from './strategies';\nexport default class LabelmapBaseTool extends BaseTool {\n    static { this.previewData = {\n        preview: null,\n        element: null,\n        timerStart: 0,\n        timer: null,\n        startPoint: [NaN, NaN],\n        isDrag: false,\n    }; }\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n        this.memoMap = new Map();\n        this.acceptedMemoIds = new Map();\n        this.centerSegmentIndexInfo = {\n            segmentIndex: null,\n            hasSegmentIndex: false,\n            hasPreviewIndex: false,\n            changedIndices: [],\n        };\n    }\n    _historyRedoHandler(evt) {\n        const { id, operationType } = evt.detail;\n        if (operationType !== 'labelmap') {\n            return;\n        }\n        if (this.acceptedMemoIds.has(id)) {\n            this._hoverData = null;\n            const memoData = this.acceptedMemoIds.get(id);\n            const element = memoData?.element;\n            const operationData = this.getOperationData(element);\n            operationData.segmentIndex = memoData?.segmentIndex;\n            if (element) {\n                this.applyActiveStrategyCallback(getEnabledElement(element), operationData, StrategyCallbacks.AcceptPreview);\n            }\n        }\n        this._previewData.isDrag = true;\n    }\n    get _previewData() {\n        return LabelmapBaseTool.previewData;\n    }\n    hasPreviewData() {\n        return !!this._previewData.preview;\n    }\n    shouldResolvePreviewRequests() {\n        return ((this.mode === 'Active' || this.mode === 'Enabled') &&\n            this.hasPreviewData());\n    }\n    createMemo(segmentationId, segmentationVoxelManager) {\n        const voxelManagerId = segmentationVoxelManager.id;\n        if (this.memo &&\n            this.memo.segmentationVoxelManager === segmentationVoxelManager) {\n            return this.memo;\n        }\n        let memo = this.memoMap.get(voxelManagerId);\n        if (!memo) {\n            memo = LabelmapMemo.createLabelmapMemo(segmentationId, segmentationVoxelManager);\n            this.memoMap.set(voxelManagerId, memo);\n        }\n        else {\n            if (memo.redoVoxelManager) {\n                memo = LabelmapMemo.createLabelmapMemo(segmentationId, segmentationVoxelManager);\n                this.memoMap.set(voxelManagerId, memo);\n            }\n        }\n        this.memo = memo;\n        return memo;\n    }\n    createEditData(element) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const activeSegmentation = getActiveSegmentation(viewport.id);\n        if (!activeSegmentation) {\n            const event = new CustomEvent(Enums.Events.ERROR_EVENT, {\n                detail: {\n                    type: 'Segmentation',\n                    message: 'No active segmentation detected, create a segmentation representation before using the brush tool',\n                },\n                cancelable: true,\n            });\n            eventTarget.dispatchEvent(event);\n            return null;\n        }\n        const { segmentationId } = activeSegmentation;\n        const segmentsLocked = getLockedSegmentIndices(segmentationId);\n        const { representationData } = getSegmentation(segmentationId);\n        const editData = this.getEditData({\n            viewport,\n            representationData,\n            segmentsLocked,\n            segmentationId,\n        });\n        return editData;\n    }\n    getEditData({ viewport, representationData, segmentsLocked, segmentationId, }) {\n        if (viewport instanceof BaseVolumeViewport) {\n            const { volumeId } = representationData[SegmentationRepresentations.Labelmap];\n            const actors = viewport.getActors();\n            const isStackViewport = viewport instanceof StackViewport;\n            if (isStackViewport) {\n                const event = new CustomEvent(Enums.Events.ERROR_EVENT, {\n                    detail: {\n                        type: 'Segmentation',\n                        message: 'Cannot perform brush operation on the selected viewport',\n                    },\n                    cancelable: true,\n                });\n                eventTarget.dispatchEvent(event);\n                return null;\n            }\n            const volumes = actors.map((actorEntry) => cache.getVolume(actorEntry.referencedId));\n            const segmentationVolume = cache.getVolume(volumeId);\n            const referencedVolumeIdToThreshold = volumes.find((volume) => csUtils.isEqual(volume.dimensions, segmentationVolume.dimensions))?.volumeId || volumes[0]?.volumeId;\n            return {\n                volumeId,\n                referencedVolumeId: this.configuration.threshold?.volumeId ??\n                    referencedVolumeIdToThreshold,\n                segmentsLocked,\n            };\n        }\n        else {\n            const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n            if (!segmentationImageId) {\n                return;\n            }\n            return {\n                imageId: segmentationImageId,\n                segmentsLocked,\n            };\n        }\n    }\n    createHoverData(element, centerCanvas) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, viewUp } = camera;\n        const viewportIdsToRender = [viewport.id];\n        const { segmentIndex, segmentationId, segmentColor } = this.getActiveSegmentationData(viewport) || {};\n        const brushCursor = {\n            metadata: {\n                viewPlaneNormal: [...viewPlaneNormal],\n                viewUp: [...viewUp],\n                FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                referencedImageId: '',\n                toolName: this.getToolName(),\n                segmentColor,\n            },\n            data: {},\n        };\n        return {\n            brushCursor,\n            centerCanvas,\n            segmentIndex,\n            viewport,\n            segmentationId,\n            segmentColor,\n            viewportIdsToRender,\n        };\n    }\n    getActiveSegmentationData(viewport) {\n        const viewportId = viewport.id;\n        const activeRepresentation = getActiveSegmentation(viewportId);\n        if (!activeRepresentation) {\n            return;\n        }\n        const { segmentationId } = activeRepresentation;\n        const segmentIndex = getActiveSegmentIndex(segmentationId);\n        if (!segmentIndex) {\n            return;\n        }\n        const segmentColor = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n        return {\n            segmentIndex,\n            segmentationId,\n            segmentColor,\n        };\n    }\n    getOperationData(element) {\n        const editData = this._editData || this.createEditData(element);\n        const { segmentIndex, segmentationId, brushCursor } = this._hoverData || this.createHoverData(element);\n        const { data, metadata = {} } = brushCursor || {};\n        const { viewPlaneNormal, viewUp } = metadata;\n        const configColor = this.configuration.preview?.previewColors?.[segmentIndex];\n        const { viewport } = getEnabledElement(element);\n        const segmentColor = getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n        if (!configColor && !segmentColor) {\n            return;\n        }\n        let previewColor = null, previewSegmentIndex = null;\n        if (this.configuration.preview?.enabled) {\n            previewColor = configColor || lightenColor(...segmentColor);\n            previewSegmentIndex = 255;\n        }\n        const operationData = {\n            ...editData,\n            points: data?.handles?.points,\n            segmentIndex,\n            viewPlaneNormal,\n            previewOnHover: !this._previewData.isDrag,\n            toolGroupId: this.toolGroupId,\n            segmentationId,\n            viewUp,\n            centerSegmentIndexInfo: this.centerSegmentIndexInfo,\n            activeStrategy: this.configuration.activeStrategy,\n            configuration: this.configuration,\n            previewColor,\n            previewSegmentIndex,\n            createMemo: this.createMemo.bind(this),\n        };\n        return operationData;\n    }\n    addPreview(element = this._previewData.element, options) {\n        const { _previewData } = this;\n        const acceptReject = options?.acceptReject;\n        if (acceptReject === true) {\n            this.acceptPreview(element);\n        }\n        else if (acceptReject === false) {\n            this.rejectPreview(element);\n        }\n        const enabledElement = getEnabledElement(element);\n        const results = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.AddPreview);\n        _previewData.isDrag = true;\n        if (results?.modified) {\n            _previewData.preview = results;\n            _previewData.element = element;\n        }\n        return results;\n    }\n    rejectPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        this.doneEditMemo();\n        const enabledElement = getEnabledElement(element);\n        this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.RejectPreview);\n        this._previewData.preview = null;\n        this._previewData.isDrag = false;\n    }\n    acceptPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        const operationData = this.getOperationData(element);\n        if (this.memo && this.memo.id) {\n            this.acceptedMemoIds.set(this.memo.id, {\n                element,\n                segmentIndex: operationData.segmentIndex,\n            });\n        }\n        const enabledElement = getEnabledElement(element);\n        this.applyActiveStrategyCallback(enabledElement, operationData, StrategyCallbacks.AcceptPreview);\n        this.doneEditMemo();\n        this._previewData.preview = null;\n        this._previewData.isDrag = false;\n    }\n    static viewportContoursToLabelmap(viewport, options) {\n        const removeContours = options?.removeContours ?? true;\n        const annotations = getAllAnnotations();\n        const viewAnnotations = filterAnnotationsForDisplay(viewport, annotations);\n        if (!viewAnnotations?.length) {\n            return;\n        }\n        const contourAnnotations = viewAnnotations.filter((annotation) => annotation.data.contour?.polyline?.length);\n        if (!contourAnnotations.length) {\n            return;\n        }\n        const brushInstance = new LabelmapBaseTool({}, {\n            configuration: {\n                strategies: {\n                    FILL_INSIDE_CIRCLE: fillInsideCircle,\n                },\n                activeStrategy: 'FILL_INSIDE_CIRCLE',\n            },\n        });\n        const preview = brushInstance.addPreview(viewport.element);\n        const { memo, segmentationId } = preview;\n        const previewVoxels = memo?.voxelManager;\n        const segmentationVoxels = previewVoxels.sourceVoxelManager || previewVoxels;\n        const { dimensions } = previewVoxels;\n        const imageData = viewport\n            .getDefaultActor()\n            .actor.getMapper()\n            .getInputData();\n        for (const annotation of contourAnnotations) {\n            const boundsIJK = [\n                [Infinity, -Infinity],\n                [Infinity, -Infinity],\n                [Infinity, -Infinity],\n            ];\n            const { polyline } = annotation.data.contour;\n            for (const point of polyline) {\n                const indexPoint = imageData.worldToIndex(point);\n                indexPoint.forEach((v, idx) => {\n                    boundsIJK[idx][0] = Math.min(boundsIJK[idx][0], v);\n                    boundsIJK[idx][1] = Math.max(boundsIJK[idx][1], v);\n                });\n            }\n            boundsIJK.forEach((bound, idx) => {\n                bound[0] = Math.round(Math.max(0, bound[0]));\n                bound[1] = Math.round(Math.min(dimensions[idx] - 1, bound[1]));\n            });\n            const activeIndex = getActiveSegmentIndex(segmentationId);\n            const startPoint = annotation.data.handles?.[0] || polyline[0];\n            const startIndex = imageData.worldToIndex(startPoint).map(Math.round);\n            const startValue = segmentationVoxels.getAtIJKPoint(startIndex) || 0;\n            let hasZeroIndex = false;\n            let hasPositiveIndex = false;\n            for (const polyPoint of polyline) {\n                const polyIndex = imageData.worldToIndex(polyPoint).map(Math.round);\n                const polyValue = segmentationVoxels.getAtIJKPoint(polyIndex);\n                if (polyValue === startValue) {\n                    hasZeroIndex = true;\n                }\n                else if (polyValue >= 0) {\n                    hasPositiveIndex = true;\n                }\n            }\n            const hasBoth = hasZeroIndex && hasPositiveIndex;\n            const segmentIndex = hasBoth\n                ? startValue\n                : startValue === 0\n                    ? activeIndex\n                    : 0;\n            for (let i = boundsIJK[0][0]; i <= boundsIJK[0][1]; i++) {\n                for (let j = boundsIJK[1][0]; j <= boundsIJK[1][1]; j++) {\n                    for (let k = boundsIJK[2][0]; k <= boundsIJK[2][1]; k++) {\n                        const worldPoint = imageData.indexToWorld([i, j, k]);\n                        const isContained = isPointInsidePolyline3D(worldPoint, polyline);\n                        if (isContained) {\n                            previewVoxels.setAtIJK(i, j, k, segmentIndex);\n                        }\n                    }\n                }\n            }\n            if (removeContours) {\n                removeAnnotation(annotation.annotationUID);\n            }\n        }\n        const slices = previewVoxels.getArrayOfModifiedSlices();\n        triggerSegmentationDataModified(segmentationId, slices);\n    }\n}\nfunction lightenColor(r, g, b, a, factor = 0.4) {\n    return [\n        Math.round(r + (255 - r) * factor),\n        Math.round(g + (255 - g) * factor),\n        Math.round(b + (255 - b) * factor),\n        a,\n    ];\n}\n", "import { getEnabledElement, eventTarget } from '@cornerstonejs/core';\nimport { vec3, vec2 } from 'gl-matrix';\nimport { Events, ToolModes, StrategyCallbacks } from '../../enums';\nimport { fillInsideSphere, thresholdInsideSphere, thresholdInsideSphereIsland, } from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport { thresholdInsideCircle, fillInsideCircle, } from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport LabelmapBaseTool from './LabelmapBaseTool';\nimport { getStrategyData } from './strategies/utils/getStrategyData';\nclass BrushTool extends LabelmapBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE_CIRCLE: fillInsideCircle,\n                ERASE_INSIDE_CIRCLE: eraseInsideCircle,\n                FILL_INSIDE_SPHERE: fillInsideSphere,\n                ERASE_INSIDE_SPHERE: eraseInsideSphere,\n                THRESHOLD_INSIDE_CIRCLE: thresholdInsideCircle,\n                THRESHOLD_INSIDE_SPHERE: thresholdInsideSphere,\n                THRESHOLD_INSIDE_SPHERE_WITH_ISLAND_REMOVAL: thresholdInsideSphereIsland,\n            },\n            defaultStrategy: 'FILL_INSIDE_CIRCLE',\n            activeStrategy: 'FILL_INSIDE_CIRCLE',\n            brushSize: 25,\n            useCenterSegmentIndex: false,\n            preview: {\n                enabled: false,\n                previewColors: {\n                    0: [255, 255, 255, 128],\n                },\n                previewTimeMs: 250,\n                previewMoveDistance: 8,\n                dragMoveDistance: 4,\n                dragTimeMs: 500,\n            },\n            actions: {\n                [StrategyCallbacks.AcceptPreview]: {\n                    method: StrategyCallbacks.AcceptPreview,\n                    bindings: [\n                        {\n                            key: 'Enter',\n                        },\n                    ],\n                },\n                [StrategyCallbacks.RejectPreview]: {\n                    method: StrategyCallbacks.RejectPreview,\n                    bindings: [\n                        {\n                            key: 'Escape',\n                        },\n                    ],\n                },\n                [StrategyCallbacks.Interpolate]: {\n                    method: StrategyCallbacks.Interpolate,\n                    bindings: [\n                        {\n                            key: 'i',\n                        },\n                    ],\n                    configuration: {\n                        useBallStructuringElement: true,\n                        noUseDistanceTransform: true,\n                        noUseExtrapolation: true,\n                    },\n                },\n                interpolateExtrapolation: {\n                    method: StrategyCallbacks.Interpolate,\n                    bindings: [\n                        {\n                            key: 'e',\n                        },\n                    ],\n                    configuration: {},\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._lastDragInfo = null;\n        this.onSetToolPassive = (evt) => {\n            this.disableCursor();\n        };\n        this.onSetToolEnabled = () => {\n            this.disableCursor();\n        };\n        this.onSetToolDisabled = (evt) => {\n            this.disableCursor();\n        };\n        this.preMouseDownCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this._editData = this.createEditData(element);\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            this._previewData.isDrag = false;\n            this._previewData.timerStart = Date.now();\n            const canvasPoint = vec2.clone(currentPoints.canvas);\n            const worldPoint = viewport.canvasToWorld([\n                canvasPoint[0],\n                canvasPoint[1],\n            ]);\n            this._lastDragInfo = {\n                canvas: canvasPoint,\n                world: vec3.clone(worldPoint),\n            };\n            const hoverData = this._hoverData || this.createHoverData(element);\n            triggerAnnotationRenderForViewportUIDs(hoverData.viewportIdsToRender);\n            const operationData = this.getOperationData(element);\n            this.applyActiveStrategyCallback(enabledElement, operationData, StrategyCallbacks.OnInteractionStart);\n            return true;\n        };\n        this.mouseMoveCallback = (evt) => {\n            if (this.mode === ToolModes.Active) {\n                this.updateCursor(evt);\n                if (!this.configuration.preview.enabled) {\n                    return;\n                }\n                const { previewTimeMs, previewMoveDistance, dragMoveDistance } = this.configuration.preview;\n                const { currentPoints, element } = evt.detail;\n                const { canvas } = currentPoints;\n                const { startPoint, timer, timerStart, isDrag } = this._previewData;\n                if (isDrag) {\n                    return;\n                }\n                const delta = vec2.distance(canvas, startPoint);\n                const time = Date.now() - timerStart;\n                if (delta > previewMoveDistance ||\n                    (time > previewTimeMs && delta > dragMoveDistance)) {\n                    if (timer) {\n                        window.clearTimeout(timer);\n                        this._previewData.timer = null;\n                    }\n                    if (!isDrag) {\n                        this.rejectPreview(element);\n                    }\n                }\n                if (!this._previewData.timer) {\n                    const timer = window.setTimeout(this.previewCallback, 250);\n                    Object.assign(this._previewData, {\n                        timerStart: Date.now(),\n                        timer,\n                        startPoint: canvas,\n                        element,\n                    });\n                }\n            }\n        };\n        this.previewCallback = () => {\n            if (this._previewData.isDrag) {\n                this._previewData.timer = null;\n                return;\n            }\n            this._previewData.timer = null;\n            const operationData = this.getOperationData(this._previewData.element);\n            const enabledElement = getEnabledElement(this._previewData.element);\n            if (!enabledElement) {\n                return;\n            }\n            const { viewport } = enabledElement;\n            const activeStrategy = this.configuration.activeStrategy;\n            const strategyData = getStrategyData({\n                operationData,\n                viewport,\n                strategy: activeStrategy,\n            });\n            if (!operationData) {\n                return;\n            }\n            const memo = this.createMemo(operationData.segmentationId, strategyData.segmentationVoxelManager);\n            this._previewData.preview = this.applyActiveStrategyCallback(getEnabledElement(this._previewData.element), {\n                ...operationData,\n                ...strategyData,\n                memo,\n            }, StrategyCallbacks.Preview);\n        };\n        this._dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.updateCursor(evt);\n            const { viewportIdsToRender } = this._hoverData;\n            triggerAnnotationRenderForViewportUIDs(viewportIdsToRender);\n            const delta = vec2.distance(currentPoints.canvas, this._previewData.startPoint);\n            const { dragTimeMs, dragMoveDistance } = this.configuration.preview;\n            if (!this._previewData.isDrag &&\n                Date.now() - this._previewData.timerStart < dragTimeMs &&\n                delta < dragMoveDistance) {\n                return;\n            }\n            if (this._previewData.timer) {\n                window.clearTimeout(this._previewData.timer);\n                this._previewData.timer = null;\n            }\n            if (!this._lastDragInfo) {\n                const startCanvas = this._previewData.startPoint;\n                const startWorld = viewport.canvasToWorld([\n                    startCanvas[0],\n                    startCanvas[1],\n                ]);\n                this._lastDragInfo = {\n                    canvas: vec2.clone(startCanvas),\n                    world: vec3.clone(startWorld),\n                };\n            }\n            const currentCanvas = currentPoints.canvas;\n            const currentWorld = viewport.canvasToWorld([\n                currentCanvas[0],\n                currentCanvas[1],\n            ]);\n            this._hoverData = this.createHoverData(element, currentCanvas);\n            this._calculateCursor(element, currentCanvas);\n            const operationData = this.getOperationData(element);\n            operationData.strokePointsWorld = [\n                vec3.clone(this._lastDragInfo.world),\n                vec3.clone(currentWorld),\n            ];\n            this._previewData.preview = this.applyActiveStrategy(enabledElement, operationData);\n            const currentCanvasClone = vec2.clone(currentCanvas);\n            this._lastDragInfo = {\n                canvas: currentCanvasClone,\n                world: vec3.clone(currentWorld),\n            };\n            this._previewData.element = element;\n            this._previewData.timerStart = Date.now() + dragTimeMs;\n            this._previewData.isDrag = true;\n            this._previewData.startPoint = currentCanvasClone;\n        };\n        this._endCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const operationData = this.getOperationData(element);\n            if (!this._previewData.preview && !this._previewData.isDrag) {\n                this.applyActiveStrategy(enabledElement, operationData);\n            }\n            this.doneEditMemo();\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.updateCursor(evt);\n            this._editData = null;\n            this._lastDragInfo = null;\n            this.applyActiveStrategyCallback(enabledElement, operationData, StrategyCallbacks.OnInteractionEnd);\n            if (!this._previewData.isDrag) {\n                this.acceptPreview(element);\n            }\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n    }\n    disableCursor() {\n        this._hoverData = undefined;\n        this.rejectPreview();\n    }\n    updateCursor(evt) {\n        const eventData = evt.detail;\n        const { element } = eventData;\n        const { currentPoints } = eventData;\n        const centerCanvas = currentPoints.canvas;\n        this._hoverData = this.createHoverData(element, centerCanvas);\n        this._calculateCursor(element, centerCanvas);\n        if (!this._hoverData) {\n            return;\n        }\n        triggerAnnotationRenderForViewportUIDs(this._hoverData.viewportIdsToRender);\n    }\n    _calculateCursor(element, centerCanvas) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { canvasToWorld } = viewport;\n        const camera = viewport.getCamera();\n        const { brushSize } = this.configuration;\n        const viewUp = vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);\n        const viewPlaneNormal = vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);\n        const viewRight = vec3.create();\n        vec3.cross(viewRight, viewUp, viewPlaneNormal);\n        const centerCursorInWorld = canvasToWorld([\n            centerCanvas[0],\n            centerCanvas[1],\n        ]);\n        const bottomCursorInWorld = vec3.create();\n        const topCursorInWorld = vec3.create();\n        const leftCursorInWorld = vec3.create();\n        const rightCursorInWorld = vec3.create();\n        for (let i = 0; i <= 2; i++) {\n            bottomCursorInWorld[i] = centerCursorInWorld[i] - viewUp[i] * brushSize;\n            topCursorInWorld[i] = centerCursorInWorld[i] + viewUp[i] * brushSize;\n            leftCursorInWorld[i] = centerCursorInWorld[i] - viewRight[i] * brushSize;\n            rightCursorInWorld[i] = centerCursorInWorld[i] + viewRight[i] * brushSize;\n        }\n        if (!this._hoverData) {\n            return;\n        }\n        const { brushCursor } = this._hoverData;\n        const { data } = brushCursor;\n        if (data.handles === undefined) {\n            data.handles = {};\n        }\n        data.handles.points = [\n            bottomCursorInWorld,\n            topCursorInWorld,\n            leftCursorInWorld,\n            rightCursorInWorld,\n        ];\n        const activeStrategy = this.configuration.activeStrategy;\n        const strategy = this.configuration.strategies[activeStrategy];\n        if (typeof strategy?.computeInnerCircleRadius === 'function') {\n            strategy.computeInnerCircleRadius({\n                configuration: this.configuration,\n                viewport,\n            });\n        }\n        data.invalidated = false;\n    }\n    getStatistics(element, segmentIndices) {\n        if (!element) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        const stats = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.GetStatistics, segmentIndices);\n        return stats;\n    }\n    rejectPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        this.doneEditMemo();\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.RejectPreview);\n        this._previewData.preview = null;\n        this._previewData.isDrag = false;\n    }\n    acceptPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        super.acceptPreview(element);\n    }\n    interpolate(element, config) {\n        if (!element) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        this._previewData.preview = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.Interpolate, config.configuration);\n        this._previewData.isDrag = true;\n    }\n    invalidateBrushCursor() {\n        if (this._hoverData === undefined) {\n            return;\n        }\n        const { data } = this._hoverData.brushCursor;\n        const { viewport } = this._hoverData;\n        data.invalidated = true;\n        const { segmentColor } = this.getActiveSegmentationData(viewport) || {};\n        this._hoverData.brushCursor.metadata.segmentColor = segmentColor;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this._hoverData) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const viewportIdsToRender = this._hoverData.viewportIdsToRender;\n        if (!viewportIdsToRender.includes(viewport.id)) {\n            return;\n        }\n        const brushCursor = this._hoverData.brushCursor;\n        if (brushCursor.data.invalidated === true) {\n            const { centerCanvas } = this._hoverData;\n            const { element } = viewport;\n            this._calculateCursor(element, centerCanvas);\n        }\n        const toolMetadata = brushCursor.metadata;\n        if (!toolMetadata) {\n            return;\n        }\n        const annotationUID = toolMetadata.brushCursorUID;\n        const data = brushCursor.data;\n        const { points } = data.handles;\n        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n        const bottom = canvasCoordinates[0];\n        const top = canvasCoordinates[1];\n        const center = [\n            Math.floor((bottom[0] + top[0]) / 2),\n            Math.floor((bottom[1] + top[1]) / 2),\n        ];\n        const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n        const color = `rgb(${toolMetadata.segmentColor?.slice(0, 3) || [0, 0, 0]})`;\n        if (!viewport.getRenderingEngine()) {\n            console.warn('Rendering Engine has been destroyed');\n            return;\n        }\n        const circleUID = '0';\n        drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n            color,\n            lineDash: this.centerSegmentIndexInfo.segmentIndex === 0 ? [1, 2] : null,\n        });\n        const { dynamicRadiusInCanvas } = this.configuration?.threshold || {\n            dynamicRadiusInCanvas: 0,\n        };\n        if (dynamicRadiusInCanvas) {\n            const circleUID1 = '1';\n            drawCircleSvg(svgDrawingHelper, annotationUID, circleUID1, center, dynamicRadiusInCanvas, {\n                color,\n            });\n        }\n    }\n}\nBrushTool.toolName = 'Brush';\nexport default BrushTool;\n", "import { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nexport function getBrushToolInstances(toolGroupId, toolName) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return [];\n    }\n    const toolInstances = toolGroup._toolInstances;\n    if (!Object.keys(toolInstances).length) {\n        return [];\n    }\n    if (toolName && toolInstances[toolName]) {\n        return [toolInstances[toolName]];\n    }\n    const brushBasedToolInstances = Object.values(toolInstances).filter((toolInstance) => toolInstance instanceof BrushTool);\n    return brushBasedToolInstances;\n}\n", "import { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport { getBrushToolInstances } from './getBrushToolInstances';\nexport function setBrushSizeForToolGroup(toolGroupId, brushSize, toolName) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\n    brushBasedToolInstances.forEach((tool) => {\n        tool.configuration.brushSize = brushSize;\n        tool.invalidateBrushCursor();\n    });\n    const viewportsInfo = toolGroup.getViewportsInfo();\n    const viewportsInfoArray = Object.keys(viewportsInfo).map((key) => viewportsInfo[key]);\n    if (!viewportsInfoArray.length) {\n        return;\n    }\n    const { renderingEngineId } = viewportsInfoArray[0];\n    const viewportIds = toolGroup.getViewportIds();\n    const renderingEngine = getRenderingEngine(renderingEngineId);\n    triggerAnnotationRenderForViewportIds(viewportIds);\n}\nexport function getBrushSizeForToolGroup(toolGroupId, toolName) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const toolInstances = toolGroup._toolInstances;\n    if (!Object.keys(toolInstances).length) {\n        return;\n    }\n    const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\n    const brushToolInstance = brushBasedToolInstances[0];\n    if (!brushToolInstance) {\n        return;\n    }\n    return brushToolInstance.configuration.brushSize;\n}\n", "import { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getBrushToolInstances } from './getBrushToolInstances';\nexport function setBrushThresholdForToolGroup(toolGroupId, threshold) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n    brushBasedToolInstances.forEach((tool) => {\n        const activeStrategy = tool.configuration.activeStrategy;\n        if (!activeStrategy.toLowerCase().includes('threshold')) {\n            return;\n        }\n        tool.configuration = {\n            ...tool.configuration,\n            threshold: {\n                ...tool.configuration.threshold,\n                ...threshold,\n            },\n        };\n    });\n    const viewportsInfo = toolGroup.getViewportsInfo();\n    if (!viewportsInfo.length) {\n        return;\n    }\n    const viewportIds = toolGroup.getViewportIds();\n    triggerAnnotationRenderForViewportIds(viewportIds);\n}\nexport function getBrushThresholdForToolGroup(toolGroupId) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const toolInstances = toolGroup._toolInstances;\n    if (!Object.keys(toolInstances).length) {\n        return;\n    }\n    const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n    const brushToolInstance = brushBasedToolInstances[0];\n    if (!brushToolInstance) {\n        return;\n    }\n    return brushToolInstance.configuration.threshold.range;\n}\n", "import { InstanceVolumetricCalculator } from './VolumetricCalculator';\nexport default class SegmentStatsCalculator {\n    static { this.calculators = new Map(); }\n    static { this.indices = []; }\n    static { this.mode = 'collective'; }\n    static statsInit(options) {\n        const { storePointData, indices, mode } = options;\n        this.mode = mode;\n        this.indices = indices;\n        this.calculators.clear();\n        if (this.mode === 'individual') {\n            indices.forEach((index) => {\n                this.calculators.set(index, new InstanceVolumetricCalculator({ storePointData }));\n            });\n        }\n        else {\n            this.calculators.set(indices, new InstanceVolumetricCalculator({ storePointData }));\n        }\n    }\n    static statsCallback(data) {\n        const { segmentIndex, ...statsData } = data;\n        if (!segmentIndex) {\n            throw new Error('Segment index is required for stats calculation');\n        }\n        const calculator = this.mode === 'individual'\n            ? this.calculators.get(segmentIndex)\n            : this.calculators.get(this.indices);\n        if (!calculator) {\n            throw new Error(`No calculator found for segment ${segmentIndex}`);\n        }\n        calculator.statsCallback(statsData);\n    }\n    static getStatistics(options) {\n        if (this.mode === 'individual') {\n            const result = {};\n            this.calculators.forEach((calculator, segmentIndex) => {\n                result[segmentIndex] = calculator.getStatistics(options);\n            });\n            return result;\n        }\n        const calculator = this.calculators.get(this.indices);\n        return calculator.getStatistics(options);\n    }\n}\n", "import { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { getVoxelOverlap, processVolumes } from './utilities';\nfunction thresholdSegmentationByRange(segmentationVolume, segmentationIndex, thresholdVolumeInformation, overlapType, segmentationId) {\n    if (!segmentationId) {\n        throw new Error('Segmentation ID is required to be passed inside thresholdSegmentationByRange');\n    }\n    const { baseVolumeIdx, volumeInfoList } = processVolumes(segmentationVolume, thresholdVolumeInformation);\n    const { voxelManager } = volumeInfoList[baseVolumeIdx];\n    const refVoxelManager = voxelManager;\n    const scalarDataLength = segmentationVolume.voxelManager.getScalarDataLength();\n    const segVoxelManager = segmentationVolume.voxelManager;\n    volumeInfoList.forEach((volumeInfo) => {\n        const { volumeSize } = volumeInfo;\n        if (volumeSize === scalarDataLength) {\n            _handleSameSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo);\n        }\n        else {\n            _handleDifferentSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo, volumeInfoList, baseVolumeIdx, overlapType);\n        }\n    });\n    triggerSegmentationDataModified(segmentationId);\n    return segmentationVolume;\n}\nfunction _handleDifferentSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo, volumeInfoList, baseVolumeIdx, overlapType) {\n    const { imageData, lower, upper, dimensions } = volumeInfo;\n    let total, overlaps, range;\n    const segScalarDataLength = segVoxelManager.getScalarDataLength();\n    for (let i = 0; i < segScalarDataLength; i++) {\n        if (segScalarDataLength.getAtIndex(i) === segmentationIndex) {\n            const overlapBounds = getVoxelOverlap(imageData, dimensions, volumeInfoList[baseVolumeIdx].spacing, volumeInfoList[baseVolumeIdx].imageData.getPoint(i));\n            const callbackOverlap = ({ value }) => {\n                total = total + 1;\n                if (value >= range.lower && value <= range.upper) {\n                    overlaps = overlaps + 1;\n                }\n            };\n            total = 0;\n            overlaps = 0;\n            range = { lower, upper };\n            let overlapTest = false;\n            segVoxelManager.forEach(callbackOverlap, {\n                imageData,\n                boundsIJK: overlapBounds,\n            });\n            overlapTest = overlapType === 0 ? overlaps > 0 : overlaps === total;\n            segVoxelManager.setAtIndex(i, overlapTest ? segmentationIndex : 0);\n        }\n    }\n    return { total, range, overlaps };\n}\nfunction _handleSameSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo) {\n    const { lower, upper } = volumeInfo;\n    const scalarDataLength = segVoxelManager.getScalarDataLength();\n    for (let i = 0; i < scalarDataLength; i++) {\n        if (segVoxelManager.getAtIndex[i] === segmentationIndex) {\n            const value = refVoxelManager.getAtIndex(i);\n            segVoxelManager.setAtIndex(i, value >= lower && value <= upper ? segmentationIndex : 0);\n        }\n    }\n}\nexport default thresholdSegmentationByRange;\n", "import { cache } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nexport default function isLineInSegment(point1, point2, isInSegment) {\n    const ijk1 = isInSegment.toIJK(point1);\n    const ijk2 = isInSegment.toIJK(point2);\n    const testPoint = vec3.create();\n    const { testIJK } = isInSegment;\n    const delta = vec3.sub(vec3.create(), ijk1, ijk2);\n    const testSize = Math.round(Math.max(...delta.map(Math.abs)));\n    if (testSize < 2) {\n        return true;\n    }\n    const unitDelta = vec3.scale(vec3.create(), delta, 1 / testSize);\n    for (let i = 1; i < testSize; i++) {\n        vec3.scaleAndAdd(testPoint, ijk2, unitDelta, i);\n        if (!testIJK(testPoint)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction createIsInSegmentMetadata({ dimensions, imageData, voxelManager, segmentIndex, containedSegmentIndices, }) {\n    const width = dimensions[0];\n    const pixelsPerSlice = width * dimensions[1];\n    return {\n        testCenter: (point1, point2) => {\n            const point = vec3.add(vec3.create(), point1, point2).map((it) => it / 2);\n            const ijk = imageData.worldToIndex(point).map(Math.round);\n            const [i, j, k] = ijk;\n            const index = i + j * width + k * pixelsPerSlice;\n            const value = voxelManager.getAtIndex(index);\n            return value === segmentIndex || containedSegmentIndices?.has(value);\n        },\n        toIJK: (point) => imageData.worldToIndex(point),\n        testIJK: (ijk) => {\n            const [i, j, k] = ijk;\n            const index = Math.round(i) + Math.round(j) * width + Math.round(k) * pixelsPerSlice;\n            const value = voxelManager.getAtIndex(index);\n            return value === segmentIndex || containedSegmentIndices?.has(value);\n        },\n    };\n}\nfunction createIsInSegment(segVolumeId, segmentIndex, containedSegmentIndices) {\n    const vol = cache.getVolume(segVolumeId);\n    if (!vol) {\n        console.warn(`No volume found for ${segVolumeId}`);\n        return;\n    }\n    return createIsInSegmentMetadata({\n        dimensions: vol.dimensions,\n        imageData: vol.imageData,\n        voxelManager: vol.voxelManager,\n        segmentIndex,\n        containedSegmentIndices,\n    });\n}\nexport { createIsInSegment, createIsInSegmentMetadata, isLineInSegment };\n", "import { vec3 } from 'gl-matrix';\nimport { createIsInSegment, isLineInSegment } from './isLineInSegment';\nconst EPSILON = 1e-2;\nexport default function findLargestBidirectional(contours, segVolumeId, segment) {\n    const { sliceContours } = contours;\n    const { segmentIndex, containedSegmentIndices } = segment;\n    let maxBidirectional;\n    const isInSegment = createIsInSegment(segVolumeId, segmentIndex, containedSegmentIndices);\n    for (const sliceContour of sliceContours) {\n        const bidirectional = createBidirectionalForSlice(sliceContour, isInSegment, maxBidirectional);\n        if (!bidirectional) {\n            continue;\n        }\n        maxBidirectional = bidirectional;\n    }\n    if (maxBidirectional) {\n        Object.assign(maxBidirectional, segment);\n    }\n    return maxBidirectional;\n}\nexport function createBidirectionalForSlice(sliceContour, isInSegment, currentMax = { maxMajor: 0, maxMinor: 0 }) {\n    const { points } = sliceContour.polyData;\n    const { maxMinor: currentMaxMinor, maxMajor: currentMaxMajor } = currentMax;\n    let maxMajor = currentMaxMajor * currentMaxMajor;\n    let maxMinor = currentMaxMinor * currentMaxMinor;\n    let maxMajorPoints;\n    for (let index1 = 0; index1 < points.length; index1++) {\n        for (let index2 = index1 + 1; index2 < points.length; index2++) {\n            const point1 = points[index1];\n            const point2 = points[index2];\n            const distance2 = vec3.sqrDist(point1, point2);\n            if (distance2 < maxMajor) {\n                continue;\n            }\n            if (distance2 - EPSILON < maxMajor + EPSILON && maxMajorPoints) {\n                continue;\n            }\n            if (!isInSegment.testCenter(point1, point2)) {\n                continue;\n            }\n            if (!isLineInSegment(point1, point2, isInSegment)) {\n                continue;\n            }\n            maxMajor = distance2 - EPSILON;\n            maxMajorPoints = [index1, index2];\n            maxMinor = 0;\n        }\n    }\n    if (!maxMajorPoints) {\n        return;\n    }\n    maxMajor = Math.sqrt(maxMajor + EPSILON);\n    const handle0 = points[maxMajorPoints[0]];\n    const handle1 = points[maxMajorPoints[1]];\n    const unitMajor = vec3.sub(vec3.create(), handle0, handle1);\n    vec3.scale(unitMajor, unitMajor, 1 / maxMajor);\n    let maxMinorPoints;\n    for (let index1 = 0; index1 < points.length; index1++) {\n        for (let index2 = index1 + 1; index2 < points.length; index2++) {\n            const point1 = points[index1];\n            const point2 = points[index2];\n            const distance2 = vec3.sqrDist(point1, point2);\n            if (distance2 <= maxMinor) {\n                continue;\n            }\n            const delta = vec3.sub(vec3.create(), point1, point2);\n            const dot = Math.abs(vec3.dot(delta, unitMajor)) / Math.sqrt(distance2);\n            if (dot > EPSILON) {\n                continue;\n            }\n            if (!isInSegment.testCenter(point1, point2)) {\n                continue;\n            }\n            if (!isLineInSegment(point1, point2, isInSegment)) {\n                continue;\n            }\n            maxMinor = distance2;\n            maxMinorPoints = [index1, index2];\n        }\n    }\n    if (!maxMinorPoints) {\n        return;\n    }\n    maxMinor = Math.sqrt(maxMinor);\n    const handle2 = points[maxMinorPoints[0]];\n    const handle3 = points[maxMinorPoints[1]];\n    const bidirectional = {\n        majorAxis: [handle0, handle1],\n        minorAxis: [handle2, handle3],\n        maxMajor,\n        maxMinor,\n        ...sliceContour,\n    };\n    return bidirectional;\n}\n", "import { generateContourSetsFromLabelmap } from '../contours';\nimport findLargestBidirectional from './findLargestBidirectional';\nimport getOrCreateSegmentationVolume from './getOrCreateSegmentationVolume';\nexport default async function contourAndFindLargestBidirectional(segmentation) {\n    const contours = await generateContourSetsFromLabelmap({\n        segmentations: segmentation,\n    });\n    if (!contours?.length || !contours[0].sliceContours.length) {\n        return;\n    }\n    const { segments = [\n        null,\n        { label: 'Unspecified', color: null, containedSegmentIndices: null },\n    ], } = segmentation;\n    const vol = getOrCreateSegmentationVolume(segmentation.segmentationId);\n    if (!vol) {\n        return;\n    }\n    const segmentIndex = segments.findIndex((it) => !!it);\n    if (segmentIndex === -1) {\n        return;\n    }\n    segments[segmentIndex].segmentIndex = segmentIndex;\n    return findLargestBidirectional(contours[0], vol.volumeId, segments[segmentIndex]);\n}\n", "export default function createBidirectionalToolData(bidirectionalData, viewport) {\n    const { majorAxis, minorAxis, label = '', sliceIndex } = bidirectionalData;\n    const [major0, major1] = majorAxis;\n    const [minor0, minor1] = minorAxis;\n    const points = [major0, major1, minor0, minor1];\n    const bidirectionalToolData = {\n        highlighted: true,\n        invalidated: true,\n        metadata: {\n            toolName: 'Bidirectional',\n            ...viewport.getViewReference({ sliceIndex }),\n        },\n        data: {\n            handles: {\n                points,\n                textBox: {\n                    hasMoved: false,\n                    worldPosition: [0, 0, 0],\n                    worldBoundingBox: {\n                        topLeft: [0, 0, 0],\n                        topRight: [0, 0, 0],\n                        bottomLeft: [0, 0, 0],\n                        bottomRight: [0, 0, 0],\n                    },\n                },\n                activeHandleIndex: null,\n            },\n            label,\n            cachedStats: {},\n        },\n        isLocked: false,\n        isVisible: true,\n    };\n    return bidirectionalToolData;\n}\n", "import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, utilities, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawLine as drawLineSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as lineSegment from '../../utilities/math/line';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nconst { transformWorldToIndex } = csUtils;\nclass BidirectionalTool extends AnnotationTool {\n    static { this.toolName = 'Bidirectional'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            let canvasPoint1 = viewport.worldToCanvas(points[0]);\n            let canvasPoint2 = viewport.worldToCanvas(points[1]);\n            let line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            let distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            canvasPoint1 = viewport.worldToCanvas(points[2]);\n            canvasPoint2 = viewport.worldToCanvas(points[3]);\n            line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const data = annotation.data;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                handleIndex = data.handles.points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            hideElementCursor(element);\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const { renderingEngine } = getEnabledElement(element);\n            if (this.editData.handleIndex !== undefined) {\n                const { points } = data.handles;\n                const firstLineSegmentLength = vec3.distance(points[0], points[1]);\n                const secondLineSegmentLength = vec3.distance(points[2], points[3]);\n                if (secondLineSegmentLength > firstLineSegmentLength) {\n                    const longAxis = [[...points[2]], [...points[3]]];\n                    const shortAxisPoint0 = [...points[0]];\n                    const shortAxisPoint1 = [...points[1]];\n                    const longAxisVector = vec2.create();\n                    vec2.set(longAxisVector, longAxis[1][0] - longAxis[0][0], longAxis[1][1] - longAxis[1][0]);\n                    const counterClockWisePerpendicularToLongAxis = vec2.create();\n                    vec2.set(counterClockWisePerpendicularToLongAxis, -longAxisVector[1], longAxisVector[0]);\n                    const currentShortAxisVector = vec2.create();\n                    vec2.set(currentShortAxisVector, shortAxisPoint1[0] - shortAxisPoint0[0], shortAxisPoint1[1] - shortAxisPoint0[0]);\n                    let shortAxis;\n                    if (vec2.dot(currentShortAxisVector, counterClockWisePerpendicularToLongAxis) > 0) {\n                        shortAxis = [shortAxisPoint0, shortAxisPoint1];\n                    }\n                    else {\n                        shortAxis = [shortAxisPoint1, shortAxisPoint0];\n                    }\n                    data.handles.points = [\n                        longAxis[0],\n                        longAxis[1],\n                        shortAxis[0],\n                        shortAxis[1],\n                    ];\n                }\n            }\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { worldToCanvas } = viewport;\n            const { annotation, viewportIdsToRender, handleIndex, newAnnotation } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            const worldPos = currentPoints.world;\n            data.handles.points[handleIndex] = [...worldPos];\n            const canvasCoordPoints = data.handles.points.map(worldToCanvas);\n            const canvasCoords = {\n                longLineSegment: {\n                    start: {\n                        x: canvasCoordPoints[0][0],\n                        y: canvasCoordPoints[0][1],\n                    },\n                    end: {\n                        x: canvasCoordPoints[1][0],\n                        y: canvasCoordPoints[1][1],\n                    },\n                },\n                shortLineSegment: {\n                    start: {\n                        x: canvasCoordPoints[2][0],\n                        y: canvasCoordPoints[2][1],\n                    },\n                    end: {\n                        x: canvasCoordPoints[3][0],\n                        y: canvasCoordPoints[3][1],\n                    },\n                },\n            };\n            const dist = vec2.distance(canvasCoordPoints[0], canvasCoordPoints[1]);\n            const shortAxisDistFromCenter = dist / 3;\n            const dx = canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;\n            const dy = canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;\n            const length = Math.sqrt(dx * dx + dy * dy);\n            const vectorX = dx / length;\n            const vectorY = dy / length;\n            const xMid = (canvasCoords.longLineSegment.start.x +\n                canvasCoords.longLineSegment.end.x) /\n                2;\n            const yMid = (canvasCoords.longLineSegment.start.y +\n                canvasCoords.longLineSegment.end.y) /\n                2;\n            const startX = xMid + shortAxisDistFromCenter * vectorY;\n            const startY = yMid - shortAxisDistFromCenter * vectorX;\n            const endX = xMid - shortAxisDistFromCenter * vectorY;\n            const endY = yMid + shortAxisDistFromCenter * vectorX;\n            data.handles.points[2] = viewport.canvasToWorld([startX, startY]);\n            data.handles.points[3] = viewport.canvasToWorld([endX, endY]);\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            this.editData.hasMoved = true;\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragModifyHandle(evt);\n                annotation.invalidated = true;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this._dragModifyHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { annotation, handleIndex: movingHandleIndex } = this.editData;\n            const { data } = annotation;\n            const worldPos = currentPoints.world;\n            const canvasCoordHandlesCurrent = [\n                viewport.worldToCanvas(data.handles.points[0]),\n                viewport.worldToCanvas(data.handles.points[1]),\n                viewport.worldToCanvas(data.handles.points[2]),\n                viewport.worldToCanvas(data.handles.points[3]),\n            ];\n            const firstLineSegment = {\n                start: {\n                    x: canvasCoordHandlesCurrent[0][0],\n                    y: canvasCoordHandlesCurrent[0][1],\n                },\n                end: {\n                    x: canvasCoordHandlesCurrent[1][0],\n                    y: canvasCoordHandlesCurrent[1][1],\n                },\n            };\n            const secondLineSegment = {\n                start: {\n                    x: canvasCoordHandlesCurrent[2][0],\n                    y: canvasCoordHandlesCurrent[2][1],\n                },\n                end: {\n                    x: canvasCoordHandlesCurrent[3][0],\n                    y: canvasCoordHandlesCurrent[3][1],\n                },\n            };\n            const proposedPoint = [...worldPos];\n            const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);\n            if (movingHandleIndex === 0 || movingHandleIndex === 1) {\n                const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;\n                const fixedHandleCanvasCoord = canvasCoordHandlesCurrent[fixedHandleIndex];\n                const fixedHandleToProposedCoordVec = vec2.set(vec2.create(), proposedCanvasCoord[0] - fixedHandleCanvasCoord[0], proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]);\n                const fixedHandleToOldCoordVec = vec2.set(vec2.create(), canvasCoordHandlesCurrent[movingHandleIndex][0] -\n                    fixedHandleCanvasCoord[0], canvasCoordHandlesCurrent[movingHandleIndex][1] -\n                    fixedHandleCanvasCoord[1]);\n                vec2.normalize(fixedHandleToProposedCoordVec, fixedHandleToProposedCoordVec);\n                vec2.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);\n                const proposedFirstLineSegment = {\n                    start: {\n                        x: fixedHandleCanvasCoord[0],\n                        y: fixedHandleCanvasCoord[1],\n                    },\n                    end: {\n                        x: proposedCanvasCoord[0],\n                        y: proposedCanvasCoord[1],\n                    },\n                };\n                if (this._movingLongAxisWouldPutItThroughShortAxis(proposedFirstLineSegment, secondLineSegment)) {\n                    return;\n                }\n                const centerOfRotation = fixedHandleCanvasCoord;\n                const angle = this._getSignedAngle(fixedHandleToOldCoordVec, fixedHandleToProposedCoordVec);\n                let firstPointX = canvasCoordHandlesCurrent[2][0];\n                let firstPointY = canvasCoordHandlesCurrent[2][1];\n                let secondPointX = canvasCoordHandlesCurrent[3][0];\n                let secondPointY = canvasCoordHandlesCurrent[3][1];\n                firstPointX -= centerOfRotation[0];\n                firstPointY -= centerOfRotation[1];\n                secondPointX -= centerOfRotation[0];\n                secondPointY -= centerOfRotation[1];\n                const rotatedFirstPoint = firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);\n                const rotatedFirstPointY = firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);\n                const rotatedSecondPoint = secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);\n                const rotatedSecondPointY = secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);\n                firstPointX = rotatedFirstPoint + centerOfRotation[0];\n                firstPointY = rotatedFirstPointY + centerOfRotation[1];\n                secondPointX = rotatedSecondPoint + centerOfRotation[0];\n                secondPointY = rotatedSecondPointY + centerOfRotation[1];\n                const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);\n                const newSecondPoint = viewport.canvasToWorld([\n                    secondPointX,\n                    secondPointY,\n                ]);\n                data.handles.points[movingHandleIndex] = proposedPoint;\n                data.handles.points[2] = newFirstPoint;\n                data.handles.points[3] = newSecondPoint;\n            }\n            else {\n                const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;\n                const canvasCoordsCurrent = {\n                    longLineSegment: {\n                        start: firstLineSegment.start,\n                        end: firstLineSegment.end,\n                    },\n                    shortLineSegment: {\n                        start: secondLineSegment.start,\n                        end: secondLineSegment.end,\n                    },\n                };\n                const longLineSegmentVec = vec2.subtract(vec2.create(), [\n                    canvasCoordsCurrent.longLineSegment.end.x,\n                    canvasCoordsCurrent.longLineSegment.end.y,\n                ], [\n                    canvasCoordsCurrent.longLineSegment.start.x,\n                    canvasCoordsCurrent.longLineSegment.start.y,\n                ]);\n                const longLineSegmentVecNormalized = vec2.normalize(vec2.create(), longLineSegmentVec);\n                const proposedToCurrentVec = vec2.subtract(vec2.create(), [proposedCanvasCoord[0], proposedCanvasCoord[1]], [\n                    canvasCoordHandlesCurrent[movingHandleIndex][0],\n                    canvasCoordHandlesCurrent[movingHandleIndex][1],\n                ]);\n                const movementLength = vec2.length(proposedToCurrentVec);\n                const angle = this._getSignedAngle(longLineSegmentVecNormalized, proposedToCurrentVec);\n                const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;\n                const newTranslatedPoint = vec2.scaleAndAdd(vec2.create(), [\n                    canvasCoordHandlesCurrent[translateHandleIndex][0],\n                    canvasCoordHandlesCurrent[translateHandleIndex][1],\n                ], longLineSegmentVecNormalized, movementAlongLineSegmentLength);\n                if (this._movingLongAxisWouldPutItThroughShortAxis({\n                    start: {\n                        x: proposedCanvasCoord[0],\n                        y: proposedCanvasCoord[1],\n                    },\n                    end: {\n                        x: newTranslatedPoint[0],\n                        y: newTranslatedPoint[1],\n                    },\n                }, {\n                    start: {\n                        x: canvasCoordsCurrent.longLineSegment.start.x,\n                        y: canvasCoordsCurrent.longLineSegment.start.y,\n                    },\n                    end: {\n                        x: canvasCoordsCurrent.longLineSegment.end.x,\n                        y: canvasCoordsCurrent.longLineSegment.end.y,\n                    },\n                })) {\n                    return;\n                }\n                const intersectionPoint = lineSegment.intersectLine([proposedCanvasCoord[0], proposedCanvasCoord[1]], [newTranslatedPoint[0], newTranslatedPoint[1]], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);\n                if (!intersectionPoint) {\n                    return;\n                }\n                data.handles.points[translateHandleIndex] = viewport.canvasToWorld(newTranslatedPoint);\n                data.handles.points[movingHandleIndex] = proposedPoint;\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = true;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        width: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, showHandlesAlways ? canvasCoordinates : activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId1 = `${annotationUID}-line-1`;\n                const dataId2 = `${annotationUID}-line-2`;\n                const lineUID = '0';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                    shadow,\n                }, dataId1);\n                const secondLineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, secondLineUID, canvasCoordinates[2], canvasCoordinates[3], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                    shadow,\n                }, dataId2);\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._movingLongAxisWouldPutItThroughShortAxis = (firstLineSegment, secondLineSegment) => {\n            const vectorInSecondLineDirection = vec2.create();\n            vec2.set(vectorInSecondLineDirection, secondLineSegment.end.x - secondLineSegment.start.x, secondLineSegment.end.y - secondLineSegment.start.y);\n            vec2.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);\n            const extendedSecondLineSegment = {\n                start: {\n                    x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,\n                    y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,\n                },\n                end: {\n                    x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,\n                    y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,\n                },\n            };\n            const proposedIntersectionPoint = lineSegment.intersectLine([extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y], [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);\n            const wouldPutThroughShortAxis = !proposedIntersectionPoint;\n            return wouldPutThroughShortAxis;\n        };\n        this._calculateCachedStats = (annotation, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { element } = enabledElement.viewport;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[1];\n            const worldPos3 = data.handles.points[2];\n            const worldPos4 = data.handles.points[3];\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { imageData, dimensions } = image;\n                const index1 = transformWorldToIndex(imageData, worldPos1);\n                const index2 = transformWorldToIndex(imageData, worldPos2);\n                const index3 = transformWorldToIndex(imageData, worldPos3);\n                const index4 = transformWorldToIndex(imageData, worldPos4);\n                const handles1 = [index1, index2];\n                const handles2 = [index3, index4];\n                const { scale: scale1, unit: units1 } = getCalibratedLengthUnitsAndScale(image, handles1);\n                const { scale: scale2, unit: units2 } = getCalibratedLengthUnitsAndScale(image, handles2);\n                const dist1 = this._calculateLength(worldPos1, worldPos2) / scale1;\n                const dist2 = this._calculateLength(worldPos3, worldPos4) / scale2;\n                const length = dist1 > dist2 ? dist1 : dist2;\n                const width = dist1 > dist2 ? dist2 : dist1;\n                const unit = dist1 > dist2 ? units1 : units2;\n                const widthUnit = dist1 > dist2 ? units2 : units1;\n                this._isInsideVolume(index1, index2, index3, index4, dimensions)\n                    ? (this.isHandleOutsideImage = false)\n                    : (this.isHandleOutsideImage = true);\n                cachedStats[targetId] = {\n                    length,\n                    width,\n                    unit,\n                    widthUnit,\n                };\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, index3, index4, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions) &&\n                csUtils.indexWithinDimensions(index3, dimensions) &&\n                csUtils.indexWithinDimensions(index4, dimensions));\n        };\n        this._getSignedAngle = (vector1, vector2) => {\n            return Math.atan2(vector1[0] * vector2[1] - vector1[1] * vector2[0], vector1[0] * vector2[0] + vector1[1] * vector2[1]);\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const worldPos = currentPoints.world;\n        this.isDrawing = true;\n        const annotation = this.createAnnotation(evt, [\n            [...worldPos],\n            [...worldPos],\n            [...worldPos],\n            [...worldPos],\n        ]);\n        addAnnotation(annotation, element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex: 1,\n            movingTextBox: false,\n            newAnnotation: true,\n            hasMoved: false,\n        };\n        this._activateDraw(element);\n        hideElementCursor(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        return annotation;\n    }\n    static { this.hydrate = (viewportId, axis, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(BidirectionalTool, enabledElement, axis[0], options);\n        const [majorAxis, minorAxis] = axis;\n        const [major0, major1] = majorAxis;\n        const [minor0, minor1] = minorAxis;\n        const points = [major0, major1, minor0, minor1];\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    activeHandleIndex: null,\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                },\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n        return annotation;\n    }; }\n    _calculateLength(pos1, pos2) {\n        const dx = pos1[0] - pos2[0];\n        const dy = pos1[1] - pos2[1];\n        const dz = pos1[2] - pos2[2];\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const { cachedStats, label } = data;\n    const { length, width, unit } = cachedStats[targetId];\n    const textLines = [];\n    if (label) {\n        textLines.push(label);\n    }\n    if (length === undefined) {\n        return textLines;\n    }\n    textLines.push(`L: ${csUtils.roundNumber(length)} ${unit || unit}`, `W: ${csUtils.roundNumber(width)} ${unit}`);\n    return textLines;\n}\nexport default BidirectionalTool;\n", "import { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { state as annotationState, config as annotationConfig, } from '../../stateManagement/annotation';\nimport contourAndFindLargestBidirectional from './contourAndFindLargestBidirectional';\nimport createBidirectionalToolData from './createBidirectionalToolData';\nimport BidirectionalTool from '../../tools/annotation/BidirectionalTool';\nimport { getSegmentations } from '../../stateManagement/segmentation/getSegmentations';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nexport default async function segmentContourAction(element, configuration) {\n    console.warn('Deprecation Alert: There is a new getSegmentLargestBidirectional function that handles volume, stack and individual segment cases properly. This function is deprecated and will be removed in a future version.');\n    const { data: configurationData } = configuration;\n    const enabledElement = getEnabledElement(element);\n    const segment = (configurationData.getSegment || defaultGetSegment)(enabledElement, configurationData);\n    if (!segment) {\n        return;\n    }\n    const FrameOfReferenceUID = enabledElement.viewport.getFrameOfReferenceUID();\n    const segmentationsList = getSegmentations();\n    const { segmentIndex, segmentationId } = segment;\n    const bidirectionals = annotationState.getAnnotations(this.toolName || BidirectionalTool.toolName, FrameOfReferenceUID);\n    let hasExistingActiveSegment = false;\n    const existingLargestBidirectionals = bidirectionals.filter((existingBidirectionalItem) => {\n        const segment = existingBidirectionalItem.data.segment;\n        if (!segment) {\n            return false;\n        }\n        if (segment.segmentationId === segmentationId &&\n            segment.segmentIndex === segmentIndex) {\n            hasExistingActiveSegment = true;\n            existingBidirectionalItem.data.segment = segment;\n        }\n        return true;\n    });\n    if (!hasExistingActiveSegment) {\n        existingLargestBidirectionals.push({\n            data: { segment },\n        });\n    }\n    let newBidirectional;\n    existingLargestBidirectionals.forEach(async (existingLargestBidirectional) => {\n        const segments = [];\n        const updateSegment = existingLargestBidirectional.data\n            .segment;\n        const { segmentIndex, segmentationId } = updateSegment;\n        segments[segmentIndex] = updateSegment;\n        annotationState.removeAnnotation(existingLargestBidirectional.annotationUID);\n        const bidirectionalData = await contourAndFindLargestBidirectional({\n            ...segmentationsList.find((segmentation) => segmentation.segmentationId === segmentationId),\n            segments,\n        });\n        if (!bidirectionalData) {\n            return;\n        }\n        const bidirectionalToolData = createBidirectionalToolData(bidirectionalData, enabledElement.viewport);\n        bidirectionalToolData.annotationUID =\n            existingLargestBidirectional.annotationUID;\n        bidirectionalToolData.data.segment = updateSegment;\n        const annotationUID = annotationState.addAnnotation(bidirectionalToolData, FrameOfReferenceUID);\n        if (updateSegment.segmentIndex === segment.segmentIndex &&\n            updateSegment.segmentationId === segment.segmentationId) {\n            newBidirectional = bidirectionalData;\n            const { style } = segment;\n            if (style) {\n                annotationConfig.style.setAnnotationStyles(annotationUID, style);\n            }\n        }\n    });\n    if (newBidirectional) {\n        const { sliceIndex } = newBidirectional;\n        const imageIds = enabledElement.viewport.getImageIds();\n        utilities.jumpToSlice(element, {\n            imageIndex: imageIds.length - 1 - sliceIndex,\n        });\n        enabledElement.viewport.render();\n    }\n    else {\n        console.warn('No bidirectional found');\n    }\n    return newBidirectional;\n}\nexport function defaultGetSegment(enabledElement, configuration) {\n    const segmentationsList = getSegmentations();\n    if (!segmentationsList.length) {\n        return;\n    }\n    const segmentationId = configuration.segmentationId || segmentationsList[0].segmentationId;\n    const segmentIndex = configuration.segmentIndex ?? getActiveSegmentIndex(segmentationId);\n    if (!segmentIndex) {\n        return;\n    }\n    const segmentData = configuration.segmentData?.get(segmentIndex);\n    return {\n        label: `Segment ${segmentIndex}`,\n        segmentIndex,\n        segmentationId,\n        ...segmentData,\n    };\n}\n", "import { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getBrushToolInstances } from './getBrushToolInstances';\nexport function invalidateBrushCursor(toolGroupId) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n    brushBasedToolInstances.forEach((tool) => {\n        tool.invalidateBrushCursor();\n    });\n    const viewportsInfo = toolGroup.getViewportsInfo();\n    const viewportsInfoArray = Object.keys(viewportsInfo).map((key) => viewportsInfo[key]);\n    if (!viewportsInfoArray.length) {\n        return;\n    }\n    const viewportIds = toolGroup.getViewportIds();\n    triggerAnnotationRenderForViewportIds(viewportIds);\n}\n", "import { BaseVolumeViewport, cache, utilities } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport { getSegmentation, getCurrentLabelmapImageIdsForViewport, } from '../../stateManagement/segmentation/segmentationState';\nimport { getAnnotation } from '../../stateManagement';\nimport { isPointInsidePolyline3D } from '../math/polyline';\nimport { getLabelmapActorEntry } from '../../stateManagement/segmentation/helpers/getSegmentationActor';\nexport function getSegmentIndexAtWorldPoint(segmentationId, worldPoint, options = {}) {\n    const segmentation = getSegmentation(segmentationId);\n    const representationData = segmentation.representationData;\n    const desiredRepresentation = options?.representationType ?? Object.keys(representationData)[0];\n    if (!desiredRepresentation) {\n        throw new Error(`Segmentation ${segmentationId} does not have any representations`);\n    }\n    switch (desiredRepresentation) {\n        case SegmentationRepresentations.Labelmap:\n            return getSegmentIndexAtWorldForLabelmap(segmentation, worldPoint, options);\n        case SegmentationRepresentations.Contour:\n            return getSegmentIndexAtWorldForContour(segmentation, worldPoint, options);\n        default:\n            return;\n    }\n}\nexport function getSegmentIndexAtWorldForLabelmap(segmentation, worldPoint, { viewport }) {\n    const labelmapData = segmentation.representationData.Labelmap;\n    if (viewport instanceof BaseVolumeViewport) {\n        const { volumeId } = labelmapData;\n        const segmentationVolume = cache.getVolume(volumeId);\n        if (!segmentationVolume) {\n            return;\n        }\n        const segmentIndex = segmentationVolume.imageData.getScalarValueFromWorld(worldPoint);\n        return segmentIndex;\n    }\n    const segmentationImageIds = getCurrentLabelmapImageIdsForViewport(viewport.id, segmentation.segmentationId);\n    if (segmentationImageIds.length > 1) {\n        console.warn('Segment selection for labelmaps with multiple imageIds in stack viewports is not supported yet.');\n        return;\n    }\n    const segmentationImageId = segmentationImageIds[0];\n    const image = cache.getImage(segmentationImageId);\n    if (!image) {\n        return;\n    }\n    const segmentationActorEntry = getLabelmapActorEntry(viewport.id, segmentation.segmentationId);\n    const imageData = segmentationActorEntry?.actor.getMapper().getInputData();\n    const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n    const dimensions = imageData.getDimensions();\n    const voxelManager = (imageData.voxelManager ||\n        utilities.VoxelManager.createScalarVolumeVoxelManager({\n            dimensions,\n            scalarData: imageData.getPointData().getScalars().getData(),\n        }));\n    const segmentIndex = voxelManager.getAtIJKPoint(indexIJK);\n    return segmentIndex;\n}\nexport function getSegmentIndexAtWorldForContour(segmentation, worldPoint, { viewport }) {\n    const contourData = segmentation.representationData.Contour;\n    const segmentIndices = Array.from(contourData.annotationUIDsMap.keys());\n    const { viewPlaneNormal } = viewport.getCamera();\n    for (const segmentIndex of segmentIndices) {\n        const annotationsSet = contourData.annotationUIDsMap.get(segmentIndex);\n        if (!annotationsSet) {\n            continue;\n        }\n        for (const annotationUID of annotationsSet) {\n            const annotation = getAnnotation(annotationUID);\n            if (!annotation) {\n                continue;\n            }\n            const { polyline } = annotation.data.contour;\n            if (!utilities.isEqual(viewPlaneNormal, annotation.metadata.viewPlaneNormal)) {\n                continue;\n            }\n            if (isPointInsidePolyline3D(worldPoint, polyline)) {\n                return Number(segmentIndex);\n            }\n        }\n    }\n}\n", "import { BaseVolumeViewport, cache, utilities } from '@cornerstonejs/core';\nimport { getSegmentation, getCurrentLabelmapImageIdForViewport, } from '../../stateManagement/segmentation/segmentationState';\nimport { getLabelmapActorEntry } from '../../stateManagement/segmentation/helpers';\nexport function getSegmentIndexAtLabelmapBorder(segmentationId, worldPoint, { viewport, searchRadius }) {\n    const segmentation = getSegmentation(segmentationId);\n    const labelmapData = segmentation.representationData.Labelmap;\n    if (viewport instanceof BaseVolumeViewport) {\n        const { volumeId } = labelmapData;\n        const segmentationVolume = cache.getVolume(volumeId);\n        if (!segmentationVolume) {\n            return;\n        }\n        const voxelManager = segmentationVolume.voxelManager;\n        const imageData = segmentationVolume.imageData;\n        const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n        const segmentIndex = voxelManager.getAtIJK(indexIJK[0], indexIJK[1], indexIJK[2]);\n        const canvasPoint = viewport.worldToCanvas(worldPoint);\n        const onEdge = isSegmentOnEdgeCanvas(canvasPoint, segmentIndex, viewport, imageData, searchRadius);\n        return onEdge ? segmentIndex : undefined;\n    }\n    const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n    const image = cache.getImage(segmentationImageId);\n    if (!image) {\n        return;\n    }\n    const segmentationActorEntry = getLabelmapActorEntry(viewport.id, segmentationId);\n    const imageData = segmentationActorEntry?.actor.getMapper().getInputData();\n    const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n    const dimensions = imageData.getDimensions();\n    const voxelManager = (imageData.voxelManager ||\n        utilities.VoxelManager.createScalarVolumeVoxelManager({\n            dimensions,\n            scalarData: imageData.getPointData().getScalars().getData(),\n        }));\n    const segmentIndex = voxelManager.getAtIJKPoint(indexIJK);\n    const onEdge = isSegmentOnEdgeIJK(indexIJK, dimensions, voxelManager, segmentIndex);\n    return onEdge ? segmentIndex : undefined;\n}\nfunction isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius = 1) {\n    const neighborRange = Array.from({ length: 2 * searchRadius + 1 }, (_, i) => i - searchRadius);\n    for (const deltaI of neighborRange) {\n        for (const deltaJ of neighborRange) {\n            for (const deltaK of neighborRange) {\n                if (deltaI === 0 && deltaJ === 0 && deltaK === 0) {\n                    continue;\n                }\n                const neighborIndex = getNeighborIndex(deltaI, deltaJ, deltaK);\n                if (neighborIndex !== undefined && segmentIndex !== neighborIndex) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nfunction isSegmentOnEdgeIJK(indexIJK, dimensions, voxelManager, segmentIndex, searchRadius) {\n    const getNeighborIndex = (deltaI, deltaJ, deltaK) => {\n        const neighborIJK = [\n            indexIJK[0] + deltaI,\n            indexIJK[1] + deltaJ,\n            indexIJK[2] + deltaK,\n        ];\n        return voxelManager.getAtIJK(neighborIJK[0], neighborIJK[1], neighborIJK[2]);\n    };\n    return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\n}\nfunction isSegmentOnEdgeCanvas(canvasPoint, segmentIndex, viewport, imageData, searchRadius) {\n    const getNeighborIndex = (deltaI, deltaJ) => {\n        const neighborCanvas = [canvasPoint[0] + deltaI, canvasPoint[1] + deltaJ];\n        const worldPoint = viewport.canvasToWorld(neighborCanvas);\n        const voxelManager = imageData.get('voxelManager').voxelManager;\n        const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n        return voxelManager.getAtIJK(indexIJK[0], indexIJK[1], indexIJK[2]);\n    };\n    return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\n}\n", "import { getAnnotation } from '../../stateManagement';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nexport function getHoveredContourSegmentationAnnotation(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    const { annotationUIDsMap } = segmentation.representationData.Contour;\n    for (const [segmentIndex, annotationUIDs] of annotationUIDsMap.entries()) {\n        const highlightedAnnotationUID = Array.from(annotationUIDs).find((annotationUID) => getAnnotation(annotationUID).highlighted);\n        if (highlightedAnnotationUID) {\n            return segmentIndex;\n        }\n    }\n    return undefined;\n}\n", "export { run } from './runGrowCut';\nexport { runGrowCutForSphere } from './runGrowCutForSphere';\nexport { runGrowCutForBoundingBox } from './runGrowCutForBoundingBox';\nexport { runOneClickGrowCut } from './runOneClickGrowCut';\n", "const shader = `\nconst MAX_STRENGTH = 65535f;\n\n// Workgroup size - X*Y*Z must be multiple of 32 for better performance\noverride workGroupSizeX = 1u;\noverride workGroupSizeY = 1u;\noverride workGroupSizeZ = 1u;\n\n// Compare the current voxel to neighbors using a 9x9x9 window\noverride windowSize = 9i;\n\nstruct Params {\n  size: vec3u,\n  iteration: u32,\n}\n\n// New structure to track bounds of modified voxels\nstruct Bounds {\n  minX: atomic<i32>,\n  minY: atomic<i32>,\n  minZ: atomic<i32>,\n  maxX: atomic<i32>,\n  maxY: atomic<i32>,\n  maxZ: atomic<i32>,\n}\n\n@group(0) @binding(0) var<uniform> params: Params;\n@group(0) @binding(1) var<storage> volumePixelData: array<f32>;\n@group(0) @binding(2) var<storage, read_write> labelmap: array<u32>;\n@group(0) @binding(3) var<storage, read_write> strengthData: array<f32>;\n@group(0) @binding(4) var<storage> prevLabelmap: array<u32>;\n@group(0) @binding(5) var<storage> prevStrengthData: array<f32>;\n@group(0) @binding(6) var<storage, read_write> updatedVoxelsCounter: array<atomic<u32>>;\n@group(0) @binding(7) var<storage, read_write> modifiedBounds: Bounds;\n\nfn getPixelIndex(ijkPos: vec3u) -> u32 {\n  let numPixelsPerSlice = params.size.x * params.size.y;\n  return ijkPos.x + ijkPos.y * params.size.x + ijkPos.z * numPixelsPerSlice;\n}\n\nfn updateBounds(position: vec3i) {\n  // Atomically update min bounds (use min operation)\n  let oldMinX = atomicMin(&modifiedBounds.minX, position.x);\n  let oldMinY = atomicMin(&modifiedBounds.minY, position.y);\n  let oldMinZ = atomicMin(&modifiedBounds.minZ, position.z);\n\n  // Atomically update max bounds (use max operation)\n  let oldMaxX = atomicMax(&modifiedBounds.maxX, position.x);\n  let oldMaxY = atomicMax(&modifiedBounds.maxY, position.y);\n  let oldMaxZ = atomicMax(&modifiedBounds.maxZ, position.z);\n}\n\n@compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\nfn main(\n  @builtin(global_invocation_id) globalId: vec3u,\n) {\n  // Make sure it will not get out of bounds for volume with sizes that\n  // are not multiple of workGroupSize\n  if (\n    globalId.x >= params.size.x ||\n    globalId.y >= params.size.y ||\n    globalId.z >= params.size.z\n  ) {\n    return;\n  }\n\n  // Initialize bounds for the first iteration\n  if (params.iteration == 0 && globalId.x == 0 && globalId.y == 0 && globalId.z == 0) {\n    // Initialize to opposite extremes to ensure any update will improve the bounds\n    atomicStore(&modifiedBounds.minX, i32(params.size.x));\n    atomicStore(&modifiedBounds.minY, i32(params.size.y));\n    atomicStore(&modifiedBounds.minZ, i32(params.size.z));\n    atomicStore(&modifiedBounds.maxX, -1);\n    atomicStore(&modifiedBounds.maxY, -1);\n    atomicStore(&modifiedBounds.maxZ, -1);\n  }\n\n  let currentCoord = vec3i(globalId);\n  let currentPixelIndex = getPixelIndex(globalId);\n\n  let numPixels = arrayLength(&volumePixelData);\n  let currentPixelValue = volumePixelData[currentPixelIndex];\n\n  if (params.iteration == 0) {\n    // All non-zero initial labels are given maximum strength\n    strengthData[currentPixelIndex] = select(MAX_STRENGTH, 0., labelmap[currentPixelIndex] == 0);\n\n    // Update bounds for non-zero initial labels\n    if (labelmap[currentPixelIndex] != 0) {\n      updateBounds(currentCoord);\n    }\n    return;\n  }\n\n  // It should at least copy the values from previous state\n  var newLabel = prevLabelmap[currentPixelIndex];\n  var newStrength = prevStrengthData[currentPixelIndex];\n\n  let window = i32(ceil(f32(windowSize - 1) * .5));\n  let minWindow = -1i * window;\n  let maxWindow = 1i * window;\n\n  for (var k = minWindow; k <= maxWindow; k++) {\n    for (var j = minWindow; j <= maxWindow; j++) {\n      for (var i = minWindow; i <= maxWindow; i++) {\n        // Skip current voxel\n        if (i == 0 && j == 0 && k == 0) {\n          continue;\n        }\n\n        let neighborCoord = currentCoord + vec3i(i, j, k);\n\n        //  Boundary conditions. Do not grow outside of the volume\n        if (\n          neighborCoord.x < 0i || neighborCoord.x >= i32(params.size.x) ||\n          neighborCoord.y < 0i || neighborCoord.y >= i32(params.size.y) ||\n          neighborCoord.z < 0i || neighborCoord.z >= i32(params.size.z)\n        ) {\n          continue;\n        }\n\n        let neighborIndex = getPixelIndex(vec3u(neighborCoord));\n        let neighborPixelValue = volumePixelData[neighborIndex];\n        let prevNeighborStrength = prevStrengthData[neighborIndex];\n        let strengthCost = abs(neighborPixelValue - currentPixelValue);\n        let takeoverStrength = prevNeighborStrength - strengthCost;\n\n        if (takeoverStrength > newStrength) {\n          newLabel = prevLabelmap[neighborIndex];\n          newStrength = takeoverStrength;\n        }\n      }\n    }\n  }\n\n  if (labelmap[currentPixelIndex] != newLabel) {\n    atomicAdd(&updatedVoxelsCounter[params.iteration], 1u);\n\n    // Update bounds for modified voxels\n    updateBounds(currentCoord);\n  }\n\n  labelmap[currentPixelIndex] = newLabel;\n  strengthData[currentPixelIndex] = newStrength;\n}\n`;\nexport default shader;\n", "import { cache } from '@cornerstonejs/core';\nimport shaderCode from './growCutShader';\nconst GB = 1024 * 1024 * 1024;\nconst WEBGPU_MEMORY_LIMIT = 1.99 * GB;\nconst DEFAULT_GROWCUT_OPTIONS = {\n    windowSize: 3,\n    maxProcessingTime: 30000,\n    inspection: {\n        numCyclesInterval: 5,\n        numCyclesBelowThreshold: 3,\n        threshold: 1e-4,\n    },\n};\nasync function runGrowCut(referenceVolumeId, labelmapVolumeId, options = DEFAULT_GROWCUT_OPTIONS) {\n    const workGroupSize = [8, 8, 4];\n    const { windowSize, maxProcessingTime } = Object.assign({}, DEFAULT_GROWCUT_OPTIONS, options);\n    const inspection = Object.assign({}, DEFAULT_GROWCUT_OPTIONS.inspection, options.inspection);\n    const volume = cache.getVolume(referenceVolumeId);\n    const labelmap = cache.getVolume(labelmapVolumeId);\n    const [columns, rows, numSlices] = volume.dimensions;\n    if (labelmap.dimensions[0] !== columns ||\n        labelmap.dimensions[1] !== rows ||\n        labelmap.dimensions[2] !== numSlices) {\n        throw new Error('Volume and labelmap must have the same size');\n    }\n    let numIterations = Math.floor(Math.sqrt(rows ** 2 + columns ** 2 + numSlices ** 2) / 2);\n    numIterations = Math.min(numIterations, 500);\n    const labelmapData = labelmap.voxelManager.getCompleteScalarDataArray();\n    let volumePixelData = volume.voxelManager.getCompleteScalarDataArray();\n    if (!(volumePixelData instanceof Float32Array)) {\n        volumePixelData = new Float32Array(volumePixelData);\n    }\n    const requiredLimits = {\n        maxStorageBufferBindingSize: WEBGPU_MEMORY_LIMIT,\n        maxBufferSize: WEBGPU_MEMORY_LIMIT,\n    };\n    const adapter = await navigator.gpu?.requestAdapter();\n    const device = await adapter.requestDevice({ requiredLimits });\n    const BUFFER_SIZE = volumePixelData.byteLength;\n    const UPDATED_VOXELS_COUNTER_BUFFER_SIZE = numIterations * Uint32Array.BYTES_PER_ELEMENT;\n    const BOUNDS_BUFFER_SIZE = 6 * Int32Array.BYTES_PER_ELEMENT;\n    const shaderModule = device.createShaderModule({\n        code: shaderCode,\n    });\n    const numIterationIndex = 3;\n    const paramsArrayValues = new Uint32Array([\n        columns,\n        rows,\n        numSlices,\n        0,\n    ]);\n    const gpuParamsBuffer = device.createBuffer({\n        size: paramsArrayValues.byteLength,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    const gpuVolumePixelDataBuffer = device.createBuffer({\n        size: BUFFER_SIZE,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(gpuVolumePixelDataBuffer, 0, volumePixelData);\n    const gpuLabelmapBuffers = [0, 1].map(() => device.createBuffer({\n        size: BUFFER_SIZE,\n        usage: GPUBufferUsage.STORAGE |\n            GPUBufferUsage.COPY_SRC |\n            GPUBufferUsage.COPY_DST,\n    }));\n    device.queue.writeBuffer(gpuLabelmapBuffers[0], 0, new Uint32Array(labelmapData));\n    const gpuStrengthBuffers = [0, 1].map(() => {\n        const strengthBuffer = device.createBuffer({\n            size: BUFFER_SIZE,\n            usage: GPUBufferUsage.STORAGE |\n                GPUBufferUsage.COPY_SRC |\n                GPUBufferUsage.COPY_DST,\n        });\n        return strengthBuffer;\n    });\n    const gpuCounterBuffer = device.createBuffer({\n        size: UPDATED_VOXELS_COUNTER_BUFFER_SIZE,\n        usage: GPUBufferUsage.STORAGE |\n            GPUBufferUsage.COPY_SRC |\n            GPUBufferUsage.COPY_DST,\n    });\n    const gpuBoundsBuffer = device.createBuffer({\n        size: BOUNDS_BUFFER_SIZE,\n        usage: GPUBufferUsage.STORAGE |\n            GPUBufferUsage.COPY_SRC |\n            GPUBufferUsage.COPY_DST,\n    });\n    const initialBounds = new Int32Array([\n        columns,\n        rows,\n        numSlices,\n        -1,\n        -1,\n        -1,\n    ]);\n    device.queue.writeBuffer(gpuBoundsBuffer, 0, initialBounds);\n    const bindGroupLayout = device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'uniform',\n                },\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'read-only-storage',\n                },\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'storage',\n                },\n            },\n            {\n                binding: 3,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'storage',\n                },\n            },\n            {\n                binding: 4,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'read-only-storage',\n                },\n            },\n            {\n                binding: 5,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'read-only-storage',\n                },\n            },\n            {\n                binding: 6,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'storage',\n                },\n            },\n            {\n                binding: 7,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'storage',\n                },\n            },\n        ],\n    });\n    const bindGroups = [0, 1].map((i) => {\n        const outputLabelmapBuffer = gpuLabelmapBuffers[i];\n        const outputStrengthBuffer = gpuStrengthBuffers[i];\n        const previouLabelmapBuffer = gpuLabelmapBuffers[(i + 1) % 2];\n        const previousStrengthBuffer = gpuStrengthBuffers[(i + 1) % 2];\n        return device.createBindGroup({\n            layout: bindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: gpuParamsBuffer,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: gpuVolumePixelDataBuffer,\n                    },\n                },\n                {\n                    binding: 2,\n                    resource: {\n                        buffer: outputLabelmapBuffer,\n                    },\n                },\n                {\n                    binding: 3,\n                    resource: {\n                        buffer: outputStrengthBuffer,\n                    },\n                },\n                {\n                    binding: 4,\n                    resource: {\n                        buffer: previouLabelmapBuffer,\n                    },\n                },\n                {\n                    binding: 5,\n                    resource: {\n                        buffer: previousStrengthBuffer,\n                    },\n                },\n                {\n                    binding: 6,\n                    resource: {\n                        buffer: gpuCounterBuffer,\n                    },\n                },\n                {\n                    binding: 7,\n                    resource: {\n                        buffer: gpuBoundsBuffer,\n                    },\n                },\n            ],\n        });\n    });\n    const pipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout({\n            bindGroupLayouts: [bindGroupLayout],\n        }),\n        compute: {\n            module: shaderModule,\n            entryPoint: 'main',\n            constants: {\n                workGroupSizeX: workGroupSize[0],\n                workGroupSizeY: workGroupSize[1],\n                workGroupSizeZ: workGroupSize[2],\n                windowSize,\n            },\n        },\n    });\n    const numWorkGroups = [\n        Math.ceil(columns / workGroupSize[0]),\n        Math.ceil(rows / workGroupSize[1]),\n        Math.ceil(numSlices / workGroupSize[2]),\n    ];\n    const gpuUpdatedVoxelsCounterStagingBuffer = device.createBuffer({\n        size: UPDATED_VOXELS_COUNTER_BUFFER_SIZE,\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    const limitProcessingTime = maxProcessingTime\n        ? performance.now() + maxProcessingTime\n        : 0;\n    let currentInspectionNumCyclesInterval = inspection.numCyclesInterval;\n    let belowThresholdCounter = 0;\n    for (let i = 0; i < numIterations; i++) {\n        paramsArrayValues[numIterationIndex] = i;\n        device.queue.writeBuffer(gpuParamsBuffer, 0, paramsArrayValues);\n        const commandEncoder = device.createCommandEncoder();\n        const passEncoder = commandEncoder.beginComputePass();\n        passEncoder.setPipeline(pipeline);\n        passEncoder.setBindGroup(0, bindGroups[i % 2]);\n        passEncoder.dispatchWorkgroups(numWorkGroups[0], numWorkGroups[1], numWorkGroups[2]);\n        passEncoder.end();\n        commandEncoder.copyBufferToBuffer(gpuCounterBuffer, i * Uint32Array.BYTES_PER_ELEMENT, gpuUpdatedVoxelsCounterStagingBuffer, i * Uint32Array.BYTES_PER_ELEMENT, Uint32Array.BYTES_PER_ELEMENT);\n        device.queue.submit([commandEncoder.finish()]);\n        const inspect = i > 0 && !(i % currentInspectionNumCyclesInterval);\n        if (inspect) {\n            await gpuUpdatedVoxelsCounterStagingBuffer.mapAsync(GPUMapMode.READ, 0, UPDATED_VOXELS_COUNTER_BUFFER_SIZE);\n            const updatedVoxelsCounterResultBuffer = gpuUpdatedVoxelsCounterStagingBuffer.getMappedRange(0, UPDATED_VOXELS_COUNTER_BUFFER_SIZE);\n            const updatedVoxelsCounterBufferData = new Uint32Array(updatedVoxelsCounterResultBuffer.slice(0));\n            const updatedVoxelsRatio = updatedVoxelsCounterBufferData[i] / volumePixelData.length;\n            gpuUpdatedVoxelsCounterStagingBuffer.unmap();\n            if (i >= 1 && updatedVoxelsRatio < inspection.threshold) {\n                currentInspectionNumCyclesInterval = 1;\n                belowThresholdCounter++;\n                if (belowThresholdCounter === inspection.numCyclesBelowThreshold) {\n                    break;\n                }\n            }\n            else {\n                currentInspectionNumCyclesInterval = inspection.numCyclesInterval;\n            }\n        }\n        if (limitProcessingTime && performance.now() > limitProcessingTime) {\n            console.warn(`Exceeded processing time limit (${maxProcessingTime})ms`);\n            break;\n        }\n    }\n    const commandEncoder = device.createCommandEncoder();\n    const outputLabelmapBufferIndex = (numIterations + 1) % 2;\n    const labelmapStagingBuffer = device.createBuffer({\n        size: BUFFER_SIZE,\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    const boundsStagingBuffer = device.createBuffer({\n        size: BOUNDS_BUFFER_SIZE,\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    commandEncoder.copyBufferToBuffer(gpuLabelmapBuffers[outputLabelmapBufferIndex], 0, labelmapStagingBuffer, 0, BUFFER_SIZE);\n    commandEncoder.copyBufferToBuffer(gpuBoundsBuffer, 0, boundsStagingBuffer, 0, BOUNDS_BUFFER_SIZE);\n    device.queue.submit([commandEncoder.finish()]);\n    await labelmapStagingBuffer.mapAsync(GPUMapMode.READ, 0, BUFFER_SIZE);\n    const labelmapResultBuffer = labelmapStagingBuffer.getMappedRange(0, BUFFER_SIZE);\n    const labelmapResult = new Uint32Array(labelmapResultBuffer);\n    labelmapData.set(labelmapResult);\n    labelmapStagingBuffer.unmap();\n    await boundsStagingBuffer.mapAsync(GPUMapMode.READ, 0, BOUNDS_BUFFER_SIZE);\n    const boundsResultBuffer = boundsStagingBuffer.getMappedRange(0, BOUNDS_BUFFER_SIZE);\n    const boundsResult = new Int32Array(boundsResultBuffer.slice(0));\n    boundsStagingBuffer.unmap();\n    const minX = boundsResult[0];\n    const minY = boundsResult[1];\n    const minZ = boundsResult[2];\n    const maxX = boundsResult[3];\n    const maxY = boundsResult[4];\n    const maxZ = boundsResult[5];\n    labelmap.voxelManager.setCompleteScalarDataArray(labelmapData);\n    labelmap.voxelManager.clearBounds();\n    labelmap.voxelManager.setBounds([\n        [minX, maxX],\n        [minY, maxY],\n        [minZ, maxZ],\n    ]);\n}\nexport { runGrowCut as default, runGrowCut as run };\n", "import { quat, vec3 } from 'gl-matrix';\nimport { utilities as csUtils, cache, volumeLoader } from '@cornerstonejs/core';\nimport { run } from './runGrowCut';\nimport { getSphereBoundsInfo } from '../../getSphereBoundsInfo';\nconst { transformWorldToIndex } = csUtils;\nconst POSITIVE_SEED_VALUE = 254;\nconst NEGATIVE_SEED_VALUE = 255;\nconst POSITIVE_SEED_VARIANCE = 0.1;\nconst NEGATIVE_SEED_VARIANCE = 0.8;\nfunction _getGrowCutSphereBoundsInfo(referencedVolume, sphereBoundsInfo) {\n    const { topLeftWorld, bottomRightWorld } = sphereBoundsInfo;\n    const topLeftIJK = transformWorldToIndex(referencedVolume.imageData, topLeftWorld);\n    const bottomRightIJK = transformWorldToIndex(referencedVolume.imageData, bottomRightWorld);\n    return {\n        ...sphereBoundsInfo,\n        topLeftIJK,\n        bottomRightIJK,\n    };\n}\nfunction _getSphereBoundsInfo(referencedVolume, sphereInfo) {\n    const direction = referencedVolume.imageData.getDirection();\n    const vecColumn = vec3.fromValues(direction[3], direction[4], direction[5]);\n    const { center: sphereCenterPoint, radius: sphereRadius } = sphereInfo;\n    const refVolImageData = referencedVolume.imageData;\n    const topCirclePoint = vec3.scaleAndAdd(vec3.create(), sphereCenterPoint, vecColumn, -sphereRadius);\n    const bottomCirclePoint = vec3.scaleAndAdd(vec3.create(), sphereCenterPoint, vecColumn, sphereRadius);\n    const sphereBoundsInfo = getSphereBoundsInfo([bottomCirclePoint, topCirclePoint], refVolImageData);\n    return _getGrowCutSphereBoundsInfo(referencedVolume, sphereBoundsInfo);\n}\nfunction _createSubVolumeFromSphere(referencedVolume, sphereInfo, viewport) {\n    const refVolImageData = referencedVolume.imageData;\n    const camera = viewport.getCamera();\n    const { ijkVecRowDir, ijkVecColDir } = csUtils.getVolumeDirectionVectors(refVolImageData, camera);\n    const obliqueView = [ijkVecRowDir, ijkVecColDir].some((vec) => !csUtils.isEqual(Math.abs(vec[0]), 1) &&\n        !csUtils.isEqual(Math.abs(vec[1]), 1) &&\n        !csUtils.isEqual(Math.abs(vec[2]), 1));\n    if (obliqueView) {\n        console.warn('Oblique view is not supported!');\n        return;\n    }\n    const { boundsIJK: sphereBoundsIJK } = _getSphereBoundsInfo(referencedVolume, sphereInfo);\n    const subVolumeBoundsIJK = {\n        minX: sphereBoundsIJK[0][0],\n        maxX: sphereBoundsIJK[0][1] + 1,\n        minY: sphereBoundsIJK[1][0],\n        maxY: sphereBoundsIJK[1][1] + 1,\n        minZ: sphereBoundsIJK[2][0],\n        maxZ: sphereBoundsIJK[2][1] + 1,\n    };\n    return csUtils.createSubVolume(referencedVolume.volumeId, subVolumeBoundsIJK, {\n        targetBuffer: {\n            type: 'Float32Array',\n        },\n    });\n}\nfunction _setPositiveSeedValues(referencedVolume, labelmap, sphereInfo, options) {\n    const refVolumePixelData = referencedVolume.voxelManager.getCompleteScalarDataArray();\n    const worldStartPos = sphereInfo.center;\n    const [width, height, numSlices] = referencedVolume.dimensions;\n    const numPixelsPerSlice = width * height;\n    const ijkStartPosition = transformWorldToIndex(referencedVolume.imageData, worldStartPos);\n    const referencePixelValue = refVolumePixelData[ijkStartPosition[2] * numPixelsPerSlice +\n        ijkStartPosition[1] * width +\n        ijkStartPosition[0]];\n    const positiveSeedValue = options.positiveSeedValue ?? POSITIVE_SEED_VALUE;\n    const positiveSeedVariance = options.positiveSeedVariance ?? POSITIVE_SEED_VARIANCE;\n    const positiveSeedVarianceValue = Math.abs(referencePixelValue * positiveSeedVariance);\n    const minPositivePixelValue = referencePixelValue - positiveSeedVarianceValue;\n    const maxPositivePixelValue = referencePixelValue + positiveSeedVarianceValue;\n    const neighborsCoordDelta = [\n        [-1, 0, 0],\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 1, 0],\n        [0, 0, -1],\n        [0, 0, 1],\n    ];\n    const startVoxelIndex = ijkStartPosition[2] * numPixelsPerSlice +\n        ijkStartPosition[1] * width +\n        ijkStartPosition[0];\n    labelmap.voxelManager.setAtIndex(startVoxelIndex, positiveSeedValue);\n    const queue = [ijkStartPosition];\n    while (queue.length) {\n        const ijkVoxel = queue.shift();\n        const [x, y, z] = ijkVoxel;\n        for (let i = 0, len = neighborsCoordDelta.length; i < len; i++) {\n            const neighborCoordDelta = neighborsCoordDelta[i];\n            const nx = x + neighborCoordDelta[0];\n            const ny = y + neighborCoordDelta[1];\n            const nz = z + neighborCoordDelta[2];\n            if (nx < 0 ||\n                nx >= width ||\n                ny < 0 ||\n                ny >= height ||\n                nz < 0 ||\n                nz >= numSlices) {\n                continue;\n            }\n            const neighborVoxelIndex = nz * numPixelsPerSlice + ny * width + nx;\n            const neighborPixelValue = refVolumePixelData[neighborVoxelIndex];\n            const neighborLabelmapValue = labelmap.voxelManager.getAtIndex(neighborVoxelIndex);\n            if (neighborLabelmapValue === positiveSeedValue ||\n                neighborPixelValue < minPositivePixelValue ||\n                neighborPixelValue > maxPositivePixelValue) {\n                continue;\n            }\n            labelmap.voxelManager.setAtIndex(neighborVoxelIndex, positiveSeedValue);\n            queue.push([nx, ny, nz]);\n        }\n    }\n}\nfunction _setNegativeSeedValues(subVolume, labelmap, sphereInfo, viewport, options) {\n    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();\n    const [columns, rows, numSlices] = labelmap.dimensions;\n    const numPixelsPerSlice = columns * rows;\n    const { worldVecRowDir, worldVecSliceDir } = csUtils.getVolumeDirectionVectors(labelmap.imageData, viewport.getCamera());\n    const ijkSphereCenter = transformWorldToIndex(subVolume.imageData, sphereInfo.center);\n    const referencePixelValue = subVolPixelData[ijkSphereCenter[2] * columns * rows +\n        ijkSphereCenter[1] * columns +\n        ijkSphereCenter[0]];\n    const negativeSeedVariance = options.negativeSeedVariance ?? NEGATIVE_SEED_VARIANCE;\n    const negativeSeedValue = options?.negativeSeedValue ?? NEGATIVE_SEED_VALUE;\n    const negativeSeedVarianceValue = Math.abs(referencePixelValue * negativeSeedVariance);\n    const minNegativePixelValue = referencePixelValue - negativeSeedVarianceValue;\n    const maxNegativePixelValue = referencePixelValue + negativeSeedVarianceValue;\n    const numCirclePoints = 360;\n    const rotationAngle = (2 * Math.PI) / numCirclePoints;\n    const worldQuat = quat.setAxisAngle(quat.create(), worldVecSliceDir, rotationAngle);\n    const vecRotation = vec3.clone(worldVecRowDir);\n    for (let i = 0; i < numCirclePoints; i++) {\n        const worldCircleBorderPoint = vec3.scaleAndAdd(vec3.create(), sphereInfo.center, vecRotation, sphereInfo.radius);\n        const ijkCircleBorderPoint = transformWorldToIndex(labelmap.imageData, worldCircleBorderPoint);\n        const [x, y, z] = ijkCircleBorderPoint;\n        vec3.transformQuat(vecRotation, vecRotation, worldQuat);\n        if (x < 0 ||\n            x >= columns ||\n            y < 0 ||\n            y >= rows ||\n            z < 0 ||\n            z >= numSlices) {\n            continue;\n        }\n        const offset = x + y * columns + z * numPixelsPerSlice;\n        const pixelValue = subVolPixelData[offset];\n        if (pixelValue < minNegativePixelValue ||\n            pixelValue > maxNegativePixelValue) {\n            labelmap.voxelManager.setAtIndex(offset, negativeSeedValue);\n        }\n    }\n}\nasync function _createAndCacheSegmentationSubVolumeForSphere(subVolume, sphereInfo, viewport, options) {\n    const labelmap = await volumeLoader.createAndCacheDerivedLabelmapVolume(subVolume.volumeId);\n    _setPositiveSeedValues(subVolume, labelmap, sphereInfo, options);\n    _setNegativeSeedValues(subVolume, labelmap, sphereInfo, viewport, options);\n    return labelmap;\n}\nasync function runGrowCutForSphere(referencedVolumeId, sphereInfo, viewport, options) {\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n    const subVolume = _createSubVolumeFromSphere(referencedVolume, sphereInfo, viewport);\n    const labelmap = await _createAndCacheSegmentationSubVolumeForSphere(subVolume, sphereInfo, viewport, options);\n    await run(subVolume.volumeId, labelmap.volumeId);\n    return labelmap;\n}\nexport { runGrowCutForSphere as default, runGrowCutForSphere };\n", "import { volumeLoader, utilities as csUtils } from '@cornerstonejs/core';\nimport { run } from './runGrowCut';\nconst POSITIVE_SEED_VALUE = 254;\nconst NEGATIVE_SEED_VALUE = 255;\nconst NEGATIVE_PIXEL_RANGE = [-Infinity, -995];\nconst POSITIVE_PIXEL_RANGE = [0, 1900];\nfunction _setNegativeSeedValues(subVolume, labelmap, options) {\n    const { negativeSeedValue = NEGATIVE_SEED_VALUE, negativePixelRange = NEGATIVE_PIXEL_RANGE, } = options;\n    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();\n    const [width, height, numSlices] = labelmap.dimensions;\n    const middleSliceIndex = Math.floor(numSlices / 2);\n    const visited = new Array(width * height).fill(false);\n    const sliceOffset = middleSliceIndex * width * height;\n    const bfs = (startX, startY) => {\n        const queue = [[startX, startY]];\n        while (queue.length) {\n            const [x, y] = queue.shift();\n            const slicePixelIndex = y * width + x;\n            if (x < 0 ||\n                x >= width ||\n                y < 0 ||\n                y >= height ||\n                visited[slicePixelIndex]) {\n                continue;\n            }\n            visited[slicePixelIndex] = true;\n            const volumeVoxelIndex = sliceOffset + slicePixelIndex;\n            const volumeVoxelValue = subVolPixelData[volumeVoxelIndex];\n            if (volumeVoxelValue < negativePixelRange[0] ||\n                volumeVoxelValue > negativePixelRange[1]) {\n                continue;\n            }\n            labelmap.voxelManager.setAtIndex(volumeVoxelIndex, negativeSeedValue);\n            queue.push([x - 1, y]);\n            queue.push([x + 1, y]);\n            queue.push([x, y - 1]);\n            queue.push([x, y + 1]);\n        }\n    };\n    const scanLine = (startX, limitX, incX, y) => {\n        for (let x = startX; x !== limitX; x += incX) {\n            const slicePixelIndex = y * width + x;\n            const volumeVoxelIndex = sliceOffset + slicePixelIndex;\n            const volumeVoxelValue = subVolPixelData[volumeVoxelIndex];\n            if (volumeVoxelValue < negativePixelRange[0] ||\n                volumeVoxelValue > negativePixelRange[1]) {\n                break;\n            }\n            if (!visited[slicePixelIndex]) {\n                bfs(x, y);\n            }\n        }\n    };\n    for (let y = 0; y < height; y++) {\n        scanLine(0, width - 1, 1, y);\n        scanLine(width - 1, 0, -1, y);\n    }\n}\nfunction _setPositiveSeedValues(subVolume, labelmap, options) {\n    const { positiveSeedValue = POSITIVE_SEED_VALUE, positivePixelRange = POSITIVE_PIXEL_RANGE, } = options;\n    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();\n    const labelmapData = labelmap.voxelManager.getCompleteScalarDataArray();\n    const [width, height, numSlices] = labelmap.dimensions;\n    const middleSliceIndex = Math.floor(numSlices / 2);\n    const startSliceIndex = Math.max(middleSliceIndex - 3, 0);\n    const stopSliceIndex = Math.max(startSliceIndex + 5, numSlices);\n    const pixelsPerSlice = width * height;\n    for (let z = startSliceIndex; z < stopSliceIndex; z++) {\n        const zOffset = z * pixelsPerSlice;\n        for (let y = 0; y < height; y++) {\n            const yOffset = y * width;\n            for (let x = 0; x < width; x++) {\n                const index = zOffset + yOffset + x;\n                const pixelValue = subVolPixelData[index];\n                const isPositiveValue = pixelValue >= positivePixelRange[0] &&\n                    pixelValue <= positivePixelRange[1];\n                if (isPositiveValue) {\n                    labelmap.voxelManager.setAtIndex(index, positiveSeedValue);\n                }\n            }\n        }\n    }\n}\nasync function _createAndCacheSegmentationSubVolumeForBoundingBox(subVolume, options) {\n    const labelmap = volumeLoader.createAndCacheDerivedLabelmapVolume(subVolume.volumeId);\n    _setPositiveSeedValues(subVolume, labelmap, options);\n    _setNegativeSeedValues(subVolume, labelmap, options);\n    return labelmap;\n}\nasync function runGrowCutForBoundingBox(referencedVolumeId, boundingBoxInfo, options) {\n    const { boundingBox } = boundingBoxInfo;\n    const { ijkTopLeft, ijkBottomRight } = boundingBox;\n    const subVolumeBoundsIJK = {\n        minX: ijkTopLeft[0],\n        maxX: ijkBottomRight[0],\n        minY: ijkTopLeft[1],\n        maxY: ijkBottomRight[1],\n        minZ: ijkTopLeft[2],\n        maxZ: ijkBottomRight[2],\n    };\n    const subVolume = csUtils.createSubVolume(referencedVolumeId, subVolumeBoundsIJK, {\n        targetBuffer: {\n            type: 'Float32Array',\n        },\n    });\n    const labelmap = await _createAndCacheSegmentationSubVolumeForBoundingBox(subVolume, options);\n    await run(subVolume.volumeId, labelmap.volumeId);\n    return labelmap;\n}\nexport { runGrowCutForBoundingBox as default, runGrowCutForBoundingBox };\n", "export const POSITIVE_SEED_LABEL = 254;\nexport const NEGATIVE_SEED_LABEL = 255;\nexport const DEFAULT_NEIGHBORHOOD_RADIUS = 1;\nexport const DEFAULT_POSITIVE_STD_DEV_MULTIPLIER = 1.8;\nexport const DEFAULT_NEGATIVE_STD_DEV_MULTIPLIER = 3.2;\nexport const DEFAULT_NEGATIVE_SEED_MARGIN = 30;\nexport const DEFAULT_NEGATIVE_SEEDS_COUNT = 70;\nexport const MAX_NEGATIVE_SEED_ATTEMPTS_MULTIPLIER = 50;\n", "import { utilities as csUtils, cache, volumeLoader } from '@cornerstonejs/core';\nimport { run } from './runGrowCut';\nimport { POSITIVE_SEED_LABEL, NEGATIVE_SEED_LABEL, DEFAULT_NEIGHBORHOOD_RADIUS, DEFAULT_POSITIVE_STD_DEV_MULTIPLIER, DEFAULT_NEGATIVE_STD_DEV_MULTIPLIER, DEFAULT_NEGATIVE_SEED_MARGIN, DEFAULT_NEGATIVE_SEEDS_COUNT, MAX_NEGATIVE_SEED_ATTEMPTS_MULTIPLIER, } from './constants';\nconst { transformWorldToIndex } = csUtils;\nconst MAX_POSITIVE_SEEDS = 100000;\nfunction calculateGrowCutSeeds(referencedVolume, worldPosition, options) {\n    const { dimensions, imageData: refImageData } = referencedVolume;\n    const [width, height, numSlices] = dimensions;\n    const referenceVolumeVoxelManager = referencedVolume.voxelManager;\n    const scalarData = referenceVolumeVoxelManager.getCompleteScalarDataArray();\n    const numPixelsPerSlice = width * height;\n    const neighborhoodRadius = options?.initialNeighborhoodRadius ?? DEFAULT_NEIGHBORHOOD_RADIUS;\n    const positiveK = options?.positiveStdDevMultiplier ?? DEFAULT_POSITIVE_STD_DEV_MULTIPLIER;\n    const negativeK = options?.negativeStdDevMultiplier ?? DEFAULT_NEGATIVE_STD_DEV_MULTIPLIER;\n    const negativeSeedMargin = options?.negativeSeedMargin ?? DEFAULT_NEGATIVE_SEED_MARGIN;\n    const negativeSeedsTargetPatches = options?.negativeSeedsTargetPatches ?? DEFAULT_NEGATIVE_SEEDS_COUNT;\n    const ijkStart = transformWorldToIndex(refImageData, worldPosition).map(Math.round);\n    const startIndex = referenceVolumeVoxelManager.toIndex(ijkStart);\n    if (ijkStart[0] < 0 ||\n        ijkStart[0] >= width ||\n        ijkStart[1] < 0 ||\n        ijkStart[1] >= height ||\n        ijkStart[2] < 0 ||\n        ijkStart[2] >= numSlices) {\n        console.warn('Click position is outside volume bounds.');\n        return null;\n    }\n    const initialStats = csUtils.calculateNeighborhoodStats(scalarData, dimensions, ijkStart, neighborhoodRadius);\n    if (initialStats.count === 0) {\n        initialStats.mean = scalarData[startIndex];\n        initialStats.stdDev = 0;\n    }\n    const positiveIntensityMin = initialStats.mean - positiveK * initialStats.stdDev;\n    const positiveIntensityMax = initialStats.mean + positiveK * initialStats.stdDev;\n    const neighborsCoordDelta = [\n        [-1, 0, 0],\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 1, 0],\n        [0, 0, -1],\n        [0, 0, 1],\n    ];\n    let minX = Infinity, minY = Infinity, minZ = Infinity;\n    let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;\n    const positiveSeedIndices = new Set();\n    const queue = [];\n    const startValue = scalarData[startIndex];\n    if (startValue >= positiveIntensityMin &&\n        startValue <= positiveIntensityMax) {\n        positiveSeedIndices.add(startIndex);\n        queue.push(ijkStart);\n        minX = maxX = ijkStart[0];\n        minY = maxY = ijkStart[1];\n        minZ = maxZ = ijkStart[2];\n    }\n    else {\n        console.warn('Clicked voxel intensity is outside the calculated positive range. No positive seeds generated.');\n        return { positiveSeedIndices: new Set(), negativeSeedIndices: new Set() };\n    }\n    let currentQueueIndex = 0;\n    while (currentQueueIndex < queue.length &&\n        positiveSeedIndices.size < MAX_POSITIVE_SEEDS) {\n        const [x, y, z] = queue[currentQueueIndex++];\n        minX = Math.min(x, minX);\n        minY = Math.min(y, minY);\n        minZ = Math.min(z, minZ);\n        maxX = Math.max(x, maxX);\n        maxY = Math.max(y, maxY);\n        maxZ = Math.max(z, maxZ);\n        for (let i = 0; i < neighborsCoordDelta.length; i++) {\n            const [dx, dy, dz] = neighborsCoordDelta[i];\n            const nx = x + dx;\n            const ny = y + dy;\n            const nz = z + dz;\n            if (nx < 0 ||\n                nx >= width ||\n                ny < 0 ||\n                ny >= height ||\n                nz < 0 ||\n                nz >= numSlices) {\n                continue;\n            }\n            const neighborIndex = nz * numPixelsPerSlice + ny * width + nx;\n            if (positiveSeedIndices.has(neighborIndex)) {\n                continue;\n            }\n            const neighborValue = scalarData[neighborIndex];\n            if (neighborValue >= positiveIntensityMin &&\n                neighborValue <= positiveIntensityMax) {\n                positiveSeedIndices.add(neighborIndex);\n                if (positiveSeedIndices.size < MAX_POSITIVE_SEEDS) {\n                    queue.push([nx, ny, nz]);\n                }\n            }\n        }\n    }\n    if (positiveSeedIndices.size >= MAX_POSITIVE_SEEDS) {\n        console.debug(`Reached maximum number of positive seeds (${MAX_POSITIVE_SEEDS}). Stopping BFS.`);\n    }\n    if (positiveSeedIndices.size === 0) {\n        console.warn('No positive seeds found after BFS.');\n        return { positiveSeedIndices: new Set(), negativeSeedIndices: new Set() };\n    }\n    let positiveSum = 0;\n    let positiveSumSq = 0;\n    positiveSeedIndices.forEach((index) => {\n        const value = scalarData[index];\n        positiveSum += value;\n        positiveSumSq += value * value;\n    });\n    const positiveCount = positiveSeedIndices.size;\n    const positiveMean = positiveSum / positiveCount;\n    const positiveVariance = positiveSumSq / positiveCount - positiveMean * positiveMean;\n    const positiveStdDev = Math.sqrt(Math.max(0, positiveVariance));\n    const negativeDiffThreshold = negativeK * positiveStdDev;\n    const minXm = Math.max(0, minX - negativeSeedMargin);\n    const minYm = Math.max(0, minY - negativeSeedMargin);\n    const minZm = Math.max(0, minZ - negativeSeedMargin);\n    const maxXm = Math.min(width - 1, maxX + negativeSeedMargin);\n    const maxYm = Math.min(height - 1, maxY + negativeSeedMargin);\n    const maxZm = Math.min(numSlices - 1, maxZ + negativeSeedMargin);\n    const negativeSeedIndices = new Set();\n    let attempts = 0;\n    let patchesAdded = 0;\n    const maxAttempts = negativeSeedsTargetPatches * MAX_NEGATIVE_SEED_ATTEMPTS_MULTIPLIER;\n    while (patchesAdded < negativeSeedsTargetPatches && attempts < maxAttempts) {\n        attempts++;\n        const rx = Math.floor(Math.random() * (maxXm - minXm + 1) + minXm);\n        const ry = Math.floor(Math.random() * (maxYm - minYm + 1) + minYm);\n        const rz = Math.floor(Math.random() * (maxZm - minZm + 1) + minZm);\n        const centerIndex = rz * numPixelsPerSlice + ry * width + rx;\n        if (positiveSeedIndices.has(centerIndex) ||\n            negativeSeedIndices.has(centerIndex)) {\n            continue;\n        }\n        const centerValue = scalarData[centerIndex];\n        if (Math.abs(centerValue - positiveMean) > negativeDiffThreshold) {\n            let patchContributed = false;\n            for (let dy = -1; dy <= 1; dy++) {\n                const ny = ry + dy;\n                if (ny < 0 || ny >= height) {\n                    continue;\n                }\n                for (let dx = -1; dx <= 1; dx++) {\n                    const nx = rx + dx;\n                    if (nx < 0 || nx >= width) {\n                        continue;\n                    }\n                    const neighborIndex = rz * numPixelsPerSlice + ny * width + nx;\n                    if (positiveSeedIndices.has(neighborIndex) ||\n                        negativeSeedIndices.has(neighborIndex)) {\n                        continue;\n                    }\n                    negativeSeedIndices.add(neighborIndex);\n                    patchContributed = true;\n                }\n            }\n            if (patchContributed) {\n                patchesAdded++;\n            }\n        }\n    }\n    if (negativeSeedIndices.size === 0) {\n        console.warn('Could not find any negative seeds. GrowCut might fail or produce poor results.');\n    }\n    console.debug('positiveSeedIndices', positiveSeedIndices.size);\n    console.debug('negativeSeedIndices', negativeSeedIndices.size);\n    return { positiveSeedIndices, negativeSeedIndices };\n}\nasync function runOneClickGrowCut({ referencedVolumeId, worldPosition, options, }) {\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n    const labelmap = volumeLoader.createAndCacheDerivedLabelmapVolume(referencedVolumeId);\n    labelmap.voxelManager.forEach(({ index, value }) => {\n        if (value !== 0) {\n            labelmap.voxelManager.setAtIndex(index, 0);\n        }\n    });\n    const seeds = options.seeds ??\n        calculateGrowCutSeeds(referencedVolume, worldPosition, options);\n    const positiveSeedLabel = options?.positiveSeedValue ?? POSITIVE_SEED_LABEL;\n    const negativeSeedLabel = options?.negativeSeedValue ?? NEGATIVE_SEED_LABEL;\n    if (!seeds) {\n        return null;\n    }\n    const { positiveSeedIndices, negativeSeedIndices } = seeds;\n    if (positiveSeedIndices.size < 10 ||\n        positiveSeedIndices.size > MAX_POSITIVE_SEEDS ||\n        negativeSeedIndices.size < 10) {\n        console.warn('Not enough seeds found. GrowCut might fail or produce poor results.');\n        return labelmap;\n    }\n    positiveSeedIndices.forEach((index) => {\n        labelmap.voxelManager.setAtIndex(index, positiveSeedLabel);\n    });\n    negativeSeedIndices.forEach((index) => {\n        labelmap.voxelManager.setAtIndex(index, negativeSeedLabel);\n    });\n    await run(referencedVolumeId, labelmap.volumeId, options);\n    return labelmap;\n}\nexport { runOneClickGrowCut as default, runOneClickGrowCut, calculateGrowCutSeeds, };\n", "import { getToolGroupForViewport } from '../../store/ToolGroupManager';\nimport { invalidateBrushCursor } from '../../utilities/segmentation/invalidateBrushCursor';\nimport { getSegmentation } from './getSegmentation';\nimport { getViewportIdsWithSegmentation } from './getViewportIdsWithSegmentation';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nimport { getActiveSegmentIndex } from './getActiveSegmentIndex';\nimport { getSegmentationRepresentations } from './getSegmentationRepresentation';\nfunction setActiveSegmentIndex(segmentationId, segmentIndex) {\n    const segmentation = getSegmentation(segmentationId);\n    if (typeof segmentIndex === 'string') {\n        console.warn('segmentIndex is a string, converting to number');\n        segmentIndex = Number(segmentIndex);\n    }\n    Object.values(segmentation.segments).forEach((segment) => {\n        segment.active = false;\n    });\n    if (!segmentation.segments[segmentIndex]) {\n        segmentation.segments[segmentIndex] = {\n            segmentIndex,\n            label: '',\n            locked: false,\n            cachedStats: {},\n            active: false,\n        };\n    }\n    if (segmentation.segments[segmentIndex].active !== true) {\n        segmentation.segments[segmentIndex].active = true;\n        triggerSegmentationModified(segmentationId);\n    }\n    const viewportIds = getViewportIdsWithSegmentation(segmentationId);\n    viewportIds.forEach((viewportId) => {\n        const representations = getSegmentationRepresentations(viewportId, {\n            segmentationId,\n        });\n        representations.forEach((representation) => {\n            if (!representation.segments[segmentIndex]) {\n                representation.segments[segmentIndex] = {\n                    visible: true,\n                };\n            }\n        });\n    });\n    viewportIds.forEach((viewportId) => {\n        const toolGroup = getToolGroupForViewport(viewportId);\n        invalidateBrushCursor(toolGroup.id);\n    });\n}\nexport { setActiveSegmentIndex, getActiveSegmentIndex };\n", "import CORNERSTONE_COLOR_LUT from '../../constants/COLOR_LUT';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { SegmentationRepresentations } from '../../enums';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nimport { addColorLUT } from './addColorLUT';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { getActiveSegmentIndex, setActiveSegmentIndex } from './segmentIndex';\nfunction internalAddSegmentationRepresentation(viewportId, representationInput) {\n    const { segmentationId, config } = representationInput;\n    const renderingConfig = {\n        colorLUTIndex: getColorLUTIndex(config),\n        ...config,\n    };\n    defaultSegmentationStateManager.addSegmentationRepresentation(viewportId, segmentationId, representationInput.type, renderingConfig);\n    if (!getActiveSegmentIndex(segmentationId)) {\n        let firstSegmentIndex = 1;\n        const segmentation = defaultSegmentationStateManager.getSegmentation(segmentationId);\n        if (segmentation) {\n            const segmentKeys = Object.keys(segmentation.segments);\n            if (segmentKeys.length > 0) {\n                firstSegmentIndex = segmentKeys.map((k) => Number(k)).sort()[0];\n            }\n        }\n        setActiveSegmentIndex(segmentationId, firstSegmentIndex);\n    }\n    if (representationInput.type === SegmentationRepresentations.Contour) {\n        triggerAnnotationRenderForViewportIds([viewportId]);\n    }\n    triggerSegmentationModified(segmentationId);\n}\nfunction getColorLUTIndex(config) {\n    const { colorLUTOrIndex } = config || {};\n    if (colorLUTOrIndex === undefined) {\n        const index = addColorLUT(JSON.parse(JSON.stringify(CORNERSTONE_COLOR_LUT)));\n        return index;\n    }\n    if (typeof colorLUTOrIndex === 'number') {\n        return colorLUTOrIndex;\n    }\n    if (Array.isArray(colorLUTOrIndex) &&\n        colorLUTOrIndex.every((item) => Array.isArray(item) && item.length === 4)) {\n        const index = addColorLUT(colorLUTOrIndex);\n        return index;\n    }\n    const index = addColorLUT(JSON.parse(JSON.stringify(CORNERSTONE_COLOR_LUT)));\n    return index;\n}\nexport { internalAddSegmentationRepresentation };\n", "import { SegmentationRepresentations } from '../../enums';\nimport { internalAddSegmentationRepresentation } from './internalAddSegmentationRepresentation';\nexport function addSegmentationRepresentations(viewportId, segmentationInputArray) {\n    segmentationInputArray.map((segmentationInput) => {\n        return internalAddSegmentationRepresentation(viewportId, segmentationInput);\n    });\n}\nfunction addContourRepresentationToViewport(viewportId, contourInputArray) {\n    return addSegmentationRepresentations(viewportId, contourInputArray.map((input) => ({\n        ...input,\n        type: SegmentationRepresentations.Contour,\n    })));\n}\nfunction addContourRepresentationToViewportMap(viewportInputMap) {\n    const results = {};\n    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {\n        results[viewportId] = addContourRepresentationToViewport(viewportId, inputArray);\n    }\n    return results;\n}\nfunction addLabelmapRepresentationToViewport(viewportId, labelmapInputArray) {\n    return addSegmentationRepresentations(viewportId, labelmapInputArray.map((input) => ({\n        ...input,\n        type: SegmentationRepresentations.Labelmap,\n    })));\n}\nfunction addLabelmapRepresentationToViewportMap(viewportInputMap) {\n    const results = {};\n    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {\n        results[viewportId] = addLabelmapRepresentationToViewport(viewportId, inputArray.map((input) => ({\n            ...input,\n            type: SegmentationRepresentations.Labelmap,\n        })));\n    }\n}\nfunction addSurfaceRepresentationToViewport(viewportId, surfaceInputArray) {\n    return addSegmentationRepresentations(viewportId, surfaceInputArray.map((input) => ({\n        ...input,\n        type: SegmentationRepresentations.Surface,\n    })));\n}\nfunction addSurfaceRepresentationToViewportMap(viewportInputMap) {\n    const results = {};\n    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {\n        results[viewportId] = addSurfaceRepresentationToViewport(viewportId, inputArray);\n    }\n    return results;\n}\nexport { addContourRepresentationToViewport, addLabelmapRepresentationToViewport, addSurfaceRepresentationToViewport, addContourRepresentationToViewportMap, addLabelmapRepresentationToViewportMap, addSurfaceRepresentationToViewportMap, };\n", "import { cache, eventTarget } from '@cornerstonejs/core';\nimport { Events, SegmentationRepresentations } from '../../../enums';\nimport { getSegmentation } from '../getSegmentation';\nimport { triggerSegmentationDataModified } from '../triggerSegmentationEvents';\nimport { addSegmentationRepresentations } from '../addSegmentationRepresentationsToViewport';\nexport async function updateStackSegmentationState({ segmentationId, viewportId, imageIds, options, }) {\n    const segmentation = getSegmentation(segmentationId);\n    if (options?.removeOriginal) {\n        const data = segmentation.representationData\n            .Labelmap;\n        if (cache.getVolume(data.volumeId)) {\n            cache.removeVolumeLoadObject(data.volumeId);\n        }\n        segmentation.representationData.Labelmap = {\n            imageIds,\n        };\n    }\n    else {\n        segmentation.representationData.Labelmap = {\n            ...segmentation.representationData.Labelmap,\n            imageIds,\n        };\n    }\n    await addSegmentationRepresentations(viewportId, [\n        {\n            segmentationId,\n            type: SegmentationRepresentations.Labelmap,\n        },\n    ]);\n    eventTarget.addEventListenerOnce(Events.SEGMENTATION_RENDERED, () => triggerSegmentationDataModified(segmentationId));\n}\n", "import { cache } from '@cornerstonejs/core';\nimport { getSegmentation } from '../getSegmentation';\nimport { updateStackSegmentationState } from '../helpers/updateStackSegmentationState';\nexport async function computeStackLabelmapFromVolume({ volumeId, }) {\n    const segmentationVolume = cache.getVolume(volumeId);\n    return { imageIds: segmentationVolume.imageIds };\n}\nexport function convertVolumeToStackLabelmap({ segmentationId, options, }) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        return;\n    }\n    const { volumeId } = segmentation.representationData\n        .Labelmap;\n    const segmentationVolume = cache.getVolume(volumeId);\n    return updateStackSegmentationState({\n        segmentationId,\n        viewportId: options.viewportId,\n        imageIds: segmentationVolume.imageIds,\n        options,\n    });\n}\n", "import { internalComputeVolumeLabelmapFromStack } from '../SegmentationStateManager';\nexport async function computeVolumeLabelmapFromStack(args) {\n    return internalComputeVolumeLabelmapFromStack(args);\n}\n", "import { getWebWorkerManager } from '@cornerstonejs/core';\nimport { WorkerTypes } from '../../enums';\nimport { registerComputeWorker } from '../registerComputeWorker';\nimport { triggerWorkerProgress, getSegmentationDataForWorker, prepareVolumeStrategyDataForWorker, prepareStackDataForWorker, } from './utilsForWorker';\nexport async function getSegmentLargestBidirectional({ segmentationId, segmentIndices, mode = 'individual', }) {\n    registerComputeWorker();\n    triggerWorkerProgress(WorkerTypes.COMPUTE_LARGEST_BIDIRECTIONAL, 0);\n    const segData = getSegmentationDataForWorker(segmentationId, segmentIndices);\n    if (!segData) {\n        return;\n    }\n    const { operationData, segImageIds, reconstructableVolume, indices } = segData;\n    const bidirectionalData = reconstructableVolume\n        ? await calculateVolumeBidirectional({\n            operationData,\n            indices,\n            mode,\n        })\n        : await calculateStackBidirectional({\n            segImageIds,\n            indices,\n            mode,\n        });\n    triggerWorkerProgress(WorkerTypes.COMPUTE_LARGEST_BIDIRECTIONAL, 100);\n    return bidirectionalData;\n}\nasync function calculateVolumeBidirectional({ operationData, indices, mode }) {\n    const strategyData = prepareVolumeStrategyDataForWorker(operationData);\n    const { segmentationVoxelManager, segmentationImageData } = strategyData;\n    const segmentationScalarData = segmentationVoxelManager.getCompleteScalarDataArray();\n    const segmentationInfo = {\n        scalarData: segmentationScalarData,\n        dimensions: segmentationImageData.getDimensions(),\n        spacing: segmentationImageData.getSpacing(),\n        origin: segmentationImageData.getOrigin(),\n        direction: segmentationImageData.getDirection(),\n    };\n    const bidirectionalData = await getWebWorkerManager().executeTask('compute', 'getSegmentLargestBidirectionalInternal', {\n        segmentationInfo,\n        indices,\n        mode,\n    });\n    return bidirectionalData;\n}\nasync function calculateStackBidirectional({ segImageIds, indices, mode }) {\n    const { segmentationInfo } = prepareStackDataForWorker(segImageIds);\n    const bidirectionalData = await getWebWorkerManager().executeTask('compute', 'getSegmentLargestBidirectionalInternal', {\n        segmentationInfo,\n        indices,\n        mode,\n        isStack: true,\n    });\n    return bidirectionalData;\n}\n", "import { cache } from '@cornerstonejs/core';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport getOrCreateImageVolume from './getOrCreateImageVolume';\nexport function getReferenceVolumeForSegmentation(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        return null;\n    }\n    let referenceImageIds;\n    const labelmap = segmentation.representationData.Labelmap;\n    if ('imageIds' in labelmap) {\n        const { imageIds } = labelmap;\n        const firstImage = cache.getImage(imageIds[0]);\n        const volumeInfo = cache.getVolumeContainingImageId(firstImage.referencedImageId);\n        if (volumeInfo?.volume) {\n            return volumeInfo.volume;\n        }\n        referenceImageIds = imageIds.map((imageId) => cache.getImage(imageId).referencedImageId);\n    }\n    else if ('volumeId' in labelmap) {\n        const { volumeId, referencedVolumeId } = labelmap;\n        if (referencedVolumeId) {\n            const refVolume = cache.getVolume(referencedVolumeId);\n            if (refVolume) {\n                return refVolume;\n            }\n        }\n        const segVolume = cache.getVolume(volumeId);\n        if (segVolume) {\n            referenceImageIds = segVolume.imageIds.map((imageId) => cache.getImage(imageId).referencedImageId);\n        }\n    }\n    return getOrCreateImageVolume(referenceImageIds);\n}\n", "import { utilities, getWebWorkerManager } from '@cornerstonejs/core';\nimport { triggerWorkerProgress } from './utilsForWorker';\nimport { WorkerTypes } from '../../enums';\nimport { registerComputeWorker } from '../registerComputeWorker';\nimport createMergedLabelmapForIndex from './createMergedLabelmapForIndex';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport getOrCreateSegmentationVolume from './getOrCreateSegmentationVolume';\nimport { getReferenceVolumeForSegmentation } from './getReferenceVolumeForSegmentation';\nasync function computeMetabolicStats({ segmentationIds, segmentIndex, }) {\n    registerComputeWorker();\n    triggerWorkerProgress(WorkerTypes.COMPUTE_STATISTICS, 0);\n    const segmentation = getSegmentation(segmentationIds[0]);\n    const { imageIds: segImageIds } = segmentation.representationData\n        .Labelmap;\n    const isValidVolume = utilities.isValidVolume(segImageIds);\n    if (!isValidVolume) {\n        throw new Error('Invalid volume - TMTV cannot be calculated');\n    }\n    const stats = await calculateForVolume({\n        segmentationIds,\n        segmentIndex,\n    });\n    return stats;\n}\nasync function calculateForVolume({ segmentationIds, segmentIndex }) {\n    const labelmapVolumes = segmentationIds.map((id) => {\n        return getOrCreateSegmentationVolume(id);\n    });\n    const mergedLabelmap = createMergedLabelmapForIndex(labelmapVolumes, segmentIndex);\n    if (!mergedLabelmap) {\n        throw new Error('Invalid volume - TMTV cannot be calculated');\n    }\n    const { imageData, dimensions, direction, origin, voxelManager } = mergedLabelmap;\n    const spacing = imageData.getSpacing();\n    const segmentationScalarData = voxelManager.getCompleteScalarDataArray();\n    const segmentationInfo = {\n        scalarData: segmentationScalarData,\n        dimensions,\n        spacing,\n        origin,\n        direction,\n    };\n    const referenceVolume = getReferenceVolumeForSegmentation(segmentationIds[0]);\n    const imageInfo = {\n        dimensions: referenceVolume.dimensions,\n        spacing: referenceVolume.spacing,\n        origin: referenceVolume.origin,\n        direction: referenceVolume.direction,\n        scalarData: referenceVolume.voxelManager.getCompleteScalarDataArray(),\n    };\n    if (imageInfo.scalarData.length === 0 ||\n        segmentationInfo.scalarData.length === 0) {\n        return {\n            [segmentIndex]: {\n                name: 'TMTV',\n                value: 0,\n            },\n        };\n    }\n    const stats = await getWebWorkerManager().executeTask('compute', 'computeMetabolicStats', {\n        segmentationInfo,\n        imageInfo,\n    });\n    triggerWorkerProgress(WorkerTypes.COMPUTE_STATISTICS, 100);\n    return stats;\n}\nexport { computeMetabolicStats };\n", "import getOrientationStringLPS from './getOrientationStringLPS';\nimport invertOrientationStringLPS from './invertOrientationStringLPS';\nexport { getOrientationStringLPS, invertOrientationStringLPS };\n", "export default function getOrientationStringLPS(vector) {\n    let orientation = '';\n    const orientationX = vector[0] < 0 ? 'R' : 'L';\n    const orientationY = vector[1] < 0 ? 'A' : 'P';\n    const orientationZ = vector[2] < 0 ? 'F' : 'H';\n    const abs = [Math.abs(vector[0]), Math.abs(vector[1]), Math.abs(vector[2])];\n    const MIN = 0.0001;\n    for (let i = 0; i < 3; i++) {\n        if (abs[0] > MIN && abs[0] > abs[1] && abs[0] > abs[2]) {\n            orientation += orientationX;\n            abs[0] = 0;\n        }\n        else if (abs[1] > MIN && abs[1] > abs[0] && abs[1] > abs[2]) {\n            orientation += orientationY;\n            abs[1] = 0;\n        }\n        else if (abs[2] > MIN && abs[2] > abs[0] && abs[2] > abs[1]) {\n            orientation += orientationZ;\n            abs[2] = 0;\n        }\n        else if (abs[0] > MIN && abs[1] > MIN && abs[0] === abs[1]) {\n            orientation += orientationX + orientationY;\n            abs[0] = 0;\n            abs[1] = 0;\n        }\n        else if (abs[0] > MIN && abs[2] > MIN && abs[0] === abs[2]) {\n            orientation += orientationX + orientationZ;\n            abs[0] = 0;\n            abs[2] = 0;\n        }\n        else if (abs[1] > MIN && abs[2] > MIN && abs[1] === abs[2]) {\n            orientation += orientationY + orientationZ;\n            abs[1] = 0;\n            abs[2] = 0;\n        }\n        else {\n            break;\n        }\n    }\n    return orientation;\n}\n", "export default function invertOrientationStringLPS(orientationString) {\n    let inverted = orientationString.replace('H', 'f');\n    inverted = inverted.replace('F', 'h');\n    inverted = inverted.replace('R', 'l');\n    inverted = inverted.replace('L', 'r');\n    inverted = inverted.replace('A', 'p');\n    inverted = inverted.replace('P', 'a');\n    inverted = inverted.toUpperCase();\n    return inverted;\n}\n", "import { playClip, stopClip } from './playClip';\nimport Events from './events';\nimport { getToolState, addToolState } from './state';\nexport { playClip, stopClip, Events, getToolState, addToolState };\n", "var Events;\n(function (Events) {\n    Events[\"CLIP_STOPPED\"] = \"CORNERSTONE_CINE_TOOL_STOPPED\";\n    Events[\"CLIP_STARTED\"] = \"CORNERSTONE_CINE_TOOL_STARTED\";\n})(Events || (Events = {}));\nexport default Events;\n", "import { getEnabledElement } from '@cornerstonejs/core';\nconst state = {};\nfunction addToolState(element, data) {\n    const enabledElement = getEnabledElement(element);\n    const { viewportId } = enabledElement;\n    state[viewportId] = data;\n}\nfunction getToolState(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewportId } = enabledElement;\n    return state[viewportId];\n}\nfunction getToolStateByViewportId(viewportId) {\n    return state[viewportId];\n}\nexport { addToolState, getToolState, getToolStateByViewportId };\n", "import { glMatrix, vec3 } from 'gl-matrix';\nimport { utilities as csUtils, getEnabledElement, StackViewport, VideoViewport, VolumeViewport, cache, BaseVolumeViewport, Enums, } from '@cornerstonejs/core';\nimport CINE_EVENTS from './events';\nimport { addToolState, getToolState, getToolStateByViewportId } from './state';\nconst { ViewportStatus } = Enums;\nconst { triggerEvent } = csUtils;\nconst debounced = true;\nconst dynamicVolumesPlayingMap = new Map();\nfunction playClip(element, playClipOptions) {\n    let playClipTimeouts;\n    let playClipIsTimeVarying;\n    if (element === undefined) {\n        throw new Error('playClip: element must not be undefined');\n    }\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        throw new Error('playClip: element must be a valid Cornerstone enabled element');\n    }\n    if (!playClipOptions) {\n        playClipOptions = {};\n    }\n    playClipOptions.dynamicCineEnabled =\n        playClipOptions.dynamicCineEnabled ?? true;\n    const { viewport } = enabledElement;\n    const playClipContext = _createCinePlayContext(viewport, playClipOptions);\n    let playClipData = getToolState(element);\n    const isDynamicCinePlaying = playClipOptions.dynamicCineEnabled;\n    if (isDynamicCinePlaying) {\n        _stopDynamicVolumeCine(element);\n    }\n    if (!playClipData) {\n        playClipData = {\n            intervalId: undefined,\n            framesPerSecond: 30,\n            lastFrameTimeStamp: undefined,\n            ignoreFrameTimeVector: false,\n            usingFrameTimeVector: false,\n            frameTimeVector: playClipOptions.frameTimeVector ?? undefined,\n            speed: playClipOptions.frameTimeVectorSpeedMultiplier ?? 1,\n            reverse: playClipOptions.reverse ?? false,\n            loop: playClipOptions.loop ?? true,\n            bounce: playClipOptions.bounce ?? false,\n        };\n        addToolState(element, playClipData);\n    }\n    else {\n        _stopClip(element, {\n            stopDynamicCine: !isDynamicCinePlaying,\n            viewportId: viewport.id,\n        });\n    }\n    playClipData.dynamicCineEnabled = playClipOptions.dynamicCineEnabled;\n    if (playClipOptions.framesPerSecond < 0 ||\n        playClipOptions.framesPerSecond > 0) {\n        playClipData.framesPerSecond = Number(playClipOptions.framesPerSecond);\n        playClipData.reverse = playClipData.framesPerSecond < 0;\n        playClipData.ignoreFrameTimeVector = true;\n    }\n    if (playClipData.ignoreFrameTimeVector !== true &&\n        playClipData.frameTimeVector &&\n        playClipData.frameTimeVector.length === playClipContext.numScrollSteps &&\n        playClipContext.frameTimeVectorEnabled) {\n        const { timeouts, isTimeVarying } = _getPlayClipTimeouts(playClipData.frameTimeVector, playClipData.speed);\n        playClipTimeouts = timeouts;\n        playClipIsTimeVarying = isTimeVarying;\n    }\n    if (playClipOptions.bounce !== undefined) {\n        playClipData.bounce = playClipOptions.bounce;\n    }\n    const playClipAction = () => {\n        const { numScrollSteps, currentStepIndex } = playClipContext;\n        let newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);\n        const outOfRange = newStepIndex < 0 || newStepIndex >= numScrollSteps;\n        if (outOfRange) {\n            if (playClipData.bounce) {\n                playClipData.reverse = !playClipData.reverse;\n                newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);\n                newStepIndex = Math.max(0, Math.min(numScrollSteps - 1, newStepIndex));\n            }\n            else if (!playClipData.loop) {\n                _stopClip(element, {\n                    stopDynamicCine: !isDynamicCinePlaying,\n                    viewportId: viewport.id,\n                });\n                triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, { element });\n                return;\n            }\n            else {\n                newStepIndex = playClipData.reverse ? numScrollSteps - 1 : 0;\n            }\n        }\n        const delta = newStepIndex - currentStepIndex;\n        if (delta) {\n            try {\n                playClipContext.scroll(delta);\n            }\n            catch (e) {\n                console.warn('Play clip not scrolling', e);\n                _stopClipWithData(playClipData);\n                triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, { element });\n            }\n        }\n    };\n    if (isDynamicCinePlaying) {\n        const volume = _getVolumeFromViewport(viewport);\n        if (volume) {\n            dynamicVolumesPlayingMap.set(volume.volumeId, element);\n        }\n    }\n    if (playClipContext.play) {\n        playClipData.framesPerSecond = playClipContext.play(playClipOptions.framesPerSecond);\n    }\n    else if (playClipTimeouts &&\n        playClipTimeouts.length > 0 &&\n        playClipIsTimeVarying) {\n        playClipData.usingFrameTimeVector = true;\n        playClipData.intervalId = window.setTimeout(function playClipTimeoutHandler() {\n            playClipData.intervalId = window.setTimeout(playClipTimeoutHandler, playClipTimeouts[playClipContext.currentStepIndex]);\n            playClipAction();\n        }, 0);\n    }\n    else {\n        playClipData.usingFrameTimeVector = false;\n        playClipData.intervalId = window.setInterval(playClipAction, 1000 / Math.abs(playClipData.framesPerSecond));\n    }\n    const eventDetail = {\n        element,\n    };\n    triggerEvent(element, CINE_EVENTS.CLIP_STARTED, eventDetail);\n}\nfunction stopClip(element, options = {}) {\n    _stopClip(element, {\n        stopDynamicCine: true,\n        ...options,\n    });\n}\nfunction _stopClip(element, options = { stopDynamicCine: true, viewportId: undefined }) {\n    const { stopDynamicCine, viewportId } = options;\n    const enabledElement = getEnabledElement(element);\n    let toolState;\n    const viewport = enabledElement?.viewport;\n    if (!enabledElement) {\n        if (viewportId) {\n            toolState = getToolStateByViewportId(viewportId);\n        }\n        else {\n            return;\n        }\n    }\n    else {\n        const { viewport } = enabledElement;\n        toolState = getToolState(viewport.element);\n    }\n    if (toolState) {\n        _stopClipWithData(toolState);\n    }\n    if (viewport instanceof VideoViewport) {\n        viewport.pause();\n    }\n    else if (stopDynamicCine && viewport instanceof BaseVolumeViewport) {\n        _stopDynamicVolumeCine(element);\n    }\n}\nfunction _stopDynamicVolumeCine(element) {\n    const { viewport } = getEnabledElement(element);\n    if (viewport instanceof VolumeViewport) {\n        const volume = _getVolumeFromViewport(viewport);\n        if (volume?.isDynamicVolume()) {\n            const dynamicCineElement = dynamicVolumesPlayingMap.get(volume.volumeId);\n            dynamicVolumesPlayingMap.delete(volume.volumeId);\n            if (dynamicCineElement && dynamicCineElement !== element) {\n                stopClip(dynamicCineElement);\n            }\n        }\n    }\n}\nfunction _getPlayClipTimeouts(vector, speed) {\n    let i;\n    let sample;\n    let delay;\n    let sum = 0;\n    const limit = vector.length;\n    const timeouts = [];\n    let isTimeVarying = false;\n    if (typeof speed !== 'number' || speed <= 0) {\n        speed = 1;\n    }\n    for (i = 1; i < limit; i++) {\n        delay = (Number(vector[i]) / speed) | 0;\n        timeouts.push(delay);\n        if (i === 1) {\n            sample = delay;\n        }\n        else if (delay !== sample) {\n            isTimeVarying = true;\n        }\n        sum += delay;\n    }\n    if (timeouts.length > 0) {\n        if (isTimeVarying) {\n            delay = (sum / timeouts.length) | 0;\n        }\n        else {\n            delay = timeouts[0];\n        }\n        timeouts.push(delay);\n    }\n    return { timeouts, isTimeVarying };\n}\nfunction _stopClipWithData(playClipData) {\n    const id = playClipData.intervalId;\n    if (typeof id !== 'undefined') {\n        playClipData.intervalId = undefined;\n        if (playClipData.usingFrameTimeVector) {\n            clearTimeout(id);\n        }\n        else {\n            clearInterval(id);\n        }\n    }\n}\nfunction _getVolumeFromViewport(viewport) {\n    if (!(viewport instanceof VolumeViewport)) {\n        return undefined;\n    }\n    const volumeIds = viewport.getAllVolumeIds();\n    if (!volumeIds?.length) {\n        return undefined;\n    }\n    const dynamicVolumeId = volumeIds.find((volumeId) => cache.getVolume(volumeId)?.isDynamicVolume());\n    const volumeId = dynamicVolumeId ?? volumeIds[0];\n    return cache.getVolume(volumeId);\n}\nfunction _createStackViewportCinePlayContext(viewport, waitForRendered) {\n    const imageIds = viewport.getImageIds();\n    return {\n        get numScrollSteps() {\n            return imageIds.length;\n        },\n        get currentStepIndex() {\n            return viewport.getTargetImageIdIndex();\n        },\n        get frameTimeVectorEnabled() {\n            return true;\n        },\n        waitForRenderedCount: 0,\n        scroll(delta) {\n            if (this.waitForRenderedCount <= waitForRendered &&\n                viewport.viewportStatus !== ViewportStatus.RENDERED) {\n                this.waitForRenderedCount++;\n                return;\n            }\n            this.waitForRenderedCount = 0;\n            csUtils.scroll(viewport, { delta, debounceLoading: debounced });\n        },\n    };\n}\nfunction _createVideoViewportCinePlayContext(viewport, waitForRendered) {\n    return {\n        get numScrollSteps() {\n            return viewport.getNumberOfSlices();\n        },\n        get currentStepIndex() {\n            return viewport.getSliceIndex();\n        },\n        get frameTimeVectorEnabled() {\n            return true;\n        },\n        waitForRenderedCount: 0,\n        scroll(delta) {\n            if (this.waitForRenderedCount <= waitForRendered &&\n                viewport.viewportStatus !== ViewportStatus.RENDERED) {\n                this.waitForRenderedCount++;\n                return;\n            }\n            this.waitForRenderedCount = 0;\n            csUtils.scroll(viewport, { delta, debounceLoading: debounced });\n        },\n        play(fps) {\n            if (fps) {\n                viewport.setPlaybackRate(fps / 24);\n            }\n            viewport.play();\n            return viewport.getFrameRate();\n        },\n    };\n}\nfunction _createVolumeViewportCinePlayContext(viewport, volume) {\n    const { volumeId } = volume;\n    const cachedScrollInfo = {\n        viewPlaneNormal: vec3.create(),\n        scrollInfo: null,\n    };\n    const getScrollInfo = () => {\n        const camera = viewport.getCamera();\n        const updateCache = !cachedScrollInfo.scrollInfo ||\n            !vec3.equals(camera.viewPlaneNormal, cachedScrollInfo.viewPlaneNormal);\n        if (updateCache) {\n            const scrollInfo = csUtils.getVolumeViewportScrollInfo(viewport, volumeId);\n            cachedScrollInfo.viewPlaneNormal = camera.viewPlaneNormal;\n            cachedScrollInfo.scrollInfo = scrollInfo;\n        }\n        return cachedScrollInfo.scrollInfo;\n    };\n    return {\n        get numScrollSteps() {\n            return getScrollInfo().numScrollSteps;\n        },\n        get currentStepIndex() {\n            return getScrollInfo().currentStepIndex;\n        },\n        get frameTimeVectorEnabled() {\n            const camera = viewport.getCamera();\n            const volumeViewPlaneNormal = volume.direction\n                .slice(6, 9)\n                .map((x) => -x);\n            const dot = vec3.dot(volumeViewPlaneNormal, camera.viewPlaneNormal);\n            return glMatrix.equals(dot, 1);\n        },\n        scroll(delta) {\n            getScrollInfo().currentStepIndex += delta;\n            csUtils.scroll(viewport, { delta });\n        },\n    };\n}\nfunction _createDynamicVolumeViewportCinePlayContext(volume) {\n    return {\n        get numScrollSteps() {\n            return volume.numDimensionGroups;\n        },\n        get currentStepIndex() {\n            return volume.dimensionGroupNumber - 1;\n        },\n        get frameTimeVectorEnabled() {\n            return false;\n        },\n        scroll(delta) {\n            volume.scroll(delta);\n        },\n    };\n}\nfunction _createCinePlayContext(viewport, playClipOptions) {\n    if (viewport instanceof StackViewport) {\n        return _createStackViewportCinePlayContext(viewport, playClipOptions.waitForRendered ?? 30);\n    }\n    if (viewport instanceof VolumeViewport) {\n        const volume = _getVolumeFromViewport(viewport);\n        if (playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume()) {\n            return _createDynamicVolumeViewportCinePlayContext(volume);\n        }\n        return _createVolumeViewportCinePlayContext(viewport, volume);\n    }\n    if (viewport instanceof VideoViewport) {\n        return _createVideoViewportCinePlayContext(viewport, playClipOptions.waitForRendered ?? 30);\n    }\n    throw new Error('Unknown viewport type');\n}\nexport { playClip, stopClip };\n", "import smoothAnnotation from './smoothAnnotation';\nexport default {\n    smoothAnnotation,\n};\nexport { smoothAnnotation };\n", "import { mat4, vec3 } from 'gl-matrix';\nimport interpolateSegmentPoints from './interpolation/interpolateSegmentPoints';\nfunction shouldPreventInterpolation(annotation, options) {\n    const knotsRatioPercentage = options?.knotsRatioPercentage || 30;\n    if (!annotation?.data?.contour?.polyline?.length ||\n        knotsRatioPercentage <= 0) {\n        return true;\n    }\n    return false;\n}\nfunction rotateMatrix(normal, focal) {\n    const mat = mat4.create();\n    const eye = vec3.add(vec3.create(), focal, normal);\n    const up = Math.abs(normal[0]) > 0.1\n        ? vec3.fromValues(-normal[1], normal[0], 0)\n        : vec3.fromValues(0, -normal[2], normal[1]);\n    mat4.lookAt(mat, focal, eye, up);\n    return mat;\n}\nfunction rotate(list, count = Math.floor(Math.random() * (list.length - 1))) {\n    if (count === 0) {\n        return 0;\n    }\n    const srcList = [...list];\n    const { length } = list;\n    for (let i = 0; i < length; i++) {\n        list[i] = srcList[(i + count + length) % length];\n    }\n    return count;\n}\nexport default function smoothAnnotation(annotation, options) {\n    if (shouldPreventInterpolation(annotation, options)) {\n        return false;\n    }\n    const { viewPlaneNormal } = annotation.metadata;\n    const { closed, polyline } = annotation.data.contour;\n    const rotateMat = rotateMatrix(viewPlaneNormal, annotation.data.contour.polyline[0]);\n    const canvasPoints = annotation.data.contour.polyline.map((p) => {\n        const planeP = vec3.transformMat4(vec3.create(), p, rotateMat);\n        return [planeP[0], planeP[1]];\n    });\n    let rotation = closed ? rotate(canvasPoints) : 0;\n    let interpolatedCanvasPoints = (interpolateSegmentPoints(canvasPoints, 0, canvasPoints.length - 1, options?.knotsRatioPercentage || 30));\n    if (interpolatedCanvasPoints === canvasPoints) {\n        return false;\n    }\n    rotate(interpolatedCanvasPoints, -rotation);\n    for (let i = 1; i < options?.loop; i++) {\n        rotation = closed ? rotate(interpolatedCanvasPoints) : 0;\n        interpolatedCanvasPoints = (interpolateSegmentPoints(interpolatedCanvasPoints, 0, interpolatedCanvasPoints.length - 1, options?.knotsRatioPercentage || 30));\n        rotate(interpolatedCanvasPoints, -rotation);\n    }\n    const unRotate = mat4.invert(mat4.create(), rotateMat);\n    annotation.data.contour.polyline = (interpolatedCanvasPoints.map((p) => vec3.transformMat4([0, 0, 0], [...p, 0], unRotate)));\n    return true;\n}\n", "import getBoundsIJKFromRectangleAnnotations from './getBoundsIJKFromRectangleAnnotations';\nimport { isAxisAlignedRectangle } from './isAxisAlignedRectangle';\nexport { getBoundsIJKFromRectangleAnnotations, isAxisAlignedRectangle };\n", "import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nconst { isEqual } = csUtils;\nconst iAxis = vec3.fromValues(1, 0, 0);\nconst jAxis = vec3.fromValues(0, 1, 0);\nconst kAxis = vec3.fromValues(0, 0, 1);\nconst axisList = [iAxis, jAxis, kAxis];\nfunction isAxisAlignedRectangle(rectangleCornersIJK) {\n    const rectangleVec1 = vec3.subtract(vec3.create(), rectangleCornersIJK[0], rectangleCornersIJK[1]);\n    const rectangleVec2 = vec3.subtract(vec3.create(), rectangleCornersIJK[0], rectangleCornersIJK[2]);\n    const anglesVec1 = calculateAnglesWithAxes(rectangleVec1, axisList);\n    const anglesVec2 = calculateAnglesWithAxes(rectangleVec2, axisList);\n    const isAligned = [...anglesVec1, ...anglesVec2].every((angle) => isEqual(angle, 0) ||\n        isEqual(angle, 90) ||\n        isEqual(angle, 180) ||\n        isEqual(angle, 270));\n    return isAligned;\n}\nfunction calculateAnglesWithAxes(vec, axes) {\n    return axes.map((axis) => (vec3.angle(vec, axis) * 180) / Math.PI);\n}\nexport { isAxisAlignedRectangle };\n", "import { getEnabledElement } from '@cornerstonejs/core';\nconst state = {};\nfunction addToolState(element, data) {\n    const enabledElement = getEnabledElement(element);\n    const { viewportId } = enabledElement;\n    state[viewportId] = data;\n}\nfunction getToolState(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewportId } = enabledElement;\n    return state[viewportId];\n}\nexport { addToolState, getToolState };\n", "import { getEnabledElement, StackViewport, Enums } from '@cornerstonejs/core';\nimport { getToolState } from './state';\nexport const requestType = Enums.RequestType.Prefetch;\nexport const priority = 0;\nexport function range(lowEnd, highEnd) {\n    lowEnd = Math.round(lowEnd) || 0;\n    highEnd = Math.round(highEnd) || 0;\n    const arr = [];\n    let c = highEnd - lowEnd + 1;\n    if (c <= 0) {\n        return arr;\n    }\n    while (c--) {\n        arr[c] = highEnd--;\n    }\n    return arr;\n}\nexport function nearestIndex(arr, x) {\n    let low = 0;\n    let high = arr.length - 1;\n    arr.forEach((v, idx) => {\n        if (v < x) {\n            low = Math.max(idx, low);\n        }\n        else if (v > x) {\n            high = Math.min(idx, high);\n        }\n    });\n    return { low, high };\n}\nexport function getStackData(element) {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        return null;\n    }\n    const { viewport } = enabledElement;\n    if (!(viewport instanceof StackViewport)) {\n        return null;\n    }\n    return {\n        currentImageIdIndex: viewport.getCurrentImageIdIndex(),\n        imageIds: viewport.getImageIds(),\n    };\n}\nexport function getPromiseRemovedHandler(element) {\n    return function (e) {\n        const eventData = e.detail;\n        let stackData;\n        try {\n            stackData = getStackData(element);\n        }\n        catch (error) {\n            return;\n        }\n        if (!stackData || !stackData.imageIds || stackData.imageIds.length === 0) {\n            return;\n        }\n        const stack = stackData;\n        const imageIdIndex = stack.imageIds.indexOf(eventData.imageId);\n        if (imageIdIndex < 0) {\n            return;\n        }\n        const stackPrefetchData = getToolState(element);\n        if (!stackPrefetchData ||\n            !stackPrefetchData.indicesToRequest ||\n            !stackPrefetchData.indicesToRequest.length) {\n            return;\n        }\n        stackPrefetchData.indicesToRequest.push(imageIdIndex);\n    };\n}\nexport const clearFromImageIds = (stack) => {\n    const imageIdSet = new Set(stack.imageIds);\n    return (requestDetails) => requestDetails.type !== requestType ||\n        !imageIdSet.has(requestDetails.additionalDetails.imageId);\n};\n", "import { imageLoader, Enums, eventTarget, imageLoadPoolManager, cache, metaData, utilities, triggerEvent, } from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport { getStackData, requestType, priority, getPromiseRemovedHandler, nearestIndex, range, } from './stackPrefetchUtils';\nimport { Events } from '../../enums';\nconst { imageRetrieveMetadataProvider } = utilities;\nlet configuration = {\n    maxImagesToPrefetch: Infinity,\n    preserveExistingPool: true,\n};\nlet resetPrefetchTimeout;\nconst resetPrefetchDelay = 10;\nfunction prefetch(element) {\n    const stackPrefetchData = getToolState(element);\n    if (!stackPrefetchData) {\n        return;\n    }\n    const stackPrefetch = (stackPrefetchData || {});\n    const stack = getStackData(element);\n    if (!stack?.imageIds?.length) {\n        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n        return;\n    }\n    const { currentImageIdIndex } = stack;\n    stackPrefetch.enabled =\n        stackPrefetch.enabled && (stackPrefetch.indicesToRequest?.length ?? 0) > 0;\n    if (stackPrefetch.enabled === false) {\n        return;\n    }\n    function removeFromList(imageIdIndex) {\n        const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n        if (index > -1) {\n            stackPrefetch.indicesToRequest.splice(index, 1);\n        }\n    }\n    stackPrefetchData.indicesToRequest.sort((a, b) => a - b);\n    const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n    indicesToRequestCopy.forEach(function (imageIdIndex) {\n        const imageId = stack.imageIds[imageIdIndex];\n        if (!imageId) {\n            return;\n        }\n        const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n        const imageCached = distance < 6\n            ? cache.getImageLoadObject(imageId)\n            : cache.isLoaded(imageId);\n        if (imageCached) {\n            removeFromList(imageIdIndex);\n        }\n    });\n    if (!stackPrefetch.indicesToRequest.length) {\n        return;\n    }\n    if (!configuration.preserveExistingPool) {\n        imageLoadPoolManager.clearRequestStack(requestType);\n    }\n    const nearest = nearestIndex(stackPrefetch.indicesToRequest, stack.currentImageIdIndex);\n    let imageId;\n    let nextImageIdIndex;\n    const preventCache = false;\n    function doneCallback(imageId) {\n        console.log('prefetch done: %s', imageId);\n        const imageIdIndex = stack.imageIds.indexOf(imageId);\n        removeFromList(imageIdIndex);\n        if (stackPrefetch.indicesToRequest.length === 0) {\n            const eventDetail = {\n                element: element,\n                lastPrefetchedImageId: imageId,\n            };\n            triggerEvent(eventTarget, Events.STACK_PREFETCH_COMPLETE, eventDetail);\n        }\n    }\n    let lowerIndex = nearest.low;\n    let higherIndex = nearest.high;\n    const imageIdsToPrefetch = [];\n    while (lowerIndex >= 0 ||\n        higherIndex < stackPrefetch.indicesToRequest.length) {\n        const currentIndex = stack.currentImageIdIndex;\n        const shouldSkipLower = currentIndex - stackPrefetch.indicesToRequest[lowerIndex] >\n            configuration.maxImagesToPrefetch;\n        const shouldSkipHigher = stackPrefetch.indicesToRequest[higherIndex] - currentIndex >\n            configuration.maxImagesToPrefetch;\n        const shouldLoadLower = !shouldSkipLower && lowerIndex >= 0;\n        const shouldLoadHigher = !shouldSkipHigher && higherIndex < stackPrefetch.indicesToRequest.length;\n        if (!shouldLoadHigher && !shouldLoadLower) {\n            break;\n        }\n        if (shouldLoadLower) {\n            nextImageIdIndex = stackPrefetch.indicesToRequest[lowerIndex--];\n            imageId = stack.imageIds[nextImageIdIndex];\n            imageIdsToPrefetch.push(imageId);\n        }\n        if (shouldLoadHigher) {\n            nextImageIdIndex = stackPrefetch.indicesToRequest[higherIndex++];\n            imageId = stack.imageIds[nextImageIdIndex];\n            imageIdsToPrefetch.push(imageId);\n        }\n    }\n    const requestFn = (imageId, options) => {\n        const { retrieveOptions = {} } = metaData.get(imageRetrieveMetadataProvider.IMAGE_RETRIEVE_CONFIGURATION, imageId, 'stack') || {};\n        options.retrieveOptions = {\n            ...options.retrieveOptions,\n            ...(retrieveOptions.default || Object.values(retrieveOptions)?.[0] || {}),\n        };\n        return imageLoader\n            .loadAndCacheImage(imageId, options)\n            .then(() => doneCallback(imageId));\n    };\n    imageIdsToPrefetch.forEach((imageId) => {\n        const options = {\n            requestType,\n        };\n        imageLoadPoolManager.addRequest(requestFn.bind(null, imageId, options), requestType, {\n            imageId,\n        }, priority);\n    });\n}\nfunction onImageUpdated(e) {\n    clearTimeout(resetPrefetchTimeout);\n    resetPrefetchTimeout = setTimeout(function () {\n        const element = e.target;\n        try {\n            prefetch(element);\n        }\n        catch (error) {\n            return;\n        }\n    }, resetPrefetchDelay);\n}\nfunction enable(element) {\n    const stack = getStackData(element);\n    if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n        return;\n    }\n    const stackPrefetchData = {\n        indicesToRequest: range(0, stack.imageIds.length - 1),\n        enabled: true,\n        direction: 1,\n    };\n    const indexOfCurrentImage = stackPrefetchData.indicesToRequest.indexOf(stack.currentImageIdIndex);\n    stackPrefetchData.indicesToRequest.splice(indexOfCurrentImage, 1);\n    addToolState(element, stackPrefetchData);\n    prefetch(element);\n    element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    const promiseRemovedHandler = getPromiseRemovedHandler(element);\n    eventTarget.removeEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n    eventTarget.addEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n}\nfunction disable(element) {\n    clearTimeout(resetPrefetchTimeout);\n    element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    const promiseRemovedHandler = getPromiseRemovedHandler(element);\n    eventTarget.removeEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n    const stackPrefetchData = getToolState(element);\n    if (stackPrefetchData && stackPrefetchData.indicesToRequest.length) {\n        stackPrefetchData.enabled = false;\n        imageLoadPoolManager.clearRequestStack(requestType);\n    }\n}\nfunction getConfiguration() {\n    return configuration;\n}\nfunction setConfiguration(config) {\n    configuration = config;\n}\nconst stackPrefetch = { enable, disable, getConfiguration, setConfiguration };\nexport default stackPrefetch;\n", "import { imageLoader, Enums, eventTarget, imageLoadPoolManager, cache, metaData, utilities, triggerEvent, } from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport { getStackData, requestType, clearFromImageIds, getPromiseRemovedHandler, } from './stackPrefetchUtils';\nimport { Events } from '../../enums';\nconst { imageRetrieveMetadataProvider } = utilities;\nlet configuration = {\n    maxImagesToPrefetch: Infinity,\n    minBefore: 2,\n    maxAfter: 2,\n    directionExtraImages: 10,\n    preserveExistingPool: false,\n};\nlet resetPrefetchTimeout;\nconst resetPrefetchDelay = 5;\nconst priorities = {};\nconst enable = (element, priority = 0) => {\n    const stack = getStackData(element);\n    if (!stack) {\n        return;\n    }\n    if (!stack.imageIds?.length) {\n        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n        return;\n    }\n    updateToolState(element);\n    priorities[element] = priority;\n    prefetch(element, priority);\n    element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    const promiseRemovedHandler = getPromiseRemovedHandler(element);\n    eventTarget.removeEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n    eventTarget.addEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n};\nfunction prefetch(element, priority = 0) {\n    const stack = getStackData(element);\n    if (!stack) {\n        return;\n    }\n    if (!stack?.imageIds?.length) {\n        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n        return;\n    }\n    const stackPrefetchData = getToolState(element);\n    if (!stackPrefetchData) {\n        return;\n    }\n    const stackPrefetch = (stackPrefetchData || {});\n    stackPrefetch.enabled =\n        stackPrefetch.enabled && (stackPrefetch.indicesToRequest?.length ?? 0) > 0;\n    if (stackPrefetch.enabled === false) {\n        return;\n    }\n    function removeFromList(imageIdIndex) {\n        const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n        if (index > -1) {\n            stackPrefetch.indicesToRequest.splice(index, 1);\n        }\n    }\n    const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n    const { currentImageIdIndex } = stack;\n    indicesToRequestCopy.forEach((imageIdIndex) => {\n        const imageId = stack.imageIds[imageIdIndex];\n        if (!imageId) {\n            return;\n        }\n        const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n        const imageCached = distance < 6\n            ? cache.getImageLoadObject(imageId)\n            : cache.isLoaded(imageId);\n        if (imageCached) {\n            removeFromList(imageIdIndex);\n        }\n    });\n    if (!stackPrefetch.indicesToRequest.length) {\n        return;\n    }\n    if (!configuration.preserveExistingPool) {\n        imageLoadPoolManager.filterRequests(clearFromImageIds(stack));\n    }\n    function doneCallback(imageId) {\n        const imageIdIndex = stack.imageIds.indexOf(imageId);\n        removeFromList(imageIdIndex);\n        const image = cache.getCachedImageBasedOnImageURI(imageId);\n        const { stats } = stackPrefetch;\n        const decodeTimeInMS = image?.image?.decodeTimeInMS || 0;\n        if (decodeTimeInMS) {\n            stats.imageIds.set(imageId, decodeTimeInMS);\n            stats.decodeTimeInMS += decodeTimeInMS;\n            const loadTimeInMS = image?.image?.loadTimeInMS || 0;\n            stats.loadTimeInMS += loadTimeInMS;\n        }\n        if (!stackPrefetch.indicesToRequest.length) {\n            if (image?.sizeInBytes) {\n                const { sizeInBytes } = image;\n                const usage = cache.getMaxCacheSize() / 4 / sizeInBytes;\n                if (!stackPrefetch.cacheFill) {\n                    stats.initialTime = Date.now() - stats.start;\n                    stats.initialSize = stats.imageIds.size;\n                    updateToolState(element, usage);\n                    prefetch(element, priority);\n                }\n                else if (stats.imageIds.size) {\n                    stats.fillTime = Date.now() - stats.start;\n                    const { size } = stats.imageIds;\n                    stats.fillSize = size;\n                }\n            }\n        }\n        if (stackPrefetch.indicesToRequest.length === 0) {\n            const eventDetail = {\n                element: element,\n                lastPrefetchedImageId: imageId,\n            };\n            triggerEvent(eventTarget, Events.STACK_PREFETCH_COMPLETE, eventDetail);\n        }\n    }\n    const requestFn = (imageId, options) => {\n        const { retrieveOptions = {} } = metaData.get(imageRetrieveMetadataProvider.IMAGE_RETRIEVE_CONFIGURATION, imageId, 'stack') || {};\n        options.retrieveOptions = {\n            ...options.retrieveOptions,\n            ...(retrieveOptions.default || Object.values(retrieveOptions)?.[0] || {}),\n        };\n        return imageLoader\n            .loadAndCacheImage(imageId, options)\n            .then(() => doneCallback(imageId));\n    };\n    stackPrefetch.indicesToRequest.forEach((imageIdIndex) => {\n        const imageId = stack.imageIds[imageIdIndex];\n        const options = {\n            requestType,\n        };\n        imageLoadPoolManager.addRequest(requestFn.bind(null, imageId, options), requestType, {\n            imageId,\n        }, priority);\n    });\n}\nfunction onImageUpdated(e) {\n    clearTimeout(resetPrefetchTimeout);\n    resetPrefetchTimeout = setTimeout(function () {\n        const element = e.target;\n        try {\n            updateToolState(element);\n            prefetch(element, priorities[element]);\n        }\n        catch (error) {\n            return;\n        }\n    }, resetPrefetchDelay);\n}\nconst signum = (x) => (x < 0 ? -1 : 1);\nconst updateToolState = (element, usage) => {\n    const stack = getStackData(element);\n    if (!stack) {\n        return;\n    }\n    if (!stack.imageIds?.length) {\n        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n        return;\n    }\n    const { currentImageIdIndex } = stack;\n    let { maxAfter = 2, minBefore = 2 } = configuration;\n    const { directionExtraImages = 10 } = configuration;\n    const stackPrefetchData = getToolState(element) ||\n        {\n            indicesToRequest: [],\n            currentImageIdIndex,\n            stackCount: 0,\n            enabled: true,\n            direction: 1,\n            stats: {\n                start: Date.now(),\n                imageIds: new Map(),\n                decodeTimeInMS: 0,\n                loadTimeInMS: 0,\n                totalBytes: 0,\n            },\n        };\n    const delta = currentImageIdIndex - stackPrefetchData.currentImageIdIndex;\n    stackPrefetchData.direction = signum(delta);\n    stackPrefetchData.currentImageIdIndex = currentImageIdIndex;\n    stackPrefetchData.enabled = true;\n    if (stackPrefetchData.stackCount < 100) {\n        stackPrefetchData.stackCount += directionExtraImages;\n    }\n    if (Math.abs(delta) > maxAfter || !delta) {\n        stackPrefetchData.stackCount = 0;\n        if (usage) {\n            const positionFraction = currentImageIdIndex / stack.imageIds.length;\n            minBefore = Math.ceil(usage * positionFraction);\n            maxAfter = Math.ceil(usage * (1 - positionFraction));\n            stackPrefetchData.cacheFill = true;\n        }\n        else {\n            stackPrefetchData.cacheFill = false;\n        }\n    }\n    else if (delta < 0) {\n        minBefore += stackPrefetchData.stackCount;\n        maxAfter = 0;\n    }\n    else {\n        maxAfter += stackPrefetchData.stackCount;\n        minBefore = 0;\n    }\n    const minIndex = Math.max(0, currentImageIdIndex - minBefore);\n    const maxIndex = Math.min(stack.imageIds.length - 1, currentImageIdIndex + maxAfter);\n    const indicesToRequest = [];\n    for (let i = currentImageIdIndex + 1; i <= maxIndex; i++) {\n        indicesToRequest.push(i);\n    }\n    for (let i = currentImageIdIndex - 1; i >= minIndex; i--) {\n        indicesToRequest.push(i);\n    }\n    stackPrefetchData.indicesToRequest = indicesToRequest;\n    addToolState(element, stackPrefetchData);\n};\nfunction disable(element) {\n    clearTimeout(resetPrefetchTimeout);\n    element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    const promiseRemovedHandler = getPromiseRemovedHandler(element);\n    eventTarget.removeEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n    const stackPrefetchData = getToolState(element);\n    if (stackPrefetchData) {\n        stackPrefetchData.enabled = false;\n    }\n}\nfunction getConfiguration() {\n    return configuration;\n}\nfunction setConfiguration(config) {\n    configuration = config;\n}\nconst stackContextPrefetch = {\n    enable,\n    disable,\n    getConfiguration,\n    setConfiguration,\n};\nexport default stackContextPrefetch;\n", "import { isViewportPreScaled } from './isViewportPreScaled';\nexport { isViewportPreScaled };\n", "import getDataInTime from './getDataInTime';\nimport { generateImageFromTimeData, updateVolumeFromTimeData, } from './generateImageFromTimeData';\nexport { getDataInTime };\nexport { generateImageFromTimeData, updateVolumeFromTimeData };\n", "import { utilities, cache } from '@cornerstonejs/core';\nimport { getVoxelOverlap } from '../segmentation/utilities';\nfunction getDataInTime(dynamicVolume, options) {\n    let dataInTime;\n    const dimensionGroups = options.dimensionGroupNumbers ||\n        options.frameNumbers ||\n        Array.from({ length: dynamicVolume.numDimensionGroups }, (_, i) => i + 1);\n    if (options.frameNumbers) {\n        console.warn('Warning: frameNumbers parameter is deprecated. Please use dimensionGroupNumbers instead.');\n    }\n    if (!options.maskVolumeId && !options.worldCoordinate) {\n        throw new Error('You should provide either maskVolumeId or imageCoordinate');\n    }\n    if (options.maskVolumeId && options.worldCoordinate) {\n        throw new Error('You can only use one of maskVolumeId or imageCoordinate');\n    }\n    if (options.maskVolumeId) {\n        const segmentationVolume = cache.getVolume(options.maskVolumeId);\n        if (!segmentationVolume) {\n            throw new Error('Segmentation volume not found');\n        }\n        const [dataInTime, ijkCoords] = _getDimensionGroupDataMask(dimensionGroups, dynamicVolume, segmentationVolume);\n        return [dataInTime, ijkCoords];\n    }\n    if (options.worldCoordinate) {\n        const dataInTime = _getDimensionGroupDataCoordinate(dimensionGroups, options.worldCoordinate, dynamicVolume);\n        return dataInTime;\n    }\n    return dataInTime;\n}\nfunction _getDimensionGroupDataCoordinate(dimensionGroups, coordinate, volume) {\n    const { dimensions, imageData } = volume;\n    const index = imageData.worldToIndex(coordinate);\n    index[0] = Math.floor(index[0]);\n    index[1] = Math.floor(index[1]);\n    index[2] = Math.floor(index[2]);\n    if (!utilities.indexWithinDimensions(index, dimensions)) {\n        throw new Error('outside bounds');\n    }\n    const yMultiple = dimensions[0];\n    const zMultiple = dimensions[0] * dimensions[1];\n    const value = [];\n    dimensionGroups.forEach((dimensionGroupNumber) => {\n        const scalarIndex = index[2] * zMultiple + index[1] * yMultiple + index[0];\n        value.push(volume.voxelManager.getAtIndexAndDimensionGroup(scalarIndex, dimensionGroupNumber));\n    });\n    return value;\n}\nfunction _getDimensionGroupDataMask(dimensionGroups, dynamicVolume, segmentationVolume) {\n    const { imageData: maskImageData } = segmentationVolume;\n    const segVoxelManager = segmentationVolume.voxelManager;\n    const scalarDataLength = segVoxelManager.getScalarDataLength();\n    const nonZeroVoxelIndices = [];\n    nonZeroVoxelIndices.length = scalarDataLength;\n    let actualLen = 0;\n    for (let i = 0, len = scalarDataLength; i < len; i++) {\n        if (segVoxelManager.getAtIndex(i) !== 0) {\n            nonZeroVoxelIndices[actualLen++] = i;\n        }\n    }\n    nonZeroVoxelIndices.length = actualLen;\n    const nonZeroVoxelValuesInTime = [];\n    const isSameVolume = dynamicVolume.voxelManager.getScalarDataLength() === scalarDataLength &&\n        JSON.stringify(dynamicVolume.spacing) ===\n            JSON.stringify(segmentationVolume.spacing);\n    const ijkCoords = [];\n    if (isSameVolume) {\n        for (let i = 0; i < nonZeroVoxelIndices.length; i++) {\n            const valuesInTime = [];\n            const index = nonZeroVoxelIndices[i];\n            for (let j = 0; j < dimensionGroups.length; j++) {\n                valuesInTime.push(dynamicVolume.voxelManager.getAtIndexAndDimensionGroup(index, dimensionGroups[j]));\n            }\n            nonZeroVoxelValuesInTime.push(valuesInTime);\n            ijkCoords.push(segVoxelManager.toIJK(index));\n        }\n        return [nonZeroVoxelValuesInTime, ijkCoords];\n    }\n    const callback = ({ pointLPS: segPointLPS, value: segValue, pointIJK: segPointIJK, }) => {\n        if (segValue === 0) {\n            return;\n        }\n        const overlapIJKMinMax = getVoxelOverlap(dynamicVolume.imageData, dynamicVolume.dimensions, dynamicVolume.spacing, segPointLPS);\n        let count = 0;\n        const perDimensionGroupSum = new Map();\n        dimensionGroups.forEach((dimensionGroupNumber) => perDimensionGroupSum.set(dimensionGroupNumber, 0));\n        const averageCallback = ({ index }) => {\n            for (let i = 0; i < dimensionGroups.length; i++) {\n                const value = dynamicVolume.voxelManager.getAtIndexAndDimensionGroup(index, dimensionGroups[i]);\n                const dimensionGroupNumber = dimensionGroups[i];\n                perDimensionGroupSum.set(dimensionGroupNumber, perDimensionGroupSum.get(dimensionGroupNumber) + value);\n            }\n            count++;\n        };\n        dynamicVolume.voxelManager.forEach(averageCallback, {\n            imageData: dynamicVolume.imageData,\n            boundsIJK: overlapIJKMinMax,\n        });\n        const averageValues = [];\n        perDimensionGroupSum.forEach((sum) => {\n            averageValues.push(sum / count);\n        });\n        ijkCoords.push(segPointIJK);\n        nonZeroVoxelValuesInTime.push(averageValues);\n    };\n    segmentationVolume.voxelManager.forEach(callback, {\n        imageData: maskImageData,\n    });\n    return [nonZeroVoxelValuesInTime, ijkCoords];\n}\nexport default getDataInTime;\n", "import { Enums } from '@cornerstonejs/core';\nfunction sumOverDimensionGroups(voxelManager, dimensionGroups) {\n    const arrayLength = voxelManager.getScalarDataLength();\n    const resultArray = new Float32Array(arrayLength);\n    for (const dimensionGroupNumber of dimensionGroups) {\n        const scalarData = voxelManager.getDimensionGroupScalarData(dimensionGroupNumber);\n        for (let i = 0; i < arrayLength; i++) {\n            resultArray[i] += scalarData[i];\n        }\n    }\n    return resultArray;\n}\nfunction averageOverDimensionGroups(voxelManager, dimensionGroups) {\n    const sumArray = sumOverDimensionGroups(voxelManager, dimensionGroups);\n    const numDimensionGroups = dimensionGroups.length;\n    for (let i = 0; i < sumArray.length; i++) {\n        sumArray[i] /= numDimensionGroups;\n    }\n    return sumArray;\n}\nconst operationFunctions = {\n    [Enums.GenerateImageType.SUM]: (voxelManager, dimensionGroups, callback) => {\n        const resultArray = sumOverDimensionGroups(voxelManager, dimensionGroups);\n        for (let i = 0; i < resultArray.length; i++) {\n            callback(i, resultArray[i]);\n        }\n    },\n    [Enums.GenerateImageType.AVERAGE]: (voxelManager, dimensionGroups, callback) => {\n        const resultArray = averageOverDimensionGroups(voxelManager, dimensionGroups);\n        for (let i = 0; i < resultArray.length; i++) {\n            callback(i, resultArray[i]);\n        }\n    },\n    [Enums.GenerateImageType.SUBTRACT]: (voxelManager, dimensionGroups, callback) => {\n        if (dimensionGroups.length !== 2) {\n            throw new Error('Please provide only 2 dimension groups for subtraction.');\n        }\n        const arrayLength = voxelManager.getScalarDataLength();\n        const scalarData1 = voxelManager.getDimensionGroupScalarData(dimensionGroups[0]);\n        const scalarData2 = voxelManager.getDimensionGroupScalarData(dimensionGroups[1]);\n        for (let i = 0; i < arrayLength; i++) {\n            const difference = scalarData1[i] - scalarData2[i];\n            callback(i, difference);\n        }\n    },\n};\nfunction generateImageFromTimeData(dynamicVolume, operation, options) {\n    const { dimensionGroupNumbers, frameNumbers } = options;\n    if (frameNumbers) {\n        console.warn('Warning: frameNumbers parameter is deprecated. Please use dimensionGroupNumbers instead.');\n    }\n    const dimensionGroups = dimensionGroupNumbers ||\n        frameNumbers ||\n        Array.from({ length: dynamicVolume.numDimensionGroups }, (_, i) => i + 1);\n    if (dimensionGroups.length <= 1) {\n        throw new Error('Please provide two or more dimension groups');\n    }\n    const voxelManager = dynamicVolume.voxelManager;\n    const arrayLength = voxelManager.getScalarDataLength();\n    const operationFunction = operationFunctions[operation];\n    if (!operationFunction) {\n        throw new Error(`Unsupported operation: ${operation}`);\n    }\n    const resultArray = new Float32Array(arrayLength);\n    operationFunction(voxelManager, dimensionGroups, (index, value) => {\n        resultArray[index] = value;\n    });\n    return resultArray;\n}\nfunction updateVolumeFromTimeData(dynamicVolume, operation, options) {\n    const { dimensionGroupNumbers, frameNumbers, targetVolume } = options;\n    if (!targetVolume) {\n        throw new Error('A target volume must be provided');\n    }\n    if (frameNumbers) {\n        console.warn('Warning: frameNumbers parameter is deprecated. Please use dimensionGroupNumbers instead.');\n    }\n    const dimensionGroups = dimensionGroupNumbers ||\n        frameNumbers ||\n        Array.from({ length: dynamicVolume.numDimensionGroups }, (_, i) => i + 1);\n    if (dimensionGroups.length <= 1) {\n        throw new Error('Please provide two or more dimension groups');\n    }\n    const voxelManager = dynamicVolume.voxelManager;\n    const targetVoxelManager = targetVolume.voxelManager;\n    const operationFunction = operationFunctions[operation];\n    if (!operationFunction) {\n        throw new Error(`Unsupported operation: ${operation}`);\n    }\n    operationFunction(voxelManager, dimensionGroups, (index, value) => {\n        targetVoxelManager.setAtIndex(index, value);\n    });\n    targetVoxelManager.resetModifiedSlices();\n    for (let k = 0; k < targetVolume.dimensions[2]; k++) {\n        targetVoxelManager.modifiedSlices.add(k);\n    }\n}\nexport { generateImageFromTimeData, updateVolumeFromTimeData };\n", "import { vec3 } from 'gl-matrix';\nexport function getPoint(points, idx) {\n    const idx3 = idx * 3;\n    if (idx3 < points.length) {\n        return vec3.fromValues(points[idx3], points[idx3 + 1], points[idx3 + 2]);\n    }\n}\nexport function getPolyDataPointIndexes(polyData) {\n    const linesData = polyData.getLines().getData();\n    let idx = 0;\n    const lineSegments = new Map();\n    while (idx < linesData.length) {\n        const segmentSize = linesData[idx++];\n        const segment = [];\n        for (let i = 0; i < segmentSize; i++) {\n            segment.push(linesData[idx + i]);\n        }\n        lineSegments.set(segment[0], segment);\n        idx += segmentSize;\n    }\n    const contours = [];\n    const findStartingPoint = (map) => {\n        for (const [key, value] of map.entries()) {\n            if (value !== undefined) {\n                return key;\n            }\n        }\n        return -1;\n    };\n    let startPoint = findStartingPoint(lineSegments);\n    while (startPoint !== -1) {\n        const contour = [startPoint];\n        while (lineSegments.has(startPoint)) {\n            const nextPoint = lineSegments.get(startPoint)[1];\n            if (lineSegments.has(nextPoint)) {\n                contour.push(nextPoint);\n            }\n            lineSegments.delete(startPoint);\n            startPoint = nextPoint;\n        }\n        contours.push(contour);\n        startPoint = findStartingPoint(lineSegments);\n    }\n    return contours.length ? contours : undefined;\n}\nexport function getPolyDataPoints(polyData) {\n    const contoursIndexes = getPolyDataPointIndexes(polyData);\n    if (!contoursIndexes) {\n        return;\n    }\n    const rawPointsData = polyData.getPoints().getData();\n    return contoursIndexes.map((contourIndexes) => contourIndexes.map((index) => getPoint(rawPointsData, index)));\n}\n", "import * as colorbar from './colorbar';\nimport * as windowLevel from './windowlevel';\nexport { colorbar, windowLevel };\n", "import * as Enums from './enums';\nexport { Enums };\nexport { Colorbar } from './Colorbar';\nexport { ViewportColorbar } from './ViewportColorbar';\n", "export { ColorbarRangeTextPosition } from './ColorbarRangeTextPosition';\n", "export var ColorbarRangeTextPosition;\n(function (ColorbarRangeTextPosition) {\n    ColorbarRangeTextPosition[\"Top\"] = \"top\";\n    ColorbarRangeTextPosition[\"Left\"] = \"left\";\n    ColorbarRangeTextPosition[\"Bottom\"] = \"bottom\";\n    ColorbarRangeTextPosition[\"Right\"] = \"right\";\n})(ColorbarRangeTextPosition || (ColorbarRangeTextPosition = {}));\n", "const isRangeValid = (range) => {\n    return range && range.upper > range.lower;\n};\nexport { isRangeValid as default, isRangeValid };\n", "const isColorbarSizeValid = (size) => {\n    return !!size && size.width > 0 && size.height > 0;\n};\nexport { isColorbarSizeValid as default, isColorbarSizeValid };\n", "const areColorbarRangesEqual = (a, b) => {\n    return !!a && !!b && a.lower === b.lower && a.upper === b.upper;\n};\nexport { areColorbarRangesEqual as default, areColorbarRangesEqual };\n", "const areColorbarSizesEqual = (a, b) => {\n    return !!a && !!b && a.width === b.width && a.height === b.height;\n};\nexport { areColorbarSizesEqual as default, areColorbarSizesEqual };\n", "const interpolateVec3 = (a, b, t) => {\n    return [\n        a[0] * (1 - t) + b[0] * t,\n        a[1] * (1 - t) + b[1] * t,\n        a[2] * (1 - t) + b[2] * t,\n    ];\n};\nexport { interpolateVec3 as default, interpolateVec3 };\n", "import { utilities } from '@cornerstonejs/core';\nimport interpolateVec3 from '../../math/vec3/interpolateVec3';\nimport { isRangeValid, areColorbarRangesEqual, isColorbarSizeValid, areColorbarSizesEqual, } from './common';\nconst { clamp } = utilities;\nclass ColorbarCanvas {\n    constructor(props) {\n        ColorbarCanvas.validateProps(props);\n        const { colormap, size = { width: 20, height: 100 }, imageRange = { lower: 0, upper: 1 }, voiRange = { lower: 0, upper: 1 }, container, showFullPixelValueRange = false, } = props;\n        this._colormap = colormap;\n        this._imageRange = imageRange;\n        this._voiRange = voiRange;\n        this._showFullImageRange = showFullPixelValueRange;\n        this._canvas = this._createRootElement(size);\n        if (container) {\n            this.appendTo(container);\n        }\n    }\n    get colormap() {\n        return this._colormap;\n    }\n    set colormap(colormap) {\n        this._colormap = colormap;\n        this.render();\n    }\n    get size() {\n        const { width, height } = this._canvas;\n        return { width, height };\n    }\n    set size(size) {\n        const { _canvas: canvas } = this;\n        if (!isColorbarSizeValid(size) || areColorbarSizesEqual(canvas, size)) {\n            return;\n        }\n        this._setCanvasSize(canvas, size);\n        this.render();\n    }\n    get imageRange() {\n        return { ...this._imageRange };\n    }\n    set imageRange(imageRange) {\n        if (!isRangeValid(imageRange) ||\n            areColorbarRangesEqual(imageRange, this._imageRange)) {\n            return;\n        }\n        this._imageRange = imageRange;\n        this.render();\n    }\n    get voiRange() {\n        return { ...this._voiRange };\n    }\n    set voiRange(voiRange) {\n        if (!isRangeValid(voiRange) ||\n            areColorbarRangesEqual(voiRange, this._voiRange)) {\n            return;\n        }\n        this._voiRange = voiRange;\n        this.render();\n    }\n    get showFullImageRange() {\n        return this._showFullImageRange;\n    }\n    set showFullImageRange(showFullImageRange) {\n        if (showFullImageRange === this._showFullImageRange) {\n            return;\n        }\n        this._showFullImageRange = showFullImageRange;\n        this.render();\n    }\n    appendTo(container) {\n        container.appendChild(this._canvas);\n        this.render();\n    }\n    dispose() {\n        const { _canvas: canvas } = this;\n        const { parentElement } = canvas;\n        parentElement?.removeChild(canvas);\n    }\n    static validateProps(props) {\n        const { size, imageRange, voiRange } = props;\n        if (size && !isColorbarSizeValid(size)) {\n            throw new Error('Invalid \"size\"');\n        }\n        if (imageRange && !isRangeValid(imageRange)) {\n            throw new Error('Invalid \"imageRange\"');\n        }\n        if (voiRange && !isRangeValid(voiRange)) {\n            throw new Error('Invalid \"voiRange\"');\n        }\n    }\n    _setCanvasSize(canvas, size) {\n        const { width, height } = size;\n        canvas.width = width;\n        canvas.height = height;\n        Object.assign(canvas.style, {\n            width: `${width}px`,\n            height: `${height}px`,\n        });\n    }\n    _createRootElement(size) {\n        const canvas = document.createElement('canvas');\n        Object.assign(canvas.style, {\n            position: 'absolute',\n            top: '0',\n            left: '0',\n            pointerEvents: 'none',\n            boxSizing: 'border-box',\n        });\n        this._setCanvasSize(canvas, size);\n        return canvas;\n    }\n    render() {\n        if (!this._canvas.isConnected) {\n            return;\n        }\n        const { _colormap: colormap } = this;\n        const { RGBPoints: rgbPoints } = colormap;\n        const colorsCount = rgbPoints.length / 4;\n        const getColorPoint = (index) => {\n            const offset = 4 * index;\n            if (index < 0 || index >= colorsCount) {\n                return;\n            }\n            return {\n                index,\n                position: rgbPoints[offset],\n                color: [\n                    rgbPoints[offset + 1],\n                    rgbPoints[offset + 2],\n                    rgbPoints[offset + 3],\n                ],\n            };\n        };\n        const { width, height } = this._canvas;\n        const canvasContext = this._canvas.getContext('2d');\n        if (!canvasContext) {\n            return;\n        }\n        const isHorizontal = width > height;\n        const maxValue = isHorizontal ? width : height;\n        const { _voiRange: voiRange } = this;\n        const range = this._showFullImageRange ? this._imageRange : { ...voiRange };\n        let previousColorPoint = undefined;\n        let currentColorPoint = getColorPoint(0);\n        const incRawPixelValue = (range.upper - range.lower) / (maxValue - 1);\n        let rawPixelValue = range.lower;\n        for (let i = 0; i < maxValue; i++) {\n            const tVoiRange = (rawPixelValue - voiRange.lower) /\n                Math.abs(voiRange.upper - voiRange.lower);\n            if (currentColorPoint) {\n                for (let i = currentColorPoint.index; i < colorsCount; i++) {\n                    if (tVoiRange <= currentColorPoint.position) {\n                        break;\n                    }\n                    previousColorPoint = currentColorPoint;\n                    currentColorPoint = getColorPoint(i + 1);\n                }\n            }\n            let normColor;\n            if (!previousColorPoint) {\n                normColor = [...currentColorPoint.color];\n            }\n            else if (!currentColorPoint) {\n                normColor = [...previousColorPoint.color];\n            }\n            else {\n                const tColorRange = (tVoiRange - previousColorPoint.position) /\n                    (currentColorPoint.position - previousColorPoint.position);\n                normColor = interpolateVec3(previousColorPoint.color, currentColorPoint.color, tColorRange);\n            }\n            const color = normColor.map((color) => clamp(Math.round(color * 255), 0, 255));\n            canvasContext.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;\n            if (isHorizontal) {\n                canvasContext.fillRect(i, 0, 1, height);\n            }\n            else {\n                canvasContext.fillRect(0, height - i - 1, width, 1);\n            }\n            rawPixelValue += incRawPixelValue;\n        }\n    }\n}\nexport { ColorbarCanvas as default, ColorbarCanvas };\n", "import { isColorbarSizeValid, isRangeValid, areColorbarRangesEqual, areColorbarSizesEqual, } from './common';\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\nconst DEFAULTS = {\n    FONT: '10px Arial',\n    COLOR: 'white',\n    TICK_SIZE: 5,\n    TICK_WIDTH: 1,\n    TICK_LABEL_MARGIN: 3,\n    MAX_NUM_TICKS: 8,\n    TICKS_STEPS: [1, 2.5, 5, 10],\n};\nclass ColorbarTicks {\n    constructor(props) {\n        ColorbarTicks.validateProps(props);\n        const { top = 0, left = 0, size = { width: 20, height: 100 }, imageRange = { lower: 0, upper: 1 }, voiRange = { lower: 0, upper: 1 }, ticks: ticksProps, container, showFullPixelValueRange = false, } = props;\n        const { style: ticksStyle, position: rangeTextPosition } = ticksProps ?? {};\n        this._imageRange = imageRange;\n        this._voiRange = voiRange;\n        this._font = ticksStyle?.font ?? DEFAULTS.FONT;\n        this._color = ticksStyle?.color ?? DEFAULTS.COLOR;\n        this._tickSize = ticksStyle?.tickSize ?? DEFAULTS.TICK_SIZE;\n        this._tickWidth = ticksStyle?.tickWidth ?? DEFAULTS.TICK_WIDTH;\n        this._labelMargin = ticksStyle?.labelMargin ?? DEFAULTS.TICK_LABEL_MARGIN;\n        this._maxNumTicks = ticksStyle?.maxNumTicks ?? DEFAULTS.MAX_NUM_TICKS;\n        this._rangeTextPosition =\n            rangeTextPosition ?? ColorbarRangeTextPosition.Right;\n        this._showFullPixelValueRange = showFullPixelValueRange;\n        this._canvas = this._createCanvasElement(size, top, left);\n        if (container) {\n            this.appendTo(container);\n        }\n    }\n    get size() {\n        const { width, height } = this._canvas;\n        return { width, height };\n    }\n    set size(size) {\n        const { _canvas: canvas } = this;\n        if (!isColorbarSizeValid(size) || areColorbarSizesEqual(canvas, size)) {\n            return;\n        }\n        this._setCanvasSize(canvas, size);\n        this.render();\n    }\n    get top() {\n        return Number.parseInt(this._canvas.style.top);\n    }\n    set top(top) {\n        const { _canvas: canvas } = this;\n        const currentTop = this.top;\n        if (top === currentTop) {\n            return;\n        }\n        canvas.style.top = `${top}px`;\n        this.render();\n    }\n    get left() {\n        return Number.parseInt(this._canvas.style.left);\n    }\n    set left(left) {\n        const { _canvas: canvas } = this;\n        const currentLeft = this.left;\n        if (left === currentLeft) {\n            return;\n        }\n        canvas.style.left = `${left}px`;\n        this.render();\n    }\n    get imageRange() {\n        return { ...this._imageRange };\n    }\n    set imageRange(imageRange) {\n        if (!isRangeValid(imageRange) ||\n            areColorbarRangesEqual(imageRange, this._imageRange)) {\n            return;\n        }\n        this._imageRange = imageRange;\n        this.render();\n    }\n    get voiRange() {\n        return { ...this._voiRange };\n    }\n    set voiRange(voiRange) {\n        if (!isRangeValid(voiRange) ||\n            areColorbarRangesEqual(voiRange, this._voiRange)) {\n            return;\n        }\n        this._voiRange = voiRange;\n        this.render();\n    }\n    get tickSize() {\n        return this._tickSize;\n    }\n    set tickSize(tickSize) {\n        if (tickSize === this._tickSize) {\n            return;\n        }\n        this._tickSize = tickSize;\n        this.render();\n    }\n    get tickWidth() {\n        return this._tickWidth;\n    }\n    set tickWidth(tickWidth) {\n        if (tickWidth === this._tickWidth) {\n            return;\n        }\n        this._tickWidth = tickWidth;\n        this.render();\n    }\n    get color() {\n        return this._color;\n    }\n    set color(color) {\n        if (color === this._color) {\n            return;\n        }\n        this._color = color;\n        this.render();\n    }\n    get showFullPixelValueRange() {\n        return this._showFullPixelValueRange;\n    }\n    set showFullPixelValueRange(showFullRange) {\n        if (showFullRange === this._showFullPixelValueRange) {\n            return;\n        }\n        this._showFullPixelValueRange = showFullRange;\n        this.render();\n    }\n    get visible() {\n        return this._canvas.style.display === 'block';\n    }\n    set visible(visible) {\n        if (visible === this.visible) {\n            return;\n        }\n        this._canvas.style.display = visible ? 'block' : 'none';\n        if (visible) {\n            this.render();\n        }\n    }\n    appendTo(container) {\n        container.appendChild(this._canvas);\n        this.render();\n    }\n    static validateProps(props) {\n        const { size, imageRange, voiRange } = props;\n        if (size && !isColorbarSizeValid(size)) {\n            throw new Error('Invalid \"size\"');\n        }\n        if (imageRange && !isRangeValid(imageRange)) {\n            throw new Error('Invalid \"imageRange\"');\n        }\n        if (voiRange && !isRangeValid(voiRange)) {\n            throw new Error('Invalid \"voiRange\"');\n        }\n    }\n    _setCanvasSize(canvas, size) {\n        const { width, height } = size;\n        canvas.width = width;\n        canvas.height = height;\n        Object.assign(canvas.style, {\n            width: `${width}px`,\n            height: `${height}px`,\n        });\n    }\n    _createCanvasElement(size, top, left) {\n        const canvas = document.createElement('canvas');\n        Object.assign(canvas.style, {\n            display: 'none',\n            position: 'absolute',\n            boxSizing: 'border-box',\n            top: `${top}px`,\n            left: `${left}px`,\n        });\n        this._setCanvasSize(canvas, size);\n        return canvas;\n    }\n    _getTicks(range) {\n        const { lower, upper } = range;\n        const rangeValue = upper - lower;\n        const roughStep = rangeValue / (this._maxNumTicks - 1);\n        const stepPower = Math.pow(10, -Math.floor(Math.log10(Math.abs(roughStep))));\n        const roughtStepNormalized = roughStep * stepPower;\n        const normalizedStep = DEFAULTS.TICKS_STEPS.find((n) => n >= roughtStepNormalized);\n        const step = normalizedStep / stepPower;\n        const scaleMax = Math.ceil(upper / step) * step;\n        const scaleMin = Math.floor(lower / step) * step;\n        const ticksCount = Math.round((scaleMax - scaleMin) / step) + 1;\n        const ticks = [];\n        for (let i = 0; i < ticksCount; i++) {\n            ticks.push(scaleMin + i * step);\n        }\n        return { scaleMin, scaleMax, step, ticks };\n    }\n    _getLeftTickInfo({ position, labelMeasure }) {\n        const { width } = this._canvas;\n        const labelX = width - this.tickSize - labelMeasure.width - this._labelMargin;\n        const labelPoint = [labelX, position];\n        const tickPoints = {\n            start: [width - this._tickSize, position],\n            end: [width, position],\n        };\n        return { labelPoint, tickPoints };\n    }\n    _getRightTickInfo({ position }) {\n        const labelPoint = [this._tickSize + this._labelMargin, position];\n        const tickPoints = {\n            start: [0, position],\n            end: [this._tickSize, position],\n        };\n        return { labelPoint, tickPoints };\n    }\n    _getTopTickInfo({ position, labelMeasure }) {\n        const { height } = this._canvas;\n        const labelY = height - this.tickSize - this._labelMargin;\n        const labelPoint = [position, labelY];\n        const tickPoints = {\n            start: [position, height - this._tickSize],\n            end: [position, height],\n        };\n        return { labelPoint, tickPoints };\n    }\n    _getBottomTickInfo({ position, labelMeasure }) {\n        const labelPoint = [position, this._tickSize + this._labelMargin];\n        const tickPoints = {\n            start: [position, 0],\n            end: [position, this._tickSize],\n        };\n        return { labelPoint, tickPoints };\n    }\n    render() {\n        const { _canvas: canvas } = this;\n        if (!canvas.isConnected || !this.visible) {\n            return;\n        }\n        const { width, height } = canvas;\n        const isHorizontal = width >= height;\n        const maxCanvasPixelValue = isHorizontal ? width : height;\n        const canvasContext = canvas.getContext('2d');\n        const { _voiRange: voiRange } = this;\n        const range = this._showFullPixelValueRange\n            ? this._imageRange\n            : { ...voiRange };\n        const rangeWidth = range.upper - range.lower;\n        const { ticks } = this._getTicks(range);\n        canvasContext.clearRect(0, 0, width, height);\n        canvasContext.font = this._font;\n        canvasContext.textBaseline = isHorizontal ? 'top' : 'middle';\n        canvasContext.textAlign = isHorizontal ? 'center' : 'left';\n        canvasContext.fillStyle = this._color;\n        canvasContext.strokeStyle = this._color;\n        canvasContext.lineWidth = this.tickWidth;\n        ticks.forEach((tick) => {\n            let position = Math.round(maxCanvasPixelValue * ((tick - range.lower) / rangeWidth));\n            if (!isHorizontal) {\n                position = height - position;\n            }\n            if (position < 0 || position > maxCanvasPixelValue) {\n                return;\n            }\n            const label = tick.toString();\n            const labelMeasure = canvasContext.measureText(label);\n            let tickInfo;\n            if (isHorizontal) {\n                if (this._rangeTextPosition === ColorbarRangeTextPosition.Top) {\n                    tickInfo = this._getTopTickInfo({ position, labelMeasure });\n                }\n                else {\n                    tickInfo = this._getBottomTickInfo({ position, labelMeasure });\n                }\n            }\n            else {\n                if (this._rangeTextPosition === ColorbarRangeTextPosition.Left) {\n                    tickInfo = this._getLeftTickInfo({ position, labelMeasure });\n                }\n                else {\n                    tickInfo = this._getRightTickInfo({ position });\n                }\n            }\n            const { labelPoint, tickPoints } = tickInfo;\n            const { start: tickStart, end: tickEnd } = tickPoints;\n            canvasContext.beginPath();\n            canvasContext.moveTo(tickStart[0], tickStart[1]);\n            canvasContext.lineTo(tickEnd[0], tickEnd[1]);\n            canvasContext.fillText(label, labelPoint[0], labelPoint[1]);\n            canvasContext.stroke();\n            return position;\n        });\n    }\n}\nexport { ColorbarTicks as default, ColorbarTicks };\n", "import { ColorbarRangeTextPosition } from '../enums';\nfunction isRangeTextPositionValid(colorbarWidth, colorbarHeight, rangeTextPosition) {\n    const isHorizontal = colorbarWidth >= colorbarHeight;\n    const validRangeTextPositions = isHorizontal\n        ? [ColorbarRangeTextPosition.Top, ColorbarRangeTextPosition.Bottom]\n        : [ColorbarRangeTextPosition.Left, ColorbarRangeTextPosition.Right];\n    return validRangeTextPositions.includes(rangeTextPosition);\n}\nexport { isRangeTextPositionValid as default, isRangeTextPositionValid };\n", "class Widget {\n    constructor({ id, container }) {\n        this._containerResizeCallback = (entries) => {\n            let width;\n            let height;\n            const { contentRect, contentBoxSize } = entries[0];\n            if (contentRect) {\n                width = contentRect.width;\n                height = contentRect.height;\n            }\n            else if (contentBoxSize?.length) {\n                width = contentBoxSize[0].inlineSize;\n                height = contentBoxSize[0].blockSize;\n            }\n            this._containerSize = { width, height };\n            this.onContainerResize();\n        };\n        this._id = id;\n        this._containerSize = { width: 0, height: 0 };\n        this._rootElement = this.createRootElement(id);\n        this._containerResizeObserver = new ResizeObserver(this._containerResizeCallback);\n        if (container) {\n            this.appendTo(container);\n        }\n    }\n    get id() {\n        return this._id;\n    }\n    get rootElement() {\n        return this._rootElement;\n    }\n    appendTo(container) {\n        const { _rootElement: rootElement, _containerResizeObserver: resizeObserver, } = this;\n        const { parentElement: currentContainer } = rootElement;\n        if (!container || container === currentContainer) {\n            return;\n        }\n        if (currentContainer) {\n            resizeObserver.unobserve(currentContainer);\n        }\n        container.appendChild(rootElement);\n        resizeObserver.observe(container);\n    }\n    destroy() {\n        const { _rootElement: rootElement, _containerResizeObserver: resizeObserver, } = this;\n        const { parentElement } = rootElement;\n        parentElement?.removeChild(rootElement);\n        resizeObserver.disconnect();\n    }\n    get containerSize() {\n        return { ...this._containerSize };\n    }\n    createRootElement(id) {\n        const rootElement = document.createElement('div');\n        rootElement.id = id;\n        rootElement.classList.add('widget');\n        Object.assign(rootElement.style, {\n            width: '100%',\n            height: '100%',\n        });\n        return rootElement;\n    }\n    onContainerResize() {\n    }\n}\nexport { Widget as default, Widget };\n", "import { vec2 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { isRangeValid, areColorbarRangesEqual } from './common';\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\nimport { ColorbarCanvas } from './ColorbarCanvas';\nimport { ColorbarTicks } from './ColorbarTicks';\nimport isRangeTextPositionValid from './common/isRangeTextPositionValid';\nimport Widget from '../../../widgets/Widget';\nconst DEFAULTS = {\n    MULTIPLIER: 1,\n    RANGE_TEXT_POSITION: ColorbarRangeTextPosition.Right,\n    TICKS_BAR_SIZE: 50,\n};\nclass Colorbar extends Widget {\n    constructor(props) {\n        super(props);\n        this._isMouseOver = false;\n        this._isInteracting = false;\n        this._mouseOverCallback = (evt) => {\n            this._isMouseOver = true;\n            this.showTicks();\n            evt.stopPropagation();\n        };\n        this._mouseOutCallback = (evt) => {\n            this._isMouseOver = false;\n            this.hideTicks();\n            evt.stopPropagation();\n        };\n        this._mouseDownCallback = (evt) => {\n            this._isInteracting = true;\n            this.showTicks();\n            this._addVOIEventListeners(evt);\n            evt.stopPropagation();\n        };\n        this._mouseDragCallback = (evt, initialState) => {\n            const multipliers = this.getVOIMultipliers();\n            const currentPoints = this._getPointsFromMouseEvent(evt);\n            const { points: startPoints, voiRange: startVOIRange } = initialState;\n            const canvasDelta = vec2.sub(vec2.create(), currentPoints.local, startPoints.local);\n            const wwDelta = canvasDelta[0] * multipliers[0];\n            const wcDelta = canvasDelta[1] * multipliers[1];\n            if (!wwDelta && !wcDelta) {\n                return;\n            }\n            const { lower: voiLower, upper: voiUpper } = startVOIRange;\n            let { windowWidth, windowCenter } = csUtils.windowLevel.toWindowLevel(voiLower, voiUpper);\n            windowWidth = Math.max(windowWidth + wwDelta, 1);\n            windowCenter += wcDelta;\n            const newVoiRange = csUtils.windowLevel.toLowHighRange(windowWidth, windowCenter);\n            this.voiRange = newVoiRange;\n            evt.stopPropagation();\n            evt.preventDefault();\n        };\n        this._mouseUpCallback = (evt) => {\n            this._isInteracting = false;\n            this.hideTicks();\n            this._removeVOIEventListeners();\n            evt.stopPropagation();\n        };\n        this._eventListenersManager =\n            new csUtils.eventListener.MultiTargetEventListenerManager();\n        this._colormaps = Colorbar.getColormapsMap(props);\n        this._activeColormapName = Colorbar.getInitialColormapName(props);\n        this._canvas = this._createCanvas(props);\n        this._ticksBar = this._createTicksBar(props);\n        this._rangeTextPosition =\n            props.ticks?.position ?? DEFAULTS.RANGE_TEXT_POSITION;\n        this._canvas.appendTo(this.rootElement);\n        this._ticksBar.appendTo(this.rootElement);\n        this._addRootElementEventListeners();\n    }\n    get activeColormapName() {\n        return this._activeColormapName;\n    }\n    set activeColormapName(colormapName) {\n        if (colormapName === this._activeColormapName) {\n            return;\n        }\n        const colormap = this._colormaps.get(colormapName);\n        if (!colormap) {\n            console.warn(`Invalid colormap name (${colormapName})`);\n            return;\n        }\n        this._activeColormapName = colormapName;\n        this._canvas.colormap = colormap;\n    }\n    get imageRange() {\n        return this._canvas.imageRange;\n    }\n    set imageRange(imageRange) {\n        this._canvas.imageRange = imageRange;\n        this._ticksBar.imageRange = imageRange;\n    }\n    get voiRange() {\n        return this._canvas.voiRange;\n    }\n    set voiRange(voiRange) {\n        const { voiRange: currentVoiRange } = this._canvas;\n        if (!isRangeValid(voiRange) ||\n            areColorbarRangesEqual(voiRange, currentVoiRange)) {\n            return;\n        }\n        this._canvas.voiRange = voiRange;\n        this._ticksBar.voiRange = voiRange;\n        this.onVoiChange(voiRange);\n    }\n    get showFullImageRange() {\n        return this._canvas.showFullImageRange;\n    }\n    set showFullImageRange(value) {\n        this._canvas.showFullImageRange = value;\n        this._ticksBar.showFullPixelValueRange = value;\n    }\n    destroy() {\n        super.destroy();\n        this._eventListenersManager.reset();\n    }\n    createRootElement() {\n        const rootElement = document.createElement('div');\n        Object.assign(rootElement.style, {\n            position: 'relative',\n            fontSize: '0',\n            width: '100%',\n            height: '100%',\n        });\n        return rootElement;\n    }\n    onContainerResize() {\n        super.onContainerResize();\n        this.updateTicksBar();\n        this._canvas.size = this.containerSize;\n    }\n    getVOIMultipliers() {\n        return [DEFAULTS.MULTIPLIER, DEFAULTS.MULTIPLIER];\n    }\n    onVoiChange(voiRange) {\n    }\n    showTicks() {\n        this.updateTicksBar();\n        this._ticksBar.visible = true;\n    }\n    hideTicks() {\n        if (this._isInteracting || this._isMouseOver) {\n            return;\n        }\n        this._ticksBar.visible = false;\n    }\n    static getColormapsMap(props) {\n        const { colormaps } = props;\n        return colormaps.reduce((items, item) => items.set(item.Name, item), new Map());\n    }\n    static getInitialColormapName(props) {\n        const { activeColormapName, colormaps } = props;\n        const colormapExists = !!activeColormapName &&\n            colormaps.some((cm) => cm.Name === activeColormapName);\n        return colormapExists ? activeColormapName : colormaps[0].Name;\n    }\n    _createCanvas(props) {\n        const { imageRange, voiRange, showFullPixelValueRange } = props;\n        const colormap = this._colormaps.get(this._activeColormapName);\n        return new ColorbarCanvas({\n            colormap,\n            imageRange,\n            voiRange: voiRange,\n            showFullPixelValueRange,\n        });\n    }\n    _createTicksBar(props) {\n        const ticksProps = props.ticks;\n        return new ColorbarTicks({\n            imageRange: props.imageRange,\n            voiRange: props.voiRange,\n            ticks: ticksProps,\n            showFullPixelValueRange: props.showFullPixelValueRange,\n        });\n    }\n    _getPointsFromMouseEvent(evt) {\n        const { rootElement: element } = this;\n        const clientPoint = [evt.clientX, evt.clientY];\n        const pagePoint = [evt.pageX, evt.pageY];\n        const rect = element.getBoundingClientRect();\n        const localPoints = [\n            pagePoint[0] - rect.left - window.pageXOffset,\n            pagePoint[1] - rect.top - window.pageYOffset,\n        ];\n        return { client: clientPoint, page: pagePoint, local: localPoints };\n    }\n    updateTicksBar() {\n        const { width: containerWidth, height: containerHeight } = this.containerSize;\n        if (containerWidth === 0 && containerHeight === 0) {\n            return;\n        }\n        const { _ticksBar: ticksBar, _rangeTextPosition: rangeTextPosition } = this;\n        const isHorizontal = containerWidth >= containerHeight;\n        const width = isHorizontal ? containerWidth : DEFAULTS.TICKS_BAR_SIZE;\n        const height = isHorizontal ? DEFAULTS.TICKS_BAR_SIZE : containerHeight;\n        if (!isRangeTextPositionValid(containerWidth, containerHeight, rangeTextPosition)) {\n            throw new Error('Invalid rangeTextPosition value for the current colobar orientation');\n        }\n        let ticksBarTop;\n        let ticksBarLeft;\n        ticksBar.size = { width, height };\n        if (isHorizontal) {\n            ticksBarLeft = 0;\n            ticksBarTop =\n                rangeTextPosition === ColorbarRangeTextPosition.Top\n                    ? -height\n                    : containerHeight;\n        }\n        else {\n            ticksBarTop = 0;\n            ticksBarLeft =\n                rangeTextPosition === ColorbarRangeTextPosition.Left\n                    ? -width\n                    : containerWidth;\n        }\n        ticksBar.top = ticksBarTop;\n        ticksBar.left = ticksBarLeft;\n    }\n    _addRootElementEventListeners() {\n        const { _eventListenersManager: manager } = this;\n        const { rootElement: element } = this;\n        manager.addEventListener(element, 'mouseover', this._mouseOverCallback);\n        manager.addEventListener(element, 'mouseout', this._mouseOutCallback);\n        manager.addEventListener(element, 'mousedown', this._mouseDownCallback);\n    }\n    _addVOIEventListeners(evt) {\n        const { _eventListenersManager: manager } = this;\n        const points = this._getPointsFromMouseEvent(evt);\n        const voiRange = { ...this._canvas.voiRange };\n        const initialDragState = { points, voiRange };\n        this._removeVOIEventListeners();\n        manager.addEventListener(document, 'voi.mouseup', this._mouseUpCallback);\n        manager.addEventListener(document, 'voi.mousemove', (evt) => this._mouseDragCallback(evt, initialDragState));\n    }\n    _removeVOIEventListeners() {\n        const { _eventListenersManager: manager } = this;\n        manager.removeEventListener(document, 'voi.mouseup');\n        manager.removeEventListener(document, 'voi.mousemove');\n    }\n}\nexport { Colorbar as default, Colorbar };\n", "import { utilities as csUtils } from '@cornerstonejs/core';\nimport { isViewportPreScaled } from './viewport';\nconst DEFAULT_MULTIPLIER = 4;\nfunction getVOIMultipliers(viewport, volumeId, options) {\n    const modality = csUtils.getViewportModality(viewport, volumeId);\n    if (modality === 'PT') {\n        const { clientWidth, clientHeight } = viewport.element;\n        const ptMultiplier = 5 / Math.max(clientWidth, clientHeight);\n        const isPreScaled = isViewportPreScaled(viewport, volumeId);\n        const { fixedPTWindowWidth = true } = options ?? {};\n        const xMultiplier = fixedPTWindowWidth ? 0 : ptMultiplier;\n        return isPreScaled\n            ? [xMultiplier, ptMultiplier]\n            : [xMultiplier, DEFAULT_MULTIPLIER];\n    }\n    return [DEFAULT_MULTIPLIER, DEFAULT_MULTIPLIER];\n}\nexport { getVOIMultipliers as default, getVOIMultipliers };\n", "import { eventTarget, VolumeViewport, StackViewport, Enums, utilities, getEnabledElement, cache, } from '@cornerstonejs/core';\nimport { Colorbar } from './Colorbar';\nimport { getVOIMultipliers } from '../../getVOIMultipliers';\nconst { Events } = Enums;\nconst defaultImageRange = { lower: -1000, upper: 1000 };\nclass ViewportColorbar extends Colorbar {\n    constructor(props) {\n        const { element, volumeId } = props;\n        const imageRange = ViewportColorbar._getImageRange(element, volumeId);\n        const voiRange = ViewportColorbar._getVOIRange(element, volumeId);\n        super({ ...props, imageRange, voiRange });\n        this.autoHideTicks = () => {\n            if (this._hideTicksTimeoutId) {\n                return;\n            }\n            const timeLeft = this._hideTicksTime - Date.now();\n            if (timeLeft <= 0) {\n                this.hideTicks();\n            }\n            else {\n                this._hideTicksTimeoutId = window.setTimeout(() => {\n                    this._hideTicksTimeoutId = 0;\n                    this.autoHideTicks();\n                }, timeLeft);\n            }\n        };\n        this._stackNewImageCallback = () => {\n            this.imageRange = ViewportColorbar._getImageRange(this._element);\n        };\n        this._imageVolumeModifiedCallback = (evt) => {\n            const { volumeId } = evt.detail;\n            if (volumeId !== this._volumeId) {\n                return;\n            }\n            const { _element: element } = this;\n            this.imageRange = ViewportColorbar._getImageRange(element, volumeId);\n        };\n        this._viewportVOIModifiedCallback = (evt) => {\n            const { viewportId, volumeId, range: voiRange, colormap } = evt.detail;\n            const { viewport } = this.enabledElement;\n            if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n                return;\n            }\n            this.voiRange = voiRange;\n            if (colormap) {\n                this.activeColormapName = colormap.name;\n            }\n            this.showAndAutoHideTicks();\n        };\n        this._viewportColormapModifiedCallback = (evt) => {\n            const { viewportId, colormap, volumeId } = evt.detail;\n            const { viewport } = this.enabledElement;\n            if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n                return;\n            }\n            this.activeColormapName = colormap.name;\n        };\n        this._element = element;\n        this._volumeId = volumeId;\n        this._addCornerstoneEventListener();\n    }\n    get element() {\n        return this._element;\n    }\n    get enabledElement() {\n        return getEnabledElement(this._element);\n    }\n    getVOIMultipliers() {\n        const { viewport } = this.enabledElement;\n        return getVOIMultipliers(viewport, this._volumeId);\n    }\n    onVoiChange(voiRange) {\n        super.onVoiChange(voiRange);\n        const { viewport } = this.enabledElement;\n        if (viewport instanceof StackViewport) {\n            viewport.setProperties({\n                voiRange: voiRange,\n            });\n            viewport.render();\n        }\n        else if (viewport instanceof VolumeViewport) {\n            const { _volumeId: volumeId } = this;\n            const viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(volumeId);\n            viewport.setProperties({ voiRange }, volumeId);\n            viewportsContainingVolumeUID.forEach((vp) => vp.render());\n        }\n    }\n    static _getImageRange(element, volumeId) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const actor = viewport.getImageActor(volumeId);\n        if (!actor) {\n            return defaultImageRange;\n        }\n        const imageData = actor.getMapper().getInputData();\n        const scalarData = imageData.getPointData().getScalars();\n        let imageRange;\n        if (!scalarData) {\n            if (!volumeId) {\n                throw new Error('volumeId is required when scalarData is not available');\n            }\n            const volume = cache.getVolume(volumeId);\n            const [minValue, maxValue] = volume.voxelManager.getRange();\n            imageRange = [minValue, maxValue];\n        }\n        else {\n            imageRange = scalarData.getRange();\n        }\n        return imageRange[0] === 0 && imageRange[1] === 0\n            ? defaultImageRange\n            : { lower: imageRange[0], upper: imageRange[1] };\n    }\n    static _getVOIRange(element, volumeId) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const actor = viewport.getImageActor(volumeId);\n        if (!actor) {\n            return defaultImageRange;\n        }\n        const voiRange = actor.getProperty().getRGBTransferFunction(0).getRange();\n        return voiRange[0] === 0 && voiRange[1] === 0\n            ? defaultImageRange\n            : { lower: voiRange[0], upper: voiRange[1] };\n    }\n    showAndAutoHideTicks(interval = 1000) {\n        this._hideTicksTime = Date.now() + interval;\n        this.showTicks();\n        this.autoHideTicks();\n    }\n    _addCornerstoneEventListener() {\n        const { _element: element } = this;\n        eventTarget.addEventListener(Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedCallback);\n        element.addEventListener(Events.STACK_NEW_IMAGE, this._stackNewImageCallback);\n        element.addEventListener(Events.VOI_MODIFIED, this._viewportVOIModifiedCallback);\n        element.addEventListener(Events.COLORMAP_MODIFIED, this._viewportColormapModifiedCallback);\n    }\n    destroy() {\n        super.destroy();\n        const { _element: element } = this;\n        eventTarget.removeEventListener(Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedCallback);\n        element.removeEventListener(Events.STACK_NEW_IMAGE, this._stackNewImageCallback);\n        element.removeEventListener(Events.VOI_MODIFIED, this._viewportVOIModifiedCallback);\n        element.removeEventListener(Events.COLORMAP_MODIFIED, this._viewportColormapModifiedCallback);\n    }\n}\nexport { ViewportColorbar as default, ViewportColorbar };\n", "import { getLuminanceFromRegion } from './getLuminanceFromRegion';\nimport { calculateMinMaxMean } from './calculateMinMaxMean';\nimport { extractWindowLevelRegionToolData } from './extractWindowLevelRegionToolData';\nexport { getLuminanceFromRegion, calculateMinMaxMean, extractWindowLevelRegionToolData, };\n", "function getLuminanceFromRegion(imageData, x, y, width, height) {\n    const luminance = [];\n    let index = 0;\n    const pixelData = imageData.scalarData;\n    let spIndex, row, column;\n    if (imageData.color) {\n        for (row = 0; row < height; row++) {\n            for (column = 0; column < width; column++) {\n                spIndex = ((row + y) * imageData.columns + (column + x)) * 4;\n                const red = pixelData[spIndex];\n                const green = pixelData[spIndex + 1];\n                const blue = pixelData[spIndex + 2];\n                luminance[index++] = 0.2126 * red + 0.7152 * green + 0.0722 * blue;\n            }\n        }\n    }\n    else {\n        for (row = 0; row < height; row++) {\n            for (column = 0; column < width; column++) {\n                spIndex = (row + y) * imageData.columns + (column + x);\n                luminance[index++] = pixelData[spIndex];\n            }\n        }\n    }\n    return luminance;\n}\nexport { getLuminanceFromRegion };\n", "function calculateMinMaxMean(pixelLuminance, globalMin, globalMax) {\n    const numPixels = pixelLuminance.length;\n    let min = globalMax;\n    let max = globalMin;\n    let sum = 0;\n    if (numPixels < 2) {\n        return {\n            min,\n            max,\n            mean: (globalMin + globalMax) / 2,\n        };\n    }\n    for (let index = 0; index < numPixels; index++) {\n        const spv = pixelLuminance[index];\n        min = Math.min(min, spv);\n        max = Math.max(max, spv);\n        sum += spv;\n    }\n    return {\n        min,\n        max,\n        mean: sum / numPixels,\n    };\n}\nexport { calculateMinMaxMean };\n", "import { utilities as csUtils, StackViewport, VolumeViewport, } from '@cornerstonejs/core';\nfunction extractWindowLevelRegionToolData(viewport) {\n    if (viewport instanceof VolumeViewport) {\n        return extractImageDataVolume(viewport);\n    }\n    if (viewport instanceof StackViewport) {\n        return extractImageDataStack(viewport);\n    }\n    throw new Error('Viewport not supported');\n}\nfunction extractImageDataVolume(viewport) {\n    const { scalarData, width, height } = csUtils.getCurrentVolumeViewportSlice(viewport);\n    const { min: minPixelValue, max: maxPixelValue } = csUtils.getMinMax(scalarData);\n    return {\n        scalarData,\n        minPixelValue,\n        maxPixelValue,\n        width,\n        height,\n        rows: width,\n        columns: height,\n    };\n}\nfunction extractImageDataStack(viewport) {\n    const imageData = viewport.getImageData();\n    const { scalarData } = imageData;\n    const { min: minPixelValue, max: maxPixelValue } = csUtils.getMinMax(scalarData);\n    const width = imageData.dimensions[0];\n    const height = imageData.dimensions[1];\n    const { rows, columns, color } = viewport.getCornerstoneImage();\n    return {\n        scalarData,\n        width,\n        height,\n        minPixelValue,\n        maxPixelValue,\n        rows,\n        columns,\n        color,\n    };\n}\nexport { extractWindowLevelRegionToolData };\n", "import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { pointInSphere } from './math/sphere';\nimport { getBoundingBoxAroundShape } from './boundingBox';\nconst { transformWorldToIndex } = csUtils;\nexport function pointInSurroundingSphereCallback(imageData, circlePoints, callback, viewport) {\n    const { boundsIJK, centerWorld, radiusWorld } = _getBounds(circlePoints, imageData, viewport);\n    const sphereObj = {\n        center: centerWorld,\n        radius: radiusWorld,\n    };\n    const dimensions = imageData.getDimensions();\n    const voxelManager = csUtils.VoxelManager.createScalarVolumeVoxelManager({\n        dimensions: dimensions,\n        scalarData: imageData.getPointData().getScalars().getData(),\n    });\n    voxelManager.forEach(callback, {\n        boundsIJK,\n        isInObject: (pointLPS) => pointInSphere(sphereObj, pointLPS),\n        imageData,\n    });\n}\nfunction _getBounds(circlePoints, imageData, viewport) {\n    const [bottom, top] = circlePoints;\n    const centerWorld = vec3.fromValues((bottom[0] + top[0]) / 2, (bottom[1] + top[1]) / 2, (bottom[2] + top[2]) / 2);\n    const radiusWorld = vec3.distance(bottom, top) / 2;\n    let boundsIJK;\n    if (!viewport) {\n        const centerIJK = transformWorldToIndex(imageData, centerWorld);\n        const spacings = imageData.getSpacing();\n        const minSpacing = Math.min(...spacings);\n        const maxRadiusIJK = Math.ceil(radiusWorld / minSpacing);\n        boundsIJK = [\n            [centerIJK[0] - maxRadiusIJK, centerIJK[0] + maxRadiusIJK],\n            [centerIJK[1] - maxRadiusIJK, centerIJK[1] + maxRadiusIJK],\n            [centerIJK[2] - maxRadiusIJK, centerIJK[2] + maxRadiusIJK],\n        ];\n        return {\n            boundsIJK,\n            centerWorld: centerWorld,\n            radiusWorld,\n        };\n    }\n    boundsIJK = _computeBoundsIJKWithCamera(imageData, viewport, circlePoints, centerWorld, radiusWorld);\n    return {\n        boundsIJK,\n        centerWorld: centerWorld,\n        radiusWorld,\n    };\n}\nfunction _computeBoundsIJKWithCamera(imageData, viewport, circlePoints, centerWorld, radiusWorld) {\n    const [bottom, top] = circlePoints;\n    const dimensions = imageData.getDimensions();\n    const camera = viewport.getCamera();\n    const viewUp = vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);\n    const viewPlaneNormal = vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const topLeftWorld = vec3.create();\n    const bottomRightWorld = vec3.create();\n    vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\n    vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\n    const sphereCornersIJK = [\n        transformWorldToIndex(imageData, topLeftWorld),\n        (transformWorldToIndex(imageData, bottomRightWorld)),\n    ];\n    const boundsIJK = getBoundingBoxAroundShape(sphereCornersIJK, dimensions);\n    return boundsIJK;\n}\n", "function validate3x3Matrix(matrix) {\n    if (!Array.isArray(matrix) || matrix.length !== 9) {\n        throw new Error('Matrix must be an array of 9 numbers');\n    }\n    if (!matrix.every((n) => typeof n === 'number' && !isNaN(n))) {\n        throw new Error('Matrix must contain only valid numbers');\n    }\n}\nexport function inverse3x3Matrix(matrix) {\n    validate3x3Matrix(matrix);\n    const mat = [\n        [matrix[0], matrix[1], matrix[2]],\n        [matrix[3], matrix[4], matrix[5]],\n        [matrix[6], matrix[7], matrix[8]],\n    ];\n    const determinant = mat[0][0] * (mat[1][1] * mat[2][2] - mat[1][2] * mat[2][1]) -\n        mat[0][1] * (mat[1][0] * mat[2][2] - mat[1][2] * mat[2][0]) +\n        mat[0][2] * (mat[1][0] * mat[2][1] - mat[1][1] * mat[2][0]);\n    if (Math.abs(determinant) < 1e-10) {\n        throw new Error('Matrix is not invertible (determinant is zero)');\n    }\n    const adjugate = [\n        [\n            mat[1][1] * mat[2][2] - mat[1][2] * mat[2][1],\n            -(mat[0][1] * mat[2][2] - mat[0][2] * mat[2][1]),\n            mat[0][1] * mat[1][2] - mat[0][2] * mat[1][1],\n        ],\n        [\n            -(mat[1][0] * mat[2][2] - mat[1][2] * mat[2][0]),\n            mat[0][0] * mat[2][2] - mat[0][2] * mat[2][0],\n            -(mat[0][0] * mat[1][2] - mat[0][2] * mat[1][0]),\n        ],\n        [\n            mat[1][0] * mat[2][1] - mat[1][1] * mat[2][0],\n            -(mat[0][0] * mat[2][1] - mat[0][1] * mat[2][0]),\n            mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0],\n        ],\n    ];\n    const inverse = [];\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            inverse.push(adjugate[i][j] / determinant);\n        }\n    }\n    return inverse;\n}\nfunction normalizeVector(v) {\n    const magnitude = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\n    return v.map((component) => component / magnitude);\n}\nexport function checkStandardBasis(directions) {\n    validate3x3Matrix(directions);\n    const xVector = directions.slice(0, 3);\n    const yVector = directions.slice(3, 6);\n    const zVector = directions.slice(6, 9);\n    const normalizedX = normalizeVector(xVector);\n    const normalizedY = normalizeVector(yVector);\n    const normalizedZ = normalizeVector(zVector);\n    const standardBasis = {\n        x: [1, 0, 0],\n        y: [0, 1, 0],\n        z: [0, 0, 1],\n    };\n    const epsilon = 1e-10;\n    const isStandard = normalizedX.every((val, i) => Math.abs(val - standardBasis.x[i]) < epsilon) &&\n        normalizedY.every((val, i) => Math.abs(val - standardBasis.y[i]) < epsilon) &&\n        normalizedZ.every((val, i) => Math.abs(val - standardBasis.z[i]) < epsilon);\n    const rotationMatrix = isStandard\n        ? [...standardBasis.x, ...standardBasis.y, ...standardBasis.z]\n        : inverse3x3Matrix([...normalizedX, ...normalizedY, ...normalizedZ]);\n    return {\n        isStandard,\n        rotationMatrix,\n    };\n}\nfunction rotatePoint(point, origin, rotationMatrix) {\n    const x = point[0] - origin[0];\n    const y = point[1] - origin[1];\n    const z = point[2] - origin[2];\n    return [\n        rotationMatrix[0] * x +\n            rotationMatrix[1] * y +\n            rotationMatrix[2] * z +\n            origin[0],\n        rotationMatrix[3] * x +\n            rotationMatrix[4] * y +\n            rotationMatrix[5] * z +\n            origin[1],\n        rotationMatrix[6] * x +\n            rotationMatrix[7] * y +\n            rotationMatrix[8] * z +\n            origin[2],\n    ];\n}\nexport function rotatePoints(rotationMatrix, origin, points) {\n    const rotatedPoints = [];\n    for (let i = 0; i < points.length; i += 3) {\n        const point = points.slice(i, i + 3);\n        const rotated = rotatePoint(point, origin, rotationMatrix);\n        rotatedPoints.push(...rotated);\n    }\n    return rotatedPoints;\n}\n", "import { triggerAnnotationModified } from '../stateManagement/annotation/helpers/state';\nimport { ChangeTypes } from '../enums';\nexport default function setAnnotationLabel(annotation, element, updatedLabel) {\n    annotation.data.label = updatedLabel;\n    triggerAnnotationModified(annotation, element, ChangeTypes.LabelChange);\n}\n", "import { StackViewport } from '@cornerstonejs/core';\nimport * as vec3 from 'gl-matrix/vec3';\nexport function moveAnnotationToViewPlane(annotation, viewport) {\n    const { data } = annotation;\n    const { points } = data.handles;\n    const { focalPoint, viewPlaneNormal } = viewport.getCamera();\n    const projectedDistance = vec3.dot(vec3.sub(vec3.create(), points[0], focalPoint), viewPlaneNormal);\n    points.forEach((point) => {\n        vec3.add(point, point, vec3.scale(vec3.create(), [-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]], projectedDistance));\n    });\n    if (viewport instanceof StackViewport) {\n        annotation.metadata.referencedImageId = viewport.getCurrentImageId();\n    }\n    return annotation;\n}\n", "import { cache } from '@cornerstonejs/core';\nimport { segmentLargestUSOutlineFromBuffer } from './segmentLargestUSOutlineFromBuffer';\nimport { generateConvexHullFromContour } from './generateConvexHullFromContour';\nimport { calculateFanShapeCorners } from './calculateFanShapeCorners';\nimport { deriveFanGeometry } from './deriveFanGeometry';\nexport function exportContourJpeg(pixelData, width, height, contour, opts = {}) {\n    const { strokeStyle = '#f00', lineWidth = 2, quality = 0.92 } = opts;\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    const totalPixels = width * height;\n    const channels = pixelData.length / totalPixels;\n    const imgData = ctx.createImageData(width, height);\n    const out = imgData.data;\n    for (let i = 0; i < totalPixels; i++) {\n        const baseIn = i * channels;\n        const baseOut = i * 4;\n        if (channels === 1) {\n            const v = pixelData[baseIn];\n            out[baseOut] = v;\n            out[baseOut + 1] = v;\n            out[baseOut + 2] = v;\n            out[baseOut + 3] = 255;\n        }\n        else {\n            out[baseOut] = pixelData[baseIn];\n            out[baseOut + 1] = pixelData[baseIn + 1];\n            out[baseOut + 2] = pixelData[baseIn + 2];\n            out[baseOut + 3] = channels === 4 ? pixelData[baseIn + 3] : 255;\n        }\n    }\n    ctx.putImageData(imgData, 0, 0);\n    if (contour.length > 0) {\n        ctx.strokeStyle = strokeStyle;\n        ctx.lineWidth = lineWidth;\n        ctx.beginPath();\n        ctx.moveTo(contour[0][0] + 0.5, contour[0][1] + 0.5);\n        for (let i = 1; i < contour.length; i++) {\n            ctx.lineTo(contour[i][0] + 0.5, contour[i][1] + 0.5);\n        }\n        ctx.closePath();\n        ctx.stroke();\n    }\n    return canvas.toDataURL('image/jpeg', quality);\n}\nexport function getPixelData(imageId) {\n    const image = cache.getImage(imageId);\n    if (!image) {\n        return;\n    }\n    const width = image.width;\n    const height = image.height;\n    const pixelData = image.getPixelData();\n    return {\n        pixelData,\n        width,\n        height,\n    };\n}\nexport default function saveBinaryData(url, filename) {\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = filename;\n    document.body.appendChild(a);\n    a.style.display = 'none';\n    a.click();\n    a.remove();\n}\nfunction exportFanJpeg(pixelData, width, height, fan, opts = {}) {\n    const { center, startAngle: startAngleInDegrees, endAngle: endAngleInDegrees, innerRadius, outerRadius, } = fan;\n    const { strokeStyle = '#0ff', lineWidth = 2, quality = 0.92 } = opts;\n    const startAngle = (startAngleInDegrees * Math.PI) / 180;\n    const endAngle = (endAngleInDegrees * Math.PI) / 180;\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    const total = width * height;\n    const channels = pixelData.length / total;\n    const imgData = ctx.createImageData(width, height);\n    const out = imgData.data;\n    for (let i = 0; i < total; i++) {\n        const baseOut = i * 4;\n        if (channels === 1) {\n            const v = pixelData[i];\n            out[baseOut] = v;\n            out[baseOut + 1] = v;\n            out[baseOut + 2] = v;\n            out[baseOut + 3] = 255;\n        }\n        else {\n            const baseIn = i * channels;\n            out[baseOut] = pixelData[baseIn];\n            out[baseOut + 1] = pixelData[baseIn + 1];\n            out[baseOut + 2] = pixelData[baseIn + 2];\n            out[baseOut + 3] = channels === 4 ? pixelData[baseIn + 3] : 255;\n        }\n    }\n    ctx.putImageData(imgData, 0, 0);\n    ctx.beginPath();\n    for (let a = startAngle; a <= endAngle; a += 0.01) {\n        const x = center[0] + innerRadius * Math.cos(a);\n        const y = center[1] + innerRadius * Math.sin(a);\n        if (a === startAngle) {\n            ctx.moveTo(x, y);\n        }\n        else {\n            ctx.lineTo(x, y);\n        }\n    }\n    for (let a = endAngle; a >= startAngle; a -= 0.01) {\n        const x = center[0] + outerRadius * Math.cos(a);\n        const y = center[1] + outerRadius * Math.sin(a);\n        ctx.lineTo(x, y);\n    }\n    ctx.closePath();\n    ctx.strokeStyle = strokeStyle;\n    ctx.lineWidth = lineWidth;\n    ctx.stroke();\n    return canvas.toDataURL('image/jpeg', quality);\n}\nexport function downloadFanJpeg(imageId, contourType = 5) {\n    const { contour, simplified, hull, refined, fanGeometry } = calculateFanGeometry(imageId);\n    const { pixelData, width, height } = getPixelData(imageId) || {};\n    if (!pixelData) {\n        return;\n    }\n    let jpegDataUrl;\n    if (contourType === 1) {\n        jpegDataUrl = exportContourJpeg(pixelData, width, height, contour);\n    }\n    else if (contourType === 2) {\n        jpegDataUrl = exportContourJpeg(pixelData, width, height, simplified);\n    }\n    else if (contourType === 3) {\n        jpegDataUrl = exportContourJpeg(pixelData, width, height, hull);\n    }\n    else if (contourType === 4) {\n        jpegDataUrl = exportContourJpeg(pixelData, width, height, [\n            refined.P1,\n            refined.P2,\n            refined.P3,\n            refined.P4,\n        ]);\n    }\n    else {\n        jpegDataUrl = exportFanJpeg(pixelData, width, height, fanGeometry, {\n            strokeStyle: '#f00',\n            lineWidth: 3,\n            quality: 0.95,\n        });\n    }\n    saveBinaryData(jpegDataUrl, 'contour.jpg');\n}\nexport function calculateFanGeometry(imageId) {\n    const { pixelData, width, height } = getPixelData(imageId) || {};\n    if (!pixelData) {\n        return;\n    }\n    const contour = segmentLargestUSOutlineFromBuffer(pixelData, width, height);\n    const { simplified, hull } = generateConvexHullFromContour(contour);\n    const refined = calculateFanShapeCorners(pixelData, width, height, hull, simplified);\n    const fanGeometry = deriveFanGeometry({\n        P1: refined.P1,\n        P2: refined.P2,\n        P3: refined.P3,\n        P4: refined.P4,\n    });\n    return { contour, simplified, hull, refined, fanGeometry };\n}\n", "import { floodFill } from '../../../../utilities/segmentation';\nexport function segmentLargestUSOutlineFromBuffer(buffer, width, height) {\n    const totalPixels = width * height;\n    const channelCount = buffer.length / totalPixels;\n    if (![1, 3, 4].includes(channelCount)) {\n        throw new Error('Buffer must be 1, 3, or 4 channels per pixel');\n    }\n    const mask = Array.from({ length: height }, () => new Array(width).fill(false));\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            const pixelIndex = y * width + x;\n            const base = pixelIndex * channelCount;\n            let isForeground = false;\n            for (let c = 0; c < Math.min(3, channelCount); c++) {\n                if (buffer[base + c] > 0) {\n                    isForeground = true;\n                    break;\n                }\n            }\n            mask[y][x] = isForeground;\n        }\n    }\n    const labels = Array.from({ length: height }, () => new Array(width).fill(0));\n    let currentLabel = 0;\n    const regionSizes = {};\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            if (mask[y][x] && labels[y][x] === 0) {\n                currentLabel++;\n                const getter = (px, py) => {\n                    if (px < 0 || px >= width || py < 0 || py >= height) {\n                        return false;\n                    }\n                    return mask[py][px] && labels[py][px] === 0;\n                };\n                let pixelCount = 0;\n                const options = {\n                    onFlood: (px, py) => {\n                        labels[py][px] = currentLabel;\n                        pixelCount++;\n                    },\n                    diagonals: false,\n                };\n                floodFill(getter, [x, y], options);\n                regionSizes[currentLabel] = pixelCount;\n            }\n        }\n    }\n    if (currentLabel === 0) {\n        return [];\n    }\n    const largestLabel = Object.keys(regionSizes).reduce((a, b) => regionSizes[a] > regionSizes[b] ? a : b);\n    function isBorder(x, y) {\n        if (labels[y][x] !== +largestLabel) {\n            return false;\n        }\n        for (const [dx, dy] of [\n            [1, 0],\n            [-1, 0],\n            [0, 1],\n            [0, -1],\n        ]) {\n            const nx = x + dx, ny = y + dy;\n            if (nx < 0 ||\n                nx >= width ||\n                ny < 0 ||\n                ny >= height ||\n                labels[ny][nx] !== +largestLabel) {\n                return true;\n            }\n        }\n        return false;\n    }\n    let start = null;\n    outer: for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            if (isBorder(x, y)) {\n                start = [x, y];\n                break outer;\n            }\n        }\n    }\n    if (!start) {\n        return [];\n    }\n    const dirs = [\n        [1, 0],\n        [1, 1],\n        [0, 1],\n        [-1, 1],\n        [-1, 0],\n        [-1, -1],\n        [0, -1],\n        [1, -1],\n    ];\n    const contour = [];\n    let current = start;\n    let prev = [start[0] - 1, start[1]];\n    do {\n        contour.push([current[0], current[1]]);\n        const dx0 = prev[0] - current[0], dy0 = prev[1] - current[1];\n        let startDir = dirs.findIndex((d) => d[0] === dx0 && d[1] === dy0);\n        if (startDir < 0) {\n            startDir = 0;\n        }\n        let nextPt = null;\n        for (let k = 1; k <= 8; k++) {\n            const [dx, dy] = dirs[(startDir + k) % 8];\n            const nx = current[0] + dx, ny = current[1] + dy;\n            if (nx >= 0 && nx < width && ny >= 0 && ny < height && isBorder(nx, ny)) {\n                nextPt = [nx, ny];\n                const [bdx, bdy] = dirs[(startDir + k - 1 + 8) % 8];\n                prev = [current[0] + bdx, current[1] + bdy];\n                break;\n            }\n        }\n        if (!nextPt) {\n            break;\n        }\n        current = nextPt;\n    } while (current[0] !== start[0] || current[1] !== start[1]);\n    return contour;\n}\n", "import * as math from '../../../../utilities/math';\nexport function generateConvexHullFromContour(contour) {\n    const simplified = math.polyline.decimate(contour, 2);\n    const hull = math.polyline.convexHull(simplified);\n    return { simplified, hull };\n}\n", "export function pickPoints(hull, slack = 7) {\n    if (!hull.length) {\n        throw new Error('Convex hull is empty');\n    }\n    const n = hull.length;\n    const next = (i) => (i + 1) % n;\n    const walk = (from, to) => {\n        const idx = [];\n        for (let i = from;; i = next(i)) {\n            idx.push(i);\n            if (i === to) {\n                break;\n            }\n        }\n        return idx;\n    };\n    let i2 = 0, i3 = 0;\n    for (let i = 1; i < n; i++) {\n        if (hull[i][0] < hull[i2][0]) {\n            i2 = i;\n        }\n        if (hull[i][0] > hull[i3][0]) {\n            i3 = i;\n        }\n    }\n    const P2 = hull[i2];\n    const P3 = hull[i3];\n    const pathA = walk(i2, i3);\n    const pathB = walk(i3, i2);\n    const globalYmin = Math.min(...hull.map((p) => p[1]));\n    const upperPath = pathA.some((i) => hull[i][1] === globalYmin)\n        ? pathA\n        : pathB;\n    const topY = Math.min(...upperPath.map((i) => hull[i][1]));\n    let arcPts = upperPath\n        .map((i) => hull[i])\n        .filter((p) => Math.abs(p[1] - topY) <= slack);\n    if (arcPts.length < 2) {\n        arcPts = upperPath\n            .map((i) => hull[i])\n            .sort((a, b) => a[1] - b[1])\n            .slice(0, 2);\n    }\n    const P1 = arcPts.reduce((best, p) => (p[0] < best[0] ? p : best), arcPts[0]);\n    const P4 = arcPts.reduce((best, p) => (p[0] > best[0] ? p : best), arcPts[0]);\n    return { P1, P2, P3, P4 };\n}\nexport function computeEdgeBuffer(buffer, width, height) {\n    const total = width * height;\n    const channels = buffer.length / total;\n    if (![1, 3, 4].includes(channels)) {\n        throw new Error('Buffer must be 1,3 or 4 channels per pixel');\n    }\n    const gray = new Float32Array(total);\n    for (let i = 0; i < total; i++) {\n        if (channels === 1) {\n            gray[i] = buffer[i];\n        }\n        else {\n            const base = i * channels;\n            const r = buffer[base];\n            const g = buffer[base + 1];\n            const b = buffer[base + 2];\n            gray[i] = 0.299 * r + 0.587 * g + 0.114 * b;\n        }\n    }\n    const edgeBuf = new Float32Array(total);\n    for (let y = 1; y < height - 1; y++) {\n        for (let x = 1; x < width - 1; x++) {\n            const idx = y * width + x;\n            const i00 = idx - width - 1;\n            const i01 = idx - width;\n            const i02 = idx - width + 1;\n            const i10 = idx - 1;\n            const i11 = idx;\n            const i12 = idx + 1;\n            const i20 = idx + width - 1;\n            const i21 = idx + width;\n            const i22 = idx + width + 1;\n            const gx = -gray[i00] +\n                gray[i02] +\n                -2 * gray[i10] +\n                2 * gray[i12] +\n                -gray[i20] +\n                gray[i22];\n            const gy = gray[i00] +\n                2 * gray[i01] +\n                gray[i02] -\n                gray[i20] -\n                2 * gray[i21] -\n                gray[i22];\n            edgeBuf[idx] = Math.hypot(gx, gy);\n        }\n    }\n    return edgeBuf;\n}\nexport function refineCornersDirectional(edgeBuf, width, height, rough, contour, opts = {}) {\n    const { maxDist = 15, slack = 2 } = opts;\n    const directions = {\n        P1: { dx: -1, dy: -1 },\n        P2: { dx: -1, dy: +1 },\n        P3: { dx: +1, dy: +1 },\n        P4: { dx: +1, dy: -1 },\n    };\n    function snapQuadrant(pt, { dx, dy }, threshold = 5) {\n        const xmin = dx < 0 ? pt[0] - maxDist : pt[0] - slack;\n        const xmax = dx < 0 ? pt[0] + slack : pt[0] + maxDist;\n        const ymin = dy < 0 ? pt[1] - maxDist : pt[1] - slack;\n        const ymax = dy < 0 ? pt[1] + slack : pt[1] + maxDist;\n        let best = pt;\n        for (const [cx, cy] of contour) {\n            if (cx < xmin || cx > xmax || cy < ymin || cy > ymax) {\n                continue;\n            }\n            const xi = Math.round(cx);\n            const yi = Math.round(cy);\n            if (xi < 0 || xi >= width || yi < 0 || yi >= height) {\n                continue;\n            }\n            const xAlign = (xi - best[0]) * dx;\n            const yAlign = (yi - best[0]) * dy;\n            const v = edgeBuf[yi * width + xi];\n            if (v > threshold && (xAlign > 0 || yAlign > 0)) {\n                best = [cx, cy];\n            }\n        }\n        return best;\n    }\n    return {\n        P1: snapQuadrant(rough.P1, directions.P1),\n        P2: snapQuadrant(rough.P2, directions.P2),\n        P3: snapQuadrant(rough.P3, directions.P3),\n        P4: snapQuadrant(rough.P4, directions.P4),\n    };\n}\nexport function calculateFanShapeCorners(imageBuffer, width, height, hull, roughContour) {\n    const rough = pickPoints(hull);\n    const refined = refineCornersDirectional(imageBuffer, width, height, rough, roughContour, {\n        maxDist: 20,\n        step: 0.5,\n    });\n    return refined;\n}\n", "import { intersectLine } from '../../../../utilities/math/line';\nfunction angleRad(center, p) {\n    return Math.atan2(p[1] - center[1], p[0] - center[0]);\n}\nexport function deriveFanGeometry(params) {\n    const { P1, P2, P3, P4 } = params;\n    const centerResult = intersectLine(P1, P2, P4, P3, true);\n    if (!centerResult) {\n        throw new Error('Fan edges appear parallel — no apex found');\n    }\n    const center = centerResult;\n    let startAngle = angleRad(center, P1) * (180 / Math.PI);\n    let endAngle = angleRad(center, P4) * (180 / Math.PI);\n    if (endAngle <= startAngle) {\n        const tempAngle = startAngle;\n        startAngle = endAngle;\n        endAngle = tempAngle;\n    }\n    const d1 = Math.hypot(P1[0] - center[0], P1[1] - center[1]);\n    const d4 = Math.hypot(P4[0] - center[0], P4[1] - center[1]);\n    const d2 = Math.hypot(P2[0] - center[0], P2[1] - center[1]);\n    const d3 = Math.hypot(P3[0] - center[0], P3[1] - center[1]);\n    const innerRadius = Math.min(d1, d4);\n    const outerRadius = Math.max(d2, d3);\n    return {\n        center,\n        startAngle,\n        endAngle,\n        innerRadius,\n        outerRadius,\n    };\n}\n", "import { init, destroy } from './init';\nimport { addTool, removeTool, ToolGroupManager, SynchronizerManager, Synchronizer, cancelActiveManipulations, } from './store';\nimport { state } from './store/state';\nimport * as store from './store';\nimport * as CONSTANTS from './constants';\nimport { version } from './version';\nimport * as synchronizers from './synchronizers';\nimport * as drawing from './drawingSvg';\nimport * as utilities from './utilities';\nimport * as cursors from './cursors';\nimport * as Types from './types';\nimport * as annotation from './stateManagement/annotation';\nimport * as segmentation from './stateManagement/segmentation';\nimport * as splines from './tools/annotation/splines';\nimport { BaseTool, AnnotationTool, AnnotationDisplayTool, PanTool, TrackballRotateTool, VolumeCroppingTool, VolumeCroppingControlTool, DragProbeTool, WindowLevelTool, ZoomTool, StackScrollTool, SegmentBidirectionalTool, PlanarRotateTool, MIPJumpToClickTool, LabelTool, LengthTool, HeightTool, ProbeTool, RectangleROITool, EllipticalROITool, CircleROITool, ETDRSGridTool, SplineROITool, SplineContourSegmentationTool, BidirectionalTool, PlanarFreehandROITool, PlanarFreehandContourSegmentationTool, LivewireContourTool, LivewireContourSegmentationTool, ArrowAnnotateTool, KeyImageTool, CrosshairsTool, ReferenceLinesTool, RectangleScissorsTool, CircleScissorsTool, SphereScissorsTool, RectangleROIThresholdTool, RectangleROIStartEndThresholdTool, CircleROIStartEndThresholdTool, BrushTool, AngleTool, CobbAngleTool, UltrasoundDirectionalTool, UltrasoundPleuraBLineTool, MagnifyTool, AdvancedMagnifyTool, ReferenceCursors, PaintFillTool, ScaleOverlayTool, OrientationMarkerTool, OverlayGridTool, SegmentationIntersectionTool, EraserTool, SculptorTool, SegmentSelectTool, WindowLevelRegionTool, VolumeRotateTool, RegionSegmentPlusTool, RegionSegmentTool, WholeBodySegmentTool, LabelmapBaseTool, SegmentLabelTool, LabelMapEditWithContourTool, } from './tools';\nimport VideoRedactionTool from './tools/annotation/VideoRedactionTool';\nimport * as Enums from './enums';\nexport { VideoRedactionTool, init, destroy, addTool, removeTool, cancelActiveManipulations, BaseTool, AnnotationTool, AnnotationDisplayTool, PanTool, SegmentBidirectionalTool, TrackballRotateTool, VolumeCroppingTool, VolumeCroppingControlTool, DragProbeTool, WindowLevelTool, WindowLevelRegionTool, ZoomTool, StackScrollTool, PlanarRotateTool, MIPJumpToClickTool, LabelTool, LengthTool, HeightTool, CrosshairsTool, ReferenceLinesTool, OverlayGridTool, SegmentationIntersectionTool, ProbeTool, RectangleROITool, EllipticalROITool, CircleROITool, ETDRSGridTool, SplineROITool, SplineContourSegmentationTool, BidirectionalTool, PlanarFreehandROITool, PlanarFreehandContourSegmentationTool, LivewireContourTool, LivewireContourSegmentationTool, ArrowAnnotateTool, AngleTool, CobbAngleTool, UltrasoundDirectionalTool, UltrasoundPleuraBLineTool, KeyImageTool, MagnifyTool, AdvancedMagnifyTool, ReferenceCursors, ScaleOverlayTool, SculptorTool, EraserTool, RectangleScissorsTool, CircleScissorsTool, SphereScissorsTool, RectangleROIThresholdTool, RectangleROIStartEndThresholdTool, CircleROIStartEndThresholdTool, BrushTool, OrientationMarkerTool, SegmentSelectTool, SegmentLabelTool, synchronizers, Synchronizer, SynchronizerManager, PaintFillTool, Types, state, ToolGroupManager, store, Enums, CONSTANTS, drawing, annotation, segmentation, utilities, cursors, VolumeRotateTool, RegionSegmentPlusTool, RegionSegmentTool, WholeBodySegmentTool, LabelmapBaseTool, LabelMapEditWithContourTool, splines, version, };\n", "import { removeContourRepresentation, removeLabelmapRepresentation, removeSegmentationRepresentation, removeSurfaceRepresentation, removeSegmentationRepresentations, removeAllSegmentationRepresentations, } from './removeSegmentationRepresentations';\nimport { addContourRepresentationToViewport, addContourRepresentationToViewportMap, addSurfaceRepresentationToViewport, addSurfaceRepresentationToViewportMap, addLabelmapRepresentationToViewport, addLabelmapRepresentationToViewportMap, addSegmentationRepresentations, } from './addSegmentationRepresentationsToViewport';\nimport { addSegmentations } from './addSegmentations';\nimport addRepresentationData from './internalAddRepresentationData';\nimport { updateSegmentations } from './updateSegmentations';\nimport * as activeSegmentation from './activeSegmentation';\nimport * as segmentLocking from './segmentLocking';\nimport * as state from './segmentationState';\nimport * as config from './config';\nimport * as segmentIndex from './segmentIndex';\nimport * as triggerSegmentationEvents from './triggerSegmentationEvents';\nimport * as utilities from './utilities';\nimport { convertStackToVolumeLabelmap } from './helpers/convertStackToVolumeLabelmap';\nimport { computeVolumeLabelmapFromStack } from './helpers/computeVolumeLabelmapFromStack';\nimport { clearSegmentValue } from './helpers/clearSegmentValue';\nimport { convertVolumeToStackLabelmap } from './helpers/computeStackLabelmapFromVolume';\nimport { removeSegment } from './removeSegment';\nimport { getLabelmapImageIds } from './getLabelmapImageIds';\nimport * as strategies from './../../tools/segmentation/strategies';\nimport { removeAllSegmentations, removeSegmentation, } from './removeSegmentation';\nimport { segmentationStyle } from './SegmentationStyle';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { getCurrentLabelmapImageIdsForViewport, getLabelmapImageIdsForImageId, } from './getCurrentLabelmapImageIdForViewport';\nimport { getActiveSegmentation } from './getActiveSegmentation';\nconst helpers = {\n    clearSegmentValue,\n    convertStackToVolumeLabelmap,\n    computeVolumeLabelmapFromStack,\n    convertVolumeToStackLabelmap,\n};\nexport { removeSegmentationRepresentation, removeContourRepresentation, removeLabelmapRepresentation, removeSurfaceRepresentation, removeAllSegmentations, removeSegmentation, removeSegmentationRepresentations, addLabelmapRepresentationToViewport, addLabelmapRepresentationToViewportMap, addSegmentationRepresentations, removeAllSegmentationRepresentations, addContourRepresentationToViewport, addContourRepresentationToViewportMap, addSurfaceRepresentationToViewport, addSurfaceRepresentationToViewportMap, addSegmentations, updateSegmentations, state, activeSegmentation, segmentLocking, config, segmentIndex, triggerSegmentationEvents, utilities, helpers, removeSegment, getLabelmapImageIds, addRepresentationData, strategies, segmentationStyle, defaultSegmentationStateManager, getCurrentLabelmapImageIdsForViewport, getLabelmapImageIdsForImageId, getActiveSegmentation, };\n", "import { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nexport function updateSegmentations(segmentationUpdateArray, suppressEvents) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    segmentationUpdateArray.forEach((segmentationUpdate) => {\n        segmentationStateManager.updateSegmentation(segmentationUpdate.segmentationId, segmentationUpdate.payload);\n        if (!suppressEvents) {\n            triggerSegmentationModified(segmentationUpdate.segmentationId);\n        }\n    });\n}\n", "import * as color from './segmentationColor';\nimport * as visibility from './segmentationVisibility';\nimport * as style from './styleHelpers';\nexport { color, visibility, style };\n", "import { getSegmentationRepresentation, getSegmentationRepresentations, } from '../getSegmentationRepresentation';\nimport { setSegmentationRepresentationVisibility as _setSegmentationRepresentationVisibility } from '../setSegmentationRepresentationVisibility';\nimport { getSegmentationRepresentationVisibility as _getSegmentationRepresentationVisibility } from '../getSegmentationRepresentationVisibility';\nimport { triggerSegmentationRenderBySegmentationId } from '../SegmentationRenderingEngine';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\nfunction setSegmentationRepresentationVisibility(viewportId, specifier, visibility) {\n    const representations = getSegmentationRepresentations(viewportId, specifier);\n    if (!representations) {\n        return;\n    }\n    representations.forEach((representation) => {\n        _setSegmentationRepresentationVisibility(viewportId, {\n            segmentationId: representation.segmentationId,\n            type: representation.type,\n        }, visibility);\n    });\n}\nfunction getSegmentationRepresentationVisibility(viewportId, specifier) {\n    return _getSegmentationRepresentationVisibility(viewportId, specifier);\n}\nfunction setSegmentIndexVisibility(viewportId, specifier, segmentIndex, visibility) {\n    const representations = getSegmentationRepresentations(viewportId, specifier);\n    if (!representations) {\n        return;\n    }\n    representations.forEach((representation) => {\n        if (!representation.segments || !representation.segments[segmentIndex]) {\n            return;\n        }\n        representation.segments[segmentIndex].visible = visibility;\n    });\n    triggerSegmentationRenderBySegmentationId(specifier.segmentationId);\n    triggerSegmentationRepresentationModified(viewportId, specifier.segmentationId);\n}\nfunction getSegmentIndexVisibility(viewportId, specifier, segmentIndex) {\n    const hiddenSegments = getHiddenSegmentIndices(viewportId, specifier);\n    return !hiddenSegments.has(segmentIndex);\n}\nfunction getHiddenSegmentIndices(viewportId, specifier) {\n    const representation = getSegmentationRepresentation(viewportId, specifier);\n    if (!representation) {\n        return new Set();\n    }\n    const segmentsHidden = Object.entries(representation.segments).reduce((acc, [segmentIndex, segment]) => {\n        if (!segment.visible) {\n            acc.add(Number(segmentIndex));\n        }\n        return acc;\n    }, new Set());\n    return segmentsHidden;\n}\nexport { setSegmentationRepresentationVisibility, getSegmentationRepresentationVisibility, setSegmentIndexVisibility, getSegmentIndexVisibility, getHiddenSegmentIndices, };\n", "import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function setSegmentationRepresentationVisibility(viewportId, specifier, visible) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    segmentationStateManager.setSegmentationRepresentationVisibility(viewportId, specifier, visible);\n}\n", "import { getSegmentations } from '../getSegmentations';\nimport { getViewportSegmentations } from '../getViewportSegmentations';\nimport { triggerSegmentationRender } from '../SegmentationRenderingEngine';\nimport { segmentationStyle } from '../SegmentationStyle';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\nfunction getStyle(specifier) {\n    return segmentationStyle.getStyle(specifier);\n}\nfunction setStyle(specifier, style) {\n    segmentationStyle.setStyle(specifier, style);\n    if (!specifier.viewportId && !specifier.segmentationId) {\n        const segmentations = getSegmentations();\n        segmentations.forEach((segmentation) => {\n            triggerSegmentationRender(segmentation.segmentationId);\n        });\n    }\n    triggerSegmentationRepresentationModified(specifier.viewportId, specifier.segmentationId, specifier.type);\n}\nfunction setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations) {\n    segmentationStyle.setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations);\n    triggerSegmentationRender(viewportId);\n    const segmentations = getViewportSegmentations(viewportId);\n    segmentations.forEach((segmentation) => {\n        triggerSegmentationRepresentationModified(viewportId, segmentation.segmentationId);\n    });\n}\nfunction getRenderInactiveSegmentations(viewportId) {\n    return segmentationStyle.getRenderInactiveSegmentations(viewportId);\n}\nfunction resetToGlobalStyle() {\n    segmentationStyle.resetToGlobalStyle();\n    triggerSegmentationRender();\n}\nfunction hasCustomStyle(specifier) {\n    return segmentationStyle.hasCustomStyle(specifier);\n}\nexport { getStyle, setStyle, setRenderInactiveSegmentations, getRenderInactiveSegmentations, resetToGlobalStyle, hasCustomStyle, };\n", "import { getAnnotationsUIDMapFromSegmentation } from './getAnnotationsUIDMapFromSegmentation';\nexport { getViewportAssociatedToSegmentation, getViewportWithMatchingViewPlaneNormal, } from './getViewportAssociatedToSegmentation';\nexport { getAnnotationsUIDMapFromSegmentation } from './getAnnotationsUIDMapFromSegmentation';\nexport { getAnnotationMapFromSegmentation } from './getAnnotationMapFromSegmentation';\nexport { default as decimateContours } from './decimateContours';\nexport { extractSegmentPolylines } from './extractSegmentPolylines';\nexport { removeCompleteContourAnnotation } from './removeCompleteContourAnnotation';\nexport { default as removeContourHoles } from './removeContourHoles';\nexport { default as removeContourIslands } from './removeContourIslands';\nexport { default as smoothContours } from './smoothContours';\nexport { default as convertContourHoles } from './convertContourHoles';\n", "import { getAnnotation } from '../../annotation/annotationState';\nexport function getAnnotationMapFromSegmentation(contourRepresentationData, options = {}) {\n    const annotationMap = contourRepresentationData.annotationUIDsMap;\n    const segmentIndices = options.segmentIndices?.length\n        ? options.segmentIndices\n        : Array.from(annotationMap.keys());\n    const annotationUIDsInSegmentMap = new Map();\n    segmentIndices.forEach((index) => {\n        const annotationUIDsInSegment = annotationMap.get(index);\n        let uids = Array.from(annotationUIDsInSegment);\n        uids = uids.filter((uid) => !getAnnotation(uid).parentAnnotationUID);\n        const annotations = uids.map((uid) => {\n            const annotation = getAnnotation(uid);\n            const hasChildAnnotations = annotation.childAnnotationUIDs?.length;\n            const childPolylinesInformation = hasChildAnnotations &&\n                annotation.childAnnotationUIDs.map((childUID) => {\n                    const childAnnotation = getAnnotation(childUID);\n                    return {\n                        polyline: childAnnotation.data.contour.polyline,\n                        isClosed: childAnnotation.data.contour.closed,\n                    };\n                });\n            const holesClosed = hasChildAnnotations &&\n                childPolylinesInformation.map((childInfo) => childInfo.isClosed);\n            const childPolylines = hasChildAnnotations &&\n                childPolylinesInformation.map((childInfo) => childInfo.polyline);\n            return {\n                polyline: annotation.data.contour.polyline,\n                isClosed: annotation.data.contour.closed,\n                annotationUID: annotation.annotationUID,\n                referencedImageId: annotation.metadata.referencedImageId,\n                holesPolyline: childPolylines,\n                holesUIDs: annotation.childAnnotationUIDs,\n                holesClosed,\n            };\n        });\n        annotationUIDsInSegmentMap.set(index, annotations);\n    });\n    return { segmentIndices, annotationUIDsInSegmentMap };\n}\n", "import { getAnnotationMapFromSegmentation, } from './getAnnotationMapFromSegmentation';\nfunction closePolyline(polyline, closed) {\n    if (!polyline || polyline.length === 0) {\n        return [];\n    }\n    if (!closed) {\n        return [...polyline];\n    }\n    const firstPoint = polyline[0];\n    const lastPoint = polyline[polyline.length - 1];\n    const isAlreadyClosed = firstPoint[0] === lastPoint[0] &&\n        firstPoint[1] === lastPoint[1] &&\n        firstPoint[2] === lastPoint[2];\n    if (isAlreadyClosed) {\n        return [...polyline];\n    }\n    return [...polyline, firstPoint];\n}\nexport function getPolylinesMap(contourRepresentationData, segmentIndex) {\n    const { annotationUIDsInSegmentMap } = getAnnotationMapFromSegmentation(contourRepresentationData);\n    if (!annotationUIDsInSegmentMap.has(segmentIndex)) {\n        console.warn(`No contour information found for segmentIndex ${segmentIndex}`);\n        return;\n    }\n    const polylines = new Map();\n    const annotationsInfo = annotationUIDsInSegmentMap.get(segmentIndex);\n    for (const annotationInfo of annotationsInfo) {\n        polylines.set(annotationInfo.annotationUID, closePolyline(annotationInfo.polyline, annotationInfo.isClosed));\n        for (let i = 0; i < annotationInfo.holesUIDs?.length; i++) {\n            polylines.set(annotationInfo.holesUIDs[i], closePolyline(annotationInfo.holesPolyline[i], annotationInfo.holesClosed[i]));\n        }\n    }\n    return polylines;\n}\n", "import { getSegmentation } from '../getSegmentation';\nimport { convertContourPolylineToCanvasSpace } from '../../../utilities/contourSegmentation';\nimport { getViewportsAssociatedToSegmentation, getViewportWithMatchingViewPlaneNormal, } from './getViewportAssociatedToSegmentation';\nimport { getPolylinesMap } from './getPolylineMap';\nimport { getAnnotation } from '../../annotation/annotationState';\nexport function extractSegmentPolylines(segmentationId, segmentIndex) {\n    const viewports = getViewportsAssociatedToSegmentation(segmentationId);\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        return;\n    }\n    if (!segmentation.representationData.Contour) {\n        return;\n    }\n    const contourRepresentationData = segmentation.representationData\n        .Contour;\n    const { annotationUIDsMap } = contourRepresentationData;\n    if (!annotationUIDsMap) {\n        return;\n    }\n    if (!annotationUIDsMap.get(segmentIndex)) {\n        return;\n    }\n    const polyLinesMap = getPolylinesMap(contourRepresentationData, segmentIndex);\n    if (!polyLinesMap) {\n        return;\n    }\n    const keys = Array.from(polyLinesMap?.keys());\n    const polylinesCanvasMap = new Map();\n    for (const key of keys) {\n        const annotation = getAnnotation(key);\n        const viewport = getViewportWithMatchingViewPlaneNormal(viewports, annotation);\n        polylinesCanvasMap.set(key, convertContourPolylineToCanvasSpace(polyLinesMap.get(key), viewport));\n    }\n    return polylinesCanvasMap;\n}\n", "import { getAnnotation, invalidateAnnotation, } from '../../annotation/annotationState';\nimport { getSegmentation } from '../getSegmentation';\nimport { extractSegmentPolylines } from './extractSegmentPolylines';\nimport decimate from '../../../utilities/math/polyline/decimate';\nimport { getViewportsAssociatedToSegmentation, getViewportWithMatchingViewPlaneNormal, } from './getViewportAssociatedToSegmentation';\nexport default function decimateContours(segmentationId, segmentIndex, options = { epsilon: 0.1 }) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        console.warn(`Invalid segmentation given ${segmentationId}`);\n        return;\n    }\n    if (!segmentation.representationData.Contour) {\n        console.warn(`No contour representation found for segmentation ${segmentationId}`);\n        return;\n    }\n    const viewports = getViewportsAssociatedToSegmentation(segmentationId);\n    if (!viewports) {\n        console.warn('No viewport associated to the segmentation found');\n        return;\n    }\n    const polylinesCanvasMap = extractSegmentPolylines(segmentationId, segmentIndex);\n    if (!polylinesCanvasMap) {\n        console.warn(`Error extracting contour data from segment ${segmentIndex} in segmentation ${segmentationId}`);\n        return;\n    }\n    const keys = Array.from(polylinesCanvasMap?.keys());\n    for (const annotationUID of keys) {\n        const annotation = getAnnotation(annotationUID);\n        if (!annotation) {\n            continue;\n        }\n        const polylineCanvas = polylinesCanvasMap.get(annotationUID);\n        const decimatedPolyline2D = decimate(polylineCanvas, options.epsilon);\n        const viewport = getViewportWithMatchingViewPlaneNormal(viewports, annotation);\n        if (viewport) {\n            annotation.data.contour.polyline = decimatedPolyline2D.map((point2D) => viewport.canvasToWorld(point2D));\n            invalidateAnnotation(annotation);\n        }\n    }\n}\n", "import { removeContourSegmentationAnnotation } from '../../../utilities/contourSegmentation';\nimport { clearParentAnnotation, removeAnnotation, } from '../../annotation/annotationState';\nexport function removeCompleteContourAnnotation(annotation) {\n    if (!annotation) {\n        return;\n    }\n    if (annotation.parentAnnotationUID) {\n        clearParentAnnotation(annotation);\n    }\n    removeAnnotation(annotation.annotationUID);\n    removeContourSegmentationAnnotation(annotation);\n}\n", "import { findContourHoles } from '../../../utilities/contours';\nimport { getAnnotation } from '../../annotation/annotationState';\nimport { getSegmentation } from '../getSegmentation';\nimport { extractSegmentPolylines } from './extractSegmentPolylines';\nimport { removeCompleteContourAnnotation } from './removeCompleteContourAnnotation';\nexport default function removeContourHoles(segmentationId, segmentIndex) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        console.warn(`Invalid segmentation given ${segmentationId}`);\n        return;\n    }\n    if (!segmentation.representationData.Contour) {\n        console.warn(`No contour representation found for segmentation ${segmentationId}`);\n        return;\n    }\n    const polylinesCanvasMap = extractSegmentPolylines(segmentationId, segmentIndex);\n    if (!polylinesCanvasMap) {\n        console.warn(`Error extracting contour data from segment ${segmentIndex} in segmentation ${segmentationId}`);\n        return;\n    }\n    const keys = Array.from(polylinesCanvasMap?.keys());\n    const polylines = keys.map((key) => polylinesCanvasMap.get(key));\n    const holeDetectionResults = findContourHoles(polylines);\n    if (holeDetectionResults?.length > 0) {\n        holeDetectionResults.forEach((hole) => {\n            hole.holeIndexes.forEach((index) => {\n                const annotation = getAnnotation(keys[index]);\n                removeCompleteContourAnnotation(annotation);\n            });\n        });\n    }\n}\n", "import { getAnnotation } from '../../annotation/annotationState';\nimport { getSegmentation } from '../getSegmentation';\nimport { extractSegmentPolylines } from './extractSegmentPolylines';\nimport findIslands from '../../../utilities/contours/findIslands';\nimport { removeCompleteContourAnnotation } from './removeCompleteContourAnnotation';\nexport default function removeContourIslands(segmentationId, segmentIndex, options = { threshold: 3 }) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        console.warn(`Invalid segmentation given ${segmentationId}`);\n        return;\n    }\n    if (!segmentation.representationData.Contour) {\n        console.warn(`No contour representation found for segmentation ${segmentationId}`);\n        return;\n    }\n    const polylinesCanvasMap = extractSegmentPolylines(segmentationId, segmentIndex);\n    if (!polylinesCanvasMap) {\n        console.warn(`Error extracting contour data from segment ${segmentIndex} in segmentation ${segmentationId}`);\n        return;\n    }\n    const keys = Array.from(polylinesCanvasMap?.keys());\n    const polylines = keys.map((key) => polylinesCanvasMap.get(key));\n    const islands = findIslands(polylines, options.threshold);\n    if (islands?.length > 0) {\n        islands.forEach((index) => {\n            const annotation = getAnnotation(keys[index]);\n            removeCompleteContourAnnotation(annotation);\n        });\n    }\n}\n", "import { getAnnotation } from '../../annotation/annotationState';\nimport { getSegmentation } from '../getSegmentation';\nimport interpolateSegmentPoints from '../../../utilities/planarFreehandROITool/interpolation/interpolateSegmentPoints';\nexport default function smoothContours(segmentationId, segmentIndex, options = { knotsRatioPercentage: 30 }) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        console.warn(`Invalid segmentation given ${segmentationId}`);\n        return;\n    }\n    if (!segmentation.representationData.Contour) {\n        console.warn(`No contour representation found for segmentation ${segmentationId}`);\n        return;\n    }\n    const contourRepresentationData = segmentation.representationData\n        .Contour;\n    const { annotationUIDsMap } = contourRepresentationData;\n    if (!annotationUIDsMap) {\n        console.warn(`No contours found for segmentation ${segmentationId}`);\n        return;\n    }\n    if (!annotationUIDsMap.has(segmentIndex)) {\n        console.warn(`Error extracting contour data from segment ${segmentIndex} in segmentation ${segmentationId}`);\n        return;\n    }\n    const annotationList = annotationUIDsMap.get(segmentIndex);\n    annotationList.forEach((annotationUID) => {\n        const annotation = getAnnotation(annotationUID);\n        if (!annotation) {\n            return;\n        }\n        const polyline = annotation.data.contour.polyline;\n        if (!polyline || polyline.length < 3) {\n            return;\n        }\n        const smoothedPolyline = interpolateSegmentPoints(polyline, 0, polyline.length - 1, options.knotsRatioPercentage);\n        annotation.data.contour.polyline = smoothedPolyline;\n    });\n}\n", "import { findContourHoles } from '../../../utilities/contours';\nimport { getAnnotation, clearParentAnnotation, } from '../../annotation/annotationState';\nimport { getSegmentation } from '../getSegmentation';\nimport { extractSegmentPolylines } from './extractSegmentPolylines';\nexport default function convertContourHoles(segmentationId, segmentIndex, targetSegmentationId, targetSegmentationIndex) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        console.warn(`Invalid segmentation given ${segmentationId}`);\n        return;\n    }\n    if (!segmentation.representationData.Contour) {\n        console.warn(`No contour representation found for segmentation ${segmentationId}`);\n        return;\n    }\n    const { annotationUIDsMap } = segmentation?.representationData.Contour || {};\n    if (!annotationUIDsMap) {\n        console.warn(`No annotation map found for segmentation ${segmentationId}`);\n        return;\n    }\n    const annotationsUIDsSet = annotationUIDsMap?.get(segmentIndex);\n    if (!annotationsUIDsSet) {\n        console.warn(`Segmentation index ${segmentIndex} has no annotations in segmentation ${segmentationId}`);\n        return;\n    }\n    let targetUIDsSet;\n    if (targetSegmentationId && typeof targetSegmentationIndex === 'number') {\n        const targetSegmentation = getSegmentation(targetSegmentationId);\n        if (!targetSegmentation) {\n            console.warn(`Target segmentation ${targetSegmentationId} does not exist.`);\n            return;\n        }\n        if (!targetSegmentation.representationData.Contour) {\n            console.warn(`No contour representation found for target segmentation ${targetSegmentationId}`);\n            return;\n        }\n        targetUIDsSet =\n            targetSegmentation.representationData.Contour.annotationUIDsMap.get(targetSegmentationIndex);\n        if (!targetUIDsSet) {\n            targetUIDsSet = new Set();\n            targetSegmentation.representationData.Contour.annotationUIDsMap.set(targetSegmentationIndex, targetUIDsSet);\n        }\n    }\n    const polylinesCanvasMap = extractSegmentPolylines(segmentationId, segmentIndex);\n    if (!polylinesCanvasMap) {\n        console.warn(`Error extracting contour data from segment ${segmentIndex} in segmentation ${segmentationId}`);\n        return;\n    }\n    const keys = Array.from(polylinesCanvasMap?.keys());\n    const polylines = keys.map((key) => polylinesCanvasMap.get(key));\n    const holeDetectionResults = findContourHoles(polylines);\n    if (holeDetectionResults?.length > 0) {\n        holeDetectionResults.forEach((hole) => {\n            hole.holeIndexes.forEach((index) => {\n                const annotation = getAnnotation(keys[index]);\n                clearParentAnnotation(annotation);\n                if (targetSegmentationId &&\n                    typeof targetSegmentationIndex === 'number') {\n                    targetUIDsSet.add(annotation.annotationUID);\n                }\n                else {\n                    annotationsUIDsSet.add(annotation.annotationUID);\n                }\n            });\n        });\n    }\n}\n", "import { internalConvertStackToVolumeLabelmap } from '../SegmentationStateManager';\nimport { triggerSegmentationModified } from '../triggerSegmentationEvents';\nexport async function convertStackToVolumeLabelmap(args) {\n    const result = internalConvertStackToVolumeLabelmap(args);\n    triggerSegmentationModified(args.segmentationId);\n    return result;\n}\n", "import { cache } from '@cornerstonejs/core';\nimport { getSegmentation } from '../getSegmentation';\nimport { triggerSegmentationDataModified } from '../triggerSegmentationEvents';\nexport function clearSegmentValue(segmentationId, segmentIndex) {\n    const segmentation = getSegmentation(segmentationId);\n    if (segmentation.representationData.Labelmap) {\n        const { representationData } = segmentation;\n        const labelmapData = representationData.Labelmap;\n        if ('imageIds' in labelmapData || 'volumeId' in labelmapData) {\n            const items = 'imageIds' in labelmapData\n                ? labelmapData.imageIds.map((imageId) => cache.getImage(imageId))\n                : [cache.getVolume(labelmapData.volumeId)];\n            items.forEach((item) => {\n                if (!item) {\n                    return;\n                }\n                const { voxelManager } = item;\n                voxelManager.forEach(({ value, index }) => {\n                    if (value === segmentIndex) {\n                        voxelManager.setAtIndex(index, 0);\n                    }\n                });\n            });\n        }\n        triggerSegmentationDataModified(segmentationId);\n    }\n    else {\n        throw new Error('Invalid segmentation type, only labelmap is supported right now');\n    }\n}\n", "import { getAnnotation } from '../../annotation/annotationState';\nimport { getAnnotationsUIDMapFromSegmentation, removeCompleteContourAnnotation, } from '../utilities';\nimport { isContourSegmentationAnnotation } from '../../../utilities/contourSegmentation';\nexport function removeContourSegmentAnnotations(segmentationId, segmentIndex) {\n    const annotationUIDsMap = getAnnotationsUIDMapFromSegmentation(segmentationId);\n    if (!annotationUIDsMap) {\n        return;\n    }\n    const annotationUIDs = annotationUIDsMap.get(segmentIndex);\n    if (!annotationUIDs) {\n        return;\n    }\n    annotationUIDs.forEach((annotationUID) => {\n        const annotation = getAnnotation(annotationUID);\n        if (isContourSegmentationAnnotation(annotation)) {\n            removeCompleteContourAnnotation(annotation);\n        }\n    });\n}\n", "import { getActiveSegmentIndex } from './getActiveSegmentIndex';\nimport { getSegmentation } from './getSegmentation';\nimport { getSegmentationRepresentations } from './getSegmentationRepresentation';\nimport { getViewportIdsWithSegmentation } from './getViewportIdsWithSegmentation';\nimport { removeContourSegmentAnnotations } from './helpers/removeSegmentAnnotations';\nimport { clearSegmentValue } from './helpers/clearSegmentValue';\nimport { setActiveSegmentIndex } from './segmentIndex';\nimport { updateSegmentations } from './updateSegmentations';\nexport function removeSegment(segmentationId, segmentIndex, options = {\n    setNextSegmentAsActive: true,\n}) {\n    const segmentation = getSegmentation(segmentationId);\n    if (segmentation?.representationData.Contour) {\n        removeContourSegmentAnnotations(segmentationId, segmentIndex);\n    }\n    else if (segmentation?.representationData.Labelmap) {\n        clearSegmentValue(segmentationId, segmentIndex);\n    }\n    else {\n        throw new Error('Invalid segmentation type');\n    }\n    const isThisSegmentActive = getActiveSegmentIndex(segmentationId) === segmentIndex;\n    const { segments } = segmentation;\n    delete segments[segmentIndex];\n    const updatedSegments = {\n        ...segments,\n    };\n    updateSegmentations([\n        {\n            segmentationId,\n            payload: {\n                segments: updatedSegments,\n            },\n        },\n    ]);\n    if (isThisSegmentActive && options.setNextSegmentAsActive) {\n        const segmentIndices = Object.keys(segments)\n            .map(Number)\n            .sort((a, b) => a - b);\n        const currentIndex = segmentIndices.indexOf(segmentIndex);\n        const nextSegmentIndex = segmentIndices[currentIndex + 1];\n        const previousSegmentIndex = segmentIndices[currentIndex - 1];\n        if (nextSegmentIndex !== undefined) {\n            setActiveSegmentIndex(segmentationId, nextSegmentIndex);\n        }\n        else if (previousSegmentIndex !== undefined) {\n            setActiveSegmentIndex(segmentationId, previousSegmentIndex);\n        }\n    }\n    const viewportIds = getViewportIdsWithSegmentation(segmentationId);\n    viewportIds.forEach((viewportId) => {\n        const representations = getSegmentationRepresentations(viewportId, {\n            segmentationId,\n        });\n        representations.forEach((representation) => {\n            delete representation.segments[segmentIndex];\n        });\n    });\n}\n", "import { getSegmentation } from './getSegmentation';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getLabelmapImageIds(segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const segmentation = getSegmentation(segmentationId);\n    return segmentationStateManager.getLabelmapImageIds(segmentation.representationData);\n}\n", "import BSpline from './BSpline';\nimport CardinalSpline from './CardinalSpline';\nimport CatmullRomSpline from './CatmullRomSpline';\nimport CubicSpline from './CubicSpline';\nimport LinearSpline from './LinearSpline';\nimport QuadraticBezier from './QuadraticBezier';\nimport QuadraticSpline from './QuadraticSpline';\nimport Spline from './Spline';\nexport { BSpline, CardinalSpline, CatmullRomSpline, CubicSpline, LinearSpline, QuadraticBezier, QuadraticSpline, Spline, };\n", "import * as math from '../../../utilities/math';\nclass Spline {\n    constructor(props) {\n        this._controlPoints = [];\n        this._invalidated = false;\n        this._length = 0;\n        this._controlPoints = [];\n        this._resolution = props?.resolution ?? 20;\n        this._fixedResolution = props?.fixedResolution ?? false;\n        this._closed = props?.closed ?? false;\n        this._invalidated = true;\n    }\n    get controlPoints() {\n        return this._controlPoints;\n    }\n    get numControlPoints() {\n        return this._controlPoints.length;\n    }\n    get resolution() {\n        return this._resolution;\n    }\n    set resolution(resolution) {\n        if (this._fixedResolution || this._resolution === resolution) {\n            return;\n        }\n        this._resolution = resolution;\n        this.invalidated = true;\n    }\n    get fixedResolution() {\n        return this._fixedResolution;\n    }\n    get closed() {\n        return this._closed;\n    }\n    set closed(closed) {\n        if (this._closed === closed) {\n            return;\n        }\n        this._closed = closed;\n        this.invalidated = true;\n    }\n    get aabb() {\n        this._update();\n        return this._aabb;\n    }\n    get length() {\n        this._update();\n        return this._length;\n    }\n    get invalidated() {\n        return this._invalidated;\n    }\n    set invalidated(invalidated) {\n        this._invalidated = invalidated;\n    }\n    hasTangentPoints() {\n        return false;\n    }\n    addControlPoint(point) {\n        this._controlPoints.push([point[0], point[1]]);\n        this.invalidated = true;\n    }\n    addControlPoints(points) {\n        points.forEach((point) => this.addControlPoint(point));\n    }\n    addControlPointAtU(u) {\n        const lineSegment = this._getLineSegmentAt(u);\n        const { start: startPoint, end: endPoint } = lineSegment.points;\n        const curveSegmentIndex = Math.floor(u);\n        const curveSegment = this._curveSegments[curveSegmentIndex];\n        const t = u - Math.floor(curveSegmentIndex);\n        const controlPointPos = [\n            startPoint[0] + t * (endPoint[0] - startPoint[0]),\n            startPoint[1] + t * (endPoint[1] - startPoint[1]),\n        ];\n        const insertIndex = this._controlPoints.indexOf(curveSegment.controlPoints.p1) + 1;\n        this._controlPoints.splice(insertIndex, 0, controlPointPos);\n        this.invalidated = true;\n        return {\n            index: insertIndex,\n            point: controlPointPos,\n        };\n    }\n    deleteControlPointByIndex(index) {\n        const minControlPoints = this._closed ? 3 : 1;\n        const canDelete = index >= 0 &&\n            index < this._controlPoints.length &&\n            this._controlPoints.length > minControlPoints;\n        if (!canDelete) {\n            return false;\n        }\n        this._controlPoints.splice(index, 1);\n        this.invalidated = true;\n        return true;\n    }\n    clearControlPoints() {\n        this._controlPoints = [];\n        this.invalidated = true;\n    }\n    setControlPoints(points) {\n        this.clearControlPoints();\n        this.addControlPoints(points);\n    }\n    updateControlPoint(index, newControlPoint) {\n        if (index < 0 || index >= this._controlPoints.length) {\n            throw new Error('Index out of bounds');\n        }\n        this._controlPoints[index] = [...newControlPoint];\n        this.invalidated = true;\n    }\n    getControlPoints() {\n        return this._controlPoints.map((controlPoint) => [\n            controlPoint[0],\n            controlPoint[1],\n        ]);\n    }\n    getClosestControlPoint(point) {\n        const controlPoints = this._controlPoints;\n        let minSquaredDist = Infinity;\n        let closestPointIndex = -1;\n        for (let i = 0, len = controlPoints.length; i < len; i++) {\n            const controlPoint = controlPoints[i];\n            const dx = point[0] - controlPoint[0];\n            const dy = point[1] - controlPoint[1];\n            const squaredDist = dx * dx + dy * dy;\n            if (squaredDist < minSquaredDist) {\n                minSquaredDist = squaredDist;\n                closestPointIndex = i;\n            }\n        }\n        return {\n            index: closestPointIndex,\n            point: closestPointIndex === -1\n                ? undefined\n                : [...controlPoints[closestPointIndex]],\n            distance: Math.sqrt(minSquaredDist),\n        };\n    }\n    getClosestControlPointWithinDistance(point, maxDist) {\n        const closestControlPoint = this.getClosestControlPoint(point);\n        return closestControlPoint.distance <= maxDist\n            ? closestControlPoint\n            : undefined;\n    }\n    getClosestPoint(point) {\n        this._update();\n        const curveSegmentsDistInfo = this._getCurveSegmmentsDistanceSquaredInfo(point);\n        if (!curveSegmentsDistInfo.length) {\n            return;\n        }\n        curveSegmentsDistInfo.sort((csA, csB) => csA.distanceSquared - csB.distanceSquared);\n        let closestPoint;\n        let closestPointCurveSegmentIndex = -1;\n        let minDistSquared = Infinity;\n        let minDistCurveSegment;\n        let minDistLineSegment;\n        for (let i = 0; i < curveSegmentsDistInfo.length; i++) {\n            const curveSegmentDistInfo = curveSegmentsDistInfo[i];\n            if (curveSegmentDistInfo.distanceSquared > minDistSquared) {\n                continue;\n            }\n            const { curveSegmentIndex, curveSegment } = curveSegmentDistInfo;\n            const { lineSegments } = curveSegment;\n            for (let j = 0; j < lineSegments.length; j++) {\n                const lineSegment = lineSegments[j];\n                const { point: lineSegPoint, distanceSquared: lineSegDistSquared } = math.lineSegment.distanceToPointSquaredInfo(lineSegment.points.start, lineSegment.points.end, point);\n                if (lineSegDistSquared < minDistSquared) {\n                    minDistLineSegment = lineSegment;\n                    closestPointCurveSegmentIndex = curveSegmentIndex;\n                    minDistCurveSegment = curveSegmentDistInfo.curveSegment;\n                    closestPoint = lineSegPoint;\n                    minDistSquared = lineSegDistSquared;\n                }\n            }\n        }\n        const curveSegmentLengthToPoint = minDistLineSegment.previousLineSegmentsLength +\n            math.point.distanceToPoint(minDistLineSegment.points.start, closestPoint);\n        const t = curveSegmentLengthToPoint / minDistCurveSegment.length;\n        const u = closestPointCurveSegmentIndex + t;\n        return {\n            point: closestPoint,\n            uValue: u,\n            distance: Math.sqrt(minDistSquared),\n        };\n    }\n    getClosestPointOnControlPointLines(point) {\n        const linePoints = [...this._controlPoints];\n        if (this._closed) {\n            linePoints.push(this._controlPoints[0]);\n        }\n        if (!linePoints.length) {\n            return;\n        }\n        let closestPoint;\n        let minDistSquared = Infinity;\n        let startPoint = linePoints[0];\n        for (let i = 1, len = linePoints.length; i < len; i++) {\n            const endPoint = linePoints[i];\n            const { point: lineSegPoint, distanceSquared: lineSegDistSquared } = math.lineSegment.distanceToPointSquaredInfo(startPoint, endPoint, point);\n            if (lineSegDistSquared < minDistSquared) {\n                closestPoint = lineSegPoint;\n                minDistSquared = lineSegDistSquared;\n            }\n            startPoint = endPoint;\n        }\n        return {\n            point: closestPoint,\n            distance: Math.sqrt(minDistSquared),\n        };\n    }\n    getPolylinePoints() {\n        this._update();\n        return this._convertCurveSegmentsToPolyline(this._curveSegments);\n    }\n    getPreviewPolylinePoints(controlPointPreview, closeDistance) {\n        if (this._closed) {\n            return [];\n        }\n        this._update();\n        const closestControlPoint = this.getClosestControlPointWithinDistance(controlPointPreview, closeDistance);\n        const closeSpline = closestControlPoint?.index === 0;\n        const previewCurveSegments = this.getPreviewCurveSegments(controlPointPreview, closeSpline);\n        return previewCurveSegments?.length\n            ? this._convertCurveSegmentsToPolyline(previewCurveSegments)\n            : [];\n    }\n    isPointNearCurve(point, maxDist) {\n        this._update();\n        const curveSegments = this._getCurveSegmmentsWithinDistance(point, maxDist);\n        const maxDistSquared = maxDist * maxDist;\n        for (let i = 0; i < curveSegments.length; i++) {\n            const { lineSegments } = curveSegments[i];\n            for (let j = 0; j < lineSegments.length; j++) {\n                const lineSegment = lineSegments[j];\n                const lineDistSquared = math.lineSegment.distanceToPointSquared(lineSegment.points.start, lineSegment.points.end, point);\n                if (lineDistSquared <= maxDistSquared) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    containsPoint(point) {\n        this._update();\n        const controlPoints = this._controlPoints;\n        if (controlPoints.length < 3) {\n            return false;\n        }\n        const curveSegments = [...this._curveSegments];\n        const closingCurveSegment = this._getClosingCurveSegmentWithStraightLineSegment();\n        if (closingCurveSegment) {\n            curveSegments.push(closingCurveSegment);\n        }\n        let numIntersections = 0;\n        for (let i = 0; i < curveSegments.length; i++) {\n            const curveSegment = curveSegments[i];\n            const { aabb: curveSegAABB } = curveSegment;\n            const mayIntersectCurveSegment = point[0] <= curveSegAABB.maxX &&\n                point[1] >= curveSegAABB.minY &&\n                point[1] < curveSegAABB.maxY;\n            if (!mayIntersectCurveSegment) {\n                continue;\n            }\n            const { lineSegments } = curveSegment;\n            for (let i = 0; i < lineSegments.length; i++) {\n                const lineSegment = lineSegments[i];\n                const { aabb: lineSegmentAABB } = lineSegment;\n                const mayIntersectLineSegment = point[0] <= lineSegmentAABB.maxX &&\n                    point[1] >= lineSegmentAABB.minY &&\n                    point[1] < lineSegmentAABB.maxY;\n                if (mayIntersectLineSegment) {\n                    const { start: p1, end: p2 } = lineSegment.points;\n                    const isVerticalLine = p1[0] === p2[0];\n                    const xIntersection = ((point[1] - p1[1]) * (p2[0] - p1[0])) / (p2[1] - p1[1]) + p1[0];\n                    numIntersections +=\n                        isVerticalLine || point[0] <= xIntersection ? 1 : 0;\n                }\n            }\n        }\n        return numIntersections % 2 === 1;\n    }\n    _update() {\n        if (!this._invalidated) {\n            return;\n        }\n        const curveSegments = this.getSplineCurves();\n        let length = 0;\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n        for (let i = 0, len = curveSegments.length; i < len; i++) {\n            const { aabb: curveSegAABB, length: curveSegLength } = curveSegments[i];\n            minX = minX <= curveSegAABB.minX ? minX : curveSegAABB.minX;\n            minY = minY <= curveSegAABB.minY ? minY : curveSegAABB.minY;\n            maxX = maxX >= curveSegAABB.maxX ? maxX : curveSegAABB.maxX;\n            maxY = maxY >= curveSegAABB.maxY ? maxY : curveSegAABB.maxY;\n            length += curveSegLength;\n        }\n        this._curveSegments = curveSegments;\n        this._aabb = { minX, minY, maxX, maxY };\n        this._length = length;\n        this._invalidated = false;\n    }\n    _convertCurveSegmentsToPolyline(curveSegments) {\n        this._update();\n        const polylinePoints = [];\n        curveSegments.forEach(({ lineSegments }, curveSegIndex) => {\n            lineSegments.forEach((lineSegment, lineSegIndex) => {\n                if (curveSegIndex === 0 && lineSegIndex === 0) {\n                    polylinePoints.push([...lineSegment.points.start]);\n                }\n                polylinePoints.push([...lineSegment.points.end]);\n            });\n        });\n        return polylinePoints;\n    }\n    _getCurveSegmmentsDistanceSquaredInfo(point) {\n        this._update();\n        const curveSegmentsDistanceSquared = [];\n        const { _curveSegments: curveSegments } = this;\n        for (let i = 0; i < curveSegments.length; i++) {\n            const curveSegment = curveSegments[i];\n            const distanceSquared = math.aabb.distanceToPointSquared(curveSegment.aabb, point);\n            curveSegmentsDistanceSquared.push({\n                curveSegmentIndex: i,\n                curveSegment,\n                distanceSquared,\n            });\n        }\n        return curveSegmentsDistanceSquared;\n    }\n    _getCurveSegmmentsWithinDistance(point, maxDist) {\n        this._update();\n        const maxDistSquared = maxDist * maxDist;\n        if (math.aabb.distanceToPointSquared(this.aabb, point) > maxDistSquared) {\n            return [];\n        }\n        const curveSegmentsDistance = this._getCurveSegmmentsDistanceSquaredInfo(point);\n        const curveSegmentsWithinRange = [];\n        for (let i = 0, len = curveSegmentsDistance.length; i < len; i++) {\n            const { curveSegment, distanceSquared: curveSegmentDistSquared } = curveSegmentsDistance[i];\n            if (curveSegmentDistSquared <= maxDistSquared) {\n                curveSegmentsWithinRange.push(curveSegment);\n            }\n        }\n        return curveSegmentsWithinRange;\n    }\n    _getLineSegmentAt(u) {\n        this._update();\n        const curveSegmentIndex = Math.floor(u);\n        const t = u - curveSegmentIndex;\n        const curveSegment = this._curveSegments[curveSegmentIndex];\n        const { lineSegments } = curveSegment;\n        const pointLength = curveSegment.length * t;\n        for (let i = 0; i < lineSegments.length; i++) {\n            const lineSegment = lineSegments[i];\n            const lengthEnd = lineSegment.previousLineSegmentsLength + lineSegment.length;\n            if (pointLength >= lineSegment.previousLineSegmentsLength &&\n                pointLength <= lengthEnd) {\n                return lineSegment;\n            }\n        }\n    }\n    _getClosingCurveSegmentWithStraightLineSegment() {\n        if (this.closed) {\n            return;\n        }\n        const controlPoints = this._controlPoints;\n        const startControlPoint = controlPoints[0];\n        const endControlPoint = controlPoints[controlPoints.length - 1];\n        const closingLineSegment = {\n            points: {\n                start: [...startControlPoint],\n                end: [...endControlPoint],\n            },\n            aabb: {\n                minX: Math.min(startControlPoint[0], endControlPoint[0]),\n                minY: Math.min(startControlPoint[1], endControlPoint[1]),\n                maxX: Math.max(startControlPoint[0], endControlPoint[0]),\n                maxY: Math.max(startControlPoint[1], endControlPoint[1]),\n            },\n        };\n        return {\n            aabb: {\n                minX: closingLineSegment.aabb.minX,\n                minY: closingLineSegment.aabb.minY,\n                maxX: closingLineSegment.aabb.maxX,\n                maxY: closingLineSegment.aabb.maxY,\n            },\n            lineSegments: [closingLineSegment],\n        };\n    }\n}\nexport { Spline as default, Spline };\n", "import { vec4 } from 'gl-matrix';\nimport { Spline } from './Spline';\nimport * as math from '../../../utilities/math';\nconst MAX_U_ERROR = 1e-8;\nclass CubicSpline extends Spline {\n    getPreviewCurveSegments(controlPointPreview, closeSpline) {\n        const previewNumCurveSegments = this._getNumCurveSegments() + 1;\n        const startCurveSegIndex = Math.max(0, previewNumCurveSegments - 2);\n        const endCurveSegIndex = closeSpline\n            ? previewNumCurveSegments\n            : previewNumCurveSegments - 1;\n        const transformMatrix = this.getTransformMatrix();\n        const controlPoints = [...this.controlPoints];\n        const curveSegments = [];\n        if (!closeSpline) {\n            controlPoints.push(controlPointPreview);\n        }\n        for (let i = startCurveSegIndex; i <= endCurveSegIndex; i++) {\n            const curveSegment = this._getCurveSegment(i, transformMatrix, controlPoints, closeSpline);\n            curveSegments.push(curveSegment);\n        }\n        return curveSegments;\n    }\n    getSplineCurves() {\n        const numCurveSegments = this._getNumCurveSegments();\n        const curveSegments = new Array(numCurveSegments);\n        if (numCurveSegments <= 0) {\n            return [];\n        }\n        const transformMatrix = this.getTransformMatrix();\n        let previousCurveSegmentsLength = 0;\n        for (let i = 0; i < numCurveSegments; i++) {\n            const curveSegment = this._getCurveSegment(i, transformMatrix);\n            curveSegment.previousCurveSegmentsLength = previousCurveSegmentsLength;\n            curveSegments[i] = curveSegment;\n            previousCurveSegmentsLength += curveSegment.length;\n        }\n        return curveSegments;\n    }\n    _getNumCurveSegments(controlPoints = this.controlPoints, closed = this.closed) {\n        return closed\n            ? controlPoints.length\n            : Math.max(0, controlPoints.length - 1);\n    }\n    _getPoint(u, transformMatrix, controlPoints = this.controlPoints, closed = this.closed) {\n        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n        const uInt = Math.floor(u);\n        let curveSegmentIndex = uInt % numCurveSegments;\n        const t = u - uInt;\n        const curveSegmentIndexOutOfBounds = curveSegmentIndex < 0 || curveSegmentIndex >= numCurveSegments;\n        if (curveSegmentIndexOutOfBounds) {\n            if (this.closed) {\n                curveSegmentIndex =\n                    (numCurveSegments + curveSegmentIndex) % numCurveSegments;\n            }\n            else {\n                return;\n            }\n        }\n        const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(curveSegmentIndex, controlPoints, closed);\n        const tt = t * t;\n        const ttt = tt * t;\n        const tValues = vec4.fromValues(1, t, tt, ttt);\n        const qValues = vec4.transformMat4(vec4.create(), tValues, transformMatrix);\n        return [\n            vec4.dot(qValues, vec4.fromValues(p0[0], p1[0], p2[0], p3[0])),\n            vec4.dot(qValues, vec4.fromValues(p0[1], p1[1], p2[1], p3[1])),\n        ];\n    }\n    _getCurveSegmentPoints(curveSegmentIndex, controlPoints = this.controlPoints, closed = this.closed) {\n        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n        const p1Index = curveSegmentIndex;\n        const p0Index = p1Index - 1;\n        const p2Index = closed ? (p1Index + 1) % numCurveSegments : p1Index + 1;\n        const p3Index = p2Index + 1;\n        const p1 = controlPoints[p1Index];\n        const p2 = controlPoints[p2Index];\n        let p0;\n        let p3;\n        if (p0Index >= 0) {\n            p0 = controlPoints[p0Index];\n        }\n        else {\n            p0 = closed\n                ? controlPoints[controlPoints.length - 1]\n                : math.point.mirror(p2, p1);\n        }\n        if (p3Index < controlPoints.length) {\n            p3 = controlPoints[p3Index];\n        }\n        else {\n            p3 = closed ? controlPoints[0] : math.point.mirror(p1, p2);\n        }\n        return { p0, p1, p2, p3 };\n    }\n    _getLineSegments(curveSegmentIndex, transformMatrix, controlPoints = this.controlPoints, closed = this.closed) {\n        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n        const numLineSegments = this.resolution + 1;\n        const inc = 1 / numLineSegments;\n        const minU = curveSegmentIndex;\n        let maxU = minU + 1;\n        if (!closed && curveSegmentIndex === numCurveSegments - 1) {\n            maxU -= MAX_U_ERROR;\n        }\n        const lineSegments = [];\n        let startPoint;\n        let endPoint;\n        let previousLineSegmentsLength = 0;\n        for (let i = 0, u = minU; i <= numLineSegments; i++, u += inc) {\n            u = u > maxU ? maxU : u;\n            const point = this._getPoint(u, transformMatrix, controlPoints, closed);\n            if (!i) {\n                startPoint = point;\n                continue;\n            }\n            endPoint = point;\n            const dx = endPoint[0] - startPoint[0];\n            const dy = endPoint[1] - startPoint[1];\n            const length = Math.sqrt(dx ** 2 + dy ** 2);\n            const aabb = {\n                minX: startPoint[0] <= endPoint[0] ? startPoint[0] : endPoint[0],\n                maxX: startPoint[0] >= endPoint[0] ? startPoint[0] : endPoint[0],\n                minY: startPoint[1] <= endPoint[1] ? startPoint[1] : endPoint[1],\n                maxY: startPoint[1] >= endPoint[1] ? startPoint[1] : endPoint[1],\n            };\n            lineSegments.push({\n                points: {\n                    start: startPoint,\n                    end: endPoint,\n                },\n                aabb,\n                length,\n                previousLineSegmentsLength,\n            });\n            startPoint = endPoint;\n            previousLineSegmentsLength += length;\n        }\n        return lineSegments;\n    }\n    _getCurveSegment(curveSegmentIndex, transformMatrix = this.getTransformMatrix(), controlPoints = this.controlPoints, closed = this.closed) {\n        const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(curveSegmentIndex, controlPoints, closed);\n        const lineSegments = this._getLineSegments(curveSegmentIndex, transformMatrix, controlPoints, closed);\n        let curveSegmentLength = 0;\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n        lineSegments.forEach(({ aabb: lineSegAABB, length: lineSegLength }) => {\n            minX = Math.min(minX, lineSegAABB.minX);\n            minY = Math.min(minY, lineSegAABB.minY);\n            maxX = Math.max(maxX, lineSegAABB.maxX);\n            maxY = Math.max(maxY, lineSegAABB.maxY);\n            curveSegmentLength += lineSegLength;\n        });\n        return {\n            controlPoints: { p0, p1, p2, p3 },\n            aabb: { minX, minY, maxX, maxY },\n            length: curveSegmentLength,\n            previousCurveSegmentsLength: 0,\n            lineSegments,\n        };\n    }\n}\nexport { CubicSpline as default, CubicSpline };\n", "import { mat4 } from 'gl-matrix';\nimport { CubicSpline } from './CubicSpline';\nconst TRANSFORM_MATRIX = mat4.multiplyScalar(mat4.create(), mat4.fromValues(1, 4, 1, 0, -3, 0, 3, 0, 3, -6, 3, 0, -1, 3, -3, 1), 1 / 6);\nclass BSpline extends CubicSpline {\n    getTransformMatrix() {\n        return TRANSFORM_MATRIX;\n    }\n}\nexport { BSpline as default, BSpline };\n", "import { CubicSpline } from './CubicSpline';\nclass CardinalSpline extends CubicSpline {\n    constructor(props) {\n        super(props);\n        this._scale = props?.scale ?? 0.5;\n        this._fixedScale = props?.fixedScale ?? false;\n    }\n    get scale() {\n        return this._scale;\n    }\n    set scale(scale) {\n        if (this._fixedScale || this._scale === scale) {\n            return;\n        }\n        this._scale = scale;\n        this.invalidated = true;\n    }\n    get fixedScale() {\n        return this._fixedScale;\n    }\n    getTransformMatrix() {\n        const { scale: s } = this;\n        const s2 = 2 * s;\n        return [\n            0, 1, 0, 0,\n            -s, 0, s, 0,\n            s2, s - 3, 3 - s2, -s,\n            -s, 2 - s, s - 2, s\n        ];\n    }\n}\nexport { CardinalSpline as default, CardinalSpline };\n", "import { CardinalSpline } from './CardinalSpline';\nclass CatmullRomSpline extends CardinalSpline {\n    constructor() {\n        super({ scale: 0.5, fixedScale: true });\n    }\n}\nexport { CatmullRomSpline as default, CatmullRomSpline };\n", "import { CardinalSpline } from './CardinalSpline';\nclass LinearSpline extends CardinalSpline {\n    constructor() {\n        super({ resolution: 0, fixedResolution: true, scale: 0, fixedScale: true });\n    }\n}\nexport { LinearSpline as default, LinearSpline };\n", "import { Spline } from './Spline';\nclass QuadraticSpline extends Spline {\n    getSplineCurves() {\n        return [];\n    }\n    getLineSegments() {\n        return [];\n    }\n    getPreviewCurveSegments(controlPointPreview, closeSpline) {\n        return [];\n    }\n}\nexport { QuadraticSpline as default, QuadraticSpline };\n", "import { QuadraticSpline } from './QuadraticSpline';\nconst TRANSFORM_MATRIX = [\n    1, 0, 0,\n    -2, 2, 0,\n    1, -2, 1,\n];\nclass QuadraticBezier extends QuadraticSpline {\n    hasTangentPoints() {\n        return true;\n    }\n    getTransformMatrix() {\n        return TRANSFORM_MATRIX;\n    }\n}\nexport { QuadraticBezier as default, QuadraticBezier };\n", "import { BaseTool } from './base';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nclass PanTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            limitToViewport: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n    }\n    touchDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    mouseDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    _checkImageInViewport(viewport, deltaPointsCanvas) {\n        const { canvas } = viewport;\n        const ratio = window.devicePixelRatio;\n        const viewportLeft = 0;\n        const viewportRight = canvas.width / ratio;\n        const viewportTop = 0;\n        const viewportBottom = canvas.height / ratio;\n        const defaultActor = viewport.getDefaultActor();\n        const renderer = viewport.getRenderer();\n        let bounds;\n        if (defaultActor && csUtils.isImageActor(defaultActor)) {\n            const imageData = defaultActor.actor.getMapper().getInputData();\n            bounds = imageData.getBounds();\n        }\n        else {\n            bounds = renderer.computeVisiblePropBounds();\n        }\n        const [imageLeft, imageTop] = viewport.worldToCanvas([\n            bounds[0],\n            bounds[2],\n            bounds[4],\n        ]);\n        const [imageRight, imageBottom] = viewport.worldToCanvas([\n            bounds[1],\n            bounds[3],\n            bounds[5],\n        ]);\n        const zoom = viewport.getZoom();\n        if (zoom <= 1) {\n            if ((imageLeft + deltaPointsCanvas[0] < viewportLeft &&\n                deltaPointsCanvas[0] < 0) ||\n                (imageRight + deltaPointsCanvas[0] > viewportRight &&\n                    deltaPointsCanvas[0] > 0) ||\n                (imageTop + deltaPointsCanvas[1] < viewportTop &&\n                    deltaPointsCanvas[1] < 0) ||\n                (imageBottom + deltaPointsCanvas[1] > viewportBottom &&\n                    deltaPointsCanvas[1] > 0)) {\n                return false;\n            }\n        }\n        else {\n            if ((imageLeft + deltaPointsCanvas[0] > viewportLeft &&\n                deltaPointsCanvas[0] > 0) ||\n                (imageRight + deltaPointsCanvas[0] < viewportRight &&\n                    deltaPointsCanvas[0] < 0) ||\n                (imageTop + deltaPointsCanvas[1] > viewportTop &&\n                    deltaPointsCanvas[1] > 0) ||\n                (imageBottom + deltaPointsCanvas[1] < viewportBottom &&\n                    deltaPointsCanvas[1] < 0)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _dragCallback(evt) {\n        const { element, deltaPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const deltaPointsWorld = deltaPoints.world;\n        const deltaPointsCanvas = deltaPoints.canvas;\n        if (deltaPointsWorld[0] === 0 &&\n            deltaPointsWorld[1] === 0 &&\n            deltaPointsWorld[2] === 0) {\n            return;\n        }\n        const viewport = enabledElement.viewport;\n        const camera = viewport.getCamera();\n        const { focalPoint, position } = camera;\n        if (this.configuration.limitToViewport &&\n            !this._checkImageInViewport(viewport, deltaPointsCanvas)) {\n            return;\n        }\n        const updatedPosition = [\n            position[0] - deltaPointsWorld[0],\n            position[1] - deltaPointsWorld[1],\n            position[2] - deltaPointsWorld[2],\n        ];\n        const updatedFocalPoint = [\n            focalPoint[0] - deltaPointsWorld[0],\n            focalPoint[1] - deltaPointsWorld[1],\n            focalPoint[2] - deltaPointsWorld[2],\n        ];\n        viewport.setCamera({\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n        viewport.render();\n    }\n}\nPanTool.toolName = 'Pan';\nexport default PanTool;\n", "import vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { Events } from '../enums';\nimport { eventTarget, getEnabledElement, getEnabledElementByIds, } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { BaseTool } from './base';\nimport { getToolGroup } from '../store/ToolGroupManager';\nclass TrackballRotateTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            rotateIncrementDegrees: 2,\n            rotateSampleDistanceFactor: 2,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._resizeObservers = new Map();\n        this._hasResolutionChanged = false;\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const actorEntry = viewport.getDefaultActor();\n            const actor = actorEntry.actor;\n            const mapper = actor.getMapper();\n            const hasSampleDistance = 'getSampleDistance' in mapper || 'getCurrentSampleDistance' in mapper;\n            if (!hasSampleDistance) {\n                return true;\n            }\n            const originalSampleDistance = mapper.getSampleDistance();\n            if (!this._hasResolutionChanged) {\n                const { rotateSampleDistanceFactor } = this.configuration;\n                mapper.setSampleDistance(originalSampleDistance * rotateSampleDistanceFactor);\n                this._hasResolutionChanged = true;\n                if (this.cleanUp !== null) {\n                    document.removeEventListener('mouseup', this.cleanUp);\n                }\n                this.cleanUp = () => {\n                    mapper.setSampleDistance(originalSampleDistance);\n                    viewport.render();\n                    this._hasResolutionChanged = false;\n                };\n                document.addEventListener('mouseup', this.cleanUp, { once: true });\n            }\n            return true;\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this.onSetToolActive = () => {\n            const subscribeToElementResize = () => {\n                const viewportsInfo = this._getViewportsInfo();\n                viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                    if (!this._resizeObservers.has(viewportId)) {\n                        const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId) || { viewport: null };\n                        if (!viewport) {\n                            return;\n                        }\n                        const { element } = viewport;\n                        const resizeObserver = new ResizeObserver(() => {\n                            const element = getEnabledElementByIds(viewportId, renderingEngineId);\n                            if (!element) {\n                                return;\n                            }\n                            const { viewport } = element;\n                            const viewPresentation = viewport.getViewPresentation();\n                            viewport.resetCamera();\n                            viewport.setViewPresentation(viewPresentation);\n                            viewport.render();\n                        });\n                        resizeObserver.observe(element);\n                        this._resizeObservers.set(viewportId, resizeObserver);\n                    }\n                });\n            };\n            subscribeToElementResize();\n            this._viewportAddedListener = (evt) => {\n                if (evt.detail.toolGroupId === this.toolGroupId) {\n                    subscribeToElementResize();\n                }\n            };\n            eventTarget.addEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);\n        };\n        this.onSetToolDisabled = () => {\n            this._resizeObservers.forEach((resizeObserver, viewportId) => {\n                resizeObserver.disconnect();\n                this._resizeObservers.delete(viewportId);\n            });\n            if (this._viewportAddedListener) {\n                eventTarget.removeEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);\n                this._viewportAddedListener = null;\n            }\n        };\n        this.rotateCamera = (viewport, centerWorld, axis, angle) => {\n            const vtkCamera = viewport.getVtkActiveCamera();\n            const viewUp = vtkCamera.getViewUp();\n            const focalPoint = vtkCamera.getFocalPoint();\n            const position = vtkCamera.getPosition();\n            const newPosition = [0, 0, 0];\n            const newFocalPoint = [0, 0, 0];\n            const newViewUp = [0, 0, 0];\n            const transform = mat4.identity(new Float32Array(16));\n            mat4.translate(transform, transform, centerWorld);\n            mat4.rotate(transform, transform, angle, axis);\n            mat4.translate(transform, transform, [\n                -centerWorld[0],\n                -centerWorld[1],\n                -centerWorld[2],\n            ]);\n            vec3.transformMat4(newPosition, position, transform);\n            vec3.transformMat4(newFocalPoint, focalPoint, transform);\n            mat4.identity(transform);\n            mat4.rotate(transform, transform, angle, axis);\n            vec3.transformMat4(newViewUp, viewUp, transform);\n            viewport.setCamera({\n                position: newPosition,\n                viewUp: newViewUp,\n                focalPoint: newFocalPoint,\n            });\n        };\n        this.touchDragCallback = this._dragCallback.bind(this);\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    _dragCallback(evt) {\n        const { element, currentPoints, lastPoints } = evt.detail;\n        const currentPointsCanvas = currentPoints.canvas;\n        const lastPointsCanvas = lastPoints.canvas;\n        const { rotateIncrementDegrees } = this.configuration;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const width = element.clientWidth;\n        const height = element.clientHeight;\n        const normalizedPosition = [\n            currentPointsCanvas[0] / width,\n            currentPointsCanvas[1] / height,\n        ];\n        const normalizedPreviousPosition = [\n            lastPointsCanvas[0] / width,\n            lastPointsCanvas[1] / height,\n        ];\n        const center = [width * 0.5, height * 0.5];\n        const centerWorld = viewport.canvasToWorld(center);\n        const normalizedCenter = [0.5, 0.5];\n        const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;\n        const op = [normalizedPreviousPosition[0], 0, 0];\n        const oe = [normalizedPosition[0], 0, 0];\n        const opsq = op[0] ** 2;\n        const oesq = oe[0] ** 2;\n        const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);\n        const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);\n        const nop = [op[0], 0, lop];\n        vtkMath.normalize(nop);\n        const noe = [oe[0], 0, loe];\n        vtkMath.normalize(noe);\n        const dot = vtkMath.dot(nop, noe);\n        if (Math.abs(dot) > 0.0001) {\n            const angleX = -2 *\n                Math.acos(vtkMath.clampValue(dot, -1.0, 1.0)) *\n                Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) *\n                rotateIncrementDegrees;\n            const upVec = camera.viewUp;\n            const atV = camera.viewPlaneNormal;\n            const rightV = [0, 0, 0];\n            const forwardV = [0, 0, 0];\n            vtkMath.cross(upVec, atV, rightV);\n            vtkMath.normalize(rightV);\n            vtkMath.cross(atV, rightV, forwardV);\n            vtkMath.normalize(forwardV);\n            vtkMath.normalize(upVec);\n            this.rotateCamera(viewport, centerWorld, forwardV, angleX);\n            const angleY = (normalizedPreviousPosition[1] - normalizedPosition[1]) *\n                rotateIncrementDegrees;\n            this.rotateCamera(viewport, centerWorld, rightV, angleY);\n            viewport.render();\n        }\n    }\n}\nTrackballRotateTool.toolName = 'TrackballRotate';\nexport default TrackballRotateTool;\n", "import { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\n\n// ----------------------------------------------------------------------------\n// vtkSphereSource methods\n// ----------------------------------------------------------------------------\n\nfunction vtkSphereSource(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkSphereSource');\n  publicAPI.requestData = (inData, outData) => {\n    if (model.deleted) {\n      return;\n    }\n    let dataset = outData[0];\n    const pointDataType = dataset ? dataset.getPoints().getDataType() : model.pointType;\n    dataset = vtkPolyData.newInstance();\n\n    // ----------------------------------------------------------------------\n    let numPoles = 0;\n\n    // Check data, determine increments, and convert to radians\n    let {\n      thetaResolution\n    } = model;\n    let startTheta = model.startTheta < model.endTheta ? model.startTheta : model.endTheta;\n    startTheta *= Math.PI / 180.0;\n    let endTheta = model.endTheta > model.startTheta ? model.endTheta : model.startTheta;\n    endTheta *= Math.PI / 180.0;\n    let startPhi = model.startPhi < model.endPhi ? model.startPhi : model.endPhi;\n    startPhi *= Math.PI / 180.0;\n    let endPhi = model.endPhi > model.startPhi ? model.endPhi : model.startPhi;\n    endPhi *= Math.PI / 180.0;\n    if (Math.abs(startTheta - endTheta) < 2.0 * Math.PI) {\n      ++thetaResolution;\n    }\n    const deltaTheta = (endTheta - startTheta) / model.thetaResolution;\n    const jStart = model.startPhi <= 0.0 ? 1 : 0;\n    const jEnd = model.phiResolution + (model.endPhi >= 180.0 ? -1 : 0);\n    const numPts = model.phiResolution * thetaResolution + 2;\n    const numPolys = model.phiResolution * 2 * model.thetaResolution;\n\n    // Points\n    let pointIdx = 0;\n    let points = macro.newTypedArray(pointDataType, numPts * 3);\n\n    // Normals\n    let normals = new Float32Array(numPts * 3);\n\n    // Cells\n    let cellLocation = 0;\n    let polys = new Uint32Array(numPolys * 5);\n\n    // Create north pole if needed\n    if (model.startPhi <= 0.0) {\n      points[pointIdx * 3 + 0] = model.center[0];\n      points[pointIdx * 3 + 1] = model.center[1];\n      points[pointIdx * 3 + 2] = model.center[2] + model.radius;\n      normals[pointIdx * 3 + 0] = 0;\n      normals[pointIdx * 3 + 1] = 0;\n      normals[pointIdx * 3 + 2] = 1;\n      pointIdx++;\n      numPoles++;\n    }\n\n    // Create south pole if needed\n    if (model.endPhi >= 180.0) {\n      points[pointIdx * 3 + 0] = model.center[0];\n      points[pointIdx * 3 + 1] = model.center[1];\n      points[pointIdx * 3 + 2] = model.center[2] - model.radius;\n      normals[pointIdx * 3 + 0] = 0;\n      normals[pointIdx * 3 + 1] = 0;\n      normals[pointIdx * 3 + 2] = -1;\n      pointIdx++;\n      numPoles++;\n    }\n    const phiResolution = model.phiResolution - numPoles;\n    const deltaPhi = (endPhi - startPhi) / (model.phiResolution - 1);\n\n    // Create intermediate points\n    for (let i = 0; i < thetaResolution; i++) {\n      const theta = startTheta + i * deltaTheta;\n      for (let j = jStart; j < jEnd; j++) {\n        const phi = startPhi + j * deltaPhi;\n        const radius = model.radius * Math.sin(phi);\n        normals[pointIdx * 3 + 0] = radius * Math.cos(theta);\n        normals[pointIdx * 3 + 1] = radius * Math.sin(theta);\n        normals[pointIdx * 3 + 2] = model.radius * Math.cos(phi);\n        points[pointIdx * 3 + 0] = normals[pointIdx * 3 + 0] + model.center[0];\n        points[pointIdx * 3 + 1] = normals[pointIdx * 3 + 1] + model.center[1];\n        points[pointIdx * 3 + 2] = normals[pointIdx * 3 + 2] + model.center[2];\n        let norm = Math.sqrt(normals[pointIdx * 3 + 0] * normals[pointIdx * 3 + 0] + normals[pointIdx * 3 + 1] * normals[pointIdx * 3 + 1] + normals[pointIdx * 3 + 2] * normals[pointIdx * 3 + 2]);\n        norm = norm === 0 ? 1 : norm;\n        normals[pointIdx * 3 + 0] /= norm;\n        normals[pointIdx * 3 + 1] /= norm;\n        normals[pointIdx * 3 + 2] /= norm;\n        pointIdx++;\n      }\n    }\n\n    // Generate mesh connectivity\n    const base = phiResolution * thetaResolution;\n    if (Math.abs(startTheta - endTheta) < 2.0 * Math.PI) {\n      --thetaResolution;\n    }\n\n    // around north pole\n    if (model.startPhi <= 0.0) {\n      for (let i = 0; i < thetaResolution; i++) {\n        polys[cellLocation++] = 3;\n        polys[cellLocation++] = phiResolution * i + numPoles;\n        polys[cellLocation++] = phiResolution * (i + 1) % base + numPoles;\n        polys[cellLocation++] = 0;\n      }\n    }\n\n    // around south pole\n    if (model.endPhi >= 180.0) {\n      const numOffset = phiResolution - 1 + numPoles;\n      for (let i = 0; i < thetaResolution; i++) {\n        polys[cellLocation++] = 3;\n        polys[cellLocation++] = phiResolution * i + numOffset;\n        polys[cellLocation++] = numPoles - 1;\n        polys[cellLocation++] = phiResolution * (i + 1) % base + numOffset;\n      }\n    }\n\n    // bands in-between poles\n    for (let i = 0; i < thetaResolution; i++) {\n      for (let j = 0; j < phiResolution - 1; j++) {\n        const a = phiResolution * i + j + numPoles;\n        const b = a + 1;\n        const c = (phiResolution * (i + 1) + j) % base + numPoles + 1;\n        if (!model.latLongTessellation) {\n          polys[cellLocation++] = 3;\n          polys[cellLocation++] = a;\n          polys[cellLocation++] = b;\n          polys[cellLocation++] = c;\n          polys[cellLocation++] = 3;\n          polys[cellLocation++] = a;\n          polys[cellLocation++] = c;\n          polys[cellLocation++] = c - 1;\n        } else {\n          polys[cellLocation++] = 4;\n          polys[cellLocation++] = a;\n          polys[cellLocation++] = b;\n          polys[cellLocation++] = c;\n          polys[cellLocation++] = c - 1;\n        }\n      }\n    }\n\n    // Squeeze\n    points = points.subarray(0, pointIdx * 3);\n    dataset.getPoints().setData(points, 3);\n    normals = normals.subarray(0, pointIdx * 3);\n    const normalArray = vtkDataArray.newInstance({\n      name: 'Normals',\n      values: normals,\n      numberOfComponents: 3\n    });\n    dataset.getPointData().setNormals(normalArray);\n    polys = polys.subarray(0, cellLocation);\n    dataset.getPolys().setData(polys, 1);\n\n    // Update output\n    outData[0] = dataset;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  radius: 0.5,\n  latLongTessellation: false,\n  thetaResolution: 8,\n  startTheta: 0.0,\n  endTheta: 360.0,\n  phiResolution: 8,\n  startPhi: 0.0,\n  endPhi: 180.0,\n  center: [0, 0, 0],\n  pointType: 'Float64Array'\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['radius', 'latLongTessellation', 'thetaResolution', 'startTheta', 'endTheta', 'phiResolution', 'startPhi', 'endPhi']);\n  macro.setGetArray(publicAPI, model, ['center'], 3);\n  macro.algo(publicAPI, model, 0, 1);\n  vtkSphereSource(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkSphereSource');\n\n// ----------------------------------------------------------------------------\n\nvar vtkSphereSource$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkSphereSource$1 as default, extend, newInstance };\n", "import vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport vtkPoints from '@kitware/vtk.js/Common/Core/Points';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport { mat3, mat4, vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkSphereSource from '@kitware/vtk.js/Filters/Sources/SphereSource';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkPlane from '@kitware/vtk.js/Common/DataModel/Plane';\nimport { BaseTool } from './base';\nimport { getRenderingEngine, getEnabledElementByIds, getEnabledElement, Enums, triggerEvent, eventTarget, } from '@cornerstonejs/core';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport { Events } from '../enums';\nconst PLANEINDEX = {\n    XMIN: 0,\n    XMAX: 1,\n    YMIN: 2,\n    YMAX: 3,\n    ZMIN: 4,\n    ZMAX: 5,\n};\nconst SPHEREINDEX = {\n    XMIN: 0,\n    XMAX: 1,\n    YMIN: 2,\n    YMAX: 3,\n    ZMIN: 4,\n    ZMAX: 5,\n    XMIN_YMIN_ZMIN: 6,\n    XMIN_YMIN_ZMAX: 7,\n    XMIN_YMAX_ZMIN: 8,\n    XMIN_YMAX_ZMAX: 9,\n    XMAX_YMIN_ZMIN: 10,\n    XMAX_YMIN_ZMAX: 11,\n    XMAX_YMAX_ZMIN: 12,\n    XMAX_YMAX_ZMAX: 13,\n};\nclass VolumeCroppingTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            showCornerSpheres: true,\n            showHandles: true,\n            showClippingPlanes: true,\n            mobile: {\n                enabled: false,\n                opacity: 0.8,\n            },\n            initialCropFactor: 0.08,\n            sphereColors: {\n                SAGITTAL: [1.0, 1.0, 0.0],\n                CORONAL: [0.0, 1.0, 0.0],\n                AXIAL: [1.0, 0.0, 0.0],\n                CORNERS: [0.0, 0.0, 1.0],\n            },\n            sphereRadius: 8,\n            grabSpherePixelDistance: 20,\n            rotateIncrementDegrees: 2,\n            rotateSampleDistanceFactor: 2,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._resizeObservers = new Map();\n        this._hasResolutionChanged = false;\n        this.originalClippingPlanes = [];\n        this.draggingSphereIndex = null;\n        this.toolCenter = [0, 0, 0];\n        this.cornerDragOffset = null;\n        this.faceDragOffset = null;\n        this.sphereStates = [];\n        this.edgeLines = {};\n        this.onSetToolConfiguration = () => {\n            console.debug('Setting tool settoolconfiguration : volumeCropping');\n        };\n        this.onSetToolEnabled = () => {\n            console.debug('Setting tool enabled: volumeCropping');\n        };\n        this.onCameraModified = (evt) => {\n            const { element } = evt.currentTarget\n                ? { element: evt.currentTarget }\n                : evt.detail;\n            const enabledElement = getEnabledElement(element);\n            this._updateClippingPlanes(enabledElement.viewport);\n            enabledElement.viewport.render();\n        };\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const actorEntry = viewport.getDefaultActor();\n            const actor = actorEntry.actor;\n            const mapper = actor.getMapper();\n            const mouseCanvas = [\n                evt.detail.currentPoints.canvas[0],\n                evt.detail.currentPoints.canvas[1],\n            ];\n            this.draggingSphereIndex = null;\n            this.cornerDragOffset = null;\n            this.faceDragOffset = null;\n            for (let i = 0; i < this.sphereStates.length; ++i) {\n                const sphereCanvas = viewport.worldToCanvas(this.sphereStates[i].point);\n                const dist = Math.sqrt(Math.pow(mouseCanvas[0] - sphereCanvas[0], 2) +\n                    Math.pow(mouseCanvas[1] - sphereCanvas[1], 2));\n                if (dist < this.configuration.grabSpherePixelDistance) {\n                    this.draggingSphereIndex = i;\n                    element.style.cursor = 'grabbing';\n                    const sphereState = this.sphereStates[i];\n                    const mouseWorld = viewport.canvasToWorld(mouseCanvas);\n                    if (sphereState.isCorner) {\n                        this.cornerDragOffset = [\n                            sphereState.point[0] - mouseWorld[0],\n                            sphereState.point[1] - mouseWorld[1],\n                            sphereState.point[2] - mouseWorld[2],\n                        ];\n                        this.faceDragOffset = null;\n                    }\n                    else {\n                        const axisIdx = { x: 0, y: 1, z: 2 }[sphereState.axis];\n                        this.faceDragOffset =\n                            sphereState.point[axisIdx] - mouseWorld[axisIdx];\n                        this.cornerDragOffset = null;\n                    }\n                    return true;\n                }\n            }\n            const hasSampleDistance = 'getSampleDistance' in mapper || 'getCurrentSampleDistance' in mapper;\n            if (!hasSampleDistance) {\n                return true;\n            }\n            const originalSampleDistance = mapper.getSampleDistance();\n            if (!this._hasResolutionChanged) {\n                const { rotateSampleDistanceFactor } = this.configuration;\n                mapper.setSampleDistance(originalSampleDistance * rotateSampleDistanceFactor);\n                this._hasResolutionChanged = true;\n                if (this.cleanUp !== null) {\n                    document.removeEventListener('mouseup', this.cleanUp);\n                }\n                this.cleanUp = () => {\n                    mapper.setSampleDistance(originalSampleDistance);\n                    evt.target.style.cursor = '';\n                    if (this.draggingSphereIndex !== null) {\n                        const sphereState = this.sphereStates[this.draggingSphereIndex];\n                        const [viewport3D] = this._getViewportsInfo();\n                        const renderingEngine = getRenderingEngine(viewport3D.renderingEngineId);\n                        const viewport = renderingEngine.getViewport(viewport3D.viewportId);\n                        if (sphereState.isCorner) {\n                            this._updateCornerSpheres();\n                            this._updateFaceSpheresFromCorners();\n                            this._updateClippingPlanesFromFaceSpheres(viewport);\n                        }\n                    }\n                    this.draggingSphereIndex = null;\n                    this.cornerDragOffset = null;\n                    this.faceDragOffset = null;\n                    viewport.render();\n                    this._hasResolutionChanged = false;\n                };\n                document.addEventListener('mouseup', this.cleanUp, { once: true });\n            }\n            return true;\n        };\n        this._onMouseMoveSphere = (evt) => {\n            if (this.draggingSphereIndex === null) {\n                return false;\n            }\n            const sphereState = this.sphereStates[this.draggingSphereIndex];\n            if (!sphereState) {\n                return false;\n            }\n            const { viewport, world } = this._getViewportAndWorldCoords(evt);\n            if (!viewport || !world) {\n                return false;\n            }\n            if (sphereState.isCorner) {\n                const newCorner = this._calculateNewCornerPosition(world);\n                this._updateSpherePosition(sphereState, newCorner);\n                const axisFlags = this._parseCornerKey(sphereState.uid);\n                this._updateRelatedCorners(sphereState, newCorner, axisFlags);\n                this._updateFaceSpheresFromCorners();\n                this._updateCornerSpheres();\n            }\n            else {\n                const axisIdx = { x: 0, y: 1, z: 2 }[sphereState.axis];\n                let newValue = world[axisIdx];\n                if (this.faceDragOffset !== null) {\n                    newValue += this.faceDragOffset;\n                }\n                sphereState.point[axisIdx] = newValue;\n                sphereState.sphereSource.setCenter(...sphereState.point);\n                sphereState.sphereSource.modified();\n                this._updateCornerSpheresFromFaces();\n                this._updateFaceSpheresFromCorners();\n                this._updateCornerSpheres();\n            }\n            this._updateClippingPlanesFromFaceSpheres(viewport);\n            viewport.render();\n            this._triggerToolChangedEvent(sphereState);\n            return true;\n        };\n        this._onControlToolChange = (evt) => {\n            const viewport = this._getViewport();\n            if (!evt.detail.toolCenter) {\n                triggerEvent(eventTarget, Events.VOLUMECROPPING_TOOL_CHANGED, {\n                    originalClippingPlanes: this.originalClippingPlanes,\n                    viewportId: viewport.id,\n                    renderingEngineId: viewport.renderingEngineId,\n                    seriesInstanceUID: this.seriesInstanceUID,\n                });\n            }\n            else {\n                if (evt.detail.seriesInstanceUID !== this.seriesInstanceUID) {\n                    return;\n                }\n                const isMin = evt.detail.handleType === 'min';\n                const toolCenter = isMin\n                    ? evt.detail.toolCenterMin\n                    : evt.detail.toolCenterMax;\n                const normals = isMin\n                    ? [\n                        [1, 0, 0],\n                        [0, 1, 0],\n                        [0, 0, 1],\n                    ]\n                    : [\n                        [-1, 0, 0],\n                        [0, -1, 0],\n                        [0, 0, -1],\n                    ];\n                const planeIndices = isMin\n                    ? [PLANEINDEX.XMIN, PLANEINDEX.YMIN, PLANEINDEX.ZMIN]\n                    : [PLANEINDEX.XMAX, PLANEINDEX.YMAX, PLANEINDEX.ZMAX];\n                const sphereIndices = isMin\n                    ? [SPHEREINDEX.XMIN, SPHEREINDEX.YMIN, SPHEREINDEX.ZMIN]\n                    : [SPHEREINDEX.XMAX, SPHEREINDEX.YMAX, SPHEREINDEX.ZMAX];\n                const axes = ['x', 'y', 'z'];\n                const orientationAxes = [\n                    Enums.OrientationAxis.SAGITTAL,\n                    Enums.OrientationAxis.CORONAL,\n                    Enums.OrientationAxis.AXIAL,\n                ];\n                for (let i = 0; i < 3; ++i) {\n                    const origin = [0, 0, 0];\n                    origin[i] = toolCenter[i];\n                    const plane = vtkPlane.newInstance({\n                        origin,\n                        normal: normals[i],\n                    });\n                    this.originalClippingPlanes[planeIndices[i]].origin = plane.getOrigin();\n                    this.sphereStates[sphereIndices[i]].point[i] = plane.getOrigin()[i];\n                    this.sphereStates[sphereIndices[i]].sphereSource.setCenter(...this.sphereStates[sphereIndices[i]].point);\n                    this.sphereStates[sphereIndices[i]].sphereSource.modified();\n                    const otherSphere = this.sphereStates.find((s, idx) => s.axis === axes[i] && idx !== sphereIndices[i]);\n                    const newCenter = (otherSphere.point[i] + plane.getOrigin()[i]) / 2;\n                    this.sphereStates.forEach((state) => {\n                        if (!state.isCorner &&\n                            state.axis !== axes[i] &&\n                            !evt.detail.viewportOrientation.includes(orientationAxes[i])) {\n                            state.point[i] = newCenter;\n                            state.sphereSource.setCenter(state.point);\n                            state.sphereActor.getProperty().setColor(state.color);\n                            state.sphereSource.modified();\n                        }\n                    });\n                    const volumeActor = viewport.getDefaultActor()?.actor;\n                    if (volumeActor) {\n                        const mapper = volumeActor.getMapper();\n                        const clippingPlanes = mapper.getClippingPlanes();\n                        if (clippingPlanes) {\n                            clippingPlanes[planeIndices[i]].setOrigin(plane.getOrigin());\n                        }\n                    }\n                }\n                this._updateCornerSpheres();\n                viewport.render();\n            }\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this._initialize3DViewports = (viewportsInfo) => {\n            if (!viewportsInfo || !viewportsInfo.length || !viewportsInfo[0]) {\n                console.warn('VolumeCroppingTool: No viewportsInfo available for initialization of volumecroppingtool.');\n                return;\n            }\n            const viewport = this._getViewport();\n            const volumeActors = viewport.getActors();\n            if (!volumeActors || volumeActors.length === 0) {\n                console.warn('VolumeCroppingTool: No volume actors found in the viewport.');\n                return;\n            }\n            const imageData = volumeActors[0].actor.getMapper().getInputData();\n            if (!imageData) {\n                console.warn('VolumeCroppingTool: No image data found for volume actor.');\n                return;\n            }\n            this.seriesInstanceUID = imageData.seriesInstanceUID || 'unknown';\n            const worldBounds = imageData.getBounds();\n            const cropFactor = this.configuration.initialCropFactor || 0.1;\n            const xRange = worldBounds[1] - worldBounds[0];\n            const yRange = worldBounds[3] - worldBounds[2];\n            const zRange = worldBounds[5] - worldBounds[4];\n            const xMin = worldBounds[0] + cropFactor * xRange;\n            const xMax = worldBounds[1] - cropFactor * xRange;\n            const yMin = worldBounds[2] + cropFactor * yRange;\n            const yMax = worldBounds[3] - cropFactor * yRange;\n            const zMin = worldBounds[4] + cropFactor * zRange;\n            const zMax = worldBounds[5] - cropFactor * zRange;\n            const planes = [];\n            const planeXmin = vtkPlane.newInstance({\n                origin: [xMin, 0, 0],\n                normal: [1, 0, 0],\n            });\n            const planeXmax = vtkPlane.newInstance({\n                origin: [xMax, 0, 0],\n                normal: [-1, 0, 0],\n            });\n            const planeYmin = vtkPlane.newInstance({\n                origin: [0, yMin, 0],\n                normal: [0, 1, 0],\n            });\n            const planeYmax = vtkPlane.newInstance({\n                origin: [0, yMax, 0],\n                normal: [0, -1, 0],\n            });\n            const planeZmin = vtkPlane.newInstance({\n                origin: [0, 0, zMin],\n                normal: [0, 0, 1],\n            });\n            const planeZmax = vtkPlane.newInstance({\n                origin: [0, 0, zMax],\n                normal: [0, 0, -1],\n            });\n            const mapper = viewport\n                .getDefaultActor()\n                .actor.getMapper();\n            planes.push(planeXmin);\n            planes.push(planeXmax);\n            planes.push(planeYmin);\n            planes.push(planeYmax);\n            planes.push(planeZmin);\n            planes.push(planeZmax);\n            const originalPlanes = planes.map((plane) => ({\n                origin: [...plane.getOrigin()],\n                normal: [...plane.getNormal()],\n            }));\n            this.originalClippingPlanes = originalPlanes;\n            const sphereXminPoint = [xMin, (yMax + yMin) / 2, (zMax + zMin) / 2];\n            const sphereXmaxPoint = [xMax, (yMax + yMin) / 2, (zMax + zMin) / 2];\n            const sphereYminPoint = [(xMax + xMin) / 2, yMin, (zMax + zMin) / 2];\n            const sphereYmaxPoint = [(xMax + xMin) / 2, yMax, (zMax + zMin) / 2];\n            const sphereZminPoint = [(xMax + xMin) / 2, (yMax + yMin) / 2, zMin];\n            const sphereZmaxPoint = [(xMax + xMin) / 2, (yMax + yMin) / 2, zMax];\n            const adaptiveRadius = this._calculateAdaptiveSphereRadius(Math.sqrt(xRange * xRange + yRange * yRange + zRange * zRange));\n            this._addSphere(viewport, sphereXminPoint, 'x', 'min', null, adaptiveRadius);\n            this._addSphere(viewport, sphereXmaxPoint, 'x', 'max', null, adaptiveRadius);\n            this._addSphere(viewport, sphereYminPoint, 'y', 'min', null, adaptiveRadius);\n            this._addSphere(viewport, sphereYmaxPoint, 'y', 'max', null, adaptiveRadius);\n            this._addSphere(viewport, sphereZminPoint, 'z', 'min', null, adaptiveRadius);\n            this._addSphere(viewport, sphereZmaxPoint, 'z', 'max', null, adaptiveRadius);\n            const corners = [\n                [xMin, yMin, zMin],\n                [xMin, yMin, zMax],\n                [xMin, yMax, zMin],\n                [xMin, yMax, zMax],\n                [xMax, yMin, zMin],\n                [xMax, yMin, zMax],\n                [xMax, yMax, zMin],\n                [xMax, yMax, zMax],\n            ];\n            const cornerKeys = [\n                'XMIN_YMIN_ZMIN',\n                'XMIN_YMIN_ZMAX',\n                'XMIN_YMAX_ZMIN',\n                'XMIN_YMAX_ZMAX',\n                'XMAX_YMIN_ZMIN',\n                'XMAX_YMIN_ZMAX',\n                'XMAX_YMAX_ZMIN',\n                'XMAX_YMAX_ZMAX',\n            ];\n            for (let i = 0; i < corners.length; i++) {\n                this._addSphere(viewport, corners[i], 'corner', null, cornerKeys[i], adaptiveRadius);\n            }\n            const edgeCornerPairs = [\n                ['XMIN_YMIN_ZMIN', 'XMAX_YMIN_ZMIN'],\n                ['XMIN_YMIN_ZMAX', 'XMAX_YMIN_ZMAX'],\n                ['XMIN_YMAX_ZMIN', 'XMAX_YMAX_ZMIN'],\n                ['XMIN_YMAX_ZMAX', 'XMAX_YMAX_ZMAX'],\n                ['XMIN_YMIN_ZMIN', 'XMIN_YMAX_ZMIN'],\n                ['XMIN_YMIN_ZMAX', 'XMIN_YMAX_ZMAX'],\n                ['XMAX_YMIN_ZMIN', 'XMAX_YMAX_ZMIN'],\n                ['XMAX_YMIN_ZMAX', 'XMAX_YMAX_ZMAX'],\n                ['XMIN_YMIN_ZMIN', 'XMIN_YMIN_ZMAX'],\n                ['XMIN_YMAX_ZMIN', 'XMIN_YMAX_ZMAX'],\n                ['XMAX_YMIN_ZMIN', 'XMAX_YMIN_ZMAX'],\n                ['XMAX_YMAX_ZMIN', 'XMAX_YMAX_ZMAX'],\n            ];\n            edgeCornerPairs.forEach(([key1, key2], i) => {\n                const state1 = this.sphereStates.find((s) => s.uid === `corner_${key1}`);\n                const state2 = this.sphereStates.find((s) => s.uid === `corner_${key2}`);\n                if (state1 && state2) {\n                    const uid = `edge_${key1}_${key2}`;\n                    const { actor, source } = this._addLine3DBetweenPoints(viewport, state1.point, state2.point, [0.7, 0.7, 0.7], uid);\n                    this.edgeLines[uid] = { actor, source, key1, key2 };\n                }\n            });\n            mapper.addClippingPlane(planeXmin);\n            mapper.addClippingPlane(planeXmax);\n            mapper.addClippingPlane(planeYmin);\n            mapper.addClippingPlane(planeYmax);\n            mapper.addClippingPlane(planeZmin);\n            mapper.addClippingPlane(planeZmax);\n            eventTarget.addEventListener(Events.VOLUMECROPPINGCONTROL_TOOL_CHANGED, (evt) => {\n                this._onControlToolChange(evt);\n            });\n            viewport.render();\n        };\n        this._getViewportAndWorldCoords = (evt) => {\n            const viewport = this._getViewport();\n            const x = evt.detail.currentPoints.canvas[0];\n            const y = evt.detail.currentPoints.canvas[1];\n            const world = viewport.canvasToWorld([x, y]);\n            return { viewport, world };\n        };\n        this._getViewport = () => {\n            const [viewport3D] = this._getViewportsInfo();\n            const renderingEngine = getRenderingEngine(viewport3D.renderingEngineId);\n            return renderingEngine.getViewport(viewport3D.viewportId);\n        };\n        this._handleCornerSphereMovement = (sphereState, world, viewport) => {\n            const newCorner = this._calculateNewCornerPosition(world);\n            this._updateSpherePosition(sphereState, newCorner);\n            const axisFlags = this._parseCornerKey(sphereState.uid);\n            this._updateRelatedCorners(sphereState, newCorner, axisFlags);\n            this._updateAfterCornerMovement(viewport);\n        };\n        this._handleFaceSphereMovement = (sphereState, world, viewport) => {\n            const axisIdx = { x: 0, y: 1, z: 2 }[sphereState.axis];\n            let newValue = world[axisIdx];\n            if (this.faceDragOffset !== null) {\n                newValue += this.faceDragOffset;\n            }\n            sphereState.point[axisIdx] = newValue;\n            sphereState.sphereSource.setCenter(...sphereState.point);\n            sphereState.sphereSource.modified();\n            this._updateAfterFaceMovement(viewport);\n        };\n        this._calculateNewCornerPosition = (world) => {\n            let newCorner = [world[0], world[1], world[2]];\n            if (this.cornerDragOffset) {\n                newCorner = [\n                    world[0] + this.cornerDragOffset[0],\n                    world[1] + this.cornerDragOffset[1],\n                    world[2] + this.cornerDragOffset[2],\n                ];\n            }\n            return newCorner;\n        };\n        this._parseCornerKey = (uid) => {\n            const cornerKey = uid.replace('corner_', '');\n            return {\n                isXMin: cornerKey.includes('XMIN'),\n                isXMax: cornerKey.includes('XMAX'),\n                isYMin: cornerKey.includes('YMIN'),\n                isYMax: cornerKey.includes('YMAX'),\n                isZMin: cornerKey.includes('ZMIN'),\n                isZMax: cornerKey.includes('ZMAX'),\n            };\n        };\n        this._updateSpherePosition = (sphereState, newPosition) => {\n            sphereState.point = newPosition;\n            sphereState.sphereSource.setCenter(...newPosition);\n            sphereState.sphereSource.modified();\n        };\n        this._updateRelatedCorners = (draggedSphere, newCorner, axisFlags) => {\n            this.sphereStates.forEach((state) => {\n                if (!state.isCorner || state === draggedSphere) {\n                    return;\n                }\n                const key = state.uid.replace('corner_', '');\n                const shouldUpdate = this._shouldUpdateCorner(key, axisFlags);\n                if (shouldUpdate) {\n                    this._updateCornerCoordinates(state, newCorner, key, axisFlags);\n                }\n            });\n        };\n        this._shouldUpdateCorner = (cornerKey, axisFlags) => {\n            return ((axisFlags.isXMin && cornerKey.includes('XMIN')) ||\n                (axisFlags.isXMax && cornerKey.includes('XMAX')) ||\n                (axisFlags.isYMin && cornerKey.includes('YMIN')) ||\n                (axisFlags.isYMax && cornerKey.includes('YMAX')) ||\n                (axisFlags.isZMin && cornerKey.includes('ZMIN')) ||\n                (axisFlags.isZMax && cornerKey.includes('ZMAX')));\n        };\n        this._updateCornerCoordinates = (state, newCorner, cornerKey, axisFlags) => {\n            if ((axisFlags.isXMin && cornerKey.includes('XMIN')) ||\n                (axisFlags.isXMax && cornerKey.includes('XMAX'))) {\n                state.point[0] = newCorner[0];\n            }\n            if ((axisFlags.isYMin && cornerKey.includes('YMIN')) ||\n                (axisFlags.isYMax && cornerKey.includes('YMAX'))) {\n                state.point[1] = newCorner[1];\n            }\n            if ((axisFlags.isZMin && cornerKey.includes('ZMIN')) ||\n                (axisFlags.isZMax && cornerKey.includes('ZMAX'))) {\n                state.point[2] = newCorner[2];\n            }\n            state.sphereSource.setCenter(...state.point);\n            state.sphereSource.modified();\n        };\n        this._updateAfterCornerMovement = (viewport) => {\n            this._updateFaceSpheresFromCorners();\n            this._updateCornerSpheres();\n            this._updateClippingPlanesFromFaceSpheres(viewport);\n        };\n        this._updateAfterFaceMovement = (viewport) => {\n            this._updateCornerSpheresFromFaces();\n            this._updateClippingPlanesFromFaceSpheres(viewport);\n        };\n        this._triggerToolChangedEvent = (sphereState) => {\n            triggerEvent(eventTarget, Events.VOLUMECROPPING_TOOL_CHANGED, {\n                toolCenter: sphereState.point,\n                axis: sphereState.isCorner ? 'corner' : sphereState.axis,\n                draggingSphereIndex: this.draggingSphereIndex,\n                seriesInstanceUID: this.seriesInstanceUID,\n            });\n        };\n        this._onNewVolume = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            this.originalClippingPlanes = [];\n            this.sphereStates = [];\n            this.edgeLines = {};\n            this._initialize3DViewports(viewportsInfo);\n        };\n        this._rotateCamera = (viewport, centerWorld, axis, angle) => {\n            const vtkCamera = viewport.getVtkActiveCamera();\n            const viewUp = vtkCamera.getViewUp();\n            const focalPoint = vtkCamera.getFocalPoint();\n            const position = vtkCamera.getPosition();\n            const newPosition = [0, 0, 0];\n            const newFocalPoint = [0, 0, 0];\n            const newViewUp = [0, 0, 0];\n            const transform = mat4.identity(new Float32Array(16));\n            mat4.translate(transform, transform, centerWorld);\n            mat4.rotate(transform, transform, angle, axis);\n            mat4.translate(transform, transform, [\n                -centerWorld[0],\n                -centerWorld[1],\n                -centerWorld[2],\n            ]);\n            vec3.transformMat4(newPosition, position, transform);\n            vec3.transformMat4(newFocalPoint, focalPoint, transform);\n            mat4.identity(transform);\n            mat4.rotate(transform, transform, angle, axis);\n            vec3.transformMat4(newViewUp, viewUp, transform);\n            viewport.setCamera({\n                position: newPosition,\n                viewUp: newViewUp,\n                focalPoint: newFocalPoint,\n            });\n        };\n        this.touchDragCallback = this._dragCallback.bind(this);\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    onSetToolActive() {\n        if (this.sphereStates && this.sphereStates.length > 0) {\n            if (this.configuration.showHandles) {\n                this.setHandlesVisible(false);\n                this.setClippingPlanesVisible(false);\n            }\n            else {\n                this.setHandlesVisible(true);\n                this.setClippingPlanesVisible(true);\n            }\n        }\n        else {\n            const viewportsInfo = this._getViewportsInfo();\n            const subscribeToElementResize = () => {\n                viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                    if (!this._resizeObservers.has(viewportId)) {\n                        const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId) || { viewport: null };\n                        if (!viewport) {\n                            return;\n                        }\n                        const { element } = viewport;\n                        const resizeObserver = new ResizeObserver(() => {\n                            const element = getEnabledElementByIds(viewportId, renderingEngineId);\n                            if (!element) {\n                                return;\n                            }\n                            const { viewport } = element;\n                            const viewPresentation = viewport.getViewPresentation();\n                            viewport.resetCamera();\n                            viewport.setViewPresentation(viewPresentation);\n                            viewport.render();\n                        });\n                        resizeObserver.observe(element);\n                        this._resizeObservers.set(viewportId, resizeObserver);\n                    }\n                });\n            };\n            subscribeToElementResize();\n            this._viewportAddedListener = (evt) => {\n                if (evt.detail.toolGroupId === this.toolGroupId) {\n                    subscribeToElementResize();\n                }\n            };\n            eventTarget.addEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);\n            this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n            this._subscribeToViewportNewVolumeSet(viewportsInfo);\n            this._initialize3DViewports(viewportsInfo);\n            if (this.sphereStates && this.sphereStates.length > 0) {\n                this.setHandlesVisible(true);\n            }\n            else {\n                this.originalClippingPlanes = [];\n                this._initialize3DViewports(viewportsInfo);\n            }\n        }\n    }\n    onSetToolDisabled() {\n        this._resizeObservers.forEach((resizeObserver, viewportId) => {\n            resizeObserver.disconnect();\n            this._resizeObservers.delete(viewportId);\n        });\n        if (this._viewportAddedListener) {\n            eventTarget.removeEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);\n            this._viewportAddedListener = null;\n        }\n        const viewportsInfo = this._getViewportsInfo();\n        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n    }\n    setHandlesVisible(visible) {\n        this.configuration.showHandles = visible;\n        if (visible) {\n            this.sphereStates[SPHEREINDEX.XMIN].point[0] =\n                this.originalClippingPlanes[PLANEINDEX.XMIN].origin[0];\n            this.sphereStates[SPHEREINDEX.XMAX].point[0] =\n                this.originalClippingPlanes[PLANEINDEX.XMAX].origin[0];\n            this.sphereStates[SPHEREINDEX.YMIN].point[1] =\n                this.originalClippingPlanes[PLANEINDEX.YMIN].origin[1];\n            this.sphereStates[SPHEREINDEX.YMAX].point[1] =\n                this.originalClippingPlanes[PLANEINDEX.YMAX].origin[1];\n            this.sphereStates[SPHEREINDEX.ZMIN].point[2] =\n                this.originalClippingPlanes[PLANEINDEX.ZMIN].origin[2];\n            this.sphereStates[SPHEREINDEX.ZMAX].point[2] =\n                this.originalClippingPlanes[PLANEINDEX.ZMAX].origin[2];\n            [\n                SPHEREINDEX.XMIN,\n                SPHEREINDEX.XMAX,\n                SPHEREINDEX.YMIN,\n                SPHEREINDEX.YMAX,\n                SPHEREINDEX.ZMIN,\n                SPHEREINDEX.ZMAX,\n            ].forEach((idx) => {\n                const s = this.sphereStates[idx];\n                s.sphereSource.setCenter(...s.point);\n                s.sphereSource.modified();\n            });\n            this._updateCornerSpheres();\n        }\n        this._updateHandlesVisibility();\n        const viewportsInfo = this._getViewportsInfo();\n        const [viewport3D] = viewportsInfo;\n        const renderingEngine = getRenderingEngine(viewport3D.renderingEngineId);\n        const viewport = renderingEngine.getViewport(viewport3D.viewportId);\n        viewport.render();\n    }\n    getHandlesVisible() {\n        return this.configuration.showHandles;\n    }\n    getClippingPlanesVisible() {\n        return this.configuration.showClippingPlanes;\n    }\n    setClippingPlanesVisible(visible) {\n        this.configuration.showClippingPlanes = visible;\n        const viewport = this._getViewport();\n        this._updateClippingPlanes(viewport);\n        viewport.render();\n    }\n    _dragCallback(evt) {\n        const { element, currentPoints, lastPoints } = evt.detail;\n        if (this.draggingSphereIndex !== null) {\n            this._onMouseMoveSphere(evt);\n        }\n        else {\n            const currentPointsCanvas = currentPoints.canvas;\n            const lastPointsCanvas = lastPoints.canvas;\n            const { rotateIncrementDegrees } = this.configuration;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const width = element.clientWidth;\n            const height = element.clientHeight;\n            const normalizedPosition = [\n                currentPointsCanvas[0] / width,\n                currentPointsCanvas[1] / height,\n            ];\n            const normalizedPreviousPosition = [\n                lastPointsCanvas[0] / width,\n                lastPointsCanvas[1] / height,\n            ];\n            const center = [width * 0.5, height * 0.5];\n            const centerWorld = viewport.canvasToWorld(center);\n            const normalizedCenter = [0.5, 0.5];\n            const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;\n            const op = [normalizedPreviousPosition[0], 0, 0];\n            const oe = [normalizedPosition[0], 0, 0];\n            const opsq = op[0] ** 2;\n            const oesq = oe[0] ** 2;\n            const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);\n            const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);\n            const nop = [op[0], 0, lop];\n            vtkMath.normalize(nop);\n            const noe = [oe[0], 0, loe];\n            vtkMath.normalize(noe);\n            const dot = vtkMath.dot(nop, noe);\n            if (Math.abs(dot) > 0.0001) {\n                const angleX = -2 *\n                    Math.acos(vtkMath.clampValue(dot, -1.0, 1.0)) *\n                    Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) *\n                    rotateIncrementDegrees;\n                const upVec = camera.viewUp;\n                const atV = camera.viewPlaneNormal;\n                const rightV = [0, 0, 0];\n                const forwardV = [0, 0, 0];\n                vtkMath.cross(upVec, atV, rightV);\n                vtkMath.normalize(rightV);\n                vtkMath.cross(atV, rightV, forwardV);\n                vtkMath.normalize(forwardV);\n                vtkMath.normalize(upVec);\n                this._rotateCamera(viewport, centerWorld, forwardV, angleX);\n                const angleY = (normalizedPreviousPosition[1] - normalizedPosition[1]) *\n                    rotateIncrementDegrees;\n                this._rotateCamera(viewport, centerWorld, rightV, angleY);\n            }\n            viewport.render();\n        }\n    }\n    _updateClippingPlanes(viewport) {\n        const actorEntry = viewport.getDefaultActor();\n        if (!actorEntry || !actorEntry.actor) {\n            if (!viewport._missingActorWarned) {\n                console.warn('VolumeCroppingTool._updateClippingPlanes: No default actor found in viewport.');\n                viewport._missingActorWarned = true;\n            }\n            return;\n        }\n        const actor = actorEntry.actor;\n        const mapper = actor.getMapper();\n        const matrix = actor.getMatrix();\n        if (!this.configuration.showClippingPlanes) {\n            mapper.removeAllClippingPlanes();\n            return;\n        }\n        const rot = mat3.create();\n        mat3.fromMat4(rot, matrix);\n        const normalMatrix = mat3.create();\n        mat3.invert(normalMatrix, rot);\n        mat3.transpose(normalMatrix, normalMatrix);\n        const originalPlanes = this.originalClippingPlanes;\n        if (!originalPlanes || !originalPlanes.length) {\n            return;\n        }\n        mapper.removeAllClippingPlanes();\n        const transformedOrigins = [];\n        const transformedNormals = [];\n        for (let i = 0; i < originalPlanes.length; ++i) {\n            const plane = originalPlanes[i];\n            const oVec = vec3.create();\n            vec3.transformMat4(oVec, new Float32Array(plane.origin), matrix);\n            const o = [oVec[0], oVec[1], oVec[2]];\n            const nVec = vec3.create();\n            vec3.transformMat3(nVec, new Float32Array(plane.normal), normalMatrix);\n            vec3.normalize(nVec, nVec);\n            const n = [nVec[0], nVec[1], nVec[2]];\n            transformedOrigins.push(o);\n            transformedNormals.push(n);\n        }\n        for (let i = 0; i < transformedOrigins.length; ++i) {\n            const planeInstance = vtkPlane.newInstance({\n                origin: transformedOrigins[i],\n                normal: transformedNormals[i],\n            });\n            mapper.addClippingPlane(planeInstance);\n        }\n    }\n    _updateHandlesVisibility() {\n        this.sphereStates.forEach((state) => {\n            if (state.sphereActor) {\n                state.sphereActor.setVisibility(this.configuration.showHandles);\n            }\n        });\n        Object.values(this.edgeLines).forEach(({ actor }) => {\n            if (actor) {\n                actor.setVisibility(this.configuration.showHandles);\n            }\n        });\n    }\n    _addLine3DBetweenPoints(viewport, point1, point2, color = [0.7, 0.7, 0.7], uid = '') {\n        if (point1[0] === point2[0] &&\n            point1[1] === point2[1] &&\n            point1[2] === point2[2]) {\n            return { actor: null, source: null };\n        }\n        const points = vtkPoints.newInstance();\n        points.setNumberOfPoints(2);\n        points.setPoint(0, point1[0], point1[1], point1[2]);\n        points.setPoint(1, point2[0], point2[1], point2[2]);\n        const lines = vtkCellArray.newInstance({ values: [2, 0, 1] });\n        const polyData = vtkPolyData.newInstance();\n        polyData.setPoints(points);\n        polyData.setLines(lines);\n        const mapper = vtkMapper.newInstance();\n        mapper.setInputData(polyData);\n        const actor = vtkActor.newInstance();\n        actor.setMapper(mapper);\n        actor.getProperty().setColor(...color);\n        actor.getProperty().setLineWidth(0.5);\n        actor.getProperty().setOpacity(1.0);\n        actor.getProperty().setInterpolationToFlat();\n        actor.getProperty().setAmbient(1.0);\n        actor.getProperty().setDiffuse(0.0);\n        actor.getProperty().setSpecular(0.0);\n        actor.setVisibility(this.configuration.showHandles);\n        viewport.addActor({ actor, uid });\n        return { actor, source: polyData };\n    }\n    _addSphere(viewport, point, axis, position, cornerKey = null, adaptiveRadius) {\n        const uid = cornerKey ? `corner_${cornerKey}` : `${axis}_${position}`;\n        const sphereState = this.sphereStates.find((s) => s.uid === uid);\n        if (sphereState) {\n            return;\n        }\n        const sphereSource = vtkSphereSource.newInstance();\n        sphereSource.setCenter(point);\n        sphereSource.setRadius(adaptiveRadius);\n        const sphereMapper = vtkMapper.newInstance();\n        sphereMapper.setInputConnection(sphereSource.getOutputPort());\n        const sphereActor = vtkActor.newInstance();\n        sphereActor.setMapper(sphereMapper);\n        let color = [0.0, 1.0, 0.0];\n        const sphereColors = this.configuration.sphereColors || {};\n        if (cornerKey) {\n            color = sphereColors.CORNERS || [0.0, 0.0, 1.0];\n        }\n        else if (axis === 'z') {\n            color = sphereColors.AXIAL || [1.0, 0.0, 0.0];\n        }\n        else if (axis === 'x') {\n            color = sphereColors.SAGITTAL || [1.0, 1.0, 0.0];\n        }\n        else if (axis === 'y') {\n            color = sphereColors.CORONAL || [0.0, 1.0, 0.0];\n        }\n        const idx = this.sphereStates.findIndex((s) => s.uid === uid);\n        if (idx === -1) {\n            this.sphereStates.push({\n                point: point.slice(),\n                axis,\n                uid,\n                sphereSource,\n                sphereActor,\n                isCorner: !!cornerKey,\n                color,\n            });\n        }\n        else {\n            this.sphereStates[idx].point = point.slice();\n            this.sphereStates[idx].sphereSource = sphereSource;\n        }\n        const existingActors = viewport.getActors();\n        const existing = existingActors.find((a) => a.uid === uid);\n        if (existing) {\n            return;\n        }\n        sphereActor.getProperty().setColor(color);\n        sphereActor.setVisibility(this.configuration.showHandles);\n        viewport.addActor({ actor: sphereActor, uid: uid });\n    }\n    _calculateAdaptiveSphereRadius(diagonal) {\n        const baseRadius = this.configuration.sphereRadius !== undefined\n            ? this.configuration.sphereRadius\n            : 8;\n        const scaleFactor = this.configuration.sphereRadiusScale || 0.01;\n        const adaptiveRadius = diagonal * scaleFactor;\n        const minRadius = this.configuration.minSphereRadius || 2;\n        const maxRadius = this.configuration.maxSphereRadius || 50;\n        return Math.max(minRadius, Math.min(maxRadius, adaptiveRadius));\n    }\n    _updateClippingPlanesFromFaceSpheres(viewport) {\n        const mapper = viewport.getDefaultActor().actor.getMapper();\n        this.originalClippingPlanes[0].origin = [\n            ...this.sphereStates[SPHEREINDEX.XMIN].point,\n        ];\n        this.originalClippingPlanes[1].origin = [\n            ...this.sphereStates[SPHEREINDEX.XMAX].point,\n        ];\n        this.originalClippingPlanes[2].origin = [\n            ...this.sphereStates[SPHEREINDEX.YMIN].point,\n        ];\n        this.originalClippingPlanes[3].origin = [\n            ...this.sphereStates[SPHEREINDEX.YMAX].point,\n        ];\n        this.originalClippingPlanes[4].origin = [\n            ...this.sphereStates[SPHEREINDEX.ZMIN].point,\n        ];\n        this.originalClippingPlanes[5].origin = [\n            ...this.sphereStates[SPHEREINDEX.ZMAX].point,\n        ];\n        mapper.removeAllClippingPlanes();\n        for (let i = 0; i < 6; ++i) {\n            const origin = this.originalClippingPlanes[i].origin;\n            const normal = this.originalClippingPlanes[i].normal;\n            const plane = vtkPlane.newInstance({\n                origin,\n                normal,\n            });\n            mapper.addClippingPlane(plane);\n        }\n    }\n    _updateCornerSpheresFromFaces() {\n        const xMin = this.sphereStates[SPHEREINDEX.XMIN].point[0];\n        const xMax = this.sphereStates[SPHEREINDEX.XMAX].point[0];\n        const yMin = this.sphereStates[SPHEREINDEX.YMIN].point[1];\n        const yMax = this.sphereStates[SPHEREINDEX.YMAX].point[1];\n        const zMin = this.sphereStates[SPHEREINDEX.ZMIN].point[2];\n        const zMax = this.sphereStates[SPHEREINDEX.ZMAX].point[2];\n        const corners = [\n            { key: 'XMIN_YMIN_ZMIN', pos: [xMin, yMin, zMin] },\n            { key: 'XMIN_YMIN_ZMAX', pos: [xMin, yMin, zMax] },\n            { key: 'XMIN_YMAX_ZMIN', pos: [xMin, yMax, zMin] },\n            { key: 'XMIN_YMAX_ZMAX', pos: [xMin, yMax, zMax] },\n            { key: 'XMAX_YMIN_ZMIN', pos: [xMax, yMin, zMin] },\n            { key: 'XMAX_YMIN_ZMAX', pos: [xMax, yMin, zMax] },\n            { key: 'XMAX_YMAX_ZMIN', pos: [xMax, yMax, zMin] },\n            { key: 'XMAX_YMAX_ZMAX', pos: [xMax, yMax, zMax] },\n        ];\n        for (const corner of corners) {\n            const state = this.sphereStates.find((s) => s.uid === `corner_${corner.key}`);\n            if (state) {\n                state.point[0] = corner.pos[0];\n                state.point[1] = corner.pos[1];\n                state.point[2] = corner.pos[2];\n                state.sphereSource.setCenter(...state.point);\n                state.sphereSource.modified();\n            }\n        }\n    }\n    _updateFaceSpheresFromCorners() {\n        const corners = [\n            this.sphereStates[SPHEREINDEX.XMIN_YMIN_ZMIN].point,\n            this.sphereStates[SPHEREINDEX.XMIN_YMIN_ZMAX].point,\n            this.sphereStates[SPHEREINDEX.XMIN_YMAX_ZMIN].point,\n            this.sphereStates[SPHEREINDEX.XMIN_YMAX_ZMAX].point,\n            this.sphereStates[SPHEREINDEX.XMAX_YMIN_ZMIN].point,\n            this.sphereStates[SPHEREINDEX.XMAX_YMIN_ZMAX].point,\n            this.sphereStates[SPHEREINDEX.XMAX_YMAX_ZMIN].point,\n            this.sphereStates[SPHEREINDEX.XMAX_YMAX_ZMAX].point,\n        ];\n        const xs = corners.map((p) => p[0]);\n        const ys = corners.map((p) => p[1]);\n        const zs = corners.map((p) => p[2]);\n        const xMin = Math.min(...xs), xMax = Math.max(...xs);\n        const yMin = Math.min(...ys), yMax = Math.max(...ys);\n        const zMin = Math.min(...zs), zMax = Math.max(...zs);\n        this.sphereStates[SPHEREINDEX.XMIN].point = [\n            xMin,\n            (yMin + yMax) / 2,\n            (zMin + zMax) / 2,\n        ];\n        this.sphereStates[SPHEREINDEX.XMAX].point = [\n            xMax,\n            (yMin + yMax) / 2,\n            (zMin + zMax) / 2,\n        ];\n        this.sphereStates[SPHEREINDEX.YMIN].point = [\n            (xMin + xMax) / 2,\n            yMin,\n            (zMin + zMax) / 2,\n        ];\n        this.sphereStates[SPHEREINDEX.YMAX].point = [\n            (xMin + xMax) / 2,\n            yMax,\n            (zMin + zMax) / 2,\n        ];\n        this.sphereStates[SPHEREINDEX.ZMIN].point = [\n            (xMin + xMax) / 2,\n            (yMin + yMax) / 2,\n            zMin,\n        ];\n        this.sphereStates[SPHEREINDEX.ZMAX].point = [\n            (xMin + xMax) / 2,\n            (yMin + yMax) / 2,\n            zMax,\n        ];\n        [\n            SPHEREINDEX.XMIN,\n            SPHEREINDEX.XMAX,\n            SPHEREINDEX.YMIN,\n            SPHEREINDEX.YMAX,\n            SPHEREINDEX.ZMIN,\n            SPHEREINDEX.ZMAX,\n        ].forEach((idx) => {\n            const s = this.sphereStates[idx];\n            s.sphereSource.setCenter(...s.point);\n            s.sphereSource.modified();\n        });\n    }\n    _updateCornerSpheres() {\n        const xMin = this.sphereStates[SPHEREINDEX.XMIN].point[0];\n        const xMax = this.sphereStates[SPHEREINDEX.XMAX].point[0];\n        const yMin = this.sphereStates[SPHEREINDEX.YMIN].point[1];\n        const yMax = this.sphereStates[SPHEREINDEX.YMAX].point[1];\n        const zMin = this.sphereStates[SPHEREINDEX.ZMIN].point[2];\n        const zMax = this.sphereStates[SPHEREINDEX.ZMAX].point[2];\n        const corners = [\n            { key: 'XMIN_YMIN_ZMIN', pos: [xMin, yMin, zMin] },\n            { key: 'XMIN_YMIN_ZMAX', pos: [xMin, yMin, zMax] },\n            { key: 'XMIN_YMAX_ZMIN', pos: [xMin, yMax, zMin] },\n            { key: 'XMIN_YMAX_ZMAX', pos: [xMin, yMax, zMax] },\n            { key: 'XMAX_YMIN_ZMIN', pos: [xMax, yMin, zMin] },\n            { key: 'XMAX_YMIN_ZMAX', pos: [xMax, yMin, zMax] },\n            { key: 'XMAX_YMAX_ZMIN', pos: [xMax, yMax, zMin] },\n            { key: 'XMAX_YMAX_ZMAX', pos: [xMax, yMax, zMax] },\n        ];\n        for (const corner of corners) {\n            const state = this.sphereStates.find((s) => s.uid === `corner_${corner.key}`);\n            if (state) {\n                state.point[0] = corner.pos[0];\n                state.point[1] = corner.pos[1];\n                state.point[2] = corner.pos[2];\n                state.sphereSource.setCenter(...state.point);\n                state.sphereSource.modified();\n            }\n        }\n        Object.values(this.edgeLines).forEach(({ source, key1, key2 }) => {\n            const state1 = this.sphereStates.find((s) => s.uid === `corner_${key1}`);\n            const state2 = this.sphereStates.find((s) => s.uid === `corner_${key2}`);\n            if (state1 && state2) {\n                const points = source.getPoints();\n                points.setPoint(0, state1.point[0], state1.point[1], state1.point[2]);\n                points.setPoint(1, state2.point[0], state2.point[1], state2.point[2]);\n                points.modified();\n                source.modified();\n            }\n        });\n    }\n    _unsubscribeToViewportNewVolumeSet(viewportsInfo) {\n        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.removeEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n    _subscribeToViewportNewVolumeSet(viewports) {\n        viewports.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.addEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n}\nVolumeCroppingTool.toolName = 'VolumeCropping';\nexport default VolumeCroppingTool;\n", "import { vec2, vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { AnnotationTool } from './base';\nimport { getRenderingEngine, getEnabledElementByIds, getEnabledElement, utilities as csUtils, Enums, CONSTANTS, triggerEvent, eventTarget, } from '@cornerstonejs/core';\nimport { getToolGroup, getToolGroupForViewport, } from '../store/ToolGroupManager';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../stateManagement/annotation/annotationState';\nimport { drawCircle as drawCircleSvg, drawLine as drawLineSvg, } from '../drawingSvg';\nimport { state } from '../store/state';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../cursors/elementCursor';\nimport liangBarksyClip from '../utilities/math/vec2/liangBarksyClip';\nimport * as lineSegment from '../utilities/math/line';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nconst { RENDERING_DEFAULTS } = CONSTANTS;\nfunction defaultReferenceLineColor() {\n    return 'rgb(0, 200, 0)';\n}\nfunction defaultReferenceLineControllable() {\n    return true;\n}\nconst OPERATION = {\n    DRAG: 1,\n    ROTATE: 2,\n    SLAB: 3,\n};\nclass VolumeCroppingControlTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse'],\n        configuration: {\n            viewportIndicators: false,\n            viewportIndicatorsConfig: {\n                radius: 5,\n                x: null,\n                y: null,\n            },\n            extendReferenceLines: true,\n            initialCropFactor: 0.2,\n            mobile: {\n                enabled: false,\n                opacity: 0.8,\n            },\n            lineColors: {\n                AXIAL: [1.0, 0.0, 0.0],\n                CORONAL: [0.0, 1.0, 0.0],\n                SAGITTAL: [1.0, 1.0, 0.0],\n                UNKNOWN: [0.0, 0.0, 1.0],\n            },\n            lineWidth: 1.5,\n            lineWidthActive: 2.5,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._virtualAnnotations = [];\n        this.sphereStates = [];\n        this.draggingSphereIndex = null;\n        this.toolCenter = [0, 0, 0];\n        this.toolCenterMin = [0, 0, 0];\n        this.toolCenterMax = [0, 0, 0];\n        this.initializeViewport = ({ renderingEngineId, viewportId, }) => {\n            if (!renderingEngineId || !viewportId) {\n                console.warn('VolumeCroppingControlTool: Missing renderingEngineId or viewportId');\n                return;\n            }\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (!enabledElement) {\n                return;\n            }\n            const { viewport } = enabledElement;\n            this._updateToolCentersFromViewport(viewport);\n            const { element } = viewport;\n            const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();\n            let annotations = this._getAnnotations(enabledElement);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (annotations?.length) {\n                removeAnnotation(annotations[0].annotationUID);\n            }\n            const orientation = this._getOrientationFromNormal(viewport.getCamera().viewPlaneNormal);\n            const annotation = {\n                highlighted: false,\n                metadata: {\n                    cameraPosition: [...position],\n                    cameraFocalPoint: [...focalPoint],\n                    toolName: this.getToolName(),\n                },\n                data: {\n                    handles: {\n                        toolCenter: this.toolCenter,\n                        toolCenterMin: this.toolCenterMin,\n                        toolCenterMax: this.toolCenterMax,\n                    },\n                    activeOperation: null,\n                    activeViewportIds: [],\n                    viewportId,\n                    referenceLines: [],\n                    orientation,\n                },\n            };\n            addAnnotation(annotation, element);\n            return {\n                normal: viewPlaneNormal,\n                point: viewport.canvasToWorld([100, 100]),\n            };\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this.resetCroppingSpheres = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            for (const viewportInfo of viewportsInfo) {\n                const { viewportId, renderingEngineId } = viewportInfo;\n                const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n                const viewport = enabledElement.viewport;\n                const resetPan = true;\n                const resetZoom = true;\n                const resetToCenter = true;\n                const resetRotation = true;\n                const suppressEvents = true;\n                viewport.resetCamera({\n                    resetPan,\n                    resetZoom,\n                    resetToCenter,\n                    resetRotation,\n                    suppressEvents,\n                });\n                viewport.resetSlabThickness();\n                const { element } = viewport;\n                let annotations = this._getAnnotations(enabledElement);\n                annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n                if (annotations.length) {\n                    removeAnnotation(annotations[0].annotationUID);\n                }\n                viewport.render();\n            }\n            this._computeToolCenter(viewportsInfo);\n        };\n        this.computeToolCenter = () => {\n            const viewportsInfo = this._getViewportsInfo();\n        };\n        this._computeToolCenter = (viewportsInfo) => {\n            if (!viewportsInfo || !viewportsInfo[0]) {\n                console.warn('  _computeToolCenter : No valid viewportsInfo for computeToolCenter.');\n                return;\n            }\n            const orientationIds = ['AXIAL', 'CORONAL', 'SAGITTAL'];\n            const presentOrientations = viewportsInfo\n                .map((vp) => {\n                if (vp.renderingEngineId) {\n                    const renderingEngine = getRenderingEngine(vp.renderingEngineId);\n                    const viewport = renderingEngine.getViewport(vp.viewportId);\n                    if (viewport && viewport.getCamera) {\n                        const orientation = this._getOrientationFromNormal(viewport.getCamera().viewPlaneNormal);\n                        if (orientation) {\n                            return orientation;\n                        }\n                    }\n                }\n                return null;\n            })\n                .filter(Boolean);\n            const missingOrientation = orientationIds.find((id) => !presentOrientations.includes(id));\n            const presentNormals = [];\n            const presentCenters = [];\n            const presentViewportInfos = viewportsInfo.filter((vp) => {\n                let orientation = null;\n                if (vp.renderingEngineId) {\n                    const renderingEngine = getRenderingEngine(vp.renderingEngineId);\n                    const viewport = renderingEngine.getViewport(vp.viewportId);\n                    if (viewport && viewport.getCamera) {\n                        orientation = this._getOrientationFromNormal(viewport.getCamera().viewPlaneNormal);\n                    }\n                }\n                return orientation && orientationIds.includes(orientation);\n            });\n            presentViewportInfos.forEach((vpInfo) => {\n                const { normal, point } = this.initializeViewport(vpInfo);\n                presentNormals.push(normal);\n                presentCenters.push(point);\n            });\n            if (presentViewportInfos.length === 2 && missingOrientation) {\n                const virtualNormal = [0, 0, 0];\n                vec3.cross(virtualNormal, presentNormals[0], presentNormals[1]);\n                vec3.normalize(virtualNormal, virtualNormal);\n                const virtualCenter = [\n                    (presentCenters[0][0] + presentCenters[1][0]) / 2,\n                    (presentCenters[0][1] + presentCenters[1][1]) / 2,\n                    (presentCenters[0][2] + presentCenters[1][2]) / 2,\n                ];\n                const orientation = null;\n                const virtualAnnotation = {\n                    highlighted: false,\n                    metadata: {\n                        cameraPosition: [...virtualCenter],\n                        cameraFocalPoint: [...virtualCenter],\n                        toolName: this.getToolName(),\n                    },\n                    data: {\n                        handles: {\n                            activeOperation: null,\n                            toolCenter: this.toolCenter,\n                            toolCenterMin: this.toolCenterMin,\n                            toolCenterMax: this.toolCenterMax,\n                        },\n                        activeViewportIds: [],\n                        viewportId: missingOrientation,\n                        referenceLines: [],\n                        orientation,\n                    },\n                    isVirtual: true,\n                    virtualNormal,\n                };\n                this._virtualAnnotations = [virtualAnnotation];\n            }\n            else if (presentViewportInfos.length === 1) {\n                let presentOrientation = null;\n                const vpInfo = presentViewportInfos[0];\n                if (vpInfo.renderingEngineId) {\n                    const renderingEngine = getRenderingEngine(vpInfo.renderingEngineId);\n                    const viewport = renderingEngine.getViewport(vpInfo.viewportId);\n                    if (viewport && viewport.getCamera) {\n                        presentOrientation = this._getOrientationFromNormal(viewport.getCamera().viewPlaneNormal);\n                    }\n                }\n                const presentCenter = presentCenters[0];\n                const canonicalNormals = {\n                    AXIAL: [0, 0, 1],\n                    CORONAL: [0, 1, 0],\n                    SAGITTAL: [1, 0, 0],\n                };\n                const missingIds = orientationIds.filter((id) => id !== presentOrientation);\n                const virtualAnnotations = missingIds.map((orientation) => {\n                    const normal = canonicalNormals[orientation];\n                    const virtualAnnotation = {\n                        highlighted: false,\n                        metadata: {\n                            cameraPosition: [...presentCenter],\n                            cameraFocalPoint: [...presentCenter],\n                            toolName: this.getToolName(),\n                        },\n                        data: {\n                            handles: {\n                                activeOperation: null,\n                                toolCenter: this.toolCenter,\n                                toolCenterMin: this.toolCenterMin,\n                                toolCenterMax: this.toolCenterMax,\n                            },\n                            activeViewportIds: [],\n                            viewportId: orientation,\n                            referenceLines: [],\n                            orientation,\n                        },\n                        isVirtual: true,\n                        virtualNormal: normal,\n                    };\n                    return virtualAnnotation;\n                });\n                this._virtualAnnotations = virtualAnnotations;\n            }\n            if (viewportsInfo && viewportsInfo.length) {\n                triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n            }\n        };\n        this.cancel = () => {\n            console.log('Not implemented yet');\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            if (this._pointNearTool(element, annotation, canvasCoords, 6)) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.onResetCamera = (evt) => {\n            this.resetCroppingSpheres();\n        };\n        this.mouseMoveCallback = (evt, filteredToolAnnotations) => {\n            if (!filteredToolAnnotations) {\n                return;\n            }\n            const { element, currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            let imageNeedsUpdate = false;\n            for (let i = 0; i < filteredToolAnnotations.length; i++) {\n                const annotation = filteredToolAnnotations[i];\n                if (isAnnotationLocked(annotation.annotationUID)) {\n                    continue;\n                }\n                const { data, highlighted } = annotation;\n                if (!data.handles) {\n                    continue;\n                }\n                const previousActiveOperation = data.handles.activeOperation;\n                const previousActiveViewportIds = data.activeViewportIds && data.activeViewportIds.length > 0\n                    ? [...data.activeViewportIds]\n                    : [];\n                data.activeViewportIds = [];\n                let near = false;\n                near = this._pointNearTool(element, annotation, canvasCoords, 6);\n                const nearToolAndNotMarkedActive = near && !highlighted;\n                const notNearToolAndMarkedActive = !near && highlighted;\n                if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n                    annotation.highlighted = !highlighted;\n                    imageNeedsUpdate = true;\n                }\n            }\n            return imageNeedsUpdate;\n        };\n        this.filterInteractableAnnotationsForElement = (element, annotations) => {\n            if (!annotations || !annotations.length) {\n                return [];\n            }\n            const enabledElement = getEnabledElement(element);\n            let orientation = null;\n            if (enabledElement.viewport && enabledElement.viewport.getCamera) {\n                orientation = this._getOrientationFromNormal(enabledElement.viewport.getCamera().viewPlaneNormal);\n            }\n            const filtered = annotations.filter((annotation) => {\n                if (annotation.isVirtual) {\n                    return true;\n                }\n                if (annotation.data.orientation &&\n                    orientation &&\n                    annotation.data.orientation === orientation) {\n                    return true;\n                }\n                return false;\n            });\n            return filtered;\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            function lineIntersection2D(p1, p2, q1, q2) {\n                const s1_x = p2[0] - p1[0];\n                const s1_y = p2[1] - p1[1];\n                const s2_x = q2[0] - q1[0];\n                const s2_y = q2[1] - q1[1];\n                const denom = -s2_x * s1_y + s1_x * s2_y;\n                if (Math.abs(denom) < 1e-8) {\n                    return null;\n                }\n                const s = (-s1_y * (p1[0] - q1[0]) + s1_x * (p1[1] - q1[1])) / denom;\n                const t = (s2_x * (p1[1] - q1[1]) - s2_y * (p1[0] - q1[0])) / denom;\n                if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n                    return [p1[0] + t * s1_x, p1[1] + t * s1_y];\n                }\n                return null;\n            }\n            const viewportsInfo = this._getViewportsInfo();\n            if (!viewportsInfo || viewportsInfo.length === 0) {\n                return false;\n            }\n            let renderStatus = false;\n            const { viewport, renderingEngine } = enabledElement;\n            const { element } = viewport;\n            let annotations = this._getAnnotations(enabledElement);\n            if (this._virtualAnnotations && this._virtualAnnotations.length) {\n                annotations = annotations.concat(this._virtualAnnotations);\n            }\n            const camera = viewport.getCamera();\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!viewportAnnotation || !viewportAnnotation.data) {\n                return renderStatus;\n            }\n            const annotationUID = viewportAnnotation.annotationUID;\n            const { clientWidth, clientHeight } = viewport.canvas;\n            const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n            const data = viewportAnnotation.data;\n            const otherViewportAnnotations = annotations;\n            const volumeCroppingCenterCanvasMin = viewport.worldToCanvas(this.toolCenterMin);\n            const volumeCroppingCenterCanvasMax = viewport.worldToCanvas(this.toolCenterMax);\n            const referenceLines = [];\n            const canvasBox = [0, 0, clientWidth, clientHeight];\n            otherViewportAnnotations.forEach((annotation) => {\n                const data = annotation.data;\n                const isVirtual = 'isVirtual' in annotation &&\n                    annotation.isVirtual === true;\n                data.handles.toolCenter = this.toolCenter;\n                let otherViewport, otherCamera, clientWidth, clientHeight, otherCanvasDiagonalLength, otherCanvasCenter, otherViewportCenterWorld;\n                if (isVirtual) {\n                    const realViewports = viewportsInfo.filter((vp) => vp.viewportId !== data.viewportId);\n                    if (realViewports.length === 2) {\n                        const vp1 = renderingEngine.getViewport(realViewports[0].viewportId);\n                        const vp2 = renderingEngine.getViewport(realViewports[1].viewportId);\n                        const normal1 = vp1.getCamera().viewPlaneNormal;\n                        const normal2 = vp2.getCamera().viewPlaneNormal;\n                        const virtualNormal = vec3.create();\n                        vec3.cross(virtualNormal, normal1, normal2);\n                        vec3.normalize(virtualNormal, virtualNormal);\n                        otherCamera = {\n                            viewPlaneNormal: virtualNormal,\n                            position: data.handles.toolCenter,\n                            focalPoint: data.handles.toolCenter,\n                            viewUp: [0, 1, 0],\n                        };\n                        clientWidth = viewport.canvas.clientWidth;\n                        clientHeight = viewport.canvas.clientHeight;\n                        otherCanvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n                        otherCanvasCenter = [clientWidth * 0.5, clientHeight * 0.5];\n                        otherViewportCenterWorld = data.handles.toolCenter;\n                        otherViewport = {\n                            id: data.viewportId,\n                            canvas: viewport.canvas,\n                            canvasToWorld: () => data.handles.toolCenter,\n                        };\n                    }\n                    else {\n                        const virtualNormal = annotation\n                            .virtualNormal ?? [0, 0, 1];\n                        otherCamera = {\n                            viewPlaneNormal: virtualNormal,\n                            position: data.handles.toolCenter,\n                            focalPoint: data.handles.toolCenter,\n                            viewUp: [0, 1, 0],\n                        };\n                        clientWidth = viewport.canvas.clientWidth;\n                        clientHeight = viewport.canvas.clientHeight;\n                        otherCanvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n                        otherCanvasCenter = [clientWidth * 0.5, clientHeight * 0.5];\n                        otherViewportCenterWorld = data.handles.toolCenter;\n                        otherViewport = {\n                            id: data.viewportId,\n                            canvas: viewport.canvas,\n                            canvasToWorld: () => data.handles.toolCenter,\n                        };\n                    }\n                }\n                else {\n                    otherViewport = renderingEngine.getViewport(data.viewportId);\n                    otherCamera = otherViewport.getCamera();\n                    clientWidth = otherViewport.canvas.clientWidth;\n                    clientHeight = otherViewport.canvas.clientHeight;\n                    otherCanvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n                    otherCanvasCenter = [clientWidth * 0.5, clientHeight * 0.5];\n                    otherViewportCenterWorld =\n                        otherViewport.canvasToWorld(otherCanvasCenter);\n                }\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const direction = [0, 0, 0];\n                vtkMath.cross(camera.viewPlaneNormal, otherCamera.viewPlaneNormal, direction);\n                vtkMath.normalize(direction);\n                vtkMath.multiplyScalar(direction, otherCanvasDiagonalLength);\n                const pointWorld0 = [0, 0, 0];\n                vtkMath.add(otherViewportCenterWorld, direction, pointWorld0);\n                const pointWorld1 = [0, 0, 0];\n                vtkMath.subtract(otherViewportCenterWorld, direction, pointWorld1);\n                const pointCanvas0 = viewport.worldToCanvas(pointWorld0);\n                const otherViewportCenterCanvas = viewport.worldToCanvas([\n                    otherViewportCenterWorld[0] ?? 0,\n                    otherViewportCenterWorld[1] ?? 0,\n                    otherViewportCenterWorld[2] ?? 0,\n                ]);\n                const canvasUnitVectorFromCenter = vec2.create();\n                vec2.subtract(canvasUnitVectorFromCenter, pointCanvas0, otherViewportCenterCanvas);\n                vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n                const canvasVectorFromCenterLong = vec2.create();\n                vec2.scale(canvasVectorFromCenterLong, canvasUnitVectorFromCenter, canvasDiagonalLength * 100);\n                const refLinesCenterMin = otherViewportControllable\n                    ? vec2.clone(volumeCroppingCenterCanvasMin)\n                    : vec2.clone(otherViewportCenterCanvas);\n                const refLinePointMinOne = vec2.create();\n                const refLinePointMinTwo = vec2.create();\n                vec2.add(refLinePointMinOne, refLinesCenterMin, canvasVectorFromCenterLong);\n                vec2.subtract(refLinePointMinTwo, refLinesCenterMin, canvasVectorFromCenterLong);\n                liangBarksyClip(refLinePointMinOne, refLinePointMinTwo, canvasBox);\n                referenceLines.push([\n                    otherViewport,\n                    refLinePointMinOne,\n                    refLinePointMinTwo,\n                    'min',\n                ]);\n                const refLinesCenterMax = otherViewportControllable\n                    ? vec2.clone(volumeCroppingCenterCanvasMax)\n                    : vec2.clone(otherViewportCenterCanvas);\n                const refLinePointMaxOne = vec2.create();\n                const refLinePointMaxTwo = vec2.create();\n                vec2.add(refLinePointMaxOne, refLinesCenterMax, canvasVectorFromCenterLong);\n                vec2.subtract(refLinePointMaxTwo, refLinesCenterMax, canvasVectorFromCenterLong);\n                liangBarksyClip(refLinePointMaxOne, refLinePointMaxTwo, canvasBox);\n                referenceLines.push([\n                    otherViewport,\n                    refLinePointMaxOne,\n                    refLinePointMaxTwo,\n                    'max',\n                ]);\n            });\n            data.referenceLines = referenceLines;\n            const viewportColor = this._getReferenceLineColor(viewport.id);\n            const color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n            referenceLines.forEach((line, lineIndex) => {\n                const intersections = [];\n                for (let j = 0; j < referenceLines.length; ++j) {\n                    if (j === lineIndex) {\n                        continue;\n                    }\n                    const otherLine = referenceLines[j];\n                    const intersection = lineIntersection2D(line[1], line[2], otherLine[1], otherLine[2]);\n                    if (intersection) {\n                        intersections.push({\n                            with: otherLine[3],\n                            point: intersection,\n                        });\n                    }\n                }\n                const otherViewport = line[0];\n                let orientation = null;\n                if (otherViewport && otherViewport.id) {\n                    const annotationForViewport = annotations.find((a) => a.data.viewportId === otherViewport.id);\n                    if (annotationForViewport && annotationForViewport.data.orientation) {\n                        orientation = String(annotationForViewport.data.orientation).toUpperCase();\n                    }\n                    else {\n                        const idUpper = otherViewport.id.toUpperCase();\n                        if (idUpper.includes('AXIAL')) {\n                            orientation = 'AXIAL';\n                        }\n                        else if (idUpper.includes('CORONAL')) {\n                            orientation = 'CORONAL';\n                        }\n                        else if (idUpper.includes('SAGITTAL')) {\n                            orientation = 'SAGITTAL';\n                        }\n                    }\n                }\n                const lineColors = this.configuration.lineColors || {};\n                const colorArr = lineColors[orientation] ||\n                    lineColors.unknown || [1.0, 0.0, 0.0];\n                const color = Array.isArray(colorArr)\n                    ? `rgb(${colorArr.map((v) => Math.round(v * 255)).join(',')})`\n                    : colorArr;\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const selectedViewportId = data.activeViewportIds.find((id) => id === otherViewport.id);\n                let lineWidth = this.configuration.lineWidth ?? 1.5;\n                const lineActive = data.handles.activeOperation !== null &&\n                    data.handles.activeOperation === OPERATION.DRAG &&\n                    selectedViewportId;\n                if (lineActive) {\n                    lineWidth = this.configuration.activeLineWidth ?? 2.5;\n                }\n                const lineUID = `${lineIndex}`;\n                if (viewportControllable) {\n                    if (intersections.length === 2) {\n                        drawLineSvg(svgDrawingHelper, annotationUID, lineUID, intersections[0].point, intersections[1].point, {\n                            color,\n                            lineWidth,\n                        });\n                    }\n                    if (this.configuration.extendReferenceLines &&\n                        intersections.length === 2) {\n                        if (this.configuration.extendReferenceLines &&\n                            intersections.length === 2) {\n                            const sortedIntersections = intersections\n                                .map((intersection) => ({\n                                ...intersection,\n                                distance: vec2.distance(line[1], intersection.point),\n                            }))\n                                .sort((a, b) => a.distance - b.distance);\n                            drawLineSvg(svgDrawingHelper, annotationUID, lineUID + '_dashed_before', line[1], sortedIntersections[0].point, { color, lineWidth, lineDash: [4, 4] });\n                            drawLineSvg(svgDrawingHelper, annotationUID, lineUID + '_dashed_after', sortedIntersections[1].point, line[2], { color, lineWidth, lineDash: [4, 4] });\n                        }\n                    }\n                }\n            });\n            renderStatus = true;\n            if (this.configuration.viewportIndicators) {\n                const { viewportIndicatorsConfig } = this.configuration;\n                const xOffset = viewportIndicatorsConfig?.xOffset || 0.95;\n                const yOffset = viewportIndicatorsConfig?.yOffset || 0.05;\n                const referenceColorCoordinates = [\n                    clientWidth * xOffset,\n                    clientHeight * yOffset,\n                ];\n                const circleRadius = viewportIndicatorsConfig?.circleRadius || canvasDiagonalLength * 0.01;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, referenceColorCoordinates, circleRadius, { color, fill: color });\n            }\n            return renderStatus;\n        };\n        this._getAnnotations = (enabledElement) => {\n            const { viewport } = enabledElement;\n            const annotations = getAnnotations(this.getToolName(), viewport.element) || [];\n            const viewportIds = this._getViewportsInfo().map(({ viewportId }) => viewportId);\n            const toolGroupAnnotations = annotations.filter((annotation) => {\n                const { data } = annotation;\n                return viewportIds.includes(data.viewportId);\n            });\n            return toolGroupAnnotations;\n        };\n        this._onSphereMoved = (evt) => {\n            if (evt.detail.originalClippingPlanes) {\n                this._syncWithVolumeCroppingTool(evt.detail.originalClippingPlanes);\n            }\n            else {\n                if (evt.detail.seriesInstanceUID !== this.seriesInstanceUID) {\n                    return;\n                }\n                const { draggingSphereIndex, toolCenter } = evt.detail;\n                const newMin = [...this.toolCenterMin];\n                const newMax = [...this.toolCenterMax];\n                if (draggingSphereIndex >= 0 && draggingSphereIndex <= 5) {\n                    const axis = Math.floor(draggingSphereIndex / 2);\n                    const isMin = draggingSphereIndex % 2 === 0;\n                    (isMin ? newMin : newMax)[axis] = toolCenter[axis];\n                    this.setToolCenter(newMin, 'min');\n                    this.setToolCenter(newMax, 'max');\n                    return;\n                }\n                if (draggingSphereIndex >= 6 && draggingSphereIndex <= 13) {\n                    const idx = draggingSphereIndex;\n                    if (idx < 10) {\n                        newMin[0] = toolCenter[0];\n                    }\n                    else {\n                        newMax[0] = toolCenter[0];\n                    }\n                    if ([6, 7, 10, 11].includes(idx)) {\n                        newMin[1] = toolCenter[1];\n                    }\n                    else {\n                        newMax[1] = toolCenter[1];\n                    }\n                    if (idx % 2 === 0) {\n                        newMin[2] = toolCenter[2];\n                    }\n                    else {\n                        newMax[2] = toolCenter[2];\n                    }\n                    this.setToolCenter(newMin, 'min');\n                    this.setToolCenter(newMax, 'max');\n                }\n            }\n        };\n        this._onNewVolume = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            if (viewportsInfo && viewportsInfo.length > 0) {\n                const { viewportId, renderingEngineId } = viewportsInfo[0];\n                const renderingEngine = getRenderingEngine(renderingEngineId);\n                const viewport = renderingEngine.getViewport(viewportId);\n                const volumeActors = viewport.getActors();\n                if (volumeActors.length > 0) {\n                    const imageData = volumeActors[0].actor.getMapper().getInputData();\n                    if (imageData) {\n                        this.seriesInstanceUID = imageData.seriesInstanceUID;\n                        this._updateToolCentersFromViewport(viewport);\n                        const annotations = getAnnotations(this.getToolName(), viewportId) || [];\n                        annotations.forEach((annotation) => {\n                            if (annotation.data && annotation.data.handles) {\n                                annotation.data.handles.toolCenter = [...this.toolCenter];\n                            }\n                        });\n                    }\n                }\n            }\n            this._computeToolCenter(viewportsInfo);\n            triggerEvent(eventTarget, Events.VOLUMECROPPINGCONTROL_TOOL_CHANGED, {\n                toolGroupId: this.toolGroupId,\n                viewportsInfo: viewportsInfo,\n                seriesInstanceUID: this.seriesInstanceUID,\n            });\n        };\n        this._getAnnotationsForViewportsWithDifferentCameras = (enabledElement, annotations) => {\n            const { viewportId, renderingEngine, viewport } = enabledElement;\n            const otherViewportAnnotations = annotations.filter((annotation) => annotation.data.viewportId !== viewportId);\n            if (!otherViewportAnnotations || !otherViewportAnnotations.length) {\n                return [];\n            }\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, position } = camera;\n            const viewportsWithDifferentCameras = otherViewportAnnotations.filter((annotation) => {\n                const { viewportId } = annotation.data;\n                const targetViewport = renderingEngine.getViewport(viewportId);\n                const cameraOfTarget = targetViewport.getCamera();\n                return !(csUtils.isEqual(cameraOfTarget.viewPlaneNormal, viewPlaneNormal, 1e-2) && csUtils.isEqual(cameraOfTarget.position, position, 1));\n            });\n            return viewportsWithDifferentCameras;\n        };\n        this._filterViewportWithSameOrientation = (enabledElement, referenceAnnotation, annotations) => {\n            const { renderingEngine } = enabledElement;\n            const { data } = referenceAnnotation;\n            const viewport = renderingEngine.getViewport(data.viewportId);\n            const linkedViewportAnnotations = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return otherViewportControllable === true;\n            });\n            if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {\n                return [];\n            }\n            const camera = viewport.getCamera();\n            const viewPlaneNormal = camera.viewPlaneNormal;\n            vtkMath.normalize(viewPlaneNormal);\n            const otherViewportsAnnotationsWithSameCameraDirection = linkedViewportAnnotations.filter((annotation) => {\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                return (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) &&\n                    csUtils.isEqual(camera.viewUp, otherCamera.viewUp, 1e-2));\n            });\n            return otherViewportsAnnotationsWithSameCameraDirection;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = !this.configuration.mobile?.enabled;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            this.editData.annotation.data.handles.activeOperation = null;\n            this.editData.annotation.data.activeViewportIds = [];\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            this.editData = null;\n            const requireSameOrientation = false;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), requireSameOrientation);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const delta = eventDetail.deltaPoints.world;\n            if (Math.abs(delta[0]) < 1e-3 &&\n                Math.abs(delta[1]) < 1e-3 &&\n                Math.abs(delta[2]) < 1e-3) {\n                return;\n            }\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            if (viewport.type === Enums.ViewportType.VOLUME_3D) {\n                return;\n            }\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!viewportAnnotation) {\n                return;\n            }\n            const { handles } = viewportAnnotation.data;\n            if (handles.activeOperation === OPERATION.DRAG) {\n                if (handles.activeType === 'min') {\n                    this.toolCenterMin[0] += delta[0];\n                    this.toolCenterMin[1] += delta[1];\n                    this.toolCenterMin[2] += delta[2];\n                }\n                else if (handles.activeType === 'max') {\n                    this.toolCenterMax[0] += delta[0];\n                    this.toolCenterMax[1] += delta[1];\n                    this.toolCenterMax[2] += delta[2];\n                }\n                else {\n                    this.toolCenter[0] += delta[0];\n                    this.toolCenter[1] += delta[1];\n                    this.toolCenter[2] += delta[2];\n                }\n                const viewportsInfo = this._getViewportsInfo();\n                triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n                triggerEvent(eventTarget, Events.VOLUMECROPPINGCONTROL_TOOL_CHANGED, {\n                    toolGroupId: this.toolGroupId,\n                    toolCenter: this.toolCenter,\n                    toolCenterMin: this.toolCenterMin,\n                    toolCenterMax: this.toolCenterMax,\n                    handleType: handles.activeType,\n                    viewportOrientation: [],\n                    seriesInstanceUID: this.seriesInstanceUID,\n                });\n            }\n        };\n        this._getReferenceLineColor =\n            toolProps.configuration?.getReferenceLineColor ||\n                defaultReferenceLineColor;\n        this._getReferenceLineControllable =\n            toolProps.configuration?.getReferenceLineControllable ||\n                defaultReferenceLineControllable;\n        const viewportsInfo = getToolGroup(this.toolGroupId)?.viewportsInfo;\n        eventTarget.addEventListener(Events.VOLUMECROPPING_TOOL_CHANGED, this._onSphereMoved);\n        if (viewportsInfo && viewportsInfo.length > 0) {\n            const { viewportId, renderingEngineId } = viewportsInfo[0];\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            const renderingEngine = getRenderingEngine(renderingEngineId);\n            const viewport = renderingEngine.getViewport(viewportId);\n            const volumeActors = viewport.getActors();\n            if (!volumeActors || !volumeActors.length) {\n                console.warn(`VolumeCroppingControlTool: No volume actors found in viewport ${viewportId}.`);\n                return;\n            }\n            const imageData = volumeActors[0].actor.getMapper().getInputData();\n            if (imageData) {\n                const dimensions = imageData.getDimensions();\n                const spacing = imageData.getSpacing();\n                const origin = imageData.getOrigin();\n                this.seriesInstanceUID = imageData.seriesInstanceUID || 'unknown';\n                const cropFactor = this.configuration.initialCropFactor ?? 0.2;\n                this.toolCenter = [\n                    origin[0] + cropFactor * (dimensions[0] - 1) * spacing[0],\n                    origin[1] + cropFactor * (dimensions[1] - 1) * spacing[1],\n                    origin[2] + cropFactor * (dimensions[2] - 1) * spacing[2],\n                ];\n                const maxCropFactor = 1 - cropFactor;\n                this.toolCenterMin = [\n                    origin[0] + cropFactor * (dimensions[0] - 1) * spacing[0],\n                    origin[1] + cropFactor * (dimensions[1] - 1) * spacing[1],\n                    origin[2] + cropFactor * (dimensions[2] - 1) * spacing[2],\n                ];\n                this.toolCenterMax = [\n                    origin[0] + maxCropFactor * (dimensions[0] - 1) * spacing[0],\n                    origin[1] + maxCropFactor * (dimensions[1] - 1) * spacing[1],\n                    origin[2] + maxCropFactor * (dimensions[2] - 1) * spacing[2],\n                ];\n            }\n        }\n    }\n    _updateToolCentersFromViewport(viewport) {\n        const volumeActors = viewport.getActors();\n        if (!volumeActors || !volumeActors.length) {\n            return;\n        }\n        const imageData = volumeActors[0].actor.getMapper().getInputData();\n        if (!imageData) {\n            return;\n        }\n        this.seriesInstanceUID = imageData.seriesInstanceUID || 'unknown';\n        const dimensions = imageData.getDimensions();\n        const spacing = imageData.getSpacing();\n        const origin = imageData.getOrigin();\n        const cropFactor = this.configuration.initialCropFactor ?? 0.2;\n        const cropStart = cropFactor / 2;\n        const cropEnd = 1 - cropFactor / 2;\n        this.toolCenter = [\n            origin[0] +\n                ((cropStart + cropEnd) / 2) * (dimensions[0] - 1) * spacing[0],\n            origin[1] +\n                ((cropStart + cropEnd) / 2) * (dimensions[1] - 1) * spacing[1],\n            origin[2] +\n                ((cropStart + cropEnd) / 2) * (dimensions[2] - 1) * spacing[2],\n        ];\n        this.toolCenterMin = [\n            origin[0] + cropStart * (dimensions[0] - 1) * spacing[0],\n            origin[1] + cropStart * (dimensions[1] - 1) * spacing[1],\n            origin[2] + cropStart * (dimensions[2] - 1) * spacing[2],\n        ];\n        this.toolCenterMax = [\n            origin[0] + cropEnd * (dimensions[0] - 1) * spacing[0],\n            origin[1] + cropEnd * (dimensions[1] - 1) * spacing[1],\n            origin[2] + cropEnd * (dimensions[2] - 1) * spacing[2],\n        ];\n    }\n    onSetToolInactive() {\n        console.debug(`VolumeCroppingControlTool: onSetToolInactive called for tool ${this.getToolName()}`);\n    }\n    onSetToolActive() {\n        const viewportsInfo = this._getViewportsInfo();\n        let anyAnnotationExists = false;\n        for (const vpInfo of viewportsInfo) {\n            const enabledElement = getEnabledElementByIds(vpInfo.viewportId, vpInfo.renderingEngineId);\n            const annotations = this._getAnnotations(enabledElement);\n            if (annotations && annotations.length > 0) {\n                anyAnnotationExists = true;\n                break;\n            }\n        }\n        if (!anyAnnotationExists) {\n            this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n            this._subscribeToViewportNewVolumeSet(viewportsInfo);\n            this._computeToolCenter(viewportsInfo);\n            triggerEvent(eventTarget, Events.VOLUMECROPPINGCONTROL_TOOL_CHANGED, {\n                toolGroupId: this.toolGroupId,\n                viewportsInfo: viewportsInfo,\n                seriesInstanceUID: this.seriesInstanceUID,\n            });\n        }\n        else {\n            for (const vpInfo of viewportsInfo) {\n                const enabledElement = getEnabledElementByIds(vpInfo.viewportId, vpInfo.renderingEngineId);\n                if (!enabledElement) {\n                    continue;\n                }\n                const annotations = this._getAnnotations(enabledElement);\n                if (annotations && annotations.length > 0) {\n                    annotations.forEach((annotation) => {\n                        removeAnnotation(annotation.annotationUID);\n                    });\n                }\n                enabledElement.viewport.render();\n            }\n        }\n    }\n    onSetToolEnabled() {\n        console.debug(`VolumeCroppingControlTool: onSetToolEnabled called for tool ${this.getToolName()}`);\n        const viewportsInfo = this._getViewportsInfo();\n    }\n    onSetToolDisabled() {\n        console.debug(`VolumeCroppingControlTool: onSetToolDisabled called for tool ${this.getToolName()}`);\n        const viewportsInfo = this._getViewportsInfo();\n        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n        viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (!enabledElement) {\n                return;\n            }\n            const annotations = this._getAnnotations(enabledElement);\n            if (annotations?.length) {\n                annotations.forEach((annotation) => {\n                    removeAnnotation(annotation.annotationUID);\n                });\n            }\n        });\n    }\n    _getOrientationFromNormal(normal) {\n        if (!normal) {\n            return null;\n        }\n        const canonical = {\n            AXIAL: [0, 0, 1],\n            CORONAL: [0, 1, 0],\n            SAGITTAL: [1, 0, 0],\n        };\n        const tol = 1e-2;\n        for (const [key, value] of Object.entries(canonical)) {\n            if (Math.abs(normal[0] - value[0]) < tol &&\n                Math.abs(normal[1] - value[1]) < tol &&\n                Math.abs(normal[2] - value[2]) < tol) {\n                return key;\n            }\n            if (Math.abs(normal[0] + value[0]) < tol &&\n                Math.abs(normal[1] + value[1]) < tol &&\n                Math.abs(normal[2] + value[2]) < tol) {\n                return key;\n            }\n        }\n        return null;\n    }\n    _syncWithVolumeCroppingTool(originalClippingPlanes) {\n        const planes = originalClippingPlanes;\n        if (planes.length >= 6) {\n            this.toolCenterMin = [\n                planes[0].origin[0],\n                planes[2].origin[1],\n                planes[4].origin[2],\n            ];\n            this.toolCenterMax = [\n                planes[1].origin[0],\n                planes[3].origin[1],\n                planes[5].origin[2],\n            ];\n            this.toolCenter = [\n                (this.toolCenterMin[0] + this.toolCenterMax[0]) / 2,\n                (this.toolCenterMin[1] + this.toolCenterMax[1]) / 2,\n                (this.toolCenterMin[2] + this.toolCenterMax[2]) / 2,\n            ];\n            const viewportsInfo = this._getViewportsInfo();\n            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n                if (enabledElement) {\n                    const annotations = this._getAnnotations(enabledElement);\n                    annotations.forEach((annotation) => {\n                        if (annotation.data &&\n                            annotation.data.handles &&\n                            annotation.data.orientation) {\n                            const orientation = annotation.data.orientation;\n                            if (orientation === 'AXIAL') {\n                                annotation.data.handles.toolCenterMin = [\n                                    planes[0].origin[0],\n                                    planes[2].origin[1],\n                                    annotation.data.handles.toolCenterMin[2],\n                                ];\n                                annotation.data.handles.toolCenterMax = [\n                                    planes[1].origin[0],\n                                    planes[3].origin[1],\n                                    annotation.data.handles.toolCenterMax[2],\n                                ];\n                            }\n                            else if (orientation === 'CORONAL') {\n                                annotation.data.handles.toolCenterMin = [\n                                    planes[0].origin[0],\n                                    annotation.data.handles.toolCenterMin[1],\n                                    planes[4].origin[2],\n                                ];\n                                annotation.data.handles.toolCenterMax = [\n                                    planes[1].origin[0],\n                                    annotation.data.handles.toolCenterMax[1],\n                                    planes[5].origin[2],\n                                ];\n                            }\n                            else if (orientation === 'SAGITTAL') {\n                                annotation.data.handles.toolCenterMin = [\n                                    annotation.data.handles.toolCenterMin[0],\n                                    planes[2].origin[1],\n                                    planes[4].origin[2],\n                                ];\n                                annotation.data.handles.toolCenterMax = [\n                                    annotation.data.handles.toolCenterMax[0],\n                                    planes[3].origin[1],\n                                    planes[5].origin[2],\n                                ];\n                            }\n                            annotation.data.handles.toolCenter = [\n                                (annotation.data.handles.toolCenterMin[0] +\n                                    annotation.data.handles.toolCenterMax[0]) /\n                                    2,\n                                (annotation.data.handles.toolCenterMin[1] +\n                                    annotation.data.handles.toolCenterMax[1]) /\n                                    2,\n                                (annotation.data.handles.toolCenterMin[2] +\n                                    annotation.data.handles.toolCenterMax[2]) /\n                                    2,\n                            ];\n                        }\n                    });\n                }\n            });\n            if (this._virtualAnnotations && this._virtualAnnotations.length > 0) {\n                this._virtualAnnotations.forEach((annotation) => {\n                    if (annotation.data &&\n                        annotation.data.handles &&\n                        annotation.data.orientation) {\n                        const orientation = annotation.data.orientation.toUpperCase();\n                        if (orientation === 'AXIAL') {\n                            annotation.data.handles.toolCenterMin = [\n                                planes[0].origin[0],\n                                planes[2].origin[1],\n                                annotation.data.handles.toolCenterMin[2],\n                            ];\n                            annotation.data.handles.toolCenterMax = [\n                                planes[1].origin[0],\n                                planes[3].origin[1],\n                                annotation.data.handles.toolCenterMax[2],\n                            ];\n                        }\n                        else if (orientation === 'CORONAL') {\n                            annotation.data.handles.toolCenterMin = [\n                                planes[0].origin[0],\n                                annotation.data.handles.toolCenterMin[1],\n                                planes[4].origin[2],\n                            ];\n                            annotation.data.handles.toolCenterMax = [\n                                planes[1].origin[0],\n                                annotation.data.handles.toolCenterMax[1],\n                                planes[5].origin[2],\n                            ];\n                        }\n                        else if (orientation === 'SAGITTAL') {\n                            annotation.data.handles.toolCenterMin = [\n                                annotation.data.handles.toolCenterMin[0],\n                                planes[2].origin[1],\n                                planes[4].origin[2],\n                            ];\n                            annotation.data.handles.toolCenterMax = [\n                                annotation.data.handles.toolCenterMax[0],\n                                planes[3].origin[1],\n                                planes[5].origin[2],\n                            ];\n                        }\n                        annotation.data.handles.toolCenter = [\n                            (annotation.data.handles.toolCenterMin[0] +\n                                annotation.data.handles.toolCenterMax[0]) /\n                                2,\n                            (annotation.data.handles.toolCenterMin[1] +\n                                annotation.data.handles.toolCenterMax[1]) /\n                                2,\n                            (annotation.data.handles.toolCenterMin[2] +\n                                annotation.data.handles.toolCenterMax[2]) /\n                                2,\n                        ];\n                    }\n                });\n            }\n            triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n        }\n    }\n    setToolCenter(toolCenter, handleType) {\n        if (handleType === 'min') {\n            this.toolCenterMin = [...toolCenter];\n        }\n        else if (handleType === 'max') {\n            this.toolCenterMax = [...toolCenter];\n        }\n        const viewportsInfo = this._getViewportsInfo();\n        triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const annotations = this._getAnnotations(enabledElement);\n        const filteredAnnotations = this.filterInteractableAnnotationsForElement(viewport.element, annotations);\n        if (!filteredAnnotations ||\n            filteredAnnotations.length === 0 ||\n            !filteredAnnotations[0]) {\n            return null;\n        }\n        const { data } = filteredAnnotations[0];\n        const viewportIdArray = [];\n        const referenceLines = data.referenceLines || [];\n        for (let i = 0; i < referenceLines.length; ++i) {\n            const otherViewport = referenceLines[i][0];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            if (!viewportControllable) {\n                continue;\n            }\n            viewportIdArray.push(otherViewport.id);\n            i++;\n        }\n        data.activeViewportIds = [...viewportIdArray];\n        data.handles.activeOperation = OPERATION.DRAG;\n        evt.preventDefault();\n        hideElementCursor(element);\n        this._activateModify(element);\n        return filteredAnnotations[0];\n    }\n    handleSelectedCallback(evt, annotation, handle, interactionType) {\n        this.toolSelectedCallback(evt, annotation, interactionType);\n    }\n    _unsubscribeToViewportNewVolumeSet(viewportsInfo) {\n        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.removeEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n    _subscribeToViewportNewVolumeSet(viewports) {\n        viewports.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.addEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n    _applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta) {\n        viewportsAnnotationsToUpdate.forEach((annotation) => {\n            this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);\n        });\n    }\n    _applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta) {\n        const { data } = annotation;\n        const viewport = renderingEngine.getViewport(data.viewportId);\n        const camera = viewport.getCamera();\n        const normal = camera.viewPlaneNormal;\n        const dotProd = vtkMath.dot(delta, normal);\n        const projectedDelta = [...normal];\n        vtkMath.multiplyScalar(projectedDelta, dotProd);\n        if (Math.abs(projectedDelta[0]) > 1e-3 ||\n            Math.abs(projectedDelta[1]) > 1e-3 ||\n            Math.abs(projectedDelta[2]) > 1e-3) {\n            const newFocalPoint = [0, 0, 0];\n            const newPosition = [0, 0, 0];\n            vtkMath.add(camera.focalPoint, projectedDelta, newFocalPoint);\n            vtkMath.add(camera.position, projectedDelta, newPosition);\n            viewport.setCamera({\n                focalPoint: newFocalPoint,\n                position: newPosition,\n            });\n            viewport.render();\n        }\n    }\n    _pointNearTool(element, annotation, canvasCoords, proximity) {\n        const { data } = annotation;\n        const referenceLines = data.referenceLines;\n        const viewportIdArray = [];\n        if (referenceLines) {\n            for (let i = 0; i < referenceLines.length; ++i) {\n                const otherViewport = referenceLines[i][0];\n                const start1 = referenceLines[i][1];\n                const end1 = referenceLines[i][2];\n                const type = referenceLines[i][3];\n                const distance1 = lineSegment.distanceToPoint(start1, end1, [\n                    canvasCoords[0],\n                    canvasCoords[1],\n                ]);\n                if (distance1 <= proximity) {\n                    viewportIdArray.push(otherViewport.id);\n                    data.handles.activeOperation = 1;\n                    data.handles.activeType = type;\n                }\n            }\n        }\n        data.activeViewportIds = [...viewportIdArray];\n        this.editData = {\n            annotation,\n        };\n        return data.handles.activeOperation === 1 ? true : false;\n    }\n}\nVolumeCroppingControlTool.toolName = 'VolumeCroppingControl';\nexport default VolumeCroppingControlTool;\n", "import { BaseTool } from './base';\nimport { getEnabledElement, VolumeViewport, cache, utilities, } from '@cornerstonejs/core';\nconst DEFAULT_MULTIPLIER = 4;\nconst DEFAULT_IMAGE_DYNAMIC_RANGE = 1024;\nconst PT = 'PT';\nclass WindowLevelTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this._getImageDynamicRangeFromMiddleSlice = (scalarData, dimensions) => {\n            const middleSliceIndex = Math.floor(dimensions[2] / 2);\n            const frameLength = dimensions[0] * dimensions[1];\n            let bytesPerVoxel;\n            let TypedArrayConstructor;\n            if (scalarData instanceof Float32Array) {\n                bytesPerVoxel = 4;\n                TypedArrayConstructor = Float32Array;\n            }\n            else if (scalarData instanceof Uint8Array) {\n                bytesPerVoxel = 1;\n                TypedArrayConstructor = Uint8Array;\n            }\n            else if (scalarData instanceof Uint16Array) {\n                bytesPerVoxel = 2;\n                TypedArrayConstructor = Uint16Array;\n            }\n            else if (scalarData instanceof Int16Array) {\n                bytesPerVoxel = 2;\n                TypedArrayConstructor = Int16Array;\n            }\n            const buffer = scalarData.buffer;\n            const byteOffset = middleSliceIndex * frameLength * bytesPerVoxel;\n            const frame = new TypedArrayConstructor(buffer, byteOffset, frameLength);\n            const { max, min } = this._getMinMax(frame, frameLength);\n            return max - min;\n        };\n    }\n    touchDragCallback(evt) {\n        this.mouseDragCallback(evt);\n    }\n    mouseDragCallback(evt) {\n        const { element, deltaPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        let volumeId, lower, upper, modality, newRange, viewportsContainingVolumeUID;\n        let isPreScaled = false;\n        const properties = viewport.getProperties();\n        if (viewport instanceof VolumeViewport) {\n            volumeId = viewport.getVolumeId();\n            viewportsContainingVolumeUID =\n                utilities.getViewportsWithVolumeId(volumeId);\n            ({ lower, upper } = properties.voiRange);\n            const volume = cache.getVolume(volumeId);\n            if (!volume) {\n                throw new Error('Volume not found ' + volumeId);\n            }\n            modality = volume.metadata.Modality;\n            isPreScaled = volume.scaling && Object.keys(volume.scaling).length > 0;\n        }\n        else if (properties.voiRange) {\n            modality = viewport.modality;\n            ({ lower, upper } = properties.voiRange);\n            const { preScale = { scaled: false } } = viewport.getImageData?.() || {};\n            isPreScaled =\n                preScale.scaled && preScale.scalingParameters?.suvbw !== undefined;\n        }\n        else {\n            throw new Error('Viewport is not a valid type');\n        }\n        if (modality === PT && isPreScaled) {\n            newRange = this.getPTScaledNewRange({\n                deltaPointsCanvas: deltaPoints.canvas,\n                lower,\n                upper,\n                clientHeight: element.clientHeight,\n                isPreScaled,\n                viewport,\n                volumeId,\n            });\n        }\n        else {\n            newRange = this.getNewRange({\n                viewport,\n                deltaPointsCanvas: deltaPoints.canvas,\n                volumeId,\n                lower,\n                upper,\n            });\n        }\n        if (newRange.lower >= newRange.upper) {\n            return;\n        }\n        viewport.setProperties({\n            voiRange: newRange,\n        });\n        viewport.render();\n        if (viewport instanceof VolumeViewport) {\n            viewportsContainingVolumeUID.forEach((vp) => {\n                if (viewport !== vp) {\n                    vp.render();\n                }\n            });\n            return;\n        }\n    }\n    getPTScaledNewRange({ deltaPointsCanvas, lower, upper, clientHeight, viewport, volumeId, isPreScaled, }) {\n        let multiplier = DEFAULT_MULTIPLIER;\n        if (isPreScaled) {\n            multiplier = 5 / clientHeight;\n        }\n        else {\n            multiplier =\n                this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n                    DEFAULT_MULTIPLIER;\n        }\n        const deltaY = deltaPointsCanvas[1];\n        const wcDelta = deltaY * multiplier;\n        upper -= wcDelta;\n        upper = isPreScaled ? Math.max(upper, 0.1) : upper;\n        return { lower, upper };\n    }\n    getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }) {\n        const multiplier = this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n            DEFAULT_MULTIPLIER;\n        const wwDelta = deltaPointsCanvas[0] * multiplier;\n        const wcDelta = deltaPointsCanvas[1] * multiplier;\n        let { windowWidth, windowCenter } = utilities.windowLevel.toWindowLevel(lower, upper);\n        windowWidth += wwDelta;\n        windowCenter += wcDelta;\n        windowWidth = Math.max(windowWidth, 1);\n        const voiLutFunction = viewport.getProperties().VOILUTFunction;\n        return utilities.windowLevel.toLowHighRange(windowWidth, windowCenter, voiLutFunction);\n    }\n    _getMultiplierFromDynamicRange(viewport, volumeId) {\n        let imageDynamicRange;\n        if (volumeId) {\n            const imageVolume = cache.getVolume(volumeId);\n            const { voxelManager } = viewport.getImageData();\n            const middleSlicePixelData = voxelManager.getMiddleSliceData();\n            const calculatedDynamicRange = middleSlicePixelData.reduce((acc, pixel) => {\n                return [Math.min(acc[0], pixel), Math.max(acc[1], pixel)];\n            }, [Infinity, -Infinity]);\n            const BitsStored = imageVolume?.metadata?.BitsStored;\n            const metadataDynamicRange = BitsStored ? 2 ** BitsStored : Infinity;\n            const calculatedRange = calculatedDynamicRange[1] - calculatedDynamicRange[0];\n            imageDynamicRange = !Number.isFinite(calculatedRange)\n                ? metadataDynamicRange\n                : Math.min(calculatedRange, metadataDynamicRange);\n        }\n        else {\n            imageDynamicRange = this._getImageDynamicRangeFromViewport(viewport);\n        }\n        const ratio = imageDynamicRange / DEFAULT_IMAGE_DYNAMIC_RANGE;\n        return !Number.isFinite(ratio)\n            ? DEFAULT_IMAGE_DYNAMIC_RANGE\n            : ratio > 1\n                ? Math.round(ratio)\n                : ratio;\n    }\n    _getImageDynamicRangeFromViewport(viewport) {\n        const { imageData, voxelManager } = viewport.getImageData();\n        if (voxelManager?.getRange) {\n            const range = voxelManager.getRange();\n            return range[1] - range[0];\n        }\n        const dimensions = imageData.getDimensions();\n        if (imageData.getRange) {\n            const imageDataRange = imageData.getRange();\n            return imageDataRange[1] - imageDataRange[0];\n        }\n        let scalarData;\n        if (imageData.getScalarData) {\n            scalarData = imageData.getScalarData();\n        }\n        else {\n            scalarData = imageData.getPointData().getScalars().getData();\n        }\n        if (dimensions[2] !== 1) {\n            return this._getImageDynamicRangeFromMiddleSlice(scalarData, dimensions);\n        }\n        let range;\n        if (scalarData.getRange) {\n            range = scalarData.getRange();\n        }\n        else {\n            const { min, max } = this._getMinMax(scalarData, scalarData.length);\n            range = [min, max];\n        }\n        return range[1] - range[0];\n    }\n    _getMinMax(frame, frameLength) {\n        let min = Infinity;\n        let max = -Infinity;\n        for (let i = 0; i < frameLength; i++) {\n            const voxel = frame[i];\n            if (voxel < min) {\n                min = voxel;\n            }\n            if (voxel > max) {\n                max = voxel;\n            }\n        }\n        return { max, min };\n    }\n}\nWindowLevelTool.toolName = 'WindowLevel';\nexport default WindowLevelTool;\n", "import { AnnotationTool } from './base';\nimport { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../stateManagement';\nimport { triggerAnnotationCompleted } from '../stateManagement/annotation/helpers/state';\nimport { drawRect as drawRectSvg } from '../drawingSvg';\nimport { state } from '../store/state';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { windowLevel } from '../utilities/voi';\nclass WindowLevelRegionTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            minWindowWidth: 10,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                    },\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender } = this.editData;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            removeAnnotation(annotation.annotationUID);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationCompleted(annotation);\n            this.applyWindowLevelRegion(annotation, element);\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            const { currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n            const worldPos = currentPoints.world;\n            const { points } = data.handles;\n            const DEFAULT_HANDLE_INDEX = 3;\n            points[DEFAULT_HANDLE_INDEX] = [...worldPos];\n            const bottomLeftCanvas = worldToCanvas(points[0]);\n            const topRightCanvas = worldToCanvas(points[3]);\n            const bottomRightCanvas = [\n                topRightCanvas[0],\n                bottomLeftCanvas[1],\n            ];\n            const topLeftCanvas = [\n                bottomLeftCanvas[0],\n                topRightCanvas[1],\n            ];\n            const bottomRightWorld = canvasToWorld(bottomRightCanvas);\n            const topLeftWorld = canvasToWorld(topLeftCanvas);\n            points[1] = bottomRightWorld;\n            points[2] = topLeftWorld;\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const dataId = `${annotationUID}-rect`;\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n        this.applyWindowLevelRegion = (annotation, element) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const imageData = windowLevel.extractWindowLevelRegionToolData(viewport);\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const startCanvas = canvasCoordinates[0];\n            const endCanvas = canvasCoordinates[3];\n            let left = Math.min(startCanvas[0], endCanvas[0]);\n            let top = Math.min(startCanvas[1], endCanvas[1]);\n            let width = Math.abs(startCanvas[0] - endCanvas[0]);\n            let height = Math.abs(startCanvas[1] - endCanvas[1]);\n            left = utilities.clip(left, 0, imageData.width);\n            top = utilities.clip(top, 0, imageData.height);\n            width = Math.floor(Math.min(width, Math.abs(imageData.width - left)));\n            height = Math.floor(Math.min(height, Math.abs(imageData.height - top)));\n            const pixelLuminanceData = windowLevel.getLuminanceFromRegion(imageData, Math.round(left), Math.round(top), width, height);\n            const minMaxMean = windowLevel.calculateMinMaxMean(pixelLuminanceData, imageData.minPixelValue, imageData.maxPixelValue);\n            if (this.configuration.minWindowWidth === undefined) {\n                this.configuration.minWindowWidth = 10;\n            }\n            const windowWidth = Math.max(Math.abs(minMaxMean.max - minMaxMean.min), this.configuration.minWindowWidth);\n            const windowCenter = minMaxMean.mean;\n            const voiLutFunction = viewport.getProperties().VOILUTFunction;\n            const voiRange = utilities.windowLevel.toLowHighRange(windowWidth, windowCenter, voiLutFunction);\n            viewport.setProperties({ voiRange });\n            viewport.render();\n        };\n        this.cancel = () => {\n            return null;\n        };\n        this.isPointNearTool = () => {\n            return null;\n        };\n        this.toolSelectedCallback = () => {\n            return null;\n        };\n        this.handleSelectedCallback = () => {\n            return null;\n        };\n        this._activateModify = () => {\n            return null;\n        };\n        this._deactivateModify = () => {\n            return null;\n        };\n    }\n}\nWindowLevelRegionTool.toolName = 'WindowLevelRegion';\nexport default WindowLevelRegionTool;\n", "import { getEnabledElementByIds, getEnabledElement, VolumeViewport, BaseVolumeViewport, utilities, } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nclass StackScrollTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            invert: false,\n            debounceIfNotLoaded: true,\n            loop: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.deltaY = 1;\n    }\n    mouseWheelCallback(evt) {\n        this._scroll(evt);\n    }\n    mouseDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    touchDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    _dragCallback(evt) {\n        this._scrollDrag(evt);\n    }\n    _scrollDrag(evt) {\n        const { deltaPoints, viewportId, renderingEngineId } = evt.detail;\n        const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n        const { debounceIfNotLoaded, invert, loop } = this.configuration;\n        const deltaPointY = deltaPoints.canvas[1];\n        let volumeId;\n        if (viewport instanceof VolumeViewport) {\n            volumeId = viewport.getVolumeId();\n        }\n        const pixelsPerImage = this._getPixelPerImage(viewport);\n        const deltaY = deltaPointY + this.deltaY;\n        if (!pixelsPerImage) {\n            return;\n        }\n        if (Math.abs(deltaY) >= pixelsPerImage) {\n            const imageIdIndexOffset = Math.round(deltaY / pixelsPerImage);\n            utilities.scroll(viewport, {\n                delta: invert ? -imageIdIndexOffset : imageIdIndexOffset,\n                volumeId,\n                debounceLoading: debounceIfNotLoaded,\n                loop: loop,\n            });\n            this.deltaY = deltaY % pixelsPerImage;\n        }\n        else {\n            this.deltaY = deltaY;\n        }\n    }\n    _scroll(evt) {\n        const { wheel, element } = evt.detail;\n        const { direction } = wheel;\n        const { invert } = this.configuration;\n        const { viewport } = getEnabledElement(element);\n        const delta = direction * (invert ? -1 : 1);\n        utilities.scroll(viewport, {\n            delta,\n            debounceLoading: this.configuration.debounceIfNotLoaded,\n            loop: this.configuration.loop,\n            volumeId: viewport instanceof BaseVolumeViewport\n                ? viewport.getVolumeId()\n                : undefined,\n            scrollSlabs: this.configuration.scrollSlabs,\n        });\n    }\n    _getPixelPerImage(viewport) {\n        const { element } = viewport;\n        const numberOfSlices = viewport.getNumberOfSlices();\n        return Math.max(2, element.offsetHeight / Math.max(numberOfSlices, 8));\n    }\n}\nStackScrollTool.toolName = 'StackScroll';\nexport default StackScrollTool;\n", "import { BaseVolumeViewport, getEnabledElement } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { BaseTool } from './base';\nimport angleBetweenLines from '../utilities/math/angle/angleBetweenLines';\nclass PlanarRotateTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this.mouseWheelCallback = (evt) => {\n            const { element, wheel } = evt.detail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { invert } = this.configuration;\n            const angle = wheel.direction * 10 * (invert ? -1 : 1);\n            this.setAngle(viewport, angle);\n        };\n        this.touchDragCallback = this._dragCallback.bind(this);\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    _dragCallback(evt) {\n        const { element, currentPoints, startPoints } = evt.detail;\n        const currentPointWorld = currentPoints.world;\n        const startPointWorld = startPoints.world;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const width = element.clientWidth;\n        const height = element.clientHeight;\n        const centerCanvas = [width * 0.5, height * 0.5];\n        const centerWorld = viewport.canvasToWorld(centerCanvas);\n        let angle = angleBetweenLines([startPointWorld, centerWorld], [centerWorld, currentPointWorld]);\n        const { viewPlaneNormal } = camera;\n        const v1 = vec3.sub(vec3.create(), centerWorld, startPointWorld);\n        const v2 = vec3.sub(vec3.create(), centerWorld, currentPointWorld);\n        const cross = vec3.cross(vec3.create(), v1, v2);\n        if (vec3.dot(viewPlaneNormal, cross) > 0) {\n            angle = -angle;\n        }\n        if (Number.isNaN(angle)) {\n            return;\n        }\n        this.setAngle(viewport, angle);\n    }\n    setAngle(viewport, angle) {\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\n        if (viewport instanceof BaseVolumeViewport) {\n            const rotAngle = (((angle + 360) % 360) * Math.PI) / 180;\n            const rotMat = mat4.identity(new Float32Array(16));\n            mat4.rotate(rotMat, rotMat, rotAngle, viewPlaneNormal);\n            const rotatedViewUp = vec3.transformMat4(vec3.create(), viewUp, rotMat);\n            viewport.setCamera({ viewUp: rotatedViewUp });\n        }\n        else {\n            const { rotation } = viewport.getViewPresentation();\n            viewport.setViewPresentation({\n                rotation: (rotation + angle + 360) % 360,\n            });\n        }\n        viewport.render();\n    }\n}\nPlanarRotateTool.toolName = 'PlanarRotate';\nexport default PlanarRotateTool;\n", "import { vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { getConfiguration } from '@cornerstonejs/core';\nimport { Enums, getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { Events } from '../enums';\nclass ZoomTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            zoomToCenter: false,\n            minZoomScale: 0.001,\n            maxZoomScale: 3000,\n            pinchToZoom: true,\n            pan: true,\n            invert: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const camera = enabledElement.viewport.getCamera();\n            const { focalPoint } = camera;\n            this.initialMousePosWorld = worldPos;\n            let dirVec = vec3.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);\n            dirVec = vec3.normalize(vec3.create(), dirVec);\n            this.dirVec = dirVec;\n            return false;\n        };\n        this.preTouchStartCallback = (evt) => {\n            if (!this.configuration.pinchToZoom) {\n                return this.preMouseDownCallback(evt);\n            }\n        };\n        this._dragParallelProjection = (evt, viewport, camera, pinch = false) => {\n            const { element, deltaPoints } = evt.detail;\n            const deltaY = pinch\n                ? evt.detail.deltaDistance.canvas\n                : deltaPoints.canvas[1];\n            const size = [element.clientWidth, element.clientHeight];\n            const { parallelScale, focalPoint, position } = camera;\n            const zoomScale = 5 / size[1];\n            const k = deltaY * zoomScale * (this.configuration.invert ? -1 : 1);\n            const parallelScaleToSet = (1.0 - k) * parallelScale;\n            let focalPointToSet = focalPoint;\n            let positionToSet = position;\n            if (!this.configuration.zoomToCenter) {\n                const distanceToCanvasCenter = vec3.distance(focalPoint, this.initialMousePosWorld);\n                positionToSet = vec3.scaleAndAdd(vec3.create(), position, this.dirVec, -distanceToCanvasCenter * k);\n                focalPointToSet = vec3.scaleAndAdd(vec3.create(), focalPoint, this.dirVec, -distanceToCanvasCenter * k);\n            }\n            const imageData = viewport.getImageData();\n            let spacing = [1, 1, 1];\n            let cappedParallelScale = parallelScaleToSet;\n            let thresholdExceeded = false;\n            if (imageData) {\n                spacing = imageData.spacing;\n                const { dimensions } = imageData;\n                const imageWidth = dimensions[0] * spacing[0];\n                const imageHeight = dimensions[1] * spacing[1];\n                const canvasAspect = size[0] / size[1];\n                const insetImageMultiplier = getConfiguration().rendering\n                    ?.useLegacyCameraFOV\n                    ? 1.1\n                    : 1;\n                const displayArea = viewport.options?.displayArea;\n                const imageAreaScaleX = displayArea?.imageArea?.[0] ?? insetImageMultiplier;\n                const imageAreaScaleY = displayArea?.imageArea?.[1] ?? insetImageMultiplier;\n                const scaledImageWidth = imageWidth * imageAreaScaleX;\n                const scaledImageHeight = imageHeight * imageAreaScaleY;\n                const scaledImageAspect = scaledImageWidth / scaledImageHeight;\n                let minParallelScaleRequired;\n                if (scaledImageAspect > canvasAspect) {\n                    minParallelScaleRequired = (scaledImageWidth / canvasAspect) * 0.5;\n                }\n                else {\n                    minParallelScaleRequired = scaledImageHeight * 0.5;\n                }\n                const { minZoomScale, maxZoomScale } = this.configuration;\n                const minScaleInWorld = minParallelScaleRequired / maxZoomScale;\n                const maxScaleInWorld = minParallelScaleRequired / minZoomScale;\n                if (parallelScaleToSet < minScaleInWorld) {\n                    cappedParallelScale = minScaleInWorld;\n                    thresholdExceeded = true;\n                }\n                else if (parallelScaleToSet > maxScaleInWorld) {\n                    cappedParallelScale = maxScaleInWorld;\n                    thresholdExceeded = true;\n                }\n            }\n            viewport.setCamera({\n                parallelScale: cappedParallelScale,\n                focalPoint: thresholdExceeded ? focalPoint : focalPointToSet,\n                position: thresholdExceeded ? position : positionToSet,\n            });\n        };\n        this._dragPerspectiveProjection = (evt, viewport, camera, pinch = false) => {\n            const { element, deltaPoints } = evt.detail;\n            const deltaY = pinch\n                ? evt.detail.deltaDistance.canvas\n                : deltaPoints.canvas[1];\n            const size = [element.clientWidth, element.clientHeight];\n            const { position, focalPoint, viewPlaneNormal } = camera;\n            const distance = vtkMath.distance2BetweenPoints(position, focalPoint);\n            const zoomScale = Math.sqrt(distance) / size[1];\n            const directionOfProjection = [\n                -viewPlaneNormal[0],\n                -viewPlaneNormal[1],\n                -viewPlaneNormal[2],\n            ];\n            const k = this.configuration.invert\n                ? deltaY / zoomScale\n                : deltaY * zoomScale;\n            let tmp = k * directionOfProjection[0];\n            position[0] += tmp;\n            focalPoint[0] += tmp;\n            tmp = k * directionOfProjection[1];\n            position[1] += tmp;\n            focalPoint[1] += tmp;\n            tmp = k * directionOfProjection[2];\n            position[2] += tmp;\n            focalPoint[2] += tmp;\n            viewport.setCamera({ position, focalPoint });\n        };\n        this.initialMousePosWorld = [0, 0, 0];\n        this.dirVec = [0, 0, 0];\n        if (this.configuration.pinchToZoom) {\n            this.touchDragCallback = this._pinchCallback.bind(this);\n        }\n        else {\n            this.touchDragCallback = this._dragCallback.bind(this);\n        }\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    mouseWheelCallback(evt) {\n        this._zoom(evt);\n    }\n    _pinchCallback(evt) {\n        const pointsList = evt.detail\n            .currentPointsList;\n        if (pointsList.length > 1) {\n            const { element, currentPoints } = evt.detail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const worldPos = currentPoints.world;\n            const { focalPoint } = camera;\n            this.initialMousePosWorld = worldPos;\n            let dirVec = vec3.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);\n            dirVec = vec3.normalize(vec3.create(), dirVec);\n            this.dirVec = dirVec;\n            if (camera.parallelProjection) {\n                this._dragParallelProjection(evt, viewport, camera, true);\n            }\n            else {\n                this._dragPerspectiveProjection(evt, viewport, camera, true);\n            }\n            viewport.render();\n        }\n        if (this.configuration.pan) {\n            this._panCallback(evt);\n        }\n    }\n    _dragCallback(evt) {\n        const { element } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        if (camera.parallelProjection) {\n            this._dragParallelProjection(evt, viewport, camera);\n        }\n        else {\n            this._dragPerspectiveProjection(evt, viewport, camera);\n        }\n        viewport.render();\n    }\n    _zoom(evt) {\n        const { element, points } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const wheelData = evt.detail.wheel;\n        const direction = wheelData.direction;\n        const eventDetails = {\n            detail: {\n                element,\n                eventName: Events.MOUSE_WHEEL,\n                renderingEngineId: enabledElement.renderingEngineId,\n                viewportId: viewport.id,\n                camera: {},\n                deltaPoints: {\n                    page: points.page,\n                    client: points.client,\n                    world: points.world,\n                    canvas: [0, -direction * 5],\n                },\n                startPoints: points,\n                lastPoints: points,\n                currentPoints: points,\n            },\n        };\n        if (viewport.type === Enums.ViewportType.STACK) {\n            this.preMouseDownCallback(eventDetails);\n        }\n        this._dragCallback(eventDetails);\n    }\n    _panCallback(evt) {\n        const { element, deltaPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const deltaPointsWorld = deltaPoints.world;\n        const camera = enabledElement.viewport.getCamera();\n        const { focalPoint, position } = camera;\n        const updatedPosition = [\n            position[0] - deltaPointsWorld[0],\n            position[1] - deltaPointsWorld[1],\n            position[2] - deltaPointsWorld[2],\n        ];\n        const updatedFocalPoint = [\n            focalPoint[0] - deltaPointsWorld[0],\n            focalPoint[1] - deltaPointsWorld[1],\n            focalPoint[2] - deltaPointsWorld[2],\n        ];\n        enabledElement.viewport.setCamera({\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n        enabledElement.viewport.render();\n    }\n}\nZoomTool.toolName = 'Zoom';\nexport default ZoomTool;\n", "import { BaseTool } from './base';\nimport { getEnabledElement, VolumeViewport } from '@cornerstonejs/core';\nimport { utilities } from '@cornerstonejs/core';\nimport { getPointInLineOfSightWithCriteria } from '../utilities/planar';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nclass MIPJumpToClickTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            targetViewportIds: [],\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n    }\n    mouseClickCallback(evt) {\n        const { element, currentPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport, renderingEngine } = enabledElement;\n        const volumeId = viewport.getVolumeId();\n        if (!volumeId) {\n            throw new Error(`MIPJumpToClickTool: targetId is not a volumeId, you should only use MIPJumpToClickTool with a volumeId as the targetId`);\n        }\n        let maxIntensity = -Infinity;\n        const maxFn = (intensity, point) => {\n            if (intensity > maxIntensity) {\n                maxIntensity = intensity;\n                return point;\n            }\n        };\n        const brightestPoint = getPointInLineOfSightWithCriteria(viewport, currentPoints.world, volumeId, maxFn);\n        if (!brightestPoint || !brightestPoint.length) {\n            return;\n        }\n        const { targetViewportIds, toolGroupId } = this.configuration;\n        const viewports = renderingEngine.getViewports().filter((vp) => {\n            if (targetViewportIds?.indexOf(vp.id) >= 0) {\n                return true;\n            }\n            const foundToolGroup = getToolGroupForViewport(vp.id, renderingEngine.id);\n            if (toolGroupId && toolGroupId === foundToolGroup?.id) {\n                return true;\n            }\n            return false;\n        });\n        viewports.forEach((viewport) => {\n            if (viewport instanceof VolumeViewport) {\n                viewport.jumpToWorld(brightestPoint);\n            }\n            else {\n                console.warn('Cannot jump to specified world coordinates for a viewport that is not a VolumeViewport');\n            }\n        });\n    }\n}\nMIPJumpToClickTool.toolName = 'MIPJumpToClickTool';\nexport default MIPJumpToClickTool;\n", "import { vec2, vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport vtkMatrixBuilder from '@kitware/vtk.js/Common/Core/MatrixBuilder';\nimport { AnnotationTool } from './base';\nimport { getEnabledElementByIds, getEnabledElement, utilities as csUtils, Enums, CONSTANTS, triggerEvent, eventTarget, } from '@cornerstonejs/core';\nimport { getToolGroup, getToolGroupForViewport, } from '../store/ToolGroupManager';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../stateManagement/annotation/annotationState';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, drawLine as drawLineSvg, } from '../drawingSvg';\nimport { state } from '../store/state';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../cursors/elementCursor';\nimport liangBarksyClip from '../utilities/math/vec2/liangBarksyClip';\nimport * as lineSegment from '../utilities/math/line';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nconst { RENDERING_DEFAULTS } = CONSTANTS;\nfunction defaultReferenceLineColor() {\n    return 'rgb(0, 200, 0)';\n}\nfunction defaultReferenceLineControllable() {\n    return true;\n}\nfunction defaultReferenceLineDraggableRotatable() {\n    return true;\n}\nfunction defaultReferenceLineSlabThicknessControlsOn() {\n    return true;\n}\nconst OPERATION = {\n    DRAG: 1,\n    ROTATE: 2,\n    SLAB: 3,\n};\nclass CrosshairsTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse'],\n        configuration: {\n            shadow: true,\n            viewportIndicators: false,\n            viewportIndicatorsConfig: {\n                radius: 5,\n                x: null,\n                y: null,\n            },\n            autoPan: {\n                enabled: false,\n                panSize: 10,\n            },\n            handleRadius: 3,\n            enableHDPIHandles: false,\n            referenceLinesCenterGapRadius: 20,\n            referenceLinesCenterGapRatio: null,\n            filterActorUIDsToSetSlabThickness: [],\n            slabThicknessBlendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n            mobile: {\n                enabled: false,\n                opacity: 0.8,\n                handleRadius: 9,\n                referenceLinesCenterGapRatio: 0.05,\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.toolCenter = [0, 0, 0];\n        this.initializeViewport = ({ renderingEngineId, viewportId, }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (!enabledElement) {\n                return;\n            }\n            const { FrameOfReferenceUID, viewport } = enabledElement;\n            const { element } = viewport;\n            const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();\n            let annotations = this._getAnnotations(enabledElement);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (annotations?.length) {\n                removeAnnotation(annotations[0].annotationUID);\n            }\n            const annotation = {\n                highlighted: false,\n                metadata: {\n                    cameraPosition: [...position],\n                    cameraFocalPoint: [...focalPoint],\n                    FrameOfReferenceUID,\n                    toolName: this.getToolName(),\n                },\n                data: {\n                    handles: {\n                        rotationPoints: [],\n                        slabThicknessPoints: [],\n                        toolCenter: this.toolCenter,\n                    },\n                    activeOperation: null,\n                    activeViewportIds: [],\n                    viewportId,\n                },\n            };\n            addAnnotation(annotation, element);\n            return {\n                normal: viewPlaneNormal,\n                point: viewport.canvasToWorld([\n                    viewport.canvas.clientWidth / 2,\n                    viewport.canvas.clientHeight / 2,\n                ]),\n            };\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this.resetCrosshairs = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            for (const viewportInfo of viewportsInfo) {\n                const { viewportId, renderingEngineId } = viewportInfo;\n                const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n                const viewport = enabledElement.viewport;\n                const resetPan = true;\n                const resetZoom = true;\n                const resetToCenter = true;\n                const resetRotation = true;\n                const suppressEvents = true;\n                viewport.resetCamera({\n                    resetPan,\n                    resetZoom,\n                    resetToCenter,\n                    resetRotation,\n                    suppressEvents,\n                });\n                viewport.resetSlabThickness();\n                const { element } = viewport;\n                let annotations = this._getAnnotations(enabledElement);\n                annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n                if (annotations.length) {\n                    removeAnnotation(annotations[0].annotationUID);\n                }\n                viewport.render();\n            }\n            this._computeToolCenter(viewportsInfo);\n        };\n        this.computeToolCenter = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            this._computeToolCenter(viewportsInfo);\n        };\n        this._computeToolCenter = (viewportsInfo) => {\n            if (!viewportsInfo.length || viewportsInfo.length === 1) {\n                console.warn('For crosshairs to operate, at least two viewports must be given.');\n                return;\n            }\n            const [firstViewport, secondViewport, thirdViewport] = viewportsInfo;\n            const { normal: normal1, point: point1 } = this.initializeViewport(firstViewport);\n            const { normal: normal2, point: point2 } = this.initializeViewport(secondViewport);\n            let normal3 = [0, 0, 0];\n            let point3 = vec3.create();\n            if (thirdViewport) {\n                ({ normal: normal3, point: point3 } =\n                    this.initializeViewport(thirdViewport));\n            }\n            else {\n                vec3.add(point3, point1, point2);\n                vec3.scale(point3, point3, 0.5);\n                vec3.cross(normal3, normal1, normal2);\n            }\n            const firstPlane = csUtils.planar.planeEquation(normal1, point1);\n            const secondPlane = csUtils.planar.planeEquation(normal2, point2);\n            const thirdPlane = csUtils.planar.planeEquation(normal3, point3);\n            const toolCenter = csUtils.planar.threePlaneIntersection(firstPlane, secondPlane, thirdPlane);\n            this.setToolCenter(toolCenter);\n        };\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const jumpWorld = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this._jump(enabledElement, jumpWorld);\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredAnnotations = this.filterInteractableAnnotationsForElement(viewport.element, annotations);\n            const { data } = filteredAnnotations[0];\n            const { rotationPoints } = data.handles;\n            const viewportIdArray = [];\n            for (let i = 0; i < rotationPoints.length - 1; ++i) {\n                const otherViewport = rotationPoints[i][1];\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                if (!viewportControllable || !viewportDraggableRotatable) {\n                    continue;\n                }\n                viewportIdArray.push(otherViewport.id);\n                i++;\n            }\n            data.activeViewportIds = [...viewportIdArray];\n            data.handles.activeOperation = OPERATION.DRAG;\n            evt.preventDefault();\n            hideElementCursor(element);\n            this._activateModify(element);\n            return filteredAnnotations[0];\n        };\n        this.cancel = () => {\n            console.log('Not implemented yet');\n        };\n        this.handleSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            if (this._pointNearTool(element, annotation, canvasCoords, 6)) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.onCameraModified = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            const viewport = enabledElement.viewport;\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!viewportAnnotation) {\n                return;\n            }\n            const currentCamera = viewport.getCamera();\n            const oldCameraPosition = viewportAnnotation.metadata.cameraPosition;\n            const deltaCameraPosition = [0, 0, 0];\n            vtkMath.subtract(currentCamera.position, oldCameraPosition, deltaCameraPosition);\n            const oldCameraFocalPoint = viewportAnnotation.metadata.cameraFocalPoint;\n            const deltaCameraFocalPoint = [0, 0, 0];\n            vtkMath.subtract(currentCamera.focalPoint, oldCameraFocalPoint, deltaCameraFocalPoint);\n            viewportAnnotation.metadata.cameraPosition = [...currentCamera.position];\n            viewportAnnotation.metadata.cameraFocalPoint = [\n                ...currentCamera.focalPoint,\n            ];\n            const viewportControllable = this._getReferenceLineControllable(viewport.id);\n            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(viewport.id);\n            if (!csUtils.isEqual(currentCamera.position, oldCameraPosition, 1e-3) &&\n                viewportControllable &&\n                viewportDraggableRotatable) {\n                let isRotation = false;\n                const cameraModifiedSameForPosAndFocalPoint = csUtils.isEqual(deltaCameraPosition, deltaCameraFocalPoint, 1e-3);\n                if (!cameraModifiedSameForPosAndFocalPoint) {\n                    isRotation = true;\n                }\n                const cameraModifiedInPlane = Math.abs(vtkMath.dot(deltaCameraPosition, currentCamera.viewPlaneNormal)) < 1e-2;\n                if (!isRotation && !cameraModifiedInPlane) {\n                    this.toolCenter[0] += deltaCameraPosition[0];\n                    this.toolCenter[1] += deltaCameraPosition[1];\n                    this.toolCenter[2] += deltaCameraPosition[2];\n                    triggerEvent(eventTarget, Events.CROSSHAIR_TOOL_CENTER_CHANGED, {\n                        toolGroupId: this.toolGroupId,\n                        toolCenter: this.toolCenter,\n                    });\n                }\n            }\n            if (this.configuration.autoPan?.enabled) {\n                const toolGroup = getToolGroupForViewport(viewport.id, renderingEngine.id);\n                const otherViewportIds = toolGroup\n                    .getViewportIds()\n                    .filter((id) => id !== viewport.id);\n                otherViewportIds.forEach((viewportId) => {\n                    this._autoPanViewportIfNecessary(viewportId, renderingEngine);\n                });\n            }\n            const requireSameOrientation = false;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), requireSameOrientation);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.onResetCamera = (evt) => {\n            this.resetCrosshairs();\n        };\n        this.mouseMoveCallback = (evt, filteredToolAnnotations) => {\n            const { element, currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            let imageNeedsUpdate = false;\n            for (let i = 0; i < filteredToolAnnotations.length; i++) {\n                const annotation = filteredToolAnnotations[i];\n                if (isAnnotationLocked(annotation.annotationUID)) {\n                    continue;\n                }\n                const { data, highlighted } = annotation;\n                if (!data.handles) {\n                    continue;\n                }\n                const previousActiveOperation = data.handles.activeOperation;\n                const previousActiveViewportIds = data.activeViewportIds && data.activeViewportIds.length > 0\n                    ? [...data.activeViewportIds]\n                    : [];\n                data.activeViewportIds = [];\n                data.handles.activeOperation = null;\n                const handleNearImagePoint = this.getHandleNearImagePoint(element, annotation, canvasCoords, 6);\n                let near = false;\n                if (handleNearImagePoint) {\n                    near = true;\n                }\n                else {\n                    near = this._pointNearTool(element, annotation, canvasCoords, 6);\n                }\n                const nearToolAndNotMarkedActive = near && !highlighted;\n                const notNearToolAndMarkedActive = !near && highlighted;\n                if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n                    annotation.highlighted = !highlighted;\n                    imageNeedsUpdate = true;\n                }\n                else if (data.handles.activeOperation !== previousActiveOperation ||\n                    !this._areViewportIdArraysEqual(data.activeViewportIds, previousActiveViewportIds)) {\n                    imageNeedsUpdate = true;\n                }\n            }\n            return imageNeedsUpdate;\n        };\n        this.filterInteractableAnnotationsForElement = (element, annotations) => {\n            if (!annotations || !annotations.length) {\n                return [];\n            }\n            const enabledElement = getEnabledElement(element);\n            const { viewportId } = enabledElement;\n            const viewportUIDSpecificCrosshairs = annotations.filter((annotation) => annotation.data.viewportId === viewportId);\n            return viewportUIDSpecificCrosshairs;\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport, renderingEngine } = enabledElement;\n            const { element } = viewport;\n            const annotations = this._getAnnotations(enabledElement);\n            const camera = viewport.getCamera();\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!annotations?.length || !viewportAnnotation?.data) {\n                return renderStatus;\n            }\n            const annotationUID = viewportAnnotation.annotationUID;\n            const { clientWidth, clientHeight } = viewport.canvas;\n            const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n            const canvasMinDimensionLength = Math.min(clientWidth, clientHeight);\n            const data = viewportAnnotation.data;\n            const crosshairCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n            const otherViewportAnnotations = this._filterAnnotationsByUniqueViewportOrientations(enabledElement, annotations);\n            const referenceLines = [];\n            const canvasBox = [0, 0, clientWidth, clientHeight];\n            otherViewportAnnotations.forEach((annotation) => {\n                const { data } = annotation;\n                data.handles.toolCenter = this.toolCenter;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n                const { clientWidth, clientHeight } = otherViewport.canvas;\n                const otherCanvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n                const otherCanvasCenter = [\n                    clientWidth * 0.5,\n                    clientHeight * 0.5,\n                ];\n                const otherViewportCenterWorld = otherViewport.canvasToWorld(otherCanvasCenter);\n                const direction = [0, 0, 0];\n                vtkMath.cross(camera.viewPlaneNormal, otherCamera.viewPlaneNormal, direction);\n                vtkMath.normalize(direction);\n                vtkMath.multiplyScalar(direction, otherCanvasDiagonalLength);\n                const pointWorld0 = [0, 0, 0];\n                vtkMath.add(otherViewportCenterWorld, direction, pointWorld0);\n                const pointWorld1 = [0, 0, 0];\n                vtkMath.subtract(otherViewportCenterWorld, direction, pointWorld1);\n                const pointCanvas0 = viewport.worldToCanvas(pointWorld0);\n                const otherViewportCenterCanvas = viewport.worldToCanvas(otherViewportCenterWorld);\n                const canvasUnitVectorFromCenter = vec2.create();\n                vec2.subtract(canvasUnitVectorFromCenter, pointCanvas0, otherViewportCenterCanvas);\n                vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n                const canvasVectorFromCenterLong = vec2.create();\n                vec2.scale(canvasVectorFromCenterLong, canvasUnitVectorFromCenter, canvasDiagonalLength * 100);\n                const canvasVectorFromCenterMid = vec2.create();\n                vec2.scale(canvasVectorFromCenterMid, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.4);\n                const canvasVectorFromCenterShort = vec2.create();\n                vec2.scale(canvasVectorFromCenterShort, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.2);\n                const canvasVectorFromCenterStart = vec2.create();\n                const mobileConfig = this.configuration.mobile;\n                const { referenceLinesCenterGapRatio } = mobileConfig?.enabled\n                    ? mobileConfig\n                    : this.configuration;\n                const centerGap = referenceLinesCenterGapRatio > 0\n                    ? canvasMinDimensionLength * referenceLinesCenterGapRatio\n                    : this.configuration.referenceLinesCenterGapRadius;\n                vec2.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, otherViewportAnnotations.length === 2 ? centerGap : 0);\n                const refLinePointOne = vec2.create();\n                const refLinePointTwo = vec2.create();\n                const refLinePointThree = vec2.create();\n                const refLinePointFour = vec2.create();\n                let refLinesCenter = vec2.clone(crosshairCenterCanvas);\n                if (!otherViewportDraggableRotatable || !otherViewportControllable) {\n                    refLinesCenter = vec2.clone(otherViewportCenterCanvas);\n                }\n                vec2.add(refLinePointOne, refLinesCenter, canvasVectorFromCenterStart);\n                vec2.add(refLinePointTwo, refLinesCenter, canvasVectorFromCenterLong);\n                vec2.subtract(refLinePointThree, refLinesCenter, canvasVectorFromCenterStart);\n                vec2.subtract(refLinePointFour, refLinesCenter, canvasVectorFromCenterLong);\n                liangBarksyClip(refLinePointOne, refLinePointTwo, canvasBox);\n                liangBarksyClip(refLinePointThree, refLinePointFour, canvasBox);\n                const rotHandleOne = vec2.create();\n                vec2.subtract(rotHandleOne, crosshairCenterCanvas, canvasVectorFromCenterMid);\n                const rotHandleTwo = vec2.create();\n                vec2.add(rotHandleTwo, crosshairCenterCanvas, canvasVectorFromCenterMid);\n                let stHandlesCenterCanvas = vec2.clone(crosshairCenterCanvas);\n                if (!otherViewportDraggableRotatable &&\n                    otherViewportSlabThicknessControlsOn) {\n                    stHandlesCenterCanvas = vec2.clone(otherViewportCenterCanvas);\n                }\n                let stHandlesCenterWorld = [...this.toolCenter];\n                if (!otherViewportDraggableRotatable &&\n                    otherViewportSlabThicknessControlsOn) {\n                    stHandlesCenterWorld = [...otherViewportCenterWorld];\n                }\n                const worldUnitVectorFromCenter = [0, 0, 0];\n                vtkMath.subtract(pointWorld0, pointWorld1, worldUnitVectorFromCenter);\n                vtkMath.normalize(worldUnitVectorFromCenter);\n                const { viewPlaneNormal } = camera;\n                const { matrix } = vtkMatrixBuilder\n                    .buildFromDegree()\n                    .rotate(90, viewPlaneNormal);\n                const worldUnitOrthoVectorFromCenter = [0, 0, 0];\n                vec3.transformMat4(worldUnitOrthoVectorFromCenter, worldUnitVectorFromCenter, matrix);\n                const slabThicknessValue = otherViewport.getSlabThickness();\n                const worldOrthoVectorFromCenter = [\n                    ...worldUnitOrthoVectorFromCenter,\n                ];\n                vtkMath.multiplyScalar(worldOrthoVectorFromCenter, slabThicknessValue);\n                const worldVerticalRefPoint = [0, 0, 0];\n                vtkMath.add(stHandlesCenterWorld, worldOrthoVectorFromCenter, worldVerticalRefPoint);\n                const canvasVerticalRefPoint = viewport.worldToCanvas(worldVerticalRefPoint);\n                const canvasOrthoVectorFromCenter = vec2.create();\n                vec2.subtract(canvasOrthoVectorFromCenter, stHandlesCenterCanvas, canvasVerticalRefPoint);\n                const stLinePointOne = vec2.create();\n                vec2.subtract(stLinePointOne, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.add(stLinePointOne, stLinePointOne, canvasOrthoVectorFromCenter);\n                const stLinePointTwo = vec2.create();\n                vec2.add(stLinePointTwo, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.add(stLinePointTwo, stLinePointTwo, canvasOrthoVectorFromCenter);\n                liangBarksyClip(stLinePointOne, stLinePointTwo, canvasBox);\n                const stLinePointThree = vec2.create();\n                vec2.add(stLinePointThree, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.subtract(stLinePointThree, stLinePointThree, canvasOrthoVectorFromCenter);\n                const stLinePointFour = vec2.create();\n                vec2.subtract(stLinePointFour, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.subtract(stLinePointFour, stLinePointFour, canvasOrthoVectorFromCenter);\n                liangBarksyClip(stLinePointThree, stLinePointFour, canvasBox);\n                const stHandleOne = vec2.create();\n                const stHandleTwo = vec2.create();\n                const stHandleThree = vec2.create();\n                const stHandleFour = vec2.create();\n                vec2.subtract(stHandleOne, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.add(stHandleOne, stHandleOne, canvasOrthoVectorFromCenter);\n                vec2.add(stHandleTwo, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.add(stHandleTwo, stHandleTwo, canvasOrthoVectorFromCenter);\n                vec2.subtract(stHandleThree, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.subtract(stHandleThree, stHandleThree, canvasOrthoVectorFromCenter);\n                vec2.add(stHandleFour, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.subtract(stHandleFour, stHandleFour, canvasOrthoVectorFromCenter);\n                referenceLines.push([\n                    otherViewport,\n                    refLinePointOne,\n                    refLinePointTwo,\n                    refLinePointThree,\n                    refLinePointFour,\n                    stLinePointOne,\n                    stLinePointTwo,\n                    stLinePointThree,\n                    stLinePointFour,\n                    rotHandleOne,\n                    rotHandleTwo,\n                    stHandleOne,\n                    stHandleTwo,\n                    stHandleThree,\n                    stHandleFour,\n                ]);\n            });\n            const newRtpoints = [];\n            const newStpoints = [];\n            const viewportColor = this._getReferenceLineColor(viewport.id);\n            const color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n            referenceLines.forEach((line, lineIndex) => {\n                const otherViewport = line[0];\n                const viewportColor = this._getReferenceLineColor(otherViewport.id);\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id) ||\n                    this.configuration.mobile?.enabled;\n                const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id) ||\n                    this.configuration.mobile?.enabled;\n                const selectedViewportId = data.activeViewportIds.find((id) => id === otherViewport.id);\n                let color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n                let lineWidth = 1;\n                const lineActive = data.handles.activeOperation !== null &&\n                    data.handles.activeOperation === OPERATION.DRAG &&\n                    selectedViewportId;\n                if (lineActive) {\n                    lineWidth = 2.5;\n                }\n                let lineUID = `${lineIndex}`;\n                if (viewportControllable && viewportDraggableRotatable) {\n                    lineUID = `${lineIndex}One`;\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[1], line[2], {\n                        color,\n                        lineWidth,\n                    });\n                    lineUID = `${lineIndex}Two`;\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[3], line[4], {\n                        color,\n                        lineWidth,\n                    });\n                }\n                else {\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[2], line[4], {\n                        color,\n                        lineWidth,\n                    });\n                }\n                if (viewportControllable) {\n                    color =\n                        viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n                    const rotHandlesActive = data.handles.activeOperation === OPERATION.ROTATE;\n                    const rotationHandles = [line[9], line[10]];\n                    const rotHandleWorldOne = [\n                        viewport.canvasToWorld(line[9]),\n                        otherViewport,\n                        line[1],\n                        line[2],\n                    ];\n                    const rotHandleWorldTwo = [\n                        viewport.canvasToWorld(line[10]),\n                        otherViewport,\n                        line[3],\n                        line[4],\n                    ];\n                    newRtpoints.push(rotHandleWorldOne, rotHandleWorldTwo);\n                    const slabThicknessHandlesActive = data.handles.activeOperation === OPERATION.SLAB;\n                    const slabThicknessHandles = [line[11], line[12], line[13], line[14]];\n                    const slabThicknessHandleWorldOne = [\n                        viewport.canvasToWorld(line[11]),\n                        otherViewport,\n                        line[5],\n                        line[6],\n                    ];\n                    const slabThicknessHandleWorldTwo = [\n                        viewport.canvasToWorld(line[12]),\n                        otherViewport,\n                        line[5],\n                        line[6],\n                    ];\n                    const slabThicknessHandleWorldThree = [\n                        viewport.canvasToWorld(line[13]),\n                        otherViewport,\n                        line[7],\n                        line[8],\n                    ];\n                    const slabThicknessHandleWorldFour = [\n                        viewport.canvasToWorld(line[14]),\n                        otherViewport,\n                        line[7],\n                        line[8],\n                    ];\n                    newStpoints.push(slabThicknessHandleWorldOne, slabThicknessHandleWorldTwo, slabThicknessHandleWorldThree, slabThicknessHandleWorldFour);\n                    let handleRadius = this.configuration.handleRadius *\n                        (this.configuration.enableHDPIHandles ? window.devicePixelRatio : 1);\n                    let opacity = 1;\n                    if (this.configuration.mobile?.enabled) {\n                        handleRadius = this.configuration.mobile.handleRadius;\n                        opacity = this.configuration.mobile.opacity;\n                    }\n                    if ((lineActive || this.configuration.mobile?.enabled) &&\n                        !rotHandlesActive &&\n                        !slabThicknessHandlesActive &&\n                        viewportDraggableRotatable &&\n                        viewportSlabThicknessControlsOn) {\n                        let handleUID = `${lineIndex}One`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {\n                            color,\n                            handleRadius,\n                            opacity,\n                            type: 'circle',\n                        });\n                        handleUID = `${lineIndex}Two`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {\n                            color,\n                            handleRadius,\n                            opacity,\n                            type: 'rect',\n                        });\n                    }\n                    else if (lineActive &&\n                        !rotHandlesActive &&\n                        !slabThicknessHandlesActive &&\n                        viewportDraggableRotatable) {\n                        const handleUID = `${lineIndex}`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {\n                            color,\n                            handleRadius,\n                            opacity,\n                            type: 'circle',\n                        });\n                    }\n                    else if (selectedViewportId &&\n                        !rotHandlesActive &&\n                        !slabThicknessHandlesActive &&\n                        viewportSlabThicknessControlsOn) {\n                        const handleUID = `${lineIndex}`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {\n                            color,\n                            handleRadius,\n                            opacity,\n                            type: 'rect',\n                        });\n                    }\n                    else if (rotHandlesActive && viewportDraggableRotatable) {\n                        const handleUID = `${lineIndex}`;\n                        const handleRadius = this.configuration.handleRadius *\n                            (this.configuration.enableHDPIHandles\n                                ? window.devicePixelRatio\n                                : 1);\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {\n                            color,\n                            handleRadius,\n                            fill: color,\n                            type: 'circle',\n                        });\n                    }\n                    else if (slabThicknessHandlesActive &&\n                        selectedViewportId &&\n                        viewportSlabThicknessControlsOn) {\n                        const handleRadius = this.configuration.handleRadius *\n                            (this.configuration.enableHDPIHandles\n                                ? window.devicePixelRatio\n                                : 1);\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, lineUID, slabThicknessHandles, {\n                            color,\n                            handleRadius,\n                            fill: color,\n                            type: 'rect',\n                        });\n                    }\n                    const slabThicknessValue = otherViewport.getSlabThickness();\n                    if (slabThicknessValue > 0.5 && viewportSlabThicknessControlsOn) {\n                        lineUID = `${lineIndex}STOne`;\n                        drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[5], line[6], {\n                            color,\n                            width: 1,\n                            lineDash: [2, 3],\n                        });\n                        lineUID = `${lineIndex}STTwo`;\n                        drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[7], line[8], {\n                            color,\n                            width: line,\n                            lineDash: [2, 3],\n                        });\n                    }\n                }\n            });\n            renderStatus = true;\n            data.handles.rotationPoints = newRtpoints;\n            data.handles.slabThicknessPoints = newStpoints;\n            if (this.configuration.viewportIndicators) {\n                const { viewportIndicatorsConfig } = this.configuration;\n                const xOffset = viewportIndicatorsConfig?.xOffset || 0.95;\n                const yOffset = viewportIndicatorsConfig?.yOffset || 0.05;\n                const referenceColorCoordinates = [\n                    clientWidth * xOffset,\n                    clientHeight * yOffset,\n                ];\n                const circleRadius = viewportIndicatorsConfig?.circleRadius || canvasDiagonalLength * 0.01;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, referenceColorCoordinates, circleRadius, { color, fill: color });\n            }\n            return renderStatus;\n        };\n        this._getAnnotations = (enabledElement) => {\n            const { viewport } = enabledElement;\n            const annotations = getAnnotations(this.getToolName(), viewport.element) || [];\n            const viewportIds = this._getViewportsInfo().map(({ viewportId }) => viewportId);\n            const toolGroupAnnotations = annotations.filter((annotation) => {\n                const { data } = annotation;\n                return viewportIds.includes(data.viewportId);\n            });\n            return toolGroupAnnotations;\n        };\n        this._onNewVolume = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            this._computeToolCenter(viewportsInfo);\n        };\n        this._areViewportIdArraysEqual = (viewportIdArrayOne, viewportIdArrayTwo) => {\n            if (viewportIdArrayOne.length !== viewportIdArrayTwo.length) {\n                return false;\n            }\n            viewportIdArrayOne.forEach((id) => {\n                let itemFound = false;\n                for (let i = 0; i < viewportIdArrayTwo.length; ++i) {\n                    if (id === viewportIdArrayTwo[i]) {\n                        itemFound = true;\n                        break;\n                    }\n                }\n                if (itemFound === false) {\n                    return false;\n                }\n            });\n            return true;\n        };\n        this._getAnnotationsForViewportsWithDifferentCameras = (enabledElement, annotations) => {\n            const { viewportId, renderingEngine, viewport } = enabledElement;\n            const otherViewportAnnotations = annotations.filter((annotation) => annotation.data.viewportId !== viewportId);\n            if (!otherViewportAnnotations || !otherViewportAnnotations.length) {\n                return [];\n            }\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, position } = camera;\n            const viewportsWithDifferentCameras = otherViewportAnnotations.filter((annotation) => {\n                const { viewportId } = annotation.data;\n                const targetViewport = renderingEngine.getViewport(viewportId);\n                const cameraOfTarget = targetViewport.getCamera();\n                return !(csUtils.isEqual(cameraOfTarget.viewPlaneNormal, viewPlaneNormal, 1e-2) && csUtils.isEqual(cameraOfTarget.position, position, 1));\n            });\n            return viewportsWithDifferentCameras;\n        };\n        this._filterViewportWithSameOrientation = (enabledElement, referenceAnnotation, annotations) => {\n            const { renderingEngine } = enabledElement;\n            const { data } = referenceAnnotation;\n            const viewport = renderingEngine.getViewport(data.viewportId);\n            const linkedViewportAnnotations = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return otherViewportControllable === true;\n            });\n            if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {\n                return [];\n            }\n            const camera = viewport.getCamera();\n            const viewPlaneNormal = camera.viewPlaneNormal;\n            vtkMath.normalize(viewPlaneNormal);\n            const otherViewportsAnnotationsWithSameCameraDirection = linkedViewportAnnotations.filter((annotation) => {\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                return (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) &&\n                    csUtils.isEqual(camera.viewUp, otherCamera.viewUp, 1e-2));\n            });\n            return otherViewportsAnnotationsWithSameCameraDirection;\n        };\n        this._filterAnnotationsByUniqueViewportOrientations = (enabledElement, annotations) => {\n            const { renderingEngine, viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const viewPlaneNormal = camera.viewPlaneNormal;\n            vtkMath.normalize(viewPlaneNormal);\n            const otherLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return (viewport !== otherViewport &&\n                    otherViewportControllable === true);\n            });\n            const otherViewportsAnnotationsWithUniqueCameras = [];\n            for (let i = 0; i < otherLinkedViewportAnnotationsFromSameScene.length; ++i) {\n                const annotation = otherLinkedViewportAnnotationsFromSameScene[i];\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                if (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n                    csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {\n                    continue;\n                }\n                let cameraFound = false;\n                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {\n                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n                    const { viewportId } = annotation.data;\n                    const stockedViewport = renderingEngine.getViewport(viewportId);\n                    const cameraOfStocked = stockedViewport.getCamera();\n                    if (csUtils.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&\n                        csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {\n                        cameraFound = true;\n                    }\n                }\n                if (!cameraFound) {\n                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n                }\n            }\n            const otherNonLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return (viewport !== otherViewport &&\n                    otherViewportControllable !== true);\n            });\n            for (let i = 0; i < otherNonLinkedViewportAnnotationsFromSameScene.length; ++i) {\n                const annotation = otherNonLinkedViewportAnnotationsFromSameScene[i];\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                if (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n                    csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {\n                    continue;\n                }\n                let cameraFound = false;\n                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {\n                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n                    const { viewportId } = annotation.data;\n                    const stockedViewport = renderingEngine.getViewport(viewportId);\n                    const cameraOfStocked = stockedViewport.getCamera();\n                    if (csUtils.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&\n                        csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {\n                        cameraFound = true;\n                    }\n                }\n                if (!cameraFound) {\n                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n                }\n            }\n            const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n            for (let i = 0; i < otherViewportAnnotations.length; ++i) {\n                const annotation = otherViewportAnnotations[i];\n                if (otherViewportsAnnotationsWithUniqueCameras.some((element) => element === annotation)) {\n                    continue;\n                }\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                if (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n                    csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {\n                    continue;\n                }\n                let cameraFound = false;\n                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {\n                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n                    const { viewportId } = annotation.data;\n                    const stockedViewport = renderingEngine.getViewport(viewportId);\n                    const cameraOfStocked = stockedViewport.getCamera();\n                    if (csUtils.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&\n                        csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {\n                        cameraFound = true;\n                    }\n                }\n                if (!cameraFound) {\n                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n                }\n            }\n            return otherViewportsAnnotationsWithUniqueCameras;\n        };\n        this._checkIfViewportsRenderingSameScene = (viewport, otherViewport) => {\n            const volumeIds = viewport.getAllVolumeIds();\n            const otherVolumeIds = otherViewport.getAllVolumeIds();\n            return (volumeIds.length === otherVolumeIds.length &&\n                volumeIds.every((id) => otherVolumeIds.includes(id)));\n        };\n        this._jump = (enabledElement, jumpWorld) => {\n            state.isInteractingWithTool = true;\n            const { viewport, renderingEngine } = enabledElement;\n            const annotations = this._getAnnotations(enabledElement);\n            const delta = [0, 0, 0];\n            vtkMath.subtract(jumpWorld, this.toolCenter, delta);\n            const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n            const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const sameScene = this._checkIfViewportsRenderingSameScene(viewport, otherViewport);\n                return (this._getReferenceLineControllable(otherViewport.id) &&\n                    this._getReferenceLineDraggableRotatable(otherViewport.id) &&\n                    sameScene);\n            });\n            if (viewportsAnnotationsToUpdate.length === 0) {\n                state.isInteractingWithTool = false;\n                return false;\n            }\n            this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);\n            state.isInteractingWithTool = false;\n            return true;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = !this.configuration.mobile?.enabled;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            this.editData.annotation.data.handles.activeOperation = null;\n            this.editData.annotation.data.activeViewportIds = [];\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            this.editData = null;\n            const requireSameOrientation = false;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), requireSameOrientation);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const delta = eventDetail.deltaPoints.world;\n            if (Math.abs(delta[0]) < 1e-3 &&\n                Math.abs(delta[1]) < 1e-3 &&\n                Math.abs(delta[2]) < 1e-3) {\n                return;\n            }\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!viewportAnnotation) {\n                return;\n            }\n            const { handles } = viewportAnnotation.data;\n            const { currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            if (handles.activeOperation === OPERATION.DRAG) {\n                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n                const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                    const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                    return (otherViewportControllable === true &&\n                        otherViewportDraggableRotatable === true &&\n                        viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id));\n                });\n                this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);\n            }\n            else if (handles.activeOperation === OPERATION.ROTATE) {\n                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n                const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                    const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                    return (otherViewportControllable === true &&\n                        otherViewportDraggableRotatable === true);\n                });\n                const dir1 = vec2.create();\n                const dir2 = vec2.create();\n                const center = [\n                    this.toolCenter[0],\n                    this.toolCenter[1],\n                    this.toolCenter[2],\n                ];\n                const centerCanvas = viewport.worldToCanvas(center);\n                const finalPointCanvas = eventDetail.currentPoints.canvas;\n                const originalPointCanvas = vec2.create();\n                vec2.sub(originalPointCanvas, finalPointCanvas, eventDetail.deltaPoints.canvas);\n                vec2.sub(dir1, originalPointCanvas, centerCanvas);\n                vec2.sub(dir2, finalPointCanvas, centerCanvas);\n                let angle = vec2.angle(dir1, dir2);\n                if (this._isClockWise(centerCanvas, originalPointCanvas, finalPointCanvas)) {\n                    angle *= -1;\n                }\n                angle = Math.round(angle * 100) / 100;\n                const rotationAxis = viewport.getCamera().viewPlaneNormal;\n                const { matrix } = vtkMatrixBuilder\n                    .buildFromRadian()\n                    .translate(center[0], center[1], center[2])\n                    .rotate(angle, rotationAxis)\n                    .translate(-center[0], -center[1], -center[2]);\n                const otherViewportsIds = [];\n                viewportsAnnotationsToUpdate.forEach((annotation) => {\n                    const { data } = annotation;\n                    data.handles.toolCenter = center;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const camera = otherViewport.getCamera();\n                    const { viewUp, position, focalPoint } = camera;\n                    viewUp[0] += position[0];\n                    viewUp[1] += position[1];\n                    viewUp[2] += position[2];\n                    vec3.transformMat4(focalPoint, focalPoint, matrix);\n                    vec3.transformMat4(position, position, matrix);\n                    vec3.transformMat4(viewUp, viewUp, matrix);\n                    viewUp[0] -= position[0];\n                    viewUp[1] -= position[1];\n                    viewUp[2] -= position[2];\n                    otherViewport.setCamera({\n                        position,\n                        viewUp,\n                        focalPoint,\n                    });\n                    otherViewportsIds.push(otherViewport.id);\n                });\n                renderingEngine.renderViewports(otherViewportsIds);\n            }\n            else if (handles.activeOperation === OPERATION.SLAB) {\n                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n                const referenceAnnotations = otherViewportAnnotations.filter((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                    const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n                    return (otherViewportControllable === true &&\n                        otherViewportSlabThicknessControlsOn === true &&\n                        viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id));\n                });\n                if (referenceAnnotations.length === 0) {\n                    return;\n                }\n                const viewportsAnnotationsToUpdate = this._filterViewportWithSameOrientation(enabledElement, referenceAnnotations[0], annotations);\n                const viewportsIds = [];\n                viewportsIds.push(viewport.id);\n                viewportsAnnotationsToUpdate.forEach((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const camera = otherViewport.getCamera();\n                    const normal = camera.viewPlaneNormal;\n                    const dotProd = vtkMath.dot(delta, normal);\n                    const projectedDelta = [...normal];\n                    vtkMath.multiplyScalar(projectedDelta, dotProd);\n                    if (Math.abs(projectedDelta[0]) > 1e-3 ||\n                        Math.abs(projectedDelta[1]) > 1e-3 ||\n                        Math.abs(projectedDelta[2]) > 1e-3) {\n                        const mod = Math.sqrt(projectedDelta[0] * projectedDelta[0] +\n                            projectedDelta[1] * projectedDelta[1] +\n                            projectedDelta[2] * projectedDelta[2]);\n                        const currentPoint = eventDetail.lastPoints.world;\n                        const direction = [0, 0, 0];\n                        const currentCenter = [\n                            this.toolCenter[0],\n                            this.toolCenter[1],\n                            this.toolCenter[2],\n                        ];\n                        const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                        if (!viewportDraggableRotatable) {\n                            const { rotationPoints } = (this.editData.annotation.data).handles;\n                            const otherViewportRotationPoints = rotationPoints.filter((point) => point[1].uid === otherViewport.id);\n                            if (otherViewportRotationPoints.length === 2) {\n                                const point1 = viewport.canvasToWorld(otherViewportRotationPoints[0][3]);\n                                const point2 = viewport.canvasToWorld(otherViewportRotationPoints[1][3]);\n                                vtkMath.add(point1, point2, currentCenter);\n                                vtkMath.multiplyScalar(currentCenter, 0.5);\n                            }\n                        }\n                        vtkMath.subtract(currentPoint, currentCenter, direction);\n                        const dotProdDirection = vtkMath.dot(direction, normal);\n                        const projectedDirection = [...normal];\n                        vtkMath.multiplyScalar(projectedDirection, dotProdDirection);\n                        const normalizedProjectedDirection = [\n                            projectedDirection[0],\n                            projectedDirection[1],\n                            projectedDirection[2],\n                        ];\n                        vec3.normalize(normalizedProjectedDirection, normalizedProjectedDirection);\n                        const normalizedProjectedDelta = [\n                            projectedDelta[0],\n                            projectedDelta[1],\n                            projectedDelta[2],\n                        ];\n                        vec3.normalize(normalizedProjectedDelta, normalizedProjectedDelta);\n                        let slabThicknessValue = otherViewport.getSlabThickness();\n                        if (csUtils.isOpposite(normalizedProjectedDirection, normalizedProjectedDelta, 1e-3)) {\n                            slabThicknessValue -= mod;\n                        }\n                        else {\n                            slabThicknessValue += mod;\n                        }\n                        slabThicknessValue = Math.abs(slabThicknessValue);\n                        slabThicknessValue = Math.max(RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS, slabThicknessValue);\n                        const near = this._pointNearReferenceLine(viewportAnnotation, canvasCoords, 6, otherViewport);\n                        if (near) {\n                            slabThicknessValue = RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;\n                        }\n                        const toolGroup = getToolGroupForViewport(otherViewport.id, renderingEngine.id);\n                        const crosshairsInstance = toolGroup.getToolInstance(this.getToolName());\n                        crosshairsInstance.setSlabThickness(otherViewport, slabThicknessValue);\n                        viewportsIds.push(otherViewport.id);\n                    }\n                });\n                renderingEngine.renderViewports(viewportsIds);\n            }\n        };\n        this._pointNearReferenceLine = (annotation, canvasCoords, proximity, lineViewport) => {\n            const { data } = annotation;\n            const { rotationPoints } = data.handles;\n            for (let i = 0; i < rotationPoints.length - 1; ++i) {\n                const otherViewport = rotationPoints[i][1];\n                if (otherViewport.id !== lineViewport.id) {\n                    continue;\n                }\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                if (!viewportControllable) {\n                    continue;\n                }\n                const lineSegment1 = {\n                    start: {\n                        x: rotationPoints[i][2][0],\n                        y: rotationPoints[i][2][1],\n                    },\n                    end: {\n                        x: rotationPoints[i][3][0],\n                        y: rotationPoints[i][3][1],\n                    },\n                };\n                const distanceToPoint1 = lineSegment.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);\n                const lineSegment2 = {\n                    start: {\n                        x: rotationPoints[i + 1][2][0],\n                        y: rotationPoints[i + 1][2][1],\n                    },\n                    end: {\n                        x: rotationPoints[i + 1][3][0],\n                        y: rotationPoints[i + 1][3][1],\n                    },\n                };\n                const distanceToPoint2 = lineSegment.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);\n                if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n                    return true;\n                }\n                i++;\n            }\n            return false;\n        };\n        this._getReferenceLineColor =\n            toolProps.configuration?.getReferenceLineColor ||\n                defaultReferenceLineColor;\n        this._getReferenceLineControllable =\n            toolProps.configuration?.getReferenceLineControllable ||\n                defaultReferenceLineControllable;\n        this._getReferenceLineDraggableRotatable =\n            toolProps.configuration?.getReferenceLineDraggableRotatable ||\n                defaultReferenceLineDraggableRotatable;\n        this._getReferenceLineSlabThicknessControlsOn =\n            toolProps.configuration?.getReferenceLineSlabThicknessControlsOn ||\n                defaultReferenceLineSlabThicknessControlsOn;\n    }\n    onSetToolActive() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n        this._subscribeToViewportNewVolumeSet(viewportsInfo);\n        this._computeToolCenter(viewportsInfo);\n    }\n    onSetToolPassive() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._computeToolCenter(viewportsInfo);\n    }\n    onSetToolEnabled() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._computeToolCenter(viewportsInfo);\n    }\n    onSetToolDisabled() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n        viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (!enabledElement) {\n                return;\n            }\n            const annotations = this._getAnnotations(enabledElement);\n            if (annotations?.length) {\n                annotations.forEach((annotation) => {\n                    removeAnnotation(annotation.annotationUID);\n                });\n            }\n        });\n    }\n    setToolCenter(toolCenter, suppressEvents = false) {\n        this.toolCenter = toolCenter;\n        const viewportsInfo = this._getViewportsInfo();\n        triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n        if (!suppressEvents) {\n            triggerEvent(eventTarget, Events.CROSSHAIR_TOOL_CENTER_CHANGED, {\n                toolGroupId: this.toolGroupId,\n                toolCenter: this.toolCenter,\n            });\n        }\n    }\n    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        let point = this._getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);\n        if (point !== null) {\n            return point;\n        }\n        point = this._getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);\n        if (point !== null) {\n            return point;\n        }\n    }\n    _unsubscribeToViewportNewVolumeSet(viewportsInfo) {\n        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.removeEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n    _subscribeToViewportNewVolumeSet(viewports) {\n        viewports.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.addEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n    _autoPanViewportIfNecessary(viewportId, renderingEngine) {\n        const viewport = renderingEngine.getViewport(viewportId);\n        const { clientWidth, clientHeight } = viewport.canvas;\n        const toolCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n        const pan = this.configuration.autoPan.panSize;\n        const visiblePointCanvas = [\n            toolCenterCanvas[0],\n            toolCenterCanvas[1],\n        ];\n        if (toolCenterCanvas[0] < 0) {\n            visiblePointCanvas[0] = pan;\n        }\n        else if (toolCenterCanvas[0] > clientWidth) {\n            visiblePointCanvas[0] = clientWidth - pan;\n        }\n        if (toolCenterCanvas[1] < 0) {\n            visiblePointCanvas[1] = pan;\n        }\n        else if (toolCenterCanvas[1] > clientHeight) {\n            visiblePointCanvas[1] = clientHeight - pan;\n        }\n        if (visiblePointCanvas[0] === toolCenterCanvas[0] &&\n            visiblePointCanvas[1] === toolCenterCanvas[1]) {\n            return;\n        }\n        const visiblePointWorld = viewport.canvasToWorld(visiblePointCanvas);\n        const deltaPointsWorld = [\n            visiblePointWorld[0] - this.toolCenter[0],\n            visiblePointWorld[1] - this.toolCenter[1],\n            visiblePointWorld[2] - this.toolCenter[2],\n        ];\n        const camera = viewport.getCamera();\n        const { focalPoint, position } = camera;\n        const updatedPosition = [\n            position[0] - deltaPointsWorld[0],\n            position[1] - deltaPointsWorld[1],\n            position[2] - deltaPointsWorld[2],\n        ];\n        const updatedFocalPoint = [\n            focalPoint[0] - deltaPointsWorld[0],\n            focalPoint[1] - deltaPointsWorld[1],\n            focalPoint[2] - deltaPointsWorld[2],\n        ];\n        viewport.setCamera({\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n        viewport.render();\n    }\n    setSlabThickness(viewport, slabThickness) {\n        let actorUIDs;\n        const { filterActorUIDsToSetSlabThickness } = this.configuration;\n        if (filterActorUIDsToSetSlabThickness &&\n            filterActorUIDsToSetSlabThickness.length > 0) {\n            actorUIDs = filterActorUIDsToSetSlabThickness;\n        }\n        let blendModeToUse = this.configuration.slabThicknessBlendMode;\n        if (slabThickness === RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS) {\n            blendModeToUse = Enums.BlendModes.COMPOSITE;\n        }\n        const immediate = false;\n        viewport.setBlendMode(blendModeToUse, actorUIDs, immediate);\n        viewport.setSlabThickness(slabThickness, actorUIDs);\n    }\n    _isClockWise(a, b, c) {\n        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0;\n    }\n    _applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta) {\n        viewportsAnnotationsToUpdate.forEach((annotation) => {\n            this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);\n        });\n    }\n    _applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta) {\n        const { data } = annotation;\n        const viewport = renderingEngine.getViewport(data.viewportId);\n        const camera = viewport.getCamera();\n        const normal = camera.viewPlaneNormal;\n        const dotProd = vtkMath.dot(delta, normal);\n        const projectedDelta = [...normal];\n        vtkMath.multiplyScalar(projectedDelta, dotProd);\n        if (Math.abs(projectedDelta[0]) > 1e-3 ||\n            Math.abs(projectedDelta[1]) > 1e-3 ||\n            Math.abs(projectedDelta[2]) > 1e-3) {\n            const newFocalPoint = [0, 0, 0];\n            const newPosition = [0, 0, 0];\n            vtkMath.add(camera.focalPoint, projectedDelta, newFocalPoint);\n            vtkMath.add(camera.position, projectedDelta, newPosition);\n            viewport.setCamera({\n                focalPoint: newFocalPoint,\n                position: newPosition,\n            });\n            viewport.render();\n        }\n    }\n    _getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {\n        const { data } = annotation;\n        const { rotationPoints } = data.handles;\n        for (let i = 0; i < rotationPoints.length; i++) {\n            const point = rotationPoints[i][0];\n            const otherViewport = rotationPoints[i][1];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            if (!viewportControllable) {\n                continue;\n            }\n            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n            if (!viewportDraggableRotatable) {\n                continue;\n            }\n            const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n            if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n                data.handles.activeOperation = OPERATION.ROTATE;\n                this.editData = {\n                    annotation,\n                };\n                return point;\n            }\n        }\n        return null;\n    }\n    _getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {\n        const { data } = annotation;\n        const { slabThicknessPoints } = data.handles;\n        for (let i = 0; i < slabThicknessPoints.length; i++) {\n            const point = slabThicknessPoints[i][0];\n            const otherViewport = slabThicknessPoints[i][1];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            if (!viewportControllable) {\n                continue;\n            }\n            const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n            if (!viewportSlabThicknessControlsOn) {\n                continue;\n            }\n            const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n            if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n                data.handles.activeOperation = OPERATION.SLAB;\n                data.activeViewportIds = [otherViewport.id];\n                this.editData = {\n                    annotation,\n                };\n                return point;\n            }\n        }\n        return null;\n    }\n    _pointNearTool(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { clientWidth, clientHeight } = viewport.canvas;\n        const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n        const { data } = annotation;\n        const { rotationPoints } = data.handles;\n        const { slabThicknessPoints } = data.handles;\n        const viewportIdArray = [];\n        for (let i = 0; i < rotationPoints.length - 1; ++i) {\n            const otherViewport = rotationPoints[i][1];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n            if (!viewportControllable || !viewportDraggableRotatable) {\n                continue;\n            }\n            const lineSegment1 = {\n                start: {\n                    x: rotationPoints[i][2][0],\n                    y: rotationPoints[i][2][1],\n                },\n                end: {\n                    x: rotationPoints[i][3][0],\n                    y: rotationPoints[i][3][1],\n                },\n            };\n            const distanceToPoint1 = lineSegment.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const lineSegment2 = {\n                start: {\n                    x: rotationPoints[i + 1][2][0],\n                    y: rotationPoints[i + 1][2][1],\n                },\n                end: {\n                    x: rotationPoints[i + 1][3][0],\n                    y: rotationPoints[i + 1][3][1],\n                },\n            };\n            const distanceToPoint2 = lineSegment.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n                viewportIdArray.push(otherViewport.id);\n                data.handles.activeOperation = OPERATION.DRAG;\n            }\n            i++;\n        }\n        for (let i = 0; i < slabThicknessPoints.length - 1; ++i) {\n            const otherViewport = slabThicknessPoints[i][1];\n            if (viewportIdArray.find((id) => id === otherViewport.id)) {\n                continue;\n            }\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n            if (!viewportControllable || !viewportSlabThicknessControlsOn) {\n                continue;\n            }\n            const stPointLineCanvas1 = slabThicknessPoints[i][2];\n            const stPointLineCanvas2 = slabThicknessPoints[i][3];\n            const centerCanvas = vec2.create();\n            vec2.add(centerCanvas, stPointLineCanvas1, stPointLineCanvas2);\n            vec2.scale(centerCanvas, centerCanvas, 0.5);\n            const canvasUnitVectorFromCenter = vec2.create();\n            vec2.subtract(canvasUnitVectorFromCenter, stPointLineCanvas1, centerCanvas);\n            vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n            const canvasVectorFromCenterStart = vec2.create();\n            vec2.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, canvasDiagonalLength * 0.05);\n            const stPointLineCanvas1Start = vec2.create();\n            const stPointLineCanvas2Start = vec2.create();\n            vec2.add(stPointLineCanvas1Start, centerCanvas, canvasVectorFromCenterStart);\n            vec2.subtract(stPointLineCanvas2Start, centerCanvas, canvasVectorFromCenterStart);\n            const lineSegment1 = {\n                start: {\n                    x: stPointLineCanvas1Start[0],\n                    y: stPointLineCanvas1Start[1],\n                },\n                end: {\n                    x: stPointLineCanvas1[0],\n                    y: stPointLineCanvas1[1],\n                },\n            };\n            const distanceToPoint1 = lineSegment.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const lineSegment2 = {\n                start: {\n                    x: stPointLineCanvas2Start[0],\n                    y: stPointLineCanvas2Start[1],\n                },\n                end: {\n                    x: stPointLineCanvas2[0],\n                    y: stPointLineCanvas2[1],\n                },\n            };\n            const distanceToPoint2 = lineSegment.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n                viewportIdArray.push(otherViewport.id);\n                data.handles.activeOperation = null;\n            }\n            i++;\n        }\n        data.activeViewportIds = [...viewportIdArray];\n        this.editData = {\n            annotation,\n        };\n        return data.handles.activeOperation === OPERATION.DRAG ? true : false;\n    }\n}\nCrosshairsTool.toolName = 'Crosshairs';\nexport default CrosshairsTool;\n", "import { BaseTool } from './base';\nimport { Events } from '../enums';\nimport { getEnabledElement, StackViewport, Enums } from '@cornerstonejs/core';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { state } from '../store/state';\nimport { hideElementCursor, resetElementCursor, } from '../cursors/elementCursor';\nconst MAGNIFY_VIEWPORT_ID = 'magnify-viewport';\nclass MagnifyTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            magnifySize: 10,\n            magnifyWidth: 250,\n            magnifyHeight: 250,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._hasBeenRemoved = false;\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            if (!(viewport instanceof StackViewport)) {\n                throw new Error('MagnifyTool only works on StackViewports');\n            }\n            const referencedImageId = this._getReferencedImageId(viewport);\n            if (!referencedImageId) {\n                throw new Error('MagnifyTool: No referenced image id found, reconstructed planes not supported yet');\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                referencedImageId,\n                viewportIdsToRender,\n                enabledElement,\n                renderingEngine,\n                currentPoints,\n            };\n            this._createMagnificationViewport();\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this.preTouchStartCallback = (evt) => {\n            this.preMouseDownCallback(evt);\n        };\n        this._createMagnificationViewport = () => {\n            const { enabledElement, referencedImageId, viewportIdsToRender, renderingEngine, currentPoints, } = this.editData;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            const viewportProperties = viewport.getProperties();\n            const { rotation: originalViewportRotation } = viewport.getViewPresentation();\n            const { canvas: canvasPos, world: worldPos } = currentPoints;\n            let magnifyToolElement;\n            magnifyToolElement = element.querySelector('.magnifyTool');\n            if (magnifyToolElement === null) {\n                const magnifyElement = document.createElement('div');\n                magnifyElement.classList.add('magnifyTool');\n                magnifyElement.style.display = 'block';\n                magnifyElement.style.width = `${this.configuration.magnifyWidth}px`;\n                magnifyElement.style.height = `${this.configuration.magnifyHeight}px`;\n                magnifyElement.style.position = 'absolute';\n                magnifyToolElement = magnifyElement;\n                const viewportElement = element.querySelector('.viewport-element');\n                viewportElement.appendChild(magnifyElement);\n                const viewportInput = {\n                    viewportId: MAGNIFY_VIEWPORT_ID,\n                    type: Enums.ViewportType.STACK,\n                    element: magnifyToolElement,\n                };\n                renderingEngine.enableElement(viewportInput);\n            }\n            magnifyToolElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;\n            magnifyToolElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;\n            const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);\n            magnifyViewport.setStack([referencedImageId]).then(() => {\n                if (this._hasBeenRemoved) {\n                    return;\n                }\n                magnifyViewport.setProperties(viewportProperties);\n                magnifyViewport.setViewPresentation({\n                    rotation: originalViewportRotation,\n                });\n                const { parallelScale } = viewport.getCamera();\n                const { focalPoint, position, viewPlaneNormal } = magnifyViewport.getCamera();\n                const distance = Math.sqrt(Math.pow(focalPoint[0] - position[0], 2) +\n                    Math.pow(focalPoint[1] - position[1], 2) +\n                    Math.pow(focalPoint[2] - position[2], 2));\n                const updatedFocalPoint = [\n                    worldPos[0],\n                    worldPos[1],\n                    worldPos[2],\n                ];\n                const updatedPosition = [\n                    updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n                    updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n                    updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n                ];\n                magnifyViewport.setCamera({\n                    parallelScale: parallelScale * (1 / this.configuration.magnifySize),\n                    focalPoint: updatedFocalPoint,\n                    position: updatedPosition,\n                });\n                magnifyViewport.render();\n            });\n            magnifyToolElement.style.display = 'block';\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { deltaPoints, element, currentPoints } = eventDetail;\n            const deltaPointsWorld = deltaPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);\n            const magnifyElement = element.querySelector('.magnifyTool');\n            if (!magnifyElement) {\n                return;\n            }\n            magnifyElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;\n            magnifyElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;\n            const { focalPoint, position } = magnifyViewport.getCamera();\n            const updatedPosition = [\n                position[0] + deltaPointsWorld[0],\n                position[1] + deltaPointsWorld[1],\n                position[2] + deltaPointsWorld[2],\n            ];\n            const updatedFocalPoint = [\n                focalPoint[0] + deltaPointsWorld[0],\n                focalPoint[1] + deltaPointsWorld[1],\n                focalPoint[2] + deltaPointsWorld[2],\n            ];\n            magnifyViewport.setCamera({\n                focalPoint: updatedFocalPoint,\n                position: updatedPosition,\n            });\n            magnifyViewport.render();\n        };\n        this._dragEndCallback = (evt) => {\n            const { element } = evt.detail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            renderingEngine.disableElement(MAGNIFY_VIEWPORT_ID);\n            const viewportElement = element.querySelector('.viewport-element');\n            const magnifyToolElement = viewportElement.querySelector('.magnifyTool');\n            viewportElement.removeChild(magnifyToolElement);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this._hasBeenRemoved = true;\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            this._hasBeenRemoved = false;\n            element.addEventListener(Events.MOUSE_UP, this._dragEndCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._dragEndCallback);\n            element.addEventListener(Events.TOUCH_END, this._dragEndCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._dragEndCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._dragEndCallback);\n            element.removeEventListener(Events.TOUCH_END, this._dragEndCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n    }\n    _getReferencedImageId(viewport) {\n        const targetId = this.getTargetId(viewport);\n        let referencedImageId;\n        if (viewport instanceof StackViewport) {\n            referencedImageId = targetId.split('imageId:')[1];\n        }\n        return referencedImageId;\n    }\n}\nMagnifyTool.toolName = 'Magnify';\nexport default MagnifyTool;\n", "import { AnnotationTool } from './base';\nimport { getEnabledElement, utilities as csUtils, eventTarget, Enums, getRenderingEngine, CONSTANTS, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { addAnnotation, getAllAnnotations, getAnnotations, removeAnnotation, } from '../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted } from '../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, } from '../drawingSvg';\nimport { state } from '../store/state';\nimport { Events, MouseBindings, KeyboardBindings, Events as cstEvents, SegmentationRepresentations, ToolModes, } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { getCanvasCircleRadius } from '../utilities/math/circle';\nimport { vec2, vec3 } from 'gl-matrix';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nimport debounce from '../utilities/debounce';\nimport { distanceToPoint } from '../utilities/math/point';\nimport { addSegmentationRepresentations } from '../stateManagement/segmentation';\nconst MAGNIFY_CLASSNAME = 'advancedMagnifyTool';\nconst MAGNIFY_VIEWPORT_INITIAL_RADIUS = 125;\nconst { Events: csEvents } = Enums;\nconst isSegmentation = (actor) => actor.uid !== actor.referencedId;\nvar AdvancedMagnifyToolActions;\n(function (AdvancedMagnifyToolActions) {\n    AdvancedMagnifyToolActions[\"ShowZoomFactorsList\"] = \"showZoomFactorsList\";\n})(AdvancedMagnifyToolActions || (AdvancedMagnifyToolActions = {}));\nconst ADVANCED_MAGNIFY_TOOL_NAME = 'AdvancedMagnify';\nconst PARALLEL_THRESHOLD = 1 - CONSTANTS.EPSILON;\nclass AdvancedMagnifyTool extends AnnotationTool {\n    static { this.Actions = AdvancedMagnifyToolActions; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            magnifyingGlass: {\n                radius: 125,\n                zoomFactor: 3,\n                zoomFactorList: [1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5],\n                autoPan: {\n                    enabled: true,\n                    padding: 10,\n                },\n            },\n            actions: {\n                showZoomFactorsList: {\n                    method: 'showZoomFactorsList',\n                    bindings: [\n                        {\n                            mouseButton: MouseBindings.Secondary,\n                            modifierKey: KeyboardBindings.Shift,\n                        },\n                    ],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const { magnifyingGlass: config } = this.configuration;\n            const { radius, zoomFactor, autoPan } = config;\n            const canvasHandlePoints = this._getCanvasHandlePoints(canvasPos, radius);\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotationUID = csUtils.uuidv4();\n            const magnifyViewportId = csUtils.uuidv4();\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                annotationUID,\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    sourceViewportId: viewport.id,\n                    magnifyViewportId,\n                    zoomFactor,\n                    isCanvasAnnotation: true,\n                    handles: {\n                        points: canvasHandlePoints,\n                        activeHandleIndex: null,\n                    },\n                },\n            };\n            this.magnifyViewportManager.createViewport(annotation, {\n                magnifyViewportId,\n                sourceEnabledElement: enabledElement,\n                position: canvasPos,\n                radius,\n                zoomFactor,\n                autoPan: {\n                    enabled: autoPan.enabled,\n                    padding: autoPan.padding,\n                    callback: (data) => {\n                        const annotationPoints = annotation.data.handles.points;\n                        const { canvas: canvasDelta } = data.delta;\n                        for (let i = 0, len = annotationPoints.length; i < len; i++) {\n                            const point = annotationPoints[i];\n                            point[0] += canvasDelta[0];\n                            point[1] += canvasDelta[1];\n                            annotation.invalidated = true;\n                        }\n                    },\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.onSetToolDisabled = () => {\n            this.magnifyViewportManager.dispose();\n            const annotations = getAllAnnotations();\n            annotations.forEach((annotation) => {\n                if (annotation.metadata.toolName === this.getToolName()) {\n                    removeAnnotation(annotation.annotationUID);\n                }\n            });\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points;\n            const canvasTop = canvasCoordinates[0];\n            const canvasBottom = canvasCoordinates[2];\n            const canvasLeft = canvasCoordinates[3];\n            const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n            const center = [\n                canvasLeft[0] + radius,\n                canvasTop[1] + radius,\n            ];\n            const radiusPoint = getCanvasCircleRadius([center, canvasCoords]);\n            if (Math.abs(radiusPoint - radius) < proximity * 2) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            const { points } = data.handles;\n            const handleIndex = points.findIndex((p) => p === handle);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { deltaPoints } = eventDetail;\n            const canvasDelta = deltaPoints?.canvas ?? [0, 0, 0];\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { points } = annotation.data.handles;\n            points.forEach((point) => {\n                point[0] += canvasDelta[0];\n                point[1] += canvasDelta[1];\n            });\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n            const { data } = annotation;\n            if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const canvasDelta = deltaPoints.canvas;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += canvasDelta[0];\n                    point[1] += canvasDelta[1];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragHandle(evt);\n                annotation.invalidated = true;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { annotation } = this.editData;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points;\n            const canvasTop = canvasCoordinates[0];\n            const canvasBottom = canvasCoordinates[2];\n            const canvasLeft = canvasCoordinates[3];\n            const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n            const canvasCenter = [\n                canvasLeft[0] + radius,\n                canvasTop[1] + radius,\n            ];\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const newRadius = getCanvasCircleRadius([\n                canvasCenter,\n                currentCanvasPoints,\n            ]);\n            const newCanvasHandlePoints = this._getCanvasHandlePoints(canvasCenter, newRadius);\n            points[0] = newCanvasHandlePoints[0];\n            points[1] = newCanvasHandlePoints[1];\n            points[2] = newCanvasHandlePoints[2];\n            points[3] = newCanvasHandlePoints[3];\n        };\n        this.cancel = (element) => {\n            if (!this.isDrawing) {\n                return;\n            }\n            this.isDrawing = false;\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            return annotation.annotationUID;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = annotations?.filter((annotation) => annotation.data.sourceViewportId ===\n                viewport.id);\n            const filteredAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!filteredAnnotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < filteredAnnotations.length; i++) {\n                const annotation = filteredAnnotations[i];\n                const { annotationUID, data } = annotation;\n                const { magnifyViewportId, zoomFactor, handles } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points;\n                const canvasTop = canvasCoordinates[0];\n                const canvasBottom = canvasCoordinates[2];\n                const canvasLeft = canvasCoordinates[3];\n                const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n                const center = [\n                    canvasLeft[0] + radius,\n                    canvasTop[1] + radius,\n                ];\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-advancedMagnify`;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                    color,\n                    lineWidth: 5,\n                }, dataId);\n                const magnifyViewport = this.magnifyViewportManager.getViewport(magnifyViewportId);\n                magnifyViewport.position = center;\n                magnifyViewport.radius = radius;\n                magnifyViewport.zoomFactor = zoomFactor;\n                magnifyViewport.update();\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n        this._getCanvasHandlePoints = (canvasCenterPos, canvasRadius) => {\n            return [\n                [canvasCenterPos[0], canvasCenterPos[1] - canvasRadius, 0],\n                [canvasCenterPos[0] + canvasRadius, canvasCenterPos[1], 0],\n                [canvasCenterPos[0], canvasCenterPos[1] + canvasRadius, 0],\n                [canvasCenterPos[0] - canvasRadius, canvasCenterPos[1], 0],\n            ];\n        };\n        this.magnifyViewportManager = AdvancedMagnifyViewportManager.getInstance();\n    }\n    showZoomFactorsList(evt, annotation) {\n        const { element, currentPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { canvas: canvasPoint } = currentPoints;\n        const viewportElement = element.querySelector(':scope .viewport-element');\n        const currentZoomFactor = annotation.data.zoomFactor;\n        const remove = () => dropdown.parentElement.removeChild(dropdown);\n        const dropdown = this._getZoomFactorsListDropdown(currentZoomFactor, (newZoomFactor) => {\n            if (newZoomFactor !== undefined) {\n                annotation.data.zoomFactor = Number.parseFloat(newZoomFactor);\n                annotation.invalidated = true;\n            }\n            remove();\n            viewport.render();\n        });\n        Object.assign(dropdown.style, {\n            left: `${canvasPoint[0]}px`,\n            top: `${canvasPoint[1]}px`,\n        });\n        viewportElement.appendChild(dropdown);\n        dropdown.focus();\n    }\n    _getZoomFactorsListDropdown(currentZoomFactor, onChangeCallback) {\n        const { zoomFactorList } = this.configuration.magnifyingGlass;\n        const dropdown = document.createElement('select');\n        dropdown.size = 5;\n        Object.assign(dropdown.style, {\n            width: '50px',\n            position: 'absolute',\n        });\n        ['mousedown', 'mouseup', 'mousemove', 'click'].forEach((eventName) => {\n            dropdown.addEventListener(eventName, (evt) => evt.stopPropagation());\n        });\n        dropdown.addEventListener('change', (evt) => {\n            evt.stopPropagation();\n            onChangeCallback(dropdown.value);\n        });\n        dropdown.addEventListener('keydown', (evt) => {\n            const shouldCancel = (evt.keyCode ?? evt.which === 27) ||\n                evt.key?.toLowerCase() === 'escape';\n            if (shouldCancel) {\n                evt.stopPropagation();\n                onChangeCallback();\n            }\n        });\n        zoomFactorList.forEach((zoomFactor) => {\n            const option = document.createElement('option');\n            option.label = zoomFactor;\n            option.title = `Zoom factor ${zoomFactor.toFixed(1)}`;\n            option.value = zoomFactor;\n            option.defaultSelected = zoomFactor === currentZoomFactor;\n            dropdown.add(option);\n        });\n        return dropdown;\n    }\n}\nclass AdvancedMagnifyViewportManager {\n    constructor() {\n        this.createViewport = (annotation, viewportInfo) => {\n            const { magnifyViewportId, sourceEnabledElement, position, radius, zoomFactor, autoPan, } = viewportInfo;\n            const { viewport: sourceViewport } = sourceEnabledElement;\n            const { element: sourceElement } = sourceViewport;\n            const magnifyViewport = new AdvancedMagnifyViewport({\n                magnifyViewportId,\n                sourceEnabledElement,\n                radius,\n                position,\n                zoomFactor,\n                autoPan,\n            });\n            this._addSourceElementEventListener(sourceElement);\n            this._magnifyViewportsMap.set(magnifyViewport.viewportId, {\n                annotation,\n                magnifyViewport,\n                magnifyViewportInfo: viewportInfo,\n            });\n            return magnifyViewport;\n        };\n        this._annotationRemovedCallback = (evt) => {\n            const { annotation } = evt.detail;\n            if (annotation.metadata.toolName !== ADVANCED_MAGNIFY_TOOL_NAME) {\n                return;\n            }\n            this.destroyViewport(annotation.data.magnifyViewportId);\n        };\n        this._newStackImageCallback = (evt) => {\n            const { viewportId: sourceViewportId, imageId } = evt.detail;\n            const magnifyViewportsMapEntries = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n            const { viewport } = getEnabledElementByViewportId(sourceViewportId);\n            if (viewport.stackActorReInitialized) {\n                this._reset(sourceViewportId);\n            }\n            magnifyViewportsMapEntries.forEach(({ annotation }) => {\n                annotation.metadata.referencedImageId = imageId;\n                annotation.invalidated = true;\n            });\n        };\n        this._newVolumeImageCallback = (evt) => {\n            const { renderingEngineId, viewportId: sourceViewportId } = evt.detail;\n            const renderingEngine = getRenderingEngine(renderingEngineId);\n            const sourceViewport = renderingEngine.getViewport(sourceViewportId);\n            const { viewPlaneNormal: currentViewPlaneNormal } = sourceViewport.getCamera();\n            const magnifyViewportsMapEntries = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n            magnifyViewportsMapEntries.forEach(({ annotation }) => {\n                const { viewPlaneNormal } = annotation.metadata;\n                const isParallel = Math.abs(vec3.dot(viewPlaneNormal, currentViewPlaneNormal)) >\n                    PARALLEL_THRESHOLD;\n                if (!isParallel) {\n                    return;\n                }\n                const { handles } = annotation.data;\n                const worldImagePlanePoint = sourceViewport.canvasToWorld([0, 0]);\n                const vecHandleToImagePlane = vec3.sub(vec3.create(), worldImagePlanePoint, handles.points[0]);\n                const worldDist = vec3.dot(vecHandleToImagePlane, currentViewPlaneNormal);\n                const worldDelta = vec3.scale(vec3.create(), currentViewPlaneNormal, worldDist);\n                for (let i = 0, len = handles.points.length; i < len; i++) {\n                    const point = handles.points[i];\n                    point[0] += worldDelta[0];\n                    point[1] += worldDelta[1];\n                    point[2] += worldDelta[2];\n                }\n                annotation.invalidated = true;\n            });\n        };\n        this._magnifyViewportsMap = new Map();\n        this._initialize();\n    }\n    static getInstance() {\n        AdvancedMagnifyViewportManager._singleton =\n            AdvancedMagnifyViewportManager._singleton ??\n                new AdvancedMagnifyViewportManager();\n        return AdvancedMagnifyViewportManager._singleton;\n    }\n    getViewport(magnifyViewportId) {\n        return this._magnifyViewportsMap.get(magnifyViewportId)?.magnifyViewport;\n    }\n    dispose() {\n        this._removeEventListeners();\n        this._destroyViewports();\n    }\n    destroyViewport(magnifyViewportId) {\n        const magnifyViewportMapEntry = this._magnifyViewportsMap.get(magnifyViewportId);\n        if (magnifyViewportMapEntry) {\n            const { magnifyViewport } = magnifyViewportMapEntry;\n            const { viewport: sourceViewport } = magnifyViewport.sourceEnabledElement;\n            const { element: sourceElement } = sourceViewport;\n            this._removeSourceElementEventListener(sourceElement);\n            magnifyViewport.dispose();\n            this._magnifyViewportsMap.delete(magnifyViewportId);\n        }\n    }\n    _destroyViewports() {\n        const magnifyViewportIds = Array.from(this._magnifyViewportsMap.keys());\n        magnifyViewportIds.forEach((magnifyViewportId) => this.destroyViewport(magnifyViewportId));\n    }\n    _getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId) {\n        const magnifyViewportsMapEntries = Array.from(this._magnifyViewportsMap.values());\n        return magnifyViewportsMapEntries.filter(({ magnifyViewport }) => {\n            const { viewport } = magnifyViewport.sourceEnabledElement;\n            return viewport.id === sourceViewportId;\n        });\n    }\n    _reset(sourceViewportId) {\n        const magnifyViewports = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n        magnifyViewports.forEach(({ magnifyViewport, annotation, magnifyViewportInfo }) => {\n            this.destroyViewport(magnifyViewport.viewportId);\n            const newEnabledElement = getEnabledElementByViewportId(sourceViewportId);\n            this.createViewport(annotation, {\n                ...magnifyViewportInfo,\n                sourceEnabledElement: {\n                    ...newEnabledElement,\n                },\n            });\n        });\n    }\n    _addEventListeners() {\n        eventTarget.addEventListener(cstEvents.ANNOTATION_REMOVED, this._annotationRemovedCallback);\n    }\n    _removeEventListeners() {\n        eventTarget.removeEventListener(cstEvents.ANNOTATION_REMOVED, this._annotationRemovedCallback);\n    }\n    _addSourceElementEventListener(element) {\n        element.addEventListener(csEvents.STACK_NEW_IMAGE, this._newStackImageCallback);\n        const newStackHandler = (evt) => {\n            const { viewportId: sourceViewportId } = evt.detail;\n            this._reset(sourceViewportId);\n        };\n        element.addEventListener(csEvents.VIEWPORT_NEW_IMAGE_SET, newStackHandler);\n        const newVolumeHandler = (evt) => {\n            const { viewportId: sourceViewportId } = evt.detail;\n            this._reset(sourceViewportId);\n        };\n        element.addEventListener(csEvents.VOLUME_VIEWPORT_NEW_VOLUME, newVolumeHandler);\n        element.addEventListener(csEvents.VOLUME_NEW_IMAGE, this._newVolumeImageCallback);\n        element.newStackHandler = newStackHandler;\n        element.newVolumeHandler = newVolumeHandler;\n    }\n    _removeSourceElementEventListener(element) {\n        element.removeEventListener(csEvents.STACK_NEW_IMAGE, this._newStackImageCallback);\n        element.removeEventListener(csEvents.VOLUME_NEW_IMAGE, this._newVolumeImageCallback);\n        element.removeEventListener(csEvents.VIEWPORT_NEW_IMAGE_SET, element.newStackHandler);\n        element.removeEventListener(csEvents.VOLUME_VIEWPORT_NEW_VOLUME, element.newVolumeHandler);\n        delete element.newStackHandler;\n        delete element.newVolumeHandler;\n    }\n    _initialize() {\n        this._addEventListeners();\n    }\n}\nclass AdvancedMagnifyViewport {\n    constructor({ magnifyViewportId, sourceEnabledElement, radius = MAGNIFY_VIEWPORT_INITIAL_RADIUS, position = [0, 0], zoomFactor, autoPan, }) {\n        this._enabledElement = null;\n        this._sourceToolGroup = null;\n        this._magnifyToolGroup = null;\n        this._isViewportReady = false;\n        this._radius = 0;\n        this._resized = false;\n        this._canAutoPan = false;\n        this._viewportId = magnifyViewportId ?? csUtils.uuidv4();\n        this._sourceEnabledElement = sourceEnabledElement;\n        this._autoPan = autoPan;\n        this.radius = radius;\n        this.position = position;\n        this.zoomFactor = zoomFactor;\n        this.visible = true;\n        this._browserMouseDownCallback = this._browserMouseDownCallback.bind(this);\n        this._browserMouseUpCallback = this._browserMouseUpCallback.bind(this);\n        this._handleToolModeChanged = this._handleToolModeChanged.bind(this);\n        this._mouseDragCallback = this._mouseDragCallback.bind(this);\n        this._resizeViewportAsync = (debounce(this._resizeViewport.bind(this), 1));\n        this._initialize();\n    }\n    get sourceEnabledElement() {\n        return this._sourceEnabledElement;\n    }\n    get viewportId() {\n        return this._viewportId;\n    }\n    get radius() {\n        return this._radius;\n    }\n    set radius(radius) {\n        if (Math.abs(this._radius - radius) > 0.00001) {\n            this._radius = radius;\n            this._resized = true;\n        }\n    }\n    update() {\n        const { radius, position, visible } = this;\n        const { viewport } = this._enabledElement;\n        const { element } = viewport;\n        const size = 2 * radius;\n        const [x, y] = position;\n        if (this._resized) {\n            this._resizeViewportAsync();\n            this._resized = false;\n        }\n        Object.assign(element.style, {\n            display: visible ? 'block' : 'hidden',\n            width: `${size}px`,\n            height: `${size}px`,\n            left: `${-radius}px`,\n            top: `${-radius}px`,\n            transform: `translate(${x}px, ${y}px)`,\n        });\n        if (this._isViewportReady) {\n            this._syncViewports();\n            viewport.render();\n        }\n    }\n    dispose() {\n        const { viewport } = this._enabledElement;\n        const { element } = viewport;\n        const renderingEngine = viewport.getRenderingEngine();\n        this._removeEventListeners(element);\n        renderingEngine.disableElement(viewport.id);\n        if (element.parentNode) {\n            element.parentNode.removeChild(element);\n        }\n    }\n    _handleToolModeChanged(evt) {\n        const { _magnifyToolGroup: magnifyToolGroup } = this;\n        const { toolGroupId, toolName, mode, toolBindingsOptions } = evt.detail;\n        if (this._sourceToolGroup?.id !== toolGroupId) {\n            return;\n        }\n        switch (mode) {\n            case ToolModes.Active:\n                magnifyToolGroup.setToolActive(toolName, toolBindingsOptions);\n                break;\n            case ToolModes.Passive:\n                magnifyToolGroup.setToolPassive(toolName);\n                break;\n            case ToolModes.Enabled:\n                magnifyToolGroup.setToolEnabled(toolName);\n                break;\n            case ToolModes.Disabled:\n                magnifyToolGroup.setToolDisabled(toolName);\n                break;\n            default:\n                throw new Error(`Unknow tool mode (${mode})`);\n        }\n    }\n    _inheritBorderRadius(magnifyElement) {\n        const viewport = magnifyElement.querySelector('.viewport-element');\n        const canvas = magnifyElement.querySelector('.cornerstone-canvas');\n        viewport.style.borderRadius = 'inherit';\n        canvas.style.borderRadius = 'inherit';\n    }\n    _createViewportNode() {\n        const magnifyElement = document.createElement('div');\n        const { radius } = this;\n        const size = radius * 2;\n        magnifyElement.classList.add(MAGNIFY_CLASSNAME);\n        Object.assign(magnifyElement.style, {\n            display: 'block',\n            width: `${size}px`,\n            height: `${size}px`,\n            position: 'absolute',\n            overflow: 'hidden',\n            borderRadius: '50%',\n            boxSizing: 'border-box',\n            left: `${-radius}px`,\n            top: `${-radius}px`,\n            transform: `translate(-1000px, -1000px)`,\n        });\n        return magnifyElement;\n    }\n    _convertZoomFactorToParallelScale(viewport, magnifyViewport, zoomFactor) {\n        const { parallelScale } = viewport.getCamera();\n        const canvasRatio = magnifyViewport.canvas.offsetWidth / viewport.canvas.offsetWidth;\n        return parallelScale * (1 / zoomFactor) * canvasRatio;\n    }\n    _isStackViewport(viewport) {\n        return 'setStack' in viewport;\n    }\n    _isVolumeViewport(viewport) {\n        return 'addVolumes' in viewport;\n    }\n    _cloneToolGroups(sourceViewport, magnifyViewport) {\n        const sourceActors = sourceViewport.getActors();\n        const magnifyToolGroupId = `${magnifyViewport.id}-toolGroup`;\n        const sourceToolGroup = getToolGroupForViewport(sourceViewport.id, sourceViewport.renderingEngineId);\n        const magnifyToolGroup = sourceToolGroup.clone(magnifyToolGroupId, (toolName) => {\n            const toolInstance = sourceToolGroup.getToolInstance(toolName);\n            const isAnnotationTool = toolInstance instanceof AnnotationTool &&\n                !(toolInstance instanceof AdvancedMagnifyTool);\n            return isAnnotationTool;\n        });\n        magnifyToolGroup.addViewport(magnifyViewport.id, magnifyViewport.renderingEngineId);\n        sourceActors.filter(isSegmentation).forEach((actor) => {\n            addSegmentationRepresentations(this.viewportId, [\n                {\n                    segmentationId: actor.referencedId,\n                    type: SegmentationRepresentations.Labelmap,\n                },\n            ]);\n        });\n        return { sourceToolGroup, magnifyToolGroup };\n    }\n    _cloneStack(sourceViewport, magnifyViewport) {\n        const imageIds = sourceViewport.getImageIds();\n        magnifyViewport.setStack(imageIds).then(() => {\n            this._isViewportReady = true;\n            this.update();\n        });\n    }\n    _cloneVolumes(sourceViewport, magnifyViewport) {\n        const actors = sourceViewport.getActors();\n        const volumeInputArray = actors\n            .filter((actor) => !isSegmentation(actor))\n            .map((actor) => ({ volumeId: actor.uid }));\n        magnifyViewport.setVolumes(volumeInputArray).then(() => {\n            this._isViewportReady = true;\n            this.update();\n        });\n        return magnifyViewport;\n    }\n    _cloneViewport(sourceViewport, magnifyElement) {\n        const { viewportId: magnifyViewportId } = this;\n        const renderingEngine = sourceViewport.getRenderingEngine();\n        const { options: sourceViewportOptions } = sourceViewport;\n        const viewportInput = {\n            element: magnifyElement,\n            viewportId: magnifyViewportId,\n            type: sourceViewport.type,\n            defaultOptions: { ...sourceViewportOptions },\n        };\n        renderingEngine.enableElement(viewportInput);\n        const magnifyViewport = (renderingEngine.getViewport(magnifyViewportId));\n        if (this._isStackViewport(sourceViewport)) {\n            this._cloneStack(sourceViewport, magnifyViewport);\n        }\n        else if (this._isVolumeViewport(sourceViewport)) {\n            this._cloneVolumes(sourceViewport, magnifyViewport);\n        }\n        this._inheritBorderRadius(magnifyElement);\n        const toolGroups = this._cloneToolGroups(sourceViewport, magnifyViewport);\n        this._sourceToolGroup = toolGroups.sourceToolGroup;\n        this._magnifyToolGroup = toolGroups.magnifyToolGroup;\n    }\n    _cancelMouseEventCallback(evt) {\n        evt.stopPropagation();\n        evt.preventDefault();\n    }\n    _browserMouseUpCallback(evt) {\n        const { element } = this._enabledElement.viewport;\n        document.removeEventListener('mouseup', this._browserMouseUpCallback);\n        element.addEventListener('mouseup', this._cancelMouseEventCallback);\n        element.addEventListener('mousemove', this._cancelMouseEventCallback);\n    }\n    _browserMouseDownCallback(evt) {\n        const { element } = this._enabledElement.viewport;\n        this._canAutoPan = !!evt.target?.closest('.advancedMagnifyTool');\n        document.addEventListener('mouseup', this._browserMouseUpCallback);\n        element.removeEventListener('mouseup', this._cancelMouseEventCallback);\n        element.removeEventListener('mousemove', this._cancelMouseEventCallback);\n    }\n    _mouseDragCallback(evt) {\n        if (!state.isInteractingWithTool) {\n            return;\n        }\n        const { _autoPan: autoPan } = this;\n        if (!autoPan.enabled || !this._canAutoPan) {\n            return;\n        }\n        const { currentPoints } = evt.detail;\n        const { viewport } = this._enabledElement;\n        const { canvasToWorld } = viewport;\n        const { canvas: canvasCurrent } = currentPoints;\n        const { radius: magnifyRadius } = this;\n        const canvasCenter = [magnifyRadius, magnifyRadius];\n        const dist = distanceToPoint(canvasCenter, canvasCurrent);\n        const maxDist = magnifyRadius - autoPan.padding;\n        if (dist <= maxDist) {\n            return;\n        }\n        const panDist = dist - maxDist;\n        const canvasDeltaPos = vec2.sub(vec2.create(), canvasCurrent, canvasCenter);\n        vec2.normalize(canvasDeltaPos, canvasDeltaPos);\n        vec2.scale(canvasDeltaPos, canvasDeltaPos, panDist);\n        const newCanvasPosition = vec2.add(vec2.create(), this.position, canvasDeltaPos);\n        const currentWorldPos = canvasToWorld(this.position);\n        const newWorldPos = canvasToWorld(newCanvasPosition);\n        const worldDeltaPos = vec3.sub(vec3.create(), newWorldPos, currentWorldPos);\n        const autoPanCallbackData = {\n            points: {\n                currentPosition: {\n                    canvas: this.position,\n                    world: currentWorldPos,\n                },\n                newPosition: {\n                    canvas: newCanvasPosition,\n                    world: newWorldPos,\n                },\n            },\n            delta: {\n                canvas: canvasDeltaPos,\n                world: worldDeltaPos,\n            },\n        };\n        autoPan.callback(autoPanCallbackData);\n    }\n    _addBrowserEventListeners(element) {\n        document.addEventListener('mousedown', this._browserMouseDownCallback, true);\n        element.addEventListener('mousedown', this._cancelMouseEventCallback);\n        element.addEventListener('mouseup', this._cancelMouseEventCallback);\n        element.addEventListener('mousemove', this._cancelMouseEventCallback);\n        element.addEventListener('dblclick', this._cancelMouseEventCallback);\n    }\n    _removeBrowserEventListeners(element) {\n        document.removeEventListener('mousedown', this._browserMouseDownCallback, true);\n        document.removeEventListener('mouseup', this._browserMouseUpCallback);\n        element.removeEventListener('mousedown', this._cancelMouseEventCallback);\n        element.removeEventListener('mouseup', this._cancelMouseEventCallback);\n        element.removeEventListener('mousemove', this._cancelMouseEventCallback);\n        element.removeEventListener('dblclick', this._cancelMouseEventCallback);\n    }\n    _addEventListeners(element) {\n        eventTarget.addEventListener(cstEvents.TOOL_MODE_CHANGED, this._handleToolModeChanged);\n        element.addEventListener(cstEvents.MOUSE_MOVE, this._mouseDragCallback);\n        element.addEventListener(cstEvents.MOUSE_DRAG, this._mouseDragCallback);\n        this._addBrowserEventListeners(element);\n    }\n    _removeEventListeners(element) {\n        eventTarget.removeEventListener(cstEvents.TOOL_MODE_CHANGED, this._handleToolModeChanged);\n        element.addEventListener(cstEvents.MOUSE_MOVE, this._mouseDragCallback);\n        element.addEventListener(cstEvents.MOUSE_DRAG, this._mouseDragCallback);\n        this._removeBrowserEventListeners(element);\n    }\n    _initialize() {\n        const { _sourceEnabledElement: sourceEnabledElement } = this;\n        const { viewport: sourceViewport } = sourceEnabledElement;\n        const { canvas: sourceCanvas } = sourceViewport;\n        const magnifyElement = this._createViewportNode();\n        sourceCanvas.parentNode.appendChild(magnifyElement);\n        this._addEventListeners(magnifyElement);\n        this._cloneViewport(sourceViewport, magnifyElement);\n        this._enabledElement = getEnabledElement(magnifyElement);\n    }\n    _syncViewportsCameras(sourceViewport, magnifyViewport) {\n        const worldPos = sourceViewport.canvasToWorld(this.position);\n        const parallelScale = this._convertZoomFactorToParallelScale(sourceViewport, magnifyViewport, this.zoomFactor);\n        const { focalPoint, position, viewPlaneNormal } = magnifyViewport.getCamera();\n        const distance = Math.sqrt(Math.pow(focalPoint[0] - position[0], 2) +\n            Math.pow(focalPoint[1] - position[1], 2) +\n            Math.pow(focalPoint[2] - position[2], 2));\n        const updatedFocalPoint = [\n            worldPos[0],\n            worldPos[1],\n            worldPos[2],\n        ];\n        const updatedPosition = [\n            updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n            updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n            updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n        ];\n        magnifyViewport.setCamera({\n            parallelScale,\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n    }\n    _syncStackViewports(sourceViewport, magnifyViewport) {\n        magnifyViewport.setImageIdIndex(sourceViewport.getCurrentImageIdIndex());\n    }\n    _syncViewports() {\n        const { viewport: sourceViewport } = this._sourceEnabledElement;\n        const { viewport: magnifyViewport } = this._enabledElement;\n        const sourceProperties = sourceViewport.getProperties();\n        const imageData = magnifyViewport.getImageData();\n        if (!imageData) {\n            return;\n        }\n        magnifyViewport.setProperties(sourceProperties);\n        this._syncViewportsCameras(sourceViewport, magnifyViewport);\n        if (this._isStackViewport(sourceViewport)) {\n            this._syncStackViewports(sourceViewport, magnifyViewport);\n        }\n        this._syncViewportsCameras(sourceViewport, magnifyViewport);\n        magnifyViewport.render();\n    }\n    _resizeViewport() {\n        const { viewport } = this._enabledElement;\n        const renderingEngine = viewport.getRenderingEngine();\n        renderingEngine.resize();\n    }\n}\nAdvancedMagnifyTool.toolName = 'AdvancedMagnify';\nexport { AdvancedMagnifyTool as default };\n", "import { vec3 } from 'gl-matrix';\nimport { getRenderingEngines, CONSTANTS, utilities as csUtils, } from '@cornerstonejs/core';\nimport { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport { addAnnotation } from '../stateManagement/annotation/annotationState';\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nconst { EPSILON } = CONSTANTS;\nclass ReferenceLines extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            sourceViewportId: '',\n            enforceSameFrameOfReference: true,\n            showFullDimension: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.editData = null;\n        this._init = () => {\n            const renderingEngines = getRenderingEngines();\n            const renderingEngine = renderingEngines[0];\n            if (!renderingEngine) {\n                return;\n            }\n            let viewports = renderingEngine.getViewports();\n            viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n            const sourceViewport = renderingEngine.getViewport(this.configuration.sourceViewportId);\n            if (!sourceViewport?.getImageData()) {\n                return;\n            }\n            const { element } = sourceViewport;\n            const { viewUp, viewPlaneNormal } = sourceViewport.getCamera();\n            const sourceViewportCanvasCornersInWorld = csUtils.getViewportImageCornersInWorld(sourceViewport);\n            let annotation = this.editData?.annotation;\n            const FrameOfReferenceUID = sourceViewport.getFrameOfReferenceUID();\n            if (!annotation) {\n                const newAnnotation = {\n                    highlighted: true,\n                    invalidated: true,\n                    metadata: {\n                        toolName: this.getToolName(),\n                        viewPlaneNormal: [...viewPlaneNormal],\n                        viewUp: [...viewUp],\n                        FrameOfReferenceUID,\n                        referencedImageId: null,\n                    },\n                    data: {\n                        handles: {\n                            points: sourceViewportCanvasCornersInWorld,\n                        },\n                    },\n                };\n                addAnnotation(newAnnotation, element);\n                annotation = newAnnotation;\n            }\n            else {\n                this.editData.annotation.data.handles.points =\n                    sourceViewportCanvasCornersInWorld;\n            }\n            this.editData = {\n                sourceViewportId: sourceViewport.id,\n                renderingEngine,\n                annotation,\n            };\n            triggerAnnotationRenderForViewportIds(viewports\n                .filter((viewport) => viewport.id !== sourceViewport.id)\n                .map((viewport) => viewport.id));\n        };\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onSetToolConfiguration = () => {\n            this._init();\n        };\n        this.onCameraModified = (evt) => {\n            this._init();\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const { viewport: targetViewport } = enabledElement;\n            if (!this.editData) {\n                return false;\n            }\n            const { annotation, sourceViewportId } = this.editData;\n            let renderStatus = false;\n            const { viewport: sourceViewport } = getEnabledElementByViewportId(sourceViewportId) || {};\n            if (!sourceViewport) {\n                return renderStatus;\n            }\n            if (sourceViewport.id === targetViewport.id) {\n                return renderStatus;\n            }\n            if (!annotation || !annotation?.data?.handles?.points) {\n                return renderStatus;\n            }\n            if (this.configuration.enforceSameFrameOfReference &&\n                sourceViewport.getFrameOfReferenceUID() !==\n                    targetViewport.getFrameOfReferenceUID()) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const topLeft = annotation.data.handles.points[0];\n            const topRight = annotation.data.handles.points[1];\n            const bottomLeft = annotation.data.handles.points[2];\n            const bottomRight = annotation.data.handles.points[3];\n            const { focalPoint, viewPlaneNormal, viewUp } = targetViewport.getCamera();\n            const { viewPlaneNormal: sourceViewPlaneNormal } = sourceViewport.getCamera();\n            if (this.isParallel(viewPlaneNormal, sourceViewPlaneNormal)) {\n                return renderStatus;\n            }\n            const targetViewportPlane = csUtils.planar.planeEquation(viewPlaneNormal, focalPoint);\n            const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n            const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n            let pointSetToUse = pointSet1;\n            let topBottomVec = vec3.subtract(vec3.create(), pointSet1[0], pointSet1[1]);\n            topBottomVec = vec3.normalize(vec3.create(), topBottomVec);\n            let topRightVec = vec3.subtract(vec3.create(), pointSet1[2], pointSet1[0]);\n            topRightVec = vec3.normalize(vec3.create(), topRightVec);\n            const newNormal = vec3.cross(vec3.create(), topBottomVec, topRightVec);\n            if (this.isParallel(newNormal, viewPlaneNormal)) {\n                return renderStatus;\n            }\n            if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n                pointSetToUse = pointSet2;\n            }\n            const lineStartWorld = csUtils.planar.linePlaneIntersection(pointSetToUse[0], pointSetToUse[1], targetViewportPlane);\n            const lineEndWorld = csUtils.planar.linePlaneIntersection(pointSetToUse[2], pointSetToUse[3], targetViewportPlane);\n            const { annotationUID } = annotation;\n            styleSpecifier.annotationUID = annotationUID;\n            const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n            const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n            const color = this.getStyle('color', styleSpecifier, annotation);\n            const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n            let canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) => targetViewport.worldToCanvas(world));\n            if (this.configuration.showFullDimension) {\n                canvasCoordinates = this.handleFullDimension(targetViewport, lineStartWorld, viewPlaneNormal, viewUp, lineEndWorld, canvasCoordinates);\n            }\n            if (canvasCoordinates.length < 2) {\n                return renderStatus;\n            }\n            const dataId = `${annotationUID}-line`;\n            const lineUID = '1';\n            drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                color,\n                width: lineWidth,\n                lineDash,\n                shadow,\n            }, dataId);\n            renderStatus = true;\n            return renderStatus;\n        };\n        this.isPerpendicular = (vec1, vec2) => {\n            const dot = vec3.dot(vec1, vec2);\n            return Math.abs(dot) < EPSILON;\n        };\n    }\n    handleFullDimension(targetViewport, lineStartWorld, viewPlaneNormal, viewUp, lineEndWorld, canvasCoordinates) {\n        const renderingEngine = targetViewport.getRenderingEngine();\n        const targetId = this.getTargetId(targetViewport);\n        const targetImage = this.getTargetImageData(targetId);\n        const referencedImageId = this.getReferencedImageId(targetViewport, lineStartWorld, viewPlaneNormal, viewUp);\n        if (referencedImageId && targetImage) {\n            try {\n                const { imageData, dimensions } = targetImage;\n                const [topLeftImageCoord, topRightImageCoord, bottomRightImageCoord, bottomLeftImageCoord,] = [\n                    imageData.indexToWorld([0, 0, 0]),\n                    imageData.indexToWorld([dimensions[0] - 1, 0, 0]),\n                    imageData.indexToWorld([\n                        dimensions[0] - 1,\n                        dimensions[1] - 1,\n                        0,\n                    ]),\n                    imageData.indexToWorld([0, dimensions[1] - 1, 0]),\n                ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n                const [lineStartImageCoord, lineEndImageCoord] = [\n                    lineStartWorld,\n                    lineEndWorld,\n                ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n                canvasCoordinates = [\n                    [topLeftImageCoord, topRightImageCoord],\n                    [topRightImageCoord, bottomRightImageCoord],\n                    [bottomLeftImageCoord, bottomRightImageCoord],\n                    [topLeftImageCoord, bottomLeftImageCoord],\n                ]\n                    .map(([start, end]) => this.intersectInfiniteLines(start, end, lineStartImageCoord, lineEndImageCoord))\n                    .filter((point) => point && this.isInBound(point, dimensions))\n                    .map((point) => {\n                    const world = csUtils.imageToWorldCoords(referencedImageId, point);\n                    return targetViewport.worldToCanvas(world);\n                });\n            }\n            catch (err) {\n                console.log(err);\n            }\n        }\n        return canvasCoordinates;\n    }\n    intersectInfiniteLines(line1Start, line1End, line2Start, line2End) {\n        const [x1, y1] = line1Start;\n        const [x2, y2] = line1End;\n        const [x3, y3] = line2Start;\n        const [x4, y4] = line2End;\n        const a1 = y2 - y1;\n        const b1 = x1 - x2;\n        const c1 = x2 * y1 - x1 * y2;\n        const a2 = y4 - y3;\n        const b2 = x3 - x4;\n        const c2 = x4 * y3 - x3 * y4;\n        if (Math.abs(a1 * b2 - a2 * b1) < EPSILON) {\n            return;\n        }\n        const x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);\n        const y = (a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1);\n        return [x, y];\n    }\n    isParallel(vec1, vec2) {\n        return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n    }\n    isInBound(point, dimensions) {\n        return (point[0] >= 0 &&\n            point[0] <= dimensions[0] &&\n            point[1] >= 0 &&\n            point[1] <= dimensions[1]);\n    }\n}\nReferenceLines.toolName = 'ReferenceLines';\nexport default ReferenceLines;\n", "import { vec3 } from 'gl-matrix';\nimport { metaData, CONSTANTS, getRenderingEngine, utilities as csUtils, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nconst { EPSILON } = CONSTANTS;\nclass OverlayGridTool extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            sourceImageIds: [],\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onSetToolActive = () => {\n            this._init();\n        };\n        this._init = () => {\n            const sourceImageIds = this.configuration.sourceImageIds;\n            if (!sourceImageIds?.length) {\n                console.warn('OverlayGridTool: No sourceImageIds provided in configuration');\n                return;\n            }\n            const imagePlaneModule = metaData.get('imagePlaneModule', sourceImageIds[0]);\n            if (!imagePlaneModule) {\n                console.warn('OverlayGridTool: No imagePlaneModule found for sourceImageIds');\n                return;\n            }\n            const { frameOfReferenceUID } = imagePlaneModule;\n            const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n            if (!viewportsInfo?.length) {\n                console.warn('OverlayGridTool: No viewports found');\n                return;\n            }\n            const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n            if (!annotations?.length) {\n                const pointSets = sourceImageIds.map((id) => {\n                    return this.calculateImageIdPointSets(id);\n                });\n                const newAnnotation = {\n                    highlighted: true,\n                    invalidated: true,\n                    metadata: {\n                        toolName: this.getToolName(),\n                        FrameOfReferenceUID: frameOfReferenceUID,\n                        referencedImageId: null,\n                    },\n                    data: {\n                        viewportData: new Map(),\n                        pointSets,\n                    },\n                };\n                addAnnotation(newAnnotation, frameOfReferenceUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n        };\n        this.calculateImageIdPointSets = (imageId) => {\n            const { imagePositionPatient, rows, columns, rowCosines, columnCosines, rowPixelSpacing, columnPixelSpacing, } = metaData.get('imagePlaneModule', imageId);\n            const topLeft = [...imagePositionPatient];\n            const topRight = [...imagePositionPatient];\n            const bottomLeft = [...imagePositionPatient];\n            const bottomRight = [...imagePositionPatient];\n            vec3.scaleAndAdd(topRight, imagePositionPatient, columnCosines, columns * columnPixelSpacing);\n            vec3.scaleAndAdd(bottomLeft, imagePositionPatient, rowCosines, rows * rowPixelSpacing);\n            vec3.scaleAndAdd(bottomRight, bottomLeft, columnCosines, columns * columnPixelSpacing);\n            const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n            const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n            return { pointSet1, pointSet2 };\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const sourceImageIds = this.configuration.sourceImageIds;\n            let renderStatus = false;\n            if (!sourceImageIds?.length) {\n                return renderStatus;\n            }\n            const { viewport: targetViewport, FrameOfReferenceUID } = enabledElement;\n            const targetImageIds = targetViewport.getImageIds();\n            if (targetImageIds.length < 2) {\n                return renderStatus;\n            }\n            const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const annotation = annotations[0];\n            const { annotationUID } = annotation;\n            const { focalPoint, viewPlaneNormal } = targetViewport.getCamera();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const imageIdNormal = (this.getImageIdNormal(sourceImageIds[0]));\n            if (this.isParallel(viewPlaneNormal, imageIdNormal)) {\n                return renderStatus;\n            }\n            const targetViewportPlane = csUtils.planar.planeEquation(viewPlaneNormal, focalPoint);\n            const pointSets = annotation.data.pointSets;\n            const viewportData = annotation.data.viewportData;\n            for (let i = 0; i < sourceImageIds.length; i++) {\n                const { pointSet1, pointSet2 } = pointSets[i];\n                const targetData = viewportData.get(targetViewport.id) ||\n                    this.initializeViewportData(viewportData, targetViewport.id);\n                if (!targetData.pointSetsToUse[i]) {\n                    let pointSetToUse = pointSet1;\n                    let topBottomVec = vec3.subtract(vec3.create(), pointSet1[0], pointSet1[1]);\n                    topBottomVec = vec3.normalize(vec3.create(), topBottomVec);\n                    if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n                        pointSetToUse = pointSet2;\n                    }\n                    targetData.pointSetsToUse[i] = pointSetToUse;\n                    targetData.lineStartsWorld[i] = csUtils.planar.linePlaneIntersection(pointSetToUse[0], pointSetToUse[1], targetViewportPlane);\n                    targetData.lineEndsWorld[i] = csUtils.planar.linePlaneIntersection(pointSetToUse[2], pointSetToUse[3], targetViewportPlane);\n                }\n                const lineStartWorld = targetData.lineStartsWorld[i];\n                const lineEndWorld = targetData.lineEndsWorld[i];\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n                const canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) => targetViewport.worldToCanvas(world));\n                const dataId = `${annotationUID}-line`;\n                const lineUID = `${i}`;\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId);\n            }\n            renderStatus = true;\n            return renderStatus;\n        };\n        this.initializeViewportData = (viewportData, id) => {\n            viewportData.set(id, {\n                pointSetsToUse: [],\n                lineStartsWorld: [],\n                lineEndsWorld: [],\n            });\n            return viewportData.get(id);\n        };\n        this.isPerpendicular = (vec1, vec2) => {\n            const dot = vec3.dot(vec1, vec2);\n            return Math.abs(dot) < EPSILON;\n        };\n    }\n    isParallel(vec1, vec2) {\n        return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n    }\n    getImageIdNormal(imageId) {\n        const { imageOrientationPatient } = metaData.get('imagePlaneModule', imageId);\n        const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n        const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n        return vec3.cross(vec3.create(), rowCosineVec, colCosineVec);\n    }\n}\nOverlayGridTool.toolName = 'OverlayGrid';\nexport default OverlayGridTool;\n", "import { getRenderingEngine } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { drawPath } from '../drawingSvg';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { distanceToPoint } from '../utilities/math/point';\nimport { pointToString } from '../utilities/pointToString';\nimport { polyDataUtils } from '../utilities';\nclass SegmentationIntersectionTool extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            opacity: 0.5,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._init = () => {\n            const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n            if (!viewportsInfo?.length) {\n                console.warn(this.getToolName() + 'Tool: No viewports found');\n                return;\n            }\n            const firstViewport = getRenderingEngine(viewportsInfo[0].renderingEngineId)?.getViewport(viewportsInfo[0].viewportId);\n            if (!firstViewport) {\n                return;\n            }\n            const frameOfReferenceUID = firstViewport.getFrameOfReferenceUID();\n            const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n            if (!annotations?.length) {\n                const actorsWorldPointsMap = new Map();\n                calculateSurfaceSegmentationIntersections(actorsWorldPointsMap, viewportsInfo);\n                const newAnnotation = {\n                    highlighted: true,\n                    invalidated: true,\n                    metadata: {\n                        toolName: this.getToolName(),\n                        FrameOfReferenceUID: frameOfReferenceUID,\n                        referencedImageId: null,\n                    },\n                    data: {\n                        actorsWorldPointsMap,\n                    },\n                };\n                addAnnotation(newAnnotation, frameOfReferenceUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n        };\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onCameraModified = (evt) => {\n            this._init();\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const { viewport, FrameOfReferenceUID } = enabledElement;\n            let renderStatus = false;\n            const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const annotation = annotations[0];\n            const { annotationUID } = annotation;\n            const actorsWorldPointsMap = (annotation).data.actorsWorldPointsMap;\n            calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport);\n            const actorEntries = viewport.getActors();\n            const cacheId = getCacheId(viewport);\n            actorEntries.forEach((actorEntry) => {\n                if (!actorEntry?.clippingFilter) {\n                    return;\n                }\n                const actorWorldPointMap = actorsWorldPointsMap.get(actorEntry.uid);\n                if (!actorWorldPointMap) {\n                    return;\n                }\n                if (!actorWorldPointMap.get(cacheId)) {\n                    return;\n                }\n                let polyLineIdx = 1;\n                const { worldPointsSet, color } = actorWorldPointMap.get(cacheId);\n                for (let i = 0; i < worldPointsSet.length; i++) {\n                    const worldPoints = worldPointsSet[i];\n                    const canvasPoints = worldPoints.map((point) => viewport.worldToCanvas(point));\n                    const options = {\n                        color: color,\n                        fillColor: color,\n                        fillOpacity: this.configuration.opacity,\n                        closePath: true,\n                        lineWidth: 2,\n                    };\n                    const polyLineUID = actorEntry.uid + '#' + polyLineIdx;\n                    drawPath(svgDrawingHelper, annotationUID, polyLineUID, canvasPoints, options);\n                    polyLineIdx++;\n                }\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nfunction calculateSurfaceSegmentationIntersections(actorsWorldPointsMap, viewportsInfo) {\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n        const viewport = getRenderingEngine(renderingEngineId)?.getViewport(viewportId);\n        calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport);\n    });\n}\nfunction calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport) {\n    const actorEntries = viewport.getActors();\n    const cacheId = getCacheId(viewport);\n    actorEntries.forEach((actorEntry) => {\n        if (!actorEntry?.clippingFilter) {\n            return;\n        }\n        let actorWorldPointsMap = actorsWorldPointsMap.get(actorEntry.uid);\n        if (!actorWorldPointsMap) {\n            actorWorldPointsMap = new Map();\n            actorsWorldPointsMap.set(actorEntry.uid, actorWorldPointsMap);\n        }\n        if (!actorWorldPointsMap.get(cacheId)) {\n            const polyData = actorEntry.clippingFilter.getOutputData();\n            const worldPointsSet = polyDataUtils.getPolyDataPoints(polyData);\n            if (!worldPointsSet) {\n                return;\n            }\n            const colorArray = actorEntry.actor.getProperty().getColor();\n            const color = colorToString(colorArray);\n            actorWorldPointsMap.set(cacheId, { worldPointsSet, color });\n        }\n    });\n}\nfunction getCacheId(viewport) {\n    const { viewPlaneNormal } = viewport.getCamera();\n    const imageIndex = viewport.getCurrentImageIdIndex();\n    return `${viewport.id}-${pointToString(viewPlaneNormal)}-${imageIndex}`;\n}\nfunction colorToString(colorArray) {\n    function colorComponentToString(component) {\n        let componentString = Math.floor(component * 255).toString(16);\n        if (componentString.length === 1) {\n            componentString = '0' + componentString;\n        }\n        return componentString;\n    }\n    return ('#' +\n        colorComponentToString(colorArray[0]) +\n        colorComponentToString(colorArray[1]) +\n        colorComponentToString(colorArray[2]));\n}\nfunction removeExtraPoints(viewport, worldPointsSet) {\n    return worldPointsSet.map((worldPoints) => {\n        const canvasPoints = worldPoints.map((point) => {\n            const canvasPoint = viewport.worldToCanvas(point);\n            return [Math.floor(canvasPoint[0]), Math.floor(canvasPoint[1])];\n        });\n        let lastPoint;\n        const newWorldPoints = [];\n        let newCanvasPoints = [];\n        for (let i = 0; i < worldPoints.length; i++) {\n            if (lastPoint) {\n                if (distanceToPoint(lastPoint, canvasPoints[i]) > 0) {\n                    newWorldPoints.push(worldPoints[i]);\n                    newCanvasPoints.push(canvasPoints[i]);\n                }\n            }\n            lastPoint = canvasPoints[i];\n        }\n        const firstPoint = newCanvasPoints[0];\n        for (let j = Math.min(30, newCanvasPoints.length); j < newCanvasPoints.length; j++) {\n            if (distanceToPoint(firstPoint, newCanvasPoints[j]) < 0.5) {\n                newCanvasPoints = newCanvasPoints.slice(0, j);\n                return newWorldPoints.slice(0, j);\n            }\n        }\n        return newWorldPoints;\n    });\n}\nSegmentationIntersectionTool.toolName = 'SegmentationIntersection';\nexport default SegmentationIntersectionTool;\n", "import { getEnabledElement, StackViewport, VolumeViewport, utilities, getEnabledElementByIds, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport { drawLine } from '../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { vec3 } from 'gl-matrix';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { hideElementCursor, resetElementCursor, } from '../cursors/elementCursor';\nimport { getToolGroup } from '../store/ToolGroupManager';\nclass ReferenceCursors extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            displayThreshold: 5,\n            positionSync: true,\n            disableCursor: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isDrawing = false;\n        this.isHandleOutsideImage = false;\n        this._elementWithCursor = null;\n        this._currentCursorWorldPosition = null;\n        this._currentCanvasPosition = null;\n        this._disableCursorEnabled = false;\n        this.mouseMoveCallback = (evt) => {\n            const { detail } = evt;\n            const { element, currentPoints } = detail;\n            this._currentCursorWorldPosition = currentPoints.world;\n            this._currentCanvasPosition = currentPoints.canvas;\n            this._elementWithCursor = element;\n            const annotation = this.getActiveAnnotation(element);\n            if (annotation === null) {\n                this.createInitialAnnotation(currentPoints.world, element);\n                return false;\n            }\n            this.updateAnnotationPosition(element, annotation);\n            return false;\n        };\n        this.createInitialAnnotation = (worldPos, element) => {\n            const enabledElement = getEnabledElement(element);\n            if (!enabledElement) {\n                throw new Error('No enabled element found');\n            }\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            if (!viewPlaneNormal || !viewUp) {\n                throw new Error('Camera not found');\n            }\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        points: [[...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                },\n            };\n            const annotations = getAnnotations(this.getToolName(), element);\n            if (annotations.length > 0) {\n                return null;\n            }\n            const annotationId = addAnnotation(annotation, element);\n            if (annotationId === null) {\n                return;\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.onCameraModified = (evt) => {\n            const eventDetail = evt.detail;\n            const { element, previousCamera, camera } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const viewport = enabledElement.viewport;\n            if (element !== this._elementWithCursor) {\n                return;\n            }\n            const oldFocalPoint = previousCamera.focalPoint;\n            const cameraNormal = camera.viewPlaneNormal;\n            const newFocalPoint = camera.focalPoint;\n            const deltaCameraFocalPoint = [0, 0, 0];\n            vtkMath.subtract(newFocalPoint, oldFocalPoint, deltaCameraFocalPoint);\n            if (deltaCameraFocalPoint.reduce((a, b) => a + b, 0) === 0) {\n                return;\n            }\n            const dotProduct = vtkMath.dot(deltaCameraFocalPoint, cameraNormal);\n            if (Math.abs(dotProduct) < 1e-2) {\n                return;\n            }\n            if (!this._currentCanvasPosition) {\n                return;\n            }\n            const newWorldPos = viewport.canvasToWorld(this._currentCanvasPosition);\n            this._currentCursorWorldPosition = newWorldPos;\n            this.updateAnnotationPosition(element, this.getActiveAnnotation(element));\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport, FrameOfReferenceUID } = enabledElement;\n            const isElementWithCursor = this._elementWithCursor === viewport.element;\n            if (this.configuration.positionSync && !isElementWithCursor) {\n                this.updateViewportImage(viewport);\n            }\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points } = handles;\n                if (!annotationUID) {\n                    return renderStatus;\n                }\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidthBase = parseFloat(this.getStyle('lineWidth', styleSpecifier, annotation));\n                const lineWidth = typeof lineWidthBase === 'number' && isElementWithCursor\n                    ? lineWidthBase\n                    : lineWidthBase;\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                if (points[0].some((e) => isNaN(e))) {\n                    return renderStatus;\n                }\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                const crosshairUIDs = {\n                    upper: 'upper',\n                    right: 'right',\n                    lower: 'lower',\n                    left: 'left',\n                };\n                const [x, y] = canvasCoordinates[0];\n                const centerSpace = isElementWithCursor ? 20 : 7;\n                const lineLength = isElementWithCursor ? 5 : 7;\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.upper, [x, y - (centerSpace / 2 + lineLength)], [x, y - centerSpace / 2], { color, lineDash, lineWidth });\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.lower, [x, y + (centerSpace / 2 + lineLength)], [x, y + centerSpace / 2], { color, lineDash, lineWidth });\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.right, [x + (centerSpace / 2 + lineLength), y], [x + centerSpace / 2, y], { color, lineDash, lineWidth });\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.left, [x - (centerSpace / 2 + lineLength), y], [x - centerSpace / 2, y], { color, lineDash, lineWidth });\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n        this._disableCursorEnabled = this.configuration.disableCursor;\n    }\n    onSetToolActive() {\n        this._disableCursorEnabled = this.configuration.disableCursor;\n        if (!this._disableCursorEnabled) {\n            return;\n        }\n        const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n        if (!viewportIds) {\n            return;\n        }\n        const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));\n        enabledElements.forEach((element) => {\n            if (element) {\n                hideElementCursor(element.viewport.element);\n            }\n        });\n    }\n    onSetToolDisabled() {\n        if (!this._disableCursorEnabled) {\n            return;\n        }\n        const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n        if (!viewportIds) {\n            return;\n        }\n        const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));\n        enabledElements.forEach((element) => {\n            if (element) {\n                resetElementCursor(element.viewport.element);\n            }\n        });\n    }\n    getActiveAnnotation(element) {\n        const annotations = getAnnotations(this.getToolName(), element);\n        if (!annotations.length) {\n            return null;\n        }\n        const targetAnnotation = annotations[0];\n        return targetAnnotation;\n    }\n    updateAnnotationPosition(element, annotation) {\n        const worldPos = this._currentCursorWorldPosition;\n        if (!worldPos) {\n            return;\n        }\n        if (!annotation.data?.handles?.points) {\n            return;\n        }\n        annotation.data.handles.points = [[...worldPos]];\n        annotation.invalidated = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    }\n    filterInteractableAnnotationsForElement(element, annotations) {\n        if (!(annotations instanceof Array) || annotations.length === 0) {\n            return [];\n        }\n        const annotation = annotations[0];\n        const viewport = getEnabledElement(element)?.viewport;\n        if (!viewport) {\n            return [];\n        }\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, focalPoint } = camera;\n        if (!viewPlaneNormal || !focalPoint) {\n            return [];\n        }\n        const points = annotation.data?.handles?.points;\n        if (!(points instanceof Array) || points.length !== 1) {\n            return [];\n        }\n        const worldPos = points[0];\n        const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n        const distance = utilities.planar.planeDistanceToPoint(plane, worldPos);\n        return distance < this.configuration.displayThreshold ? [annotation] : [];\n    }\n    updateViewportImage(viewport) {\n        const currentMousePosition = this._currentCursorWorldPosition;\n        if (!currentMousePosition || currentMousePosition.some((e) => isNaN(e))) {\n            return;\n        }\n        if (viewport instanceof StackViewport) {\n            const closestIndex = utilities.getClosestStackImageIndexForPoint(currentMousePosition, viewport);\n            if (closestIndex === null) {\n                return;\n            }\n            if (closestIndex !== viewport.getCurrentImageIdIndex()) {\n                viewport.setImageIdIndex(closestIndex);\n            }\n        }\n        else if (viewport instanceof VolumeViewport) {\n            const { focalPoint, viewPlaneNormal } = viewport.getCamera();\n            if (!focalPoint || !viewPlaneNormal) {\n                return;\n            }\n            const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n            const currentDistance = utilities.planar.planeDistanceToPoint(plane, currentMousePosition, true);\n            if (Math.abs(currentDistance) < 0.5) {\n                return;\n            }\n            const normalizedViewPlane = vec3.normalize(vec3.create(), vec3.fromValues(...viewPlaneNormal));\n            const scaledPlaneNormal = vec3.scale(vec3.create(), normalizedViewPlane, currentDistance);\n            const newFocalPoint = vec3.add(vec3.create(), vec3.fromValues(...focalPoint), scaledPlaneNormal);\n            const isInBounds = true;\n            if (isInBounds) {\n                viewport.setCamera({ focalPoint: newFocalPoint });\n                const renderingEngine = viewport.getRenderingEngine();\n                if (renderingEngine) {\n                    renderingEngine.renderViewport(viewport.id);\n                }\n            }\n        }\n    }\n}\nReferenceCursors.toolName = 'ReferenceCursors';\nexport default ReferenceCursors;\n", "import AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { vec3 } from 'gl-matrix';\nimport { getEnabledElementByIds, getRenderingEngines, utilities as csUtils, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { drawLine as drawLineSvg, drawTextBox as drawTextBoxSvg, } from '../drawingSvg';\nimport { getToolGroup } from '../store/ToolGroupManager';\nconst viewportsWithAnnotations = [];\nclass ScaleOverlayTool extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            viewportId: '',\n            scaleLocation: 'bottom',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.editData = null;\n        this._init = () => {\n            const renderingEngines = getRenderingEngines();\n            const renderingEngine = renderingEngines[0];\n            if (!renderingEngine) {\n                return;\n            }\n            const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n            if (!viewportIds) {\n                return;\n            }\n            const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));\n            let { viewport } = enabledElements[0];\n            const { FrameOfReferenceUID } = enabledElements[0];\n            if (this.configuration.viewportId) {\n                enabledElements.forEach((element) => {\n                    if (element.viewport.id == this.configuration.viewportId) {\n                        viewport = element.viewport;\n                    }\n                });\n            }\n            if (!viewport) {\n                return;\n            }\n            const { viewUp, viewPlaneNormal } = viewport.getCamera();\n            const viewportCanvasCornersInWorld = csUtils.getViewportImageCornersInWorld(viewport);\n            let annotation = this.editData?.annotation;\n            const annotations = getAnnotations(this.getToolName(), viewport.element);\n            if (annotations.length) {\n                annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];\n            }\n            enabledElements.forEach((element) => {\n                const { viewport } = element;\n                if (!viewportsWithAnnotations.includes(viewport.id)) {\n                    const newAnnotation = {\n                        metadata: {\n                            toolName: this.getToolName(),\n                            viewPlaneNormal: [...viewPlaneNormal],\n                            viewUp: [...viewUp],\n                            FrameOfReferenceUID,\n                            referencedImageId: null,\n                        },\n                        data: {\n                            handles: {\n                                points: csUtils.getViewportImageCornersInWorld(viewport),\n                            },\n                            viewportId: viewport.id,\n                        },\n                    };\n                    viewportsWithAnnotations.push(viewport.id);\n                    addAnnotation(newAnnotation, viewport.element);\n                    annotation = newAnnotation;\n                }\n            });\n            if (this.editData?.annotation &&\n                this.editData.annotation.data.viewportId == viewport.id) {\n                this.editData.annotation.data.handles.points =\n                    viewportCanvasCornersInWorld;\n                this.editData.annotation.data.viewportId = viewport.id;\n            }\n            this.editData = {\n                viewport,\n                renderingEngine,\n                annotation,\n            };\n        };\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onCameraModified = (evt) => {\n            this.configuration.viewportId = evt.detail.viewportId;\n            this._init();\n        };\n        this.computeScaleSize = (worldWidthViewport, worldHeightViewport, location) => {\n            const scaleSizes = [\n                16000, 8000, 4000, 2000, 1000, 500, 250, 100, 50, 25, 10, 5, 2,\n            ];\n            let currentScaleSize;\n            if (location == 'top' || location == 'bottom') {\n                currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldWidthViewport * 0.6 &&\n                    scaleSize > worldWidthViewport * 0.2);\n            }\n            else {\n                currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldHeightViewport * 0.6 &&\n                    scaleSize > worldHeightViewport * 0.2);\n            }\n            return currentScaleSize[0];\n        };\n        this.computeEndScaleTicks = (canvasCoordinates, location) => {\n            const locationTickOffset = {\n                bottom: [\n                    [0, -10],\n                    [0, -10],\n                ],\n                top: [\n                    [0, 10],\n                    [0, 10],\n                ],\n                left: [\n                    [0, 0],\n                    [10, 0],\n                ],\n                right: [\n                    [0, 0],\n                    [-10, 0],\n                ],\n            };\n            const endTick1 = [\n                [\n                    canvasCoordinates[1][0] + locationTickOffset[location][0][0],\n                    canvasCoordinates[1][1] + locationTickOffset[location][0][0],\n                ],\n                [\n                    canvasCoordinates[1][0] + locationTickOffset[location][1][0],\n                    canvasCoordinates[1][1] + locationTickOffset[location][1][1],\n                ],\n            ];\n            const endTick2 = [\n                [\n                    canvasCoordinates[0][0] + locationTickOffset[location][0][0],\n                    canvasCoordinates[0][1] + locationTickOffset[location][0][0],\n                ],\n                [\n                    canvasCoordinates[0][0] + locationTickOffset[location][1][0],\n                    canvasCoordinates[0][1] + locationTickOffset[location][1][1],\n                ],\n            ];\n            return {\n                endTick1: endTick1,\n                endTick2: endTick2,\n            };\n        };\n        this.computeInnerScaleTicks = (scaleSize, location, annotationUID, leftTick, rightTick) => {\n            let canvasScaleSize;\n            if (location == 'bottom' || location == 'top') {\n                canvasScaleSize = rightTick[0][0] - leftTick[0][0];\n            }\n            else if (location == 'left' || location == 'right') {\n                canvasScaleSize = rightTick[0][1] - leftTick[0][1];\n            }\n            const tickIds = [];\n            const tickUIDs = [];\n            const tickCoordinates = [];\n            let numberSmallTicks = scaleSize;\n            if (scaleSize >= 50) {\n                numberSmallTicks = scaleSize / 10;\n            }\n            const tickSpacing = canvasScaleSize / numberSmallTicks;\n            for (let i = 0; i < numberSmallTicks - 1; i++) {\n                const locationOffset = {\n                    bottom: [\n                        [tickSpacing * (i + 1), 0],\n                        [tickSpacing * (i + 1), 5],\n                    ],\n                    top: [\n                        [tickSpacing * (i + 1), 0],\n                        [tickSpacing * (i + 1), -5],\n                    ],\n                    left: [\n                        [0, tickSpacing * (i + 1)],\n                        [-5, tickSpacing * (i + 1)],\n                    ],\n                    right: [\n                        [0, tickSpacing * (i + 1)],\n                        [5, tickSpacing * (i + 1)],\n                    ],\n                };\n                tickIds.push(`${annotationUID}-tick${i}`);\n                tickUIDs.push(`tick${i}`);\n                if ((i + 1) % 5 == 0) {\n                    tickCoordinates.push([\n                        [\n                            leftTick[0][0] + locationOffset[location][0][0],\n                            leftTick[0][1] + locationOffset[location][0][1],\n                        ],\n                        [\n                            leftTick[1][0] + locationOffset[location][0][0],\n                            leftTick[1][1] + locationOffset[location][0][1],\n                        ],\n                    ]);\n                }\n                else {\n                    tickCoordinates.push([\n                        [\n                            leftTick[0][0] + locationOffset[location][0][0],\n                            leftTick[0][1] + locationOffset[location][0][1],\n                        ],\n                        [\n                            leftTick[1][0] + locationOffset[location][1][0],\n                            leftTick[1][1] + locationOffset[location][1][1],\n                        ],\n                    ]);\n                }\n            }\n            return { tickIds, tickUIDs, tickCoordinates };\n        };\n        this.computeWorldScaleCoordinates = (scaleSize, location, pointSet) => {\n            let worldCoordinates;\n            let topBottomVec = vec3.subtract(vec3.create(), pointSet[0], pointSet[1]);\n            topBottomVec = vec3.normalize(vec3.create(), topBottomVec);\n            let topRightVec = vec3.subtract(vec3.create(), pointSet[2], pointSet[0]);\n            topRightVec = vec3.normalize(vec3.create(), topRightVec);\n            const midpointLocation = {\n                bottom: [pointSet[1], pointSet[2]],\n                top: [pointSet[0], pointSet[3]],\n                right: [pointSet[2], pointSet[3]],\n                left: [pointSet[0], pointSet[1]],\n            };\n            const midpoint = vec3\n                .add(vec3.create(), midpointLocation[location][0], midpointLocation[location][0])\n                .map((i) => i / 2);\n            const offset = scaleSize /\n                2 /\n                Math.sqrt(Math.pow(topBottomVec[0], 2) +\n                    Math.pow(topBottomVec[1], 2) +\n                    Math.pow(topBottomVec[2], 2));\n            if (location == 'top' || location == 'bottom') {\n                worldCoordinates = [\n                    vec3.subtract(vec3.create(), midpoint, topRightVec.map((i) => i * offset)),\n                    vec3.add(vec3.create(), midpoint, topRightVec.map((i) => i * offset)),\n                ];\n            }\n            else if (location == 'left' || location == 'right') {\n                worldCoordinates = [\n                    vec3.add(vec3.create(), midpoint, topBottomVec.map((i) => i * offset)),\n                    vec3.subtract(vec3.create(), midpoint, topBottomVec.map((i) => i * offset)),\n                ];\n            }\n            return worldCoordinates;\n        };\n        this.computeCanvasScaleCoordinates = (canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location) => {\n            let scaleCanvasCoordinates;\n            if (location == 'top' || location == 'bottom') {\n                const worldDistanceOnCanvas = canvasCoordinates[0][0] - canvasCoordinates[1][0];\n                scaleCanvasCoordinates = [\n                    [canvasSize.width / 2 - worldDistanceOnCanvas / 2, vscaleBounds.height],\n                    [canvasSize.width / 2 + worldDistanceOnCanvas / 2, vscaleBounds.height],\n                ];\n            }\n            else if (location == 'left' || location == 'right') {\n                const worldDistanceOnCanvas = canvasCoordinates[0][1] - canvasCoordinates[1][1];\n                scaleCanvasCoordinates = [\n                    [hscaleBounds.width, canvasSize.height / 2 - worldDistanceOnCanvas / 2],\n                    [hscaleBounds.width, canvasSize.height / 2 + worldDistanceOnCanvas / 2],\n                ];\n            }\n            return scaleCanvasCoordinates;\n        };\n        this.computeScaleBounds = (canvasSize, horizontalReduction, verticalReduction, location) => {\n            const hReduction = horizontalReduction * Math.min(1000, canvasSize.width);\n            const vReduction = verticalReduction * Math.min(1000, canvasSize.height);\n            const locationBounds = {\n                bottom: [-vReduction, -hReduction],\n                top: [vReduction, hReduction],\n                left: [vReduction, hReduction],\n                right: [-vReduction, -hReduction],\n            };\n            const canvasBounds = {\n                bottom: [canvasSize.height, canvasSize.width],\n                top: [0, canvasSize.width],\n                left: [canvasSize.height, 0],\n                right: [canvasSize.height, canvasSize.width],\n            };\n            return {\n                height: canvasBounds[location][0] + locationBounds[location][0],\n                width: canvasBounds[location][1] + locationBounds[location][1],\n            };\n        };\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this.editData || !this.editData.viewport) {\n            return;\n        }\n        const location = this.configuration.scaleLocation;\n        const { viewport } = enabledElement;\n        const annotations = getAnnotations(this.getToolName(), viewport.element);\n        const annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];\n        const canvas = enabledElement.viewport.canvas;\n        const renderStatus = false;\n        if (!viewport) {\n            return renderStatus;\n        }\n        const styleSpecifier = {\n            toolGroupId: this.toolGroupId,\n            toolName: this.getToolName(),\n            viewportId: enabledElement.viewport.id,\n        };\n        const canvasSize = {\n            width: canvas.width / window.devicePixelRatio || 1,\n            height: canvas.height / window.devicePixelRatio || 1,\n        };\n        const topLeft = annotation.data.handles.points[0];\n        const topRight = annotation.data.handles.points[1];\n        const bottomLeft = annotation.data.handles.points[2];\n        const bottomRight = annotation.data.handles.points[3];\n        const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n        const worldWidthViewport = vec3.distance(bottomLeft, bottomRight);\n        const worldHeightViewport = vec3.distance(topLeft, bottomLeft);\n        const hscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);\n        const vscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);\n        const scaleSize = this.computeScaleSize(worldWidthViewport, worldHeightViewport, location);\n        const canvasCoordinates = this.computeWorldScaleCoordinates(scaleSize, location, pointSet1).map((world) => viewport.worldToCanvas(world));\n        const scaleCanvasCoordinates = this.computeCanvasScaleCoordinates(canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location);\n        const scaleTicks = this.computeEndScaleTicks(scaleCanvasCoordinates, location);\n        const { annotationUID } = annotation;\n        styleSpecifier.annotationUID = annotationUID;\n        const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n        const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n        const color = this.getStyle('color', styleSpecifier, annotation);\n        const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n        const scaleId = `${annotationUID}-scaleline`;\n        const scaleLineUID = '1';\n        drawLineSvg(svgDrawingHelper, annotationUID, scaleLineUID, scaleCanvasCoordinates[0], scaleCanvasCoordinates[1], {\n            color,\n            width: lineWidth,\n            lineDash,\n            shadow,\n        }, scaleId);\n        const leftTickId = `${annotationUID}-left`;\n        const leftTickUID = '2';\n        drawLineSvg(svgDrawingHelper, annotationUID, leftTickUID, scaleTicks.endTick1[0], scaleTicks.endTick1[1], {\n            color,\n            width: lineWidth,\n            lineDash,\n            shadow,\n        }, leftTickId);\n        const rightTickId = `${annotationUID}-right`;\n        const rightTickUID = '3';\n        drawLineSvg(svgDrawingHelper, annotationUID, rightTickUID, scaleTicks.endTick2[0], scaleTicks.endTick2[1], {\n            color,\n            width: lineWidth,\n            lineDash,\n            shadow,\n        }, rightTickId);\n        const locationTextOffest = {\n            bottom: [-10, -42],\n            top: [-12, -35],\n            left: [-40, -20],\n            right: [-50, -20],\n        };\n        const textCanvasCoordinates = [\n            scaleCanvasCoordinates[0][0] + locationTextOffest[location][0],\n            scaleCanvasCoordinates[0][1] + locationTextOffest[location][1],\n        ];\n        const textBoxLines = this._getTextLines(scaleSize);\n        const { tickIds, tickUIDs, tickCoordinates } = this.computeInnerScaleTicks(scaleSize, location, annotationUID, scaleTicks.endTick1, scaleTicks.endTick2);\n        for (let i = 0; i < tickUIDs.length; i++) {\n            drawLineSvg(svgDrawingHelper, annotationUID, tickUIDs[i], tickCoordinates[i][0], tickCoordinates[i][1], {\n                color,\n                width: lineWidth,\n                lineDash,\n                shadow,\n            }, tickIds[i]);\n        }\n        const textUID = 'text0';\n        drawTextBoxSvg(svgDrawingHelper, annotationUID, textUID, textBoxLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], {\n            fontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n            fontSize: '14px',\n            lineDash: '2,3',\n            lineWidth: '1',\n            shadow: true,\n            color: color,\n        });\n        return renderStatus;\n    }\n    _getTextLines(scaleSize) {\n        let scaleSizeDisplayValue;\n        let scaleSizeUnits;\n        if (scaleSize >= 50) {\n            scaleSizeDisplayValue = scaleSize / 10;\n            scaleSizeUnits = ' cm';\n        }\n        else {\n            scaleSizeDisplayValue = scaleSize;\n            scaleSizeUnits = ' mm';\n        }\n        const textLines = [scaleSizeDisplayValue.toString().concat(scaleSizeUnits)];\n        return textLines;\n    }\n}\nScaleOverlayTool.toolName = 'ScaleOverlay';\nexport default ScaleOverlayTool;\n", "import { point } from '../utilities/math';\nexport const distancePointToContour = (viewport, annotation, coords) => {\n    if (!annotation?.data?.contour?.polyline?.length) {\n        return;\n    }\n    const { polyline } = annotation.data.contour;\n    const { length } = polyline;\n    let distance = Infinity;\n    for (let i = 0; i < length; i++) {\n        const canvasPoint = viewport.worldToCanvas(polyline[i]);\n        const distanceToPoint = point.distanceToPoint(canvasPoint, coords);\n        distance = Math.min(distance, distanceToPoint);\n    }\n    if (distance === Infinity || isNaN(distance)) {\n        return;\n    }\n    return distance;\n};\n", "import { vec3 } from 'gl-matrix';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { distancePointToContour } from '../distancePointToContour';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { point } from '../../utilities/math';\nclass CircleSculptCursor {\n    constructor() {\n        this.toolInfo = {\n            toolSize: null,\n            maxToolSize: null,\n        };\n    }\n    static { this.shapeName = 'Circle'; }\n    static { this.CHAIN_MAINTENANCE_ITERATIONS = 3; }\n    static { this.CHAIN_PULL_STRENGTH_FACTOR = 0.3; }\n    static { this.MAX_INTER_DISTANCE_FACTOR = 1.2; }\n    renderShape(svgDrawingHelper, canvasLocation, options) {\n        const circleUID = '0';\n        drawCircleSvg(svgDrawingHelper, 'SculptorTool', circleUID, canvasLocation, this.toolInfo.toolSize, options);\n    }\n    pushHandles(viewport, sculptData) {\n        const { points, mouseCanvasPoint } = sculptData;\n        const pushedHandles = { first: undefined, last: undefined };\n        const worldRadius = point.distanceToPoint(viewport.canvasToWorld(mouseCanvasPoint), viewport.canvasToWorld([\n            mouseCanvasPoint[0] + this.toolInfo.toolSize,\n            mouseCanvasPoint[1],\n        ]));\n        for (let i = 0; i < points.length; i++) {\n            const handleCanvasPoint = viewport.worldToCanvas(points[i]);\n            const distanceToHandle = point.distanceToPoint(handleCanvasPoint, mouseCanvasPoint);\n            if (distanceToHandle > this.toolInfo.toolSize) {\n                continue;\n            }\n            this.pushOneHandle(i, worldRadius, sculptData);\n            if (pushedHandles.first === undefined) {\n                pushedHandles.first = i;\n                pushedHandles.last = i;\n            }\n            else {\n                pushedHandles.last = i;\n            }\n        }\n        if (pushedHandles.first !== undefined && pushedHandles.last !== undefined) {\n            for (let i = 0; i < CircleSculptCursor.CHAIN_MAINTENANCE_ITERATIONS; i++) {\n                this.maintainChainStructure(sculptData, pushedHandles);\n            }\n        }\n        return pushedHandles;\n    }\n    configureToolSize(evt) {\n        const toolInfo = this.toolInfo;\n        if (toolInfo.toolSize && toolInfo.maxToolSize) {\n            return;\n        }\n        const eventData = evt.detail;\n        const element = eventData.element;\n        const minDim = Math.min(element.clientWidth, element.clientHeight);\n        const maxRadius = minDim / 12;\n        toolInfo.toolSize = maxRadius;\n        toolInfo.maxToolSize = maxRadius;\n    }\n    updateToolSize(canvasCoords, viewport, activeAnnotation) {\n        const toolInfo = this.toolInfo;\n        const radius = distancePointToContour(viewport, activeAnnotation, canvasCoords);\n        if (radius > 0) {\n            toolInfo.toolSize = Math.min(toolInfo.maxToolSize, radius);\n        }\n    }\n    getMaxSpacing(minSpacing) {\n        return Math.max(this.toolInfo.toolSize / 4, minSpacing);\n    }\n    getInsertPosition(previousIndex, nextIndex, sculptData) {\n        let insertPosition;\n        const { points, element, mouseCanvasPoint } = sculptData;\n        const toolSize = this.toolInfo.toolSize;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const previousCanvasPoint = viewport.worldToCanvas(points[previousIndex]);\n        const nextCanvasPoint = viewport.worldToCanvas(points[nextIndex]);\n        const midPoint = [\n            (previousCanvasPoint[0] + nextCanvasPoint[0]) / 2.0,\n            (previousCanvasPoint[1] + nextCanvasPoint[1]) / 2.0,\n        ];\n        const distanceToMidPoint = point.distanceToPoint(mouseCanvasPoint, midPoint);\n        if (distanceToMidPoint < toolSize) {\n            const directionUnitVector = {\n                x: (midPoint[0] - mouseCanvasPoint[0]) / distanceToMidPoint,\n                y: (midPoint[1] - mouseCanvasPoint[1]) / distanceToMidPoint,\n            };\n            insertPosition = [\n                mouseCanvasPoint[0] + toolSize * directionUnitVector.x,\n                mouseCanvasPoint[1] + toolSize * directionUnitVector.y,\n            ];\n        }\n        else {\n            insertPosition = midPoint;\n        }\n        const worldPosition = viewport.canvasToWorld(insertPosition);\n        return worldPosition;\n    }\n    pushOneHandle(i, worldRadius, sculptData) {\n        const { points, mousePoint } = sculptData;\n        const handle = points[i];\n        const directionUnitVector = this.directionalVector(mousePoint, handle);\n        const position = vec3.scaleAndAdd(vec3.create(), mousePoint, directionUnitVector, worldRadius);\n        handle[0] = position[0];\n        handle[1] = position[1];\n        handle[2] = position[2];\n    }\n    directionalVector(p1, p2) {\n        return vec3.normalize(vec3.create(), [\n            p2[0] - p1[0],\n            p2[1] - p1[1],\n            p2[2] - p1[2],\n        ]);\n    }\n    calculateMeanConsecutiveDistance(points) {\n        if (points.length < 2) {\n            return 0;\n        }\n        let totalDistance = 0;\n        const numPoints = points.length;\n        for (let i = 0; i < numPoints; i++) {\n            const nextIndex = (i + 1) % numPoints;\n            const distance = point.distanceToPoint(points[i], points[nextIndex]);\n            totalDistance += distance;\n        }\n        return totalDistance / numPoints;\n    }\n    maintainChainStructure(sculptData, pushedHandles) {\n        const { points } = sculptData;\n        const first = pushedHandles.first;\n        const last = pushedHandles.last;\n        const mean = Math.round((first + last) / 2);\n        const numPoints = points.length;\n        if (!sculptData.meanDistance) {\n            sculptData.meanDistance = this.calculateMeanConsecutiveDistance(points);\n        }\n        const maxInterDistance = sculptData.meanDistance * CircleSculptCursor.MAX_INTER_DISTANCE_FACTOR;\n        for (let i = mean; i >= 0; i--) {\n            if (i >= numPoints - 1 || i < 0) {\n                continue;\n            }\n            const nextIndex = i + 1;\n            const distanceToNext = point.distanceToPoint(points[i], points[nextIndex]);\n            if (distanceToNext > maxInterDistance) {\n                const pullDirection = this.directionalVector(points[i], points[nextIndex]);\n                const pullStrength = (distanceToNext - sculptData.meanDistance) / sculptData.meanDistance;\n                const adjustmentMagnitude = pullStrength *\n                    sculptData.meanDistance *\n                    CircleSculptCursor.CHAIN_PULL_STRENGTH_FACTOR;\n                points[i][0] += pullDirection[0] * adjustmentMagnitude;\n                points[i][1] += pullDirection[1] * adjustmentMagnitude;\n                points[i][2] += pullDirection[2] * adjustmentMagnitude;\n            }\n        }\n        for (let i = mean + 1; i < numPoints; i++) {\n            if (i >= numPoints || i <= 0) {\n                continue;\n            }\n            const previousIndex = i - 1;\n            const distanceToPrevious = point.distanceToPoint(points[i], points[previousIndex]);\n            if (distanceToPrevious > maxInterDistance) {\n                const pullDirection = this.directionalVector(points[i], points[previousIndex]);\n                const pullStrength = (distanceToPrevious - sculptData.meanDistance) /\n                    sculptData.meanDistance;\n                const adjustmentMagnitude = pullStrength *\n                    sculptData.meanDistance *\n                    CircleSculptCursor.CHAIN_PULL_STRENGTH_FACTOR;\n                points[i][0] += pullDirection[0] * adjustmentMagnitude;\n                points[i][1] += pullDirection[1] * adjustmentMagnitude;\n                points[i][2] += pullDirection[2] * adjustmentMagnitude;\n            }\n        }\n    }\n}\nexport default CircleSculptCursor;\n", "import { getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { getAnnotations } from '../stateManagement';\nimport { point } from '../utilities/math';\nimport { Events, ToolModes, AnnotationStyleStates, ChangeTypes, } from '../enums';\nimport { triggerAnnotationRenderForViewportIds } from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { hideElementCursor, resetElementCursor, } from '../cursors/elementCursor';\nimport { getStyleProperty } from '../stateManagement/annotation/config/helpers';\nimport { triggerAnnotationModified } from '../stateManagement/annotation/helpers/state';\nimport CircleSculptCursor from './SculptorTool/CircleSculptCursor';\nimport { distancePointToContour } from './distancePointToContour';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nclass SculptorTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            minSpacing: 1,\n            referencedToolNames: [\n                'PlanarFreehandROI',\n                'PlanarFreehandContourSegmentationTool',\n            ],\n            toolShape: 'circle',\n            referencedToolName: 'PlanarFreehandROI',\n            updateCursorSize: 'dynamic',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.registeredShapes = new Map();\n        this.isActive = false;\n        this.commonData = {\n            activeAnnotationUID: null,\n            viewportIdsToRender: [],\n            isEditingOpenContour: false,\n            canvasLocation: undefined,\n        };\n        this.preMouseDownCallback = (evt) => {\n            const eventData = evt.detail;\n            const element = eventData.element;\n            this.configureToolSize(evt);\n            this.selectFreehandTool(eventData);\n            if (this.commonData.activeAnnotationUID === null) {\n                return;\n            }\n            this.isActive = true;\n            hideElementCursor(element);\n            this.activateModify(element);\n            return true;\n        };\n        this.mouseMoveCallback = (evt) => {\n            if (this.mode === ToolModes.Active) {\n                this.configureToolSize(evt);\n                this.updateCursor(evt);\n            }\n            else {\n                this.commonData.canvasLocation = undefined;\n            }\n        };\n        this.endCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const config = this.configuration;\n            const enabledElement = getEnabledElement(element);\n            this.isActive = false;\n            this.deactivateModify(element);\n            resetElementCursor(element);\n            const { renderingEngineId, viewportId } = enabledElement;\n            const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n            const toolInstance = toolGroup.getToolInstance(config.referencedToolName);\n            const annotations = this.filterSculptableAnnotationsForElement(element);\n            const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);\n            if (toolInstance.configuration.calculateStats) {\n                activeAnnotation.invalidated = true;\n            }\n            triggerAnnotationModified(activeAnnotation, element, ChangeTypes.HandlesUpdated);\n        };\n        this.dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const element = eventData.element;\n            this.updateCursor(evt);\n            const annotations = this.filterSculptableAnnotationsForElement(element);\n            const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);\n            if (!annotations?.length || !this.isActive) {\n                return;\n            }\n            const points = activeAnnotation.data.contour.polyline;\n            this.sculpt(eventData, points);\n        };\n        this.registerShapes(CircleSculptCursor.shapeName, CircleSculptCursor);\n        this.setToolShape(this.configuration.toolShape);\n    }\n    registerShapes(shapeName, shapeClass) {\n        const shape = new shapeClass();\n        this.registeredShapes.set(shapeName, shape);\n    }\n    sculpt(eventData, points) {\n        const config = this.configuration;\n        const element = eventData.element;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        this.sculptData = {\n            mousePoint: eventData.currentPoints.world,\n            mouseCanvasPoint: eventData.currentPoints.canvas,\n            deltaWorld: eventData.deltaPoints.world,\n            points,\n            maxSpacing: cursorShape.getMaxSpacing(config.minSpacing),\n            element: element,\n        };\n        const pushedHandles = cursorShape.pushHandles(viewport, this.sculptData);\n        if (pushedHandles.first !== undefined) {\n            this.insertNewHandles(pushedHandles);\n        }\n    }\n    interpolatePointsWithinMaxSpacing(i, points, indicesToInsertAfter, maxSpacing) {\n        const { element } = this.sculptData;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const nextHandleIndex = contourIndex(i + 1, points.length);\n        const currentCanvasPoint = viewport.worldToCanvas(points[i]);\n        const nextCanvasPoint = viewport.worldToCanvas(points[nextHandleIndex]);\n        const distanceToNextHandle = point.distanceToPoint(currentCanvasPoint, nextCanvasPoint);\n        if (distanceToNextHandle > maxSpacing) {\n            indicesToInsertAfter.push(i);\n        }\n    }\n    updateCursor(evt) {\n        const eventData = evt.detail;\n        const element = eventData.element;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine, viewport } = enabledElement;\n        this.commonData.viewportIdsToRender = [viewport.id];\n        const annotations = this.filterSculptableAnnotationsForElement(element);\n        if (!annotations?.length) {\n            return;\n        }\n        const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);\n        this.commonData.canvasLocation = eventData.currentPoints.canvas;\n        if (this.isActive) {\n            activeAnnotation.highlighted = true;\n        }\n        else {\n            const cursorShape = this.registeredShapes.get(this.selectedShape);\n            const canvasCoords = eventData.currentPoints.canvas;\n            if (this.configuration.updateCursorSize === 'dynamic') {\n                cursorShape.updateToolSize(canvasCoords, viewport, activeAnnotation);\n            }\n        }\n        triggerAnnotationRenderForViewportIds(this.commonData.viewportIdsToRender);\n    }\n    filterSculptableAnnotationsForElement(element) {\n        const config = this.configuration;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngineId, viewportId } = enabledElement;\n        const sculptableAnnotations = [];\n        const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n        const toolInstance = toolGroup.getToolInstance(config.referencedToolName);\n        config.referencedToolNames.forEach((referencedToolName) => {\n            const annotations = getAnnotations(referencedToolName, element);\n            if (annotations) {\n                sculptableAnnotations.push(...annotations);\n            }\n        });\n        return toolInstance.filterInteractableAnnotationsForElement(element, sculptableAnnotations);\n    }\n    configureToolSize(evt) {\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        cursorShape.configureToolSize(evt);\n    }\n    insertNewHandles(pushedHandles) {\n        const indicesToInsertAfter = this.findNewHandleIndices(pushedHandles);\n        let newIndexModifier = 0;\n        for (let i = 0; i < indicesToInsertAfter?.length; i++) {\n            const insertIndex = indicesToInsertAfter[i] + 1 + newIndexModifier;\n            this.insertHandleRadially(insertIndex);\n            newIndexModifier++;\n        }\n    }\n    findNewHandleIndices(pushedHandles) {\n        const { points, maxSpacing } = this.sculptData;\n        const indicesToInsertAfter = [];\n        for (let i = pushedHandles.first; i <= pushedHandles.last; i++) {\n            this.interpolatePointsWithinMaxSpacing(i, points, indicesToInsertAfter, maxSpacing);\n        }\n        return indicesToInsertAfter;\n    }\n    insertHandleRadially(insertIndex) {\n        const { points } = this.sculptData;\n        if (insertIndex > points.length - 1 &&\n            this.commonData.isEditingOpenContour) {\n            return;\n        }\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        const previousIndex = insertIndex - 1;\n        const nextIndex = contourIndex(insertIndex, points.length);\n        const insertPosition = cursorShape.getInsertPosition(previousIndex, nextIndex, this.sculptData);\n        const handleData = insertPosition;\n        points.splice(insertIndex, 0, handleData);\n    }\n    selectFreehandTool(eventData) {\n        const closestAnnotationUID = this.getClosestFreehandToolOnElement(eventData);\n        if (closestAnnotationUID === undefined) {\n            return;\n        }\n        this.commonData.activeAnnotationUID = closestAnnotationUID;\n    }\n    getClosestFreehandToolOnElement(eventData) {\n        const { element } = eventData;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const config = this.configuration;\n        const annotations = this.filterSculptableAnnotationsForElement(element);\n        if (!annotations?.length) {\n            return;\n        }\n        const canvasPoints = eventData.currentPoints.canvas;\n        const closest = {\n            distance: Infinity,\n            toolIndex: undefined,\n            annotationUID: undefined,\n        };\n        for (let i = 0; i < annotations?.length; i++) {\n            if (annotations[i].isLocked || !annotations[i].isVisible) {\n                continue;\n            }\n            const distanceFromTool = distancePointToContour(viewport, annotations[i], canvasPoints);\n            if (distanceFromTool === -1) {\n                continue;\n            }\n            if (distanceFromTool < closest.distance) {\n                closest.distance = distanceFromTool;\n                closest.toolIndex = i;\n                closest.annotationUID = annotations[i].annotationUID;\n            }\n        }\n        this.commonData.isEditingOpenContour =\n            !annotations[closest.toolIndex].data.contour.closed;\n        config.referencedToolName =\n            annotations[closest.toolIndex].metadata.toolName;\n        return closest.annotationUID;\n    }\n    activateModify(element) {\n        element.addEventListener(Events.MOUSE_UP, this.endCallback);\n        element.addEventListener(Events.MOUSE_CLICK, this.endCallback);\n        element.addEventListener(Events.MOUSE_DRAG, this.dragCallback);\n        element.addEventListener(Events.TOUCH_TAP, this.endCallback);\n        element.addEventListener(Events.TOUCH_END, this.endCallback);\n        element.addEventListener(Events.TOUCH_DRAG, this.dragCallback);\n    }\n    deactivateModify(element) {\n        element.removeEventListener(Events.MOUSE_UP, this.endCallback);\n        element.removeEventListener(Events.MOUSE_CLICK, this.endCallback);\n        element.removeEventListener(Events.MOUSE_DRAG, this.dragCallback);\n        element.removeEventListener(Events.TOUCH_TAP, this.endCallback);\n        element.removeEventListener(Events.TOUCH_END, this.endCallback);\n        element.removeEventListener(Events.TOUCH_DRAG, this.dragCallback);\n    }\n    setToolShape(toolShape) {\n        this.selectedShape =\n            this.registeredShapes.get(toolShape) ?? CircleSculptCursor.shapeName;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        const viewportIdsToRender = this.commonData.viewportIdsToRender;\n        if (!this.commonData.canvasLocation ||\n            this.mode !== ToolModes.Active ||\n            !viewportIdsToRender.includes(viewport.id)) {\n            return;\n        }\n        const annotations = this.filterSculptableAnnotationsForElement(element);\n        if (!annotations?.length) {\n            return;\n        }\n        const styleSpecifier = {\n            toolGroupId: this.toolGroupId,\n            toolName: this.getToolName(),\n            viewportId: enabledElement.viewport.id,\n        };\n        let color = getStyleProperty('color', styleSpecifier, AnnotationStyleStates.Default, this.mode);\n        if (this.isActive) {\n            color = getStyleProperty('color', styleSpecifier, AnnotationStyleStates.Highlighted, this.mode);\n        }\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        cursorShape.renderShape(svgDrawingHelper, this.commonData.canvasLocation, {\n            color,\n        });\n    }\n}\nexport const contourIndex = (i, length) => {\n    return (i + length) % length;\n};\nSculptorTool.toolName = 'SculptorTool';\nexport default SculptorTool;\n", "import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nconst DIRECTIONS = {\n    X: [1, 0, 0],\n    Y: [0, 1, 0],\n    Z: [0, 0, 1],\n    CUSTOM: [],\n};\nclass VolumeRotateTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            direction: DIRECTIONS.Z,\n            rotateIncrementDegrees: 30,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n    }\n    mouseWheelCallback(evt) {\n        const { element, wheel } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { direction, rotateIncrementDegrees } = this.configuration;\n        const camera = viewport.getCamera();\n        const { viewUp, position, focalPoint } = camera;\n        const { direction: deltaY } = wheel;\n        const [cx, cy, cz] = focalPoint;\n        const [ax, ay, az] = direction;\n        const angle = (deltaY * (rotateIncrementDegrees * Math.PI)) / 180;\n        const newPosition = [0, 0, 0];\n        const newFocalPoint = [0, 0, 0];\n        const newViewUp = [0, 0, 0];\n        const transform = mat4.identity(new Float32Array(16));\n        mat4.translate(transform, transform, [cx, cy, cz]);\n        mat4.rotate(transform, transform, angle, [ax, ay, az]);\n        mat4.translate(transform, transform, [-cx, -cy, -cz]);\n        vec3.transformMat4(newPosition, position, transform);\n        vec3.transformMat4(newFocalPoint, focalPoint, transform);\n        mat4.identity(transform);\n        mat4.rotate(transform, transform, angle, [ax, ay, az]);\n        vec3.transformMat4(newViewUp, viewUp, transform);\n        viewport.setCamera({\n            position: newPosition,\n            viewUp: newViewUp,\n            focalPoint: newFocalPoint,\n        });\n        viewport.render();\n    }\n}\nVolumeRotateTool.toolName = 'VolumeRotateMouseWheel';\nexport default VolumeRotateTool;\n", "import { vec2 } from 'gl-matrix';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { drawTextBox as drawTextBoxSvg } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nclass LabelTool extends AnnotationTool {\n    static { this.toolName = 'Label'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            getTextCallback,\n            changeTextCallback,\n            preventHandleOutsideImage: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { annotationUID } = annotation;\n            const point = annotation.data.handles.points[0];\n            const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n            const dist = vec2.distance(canvasCoords, annotationCanvasCoordinate);\n            if (dist < proximity) {\n                return true;\n            }\n            const svgLayer = element.querySelector('svg');\n            if (!svgLayer) {\n                return false;\n            }\n            const textGroup = svgLayer.querySelector(`g[data-annotation-uid=\"${annotationUID}\"]`);\n            if (!textGroup) {\n                return false;\n            }\n            const textGroupElement = textGroup;\n            const bbox = textGroupElement.getBBox();\n            const transform = textGroupElement.getAttribute('transform');\n            let translateX = 0;\n            let translateY = 0;\n            if (transform) {\n                const matches = transform.match(/translate\\(([-\\d.]+)\\s+([-\\d.]+)\\)/);\n                if (matches) {\n                    translateX = parseFloat(matches[1]);\n                    translateY = parseFloat(matches[2]);\n                }\n            }\n            const x = bbox.x + translateX;\n            const y = bbox.y + translateY;\n            const isNear = canvasCoords[0] >= x &&\n                canvasCoords[0] <= x + bbox.width &&\n                canvasCoords[1] >= y &&\n                canvasCoords[1] <= y + bbox.height;\n            return isNear;\n        };\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const annotation = (this.createAnnotation(evt, [\n                [...worldPos],\n                [...worldPos],\n            ]));\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                newAnnotation: true,\n                viewportIdsToRender,\n                offset: [0, 0, 0],\n            };\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.configuration.getTextCallback((label) => {\n                if (!label) {\n                    removeAnnotation(annotation.annotationUID);\n                    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                    this.isDrawing = false;\n                    return;\n                }\n                resetElementCursor(element);\n                annotation.data.label = label;\n                triggerAnnotationCompleted(annotation);\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            });\n            this.createMemo(element, annotation, { newAnnotation: true });\n            return annotation;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            let offset = [0, 0, 0];\n            if (currentPoints && currentPoints.world) {\n                const initialWorldPos = currentPoints.world;\n                const anchorWorldPos = annotation.data.handles.points[0];\n                offset = [\n                    anchorWorldPos[0] - initialWorldPos[0],\n                    anchorWorldPos[1] - initialWorldPos[1],\n                    anchorWorldPos[2] - initialWorldPos[2],\n                ];\n            }\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                offset,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            this._deactivateDraw(element);\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            if (newAnnotation) {\n                this.createMemo(element, annotation, { newAnnotation });\n            }\n            this.editData = null;\n            this.isDrawing = false;\n            this.doneEditMemo();\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { annotation, viewportIdsToRender, offset } = this.editData;\n            if (offset) {\n                annotation.data.handles.points[0] = [\n                    worldPos[0] + offset[0],\n                    worldPos[1] + offset[1],\n                    worldPos[2] + offset[2],\n                ];\n            }\n            else {\n                annotation.data.handles.points[0] = [...worldPos];\n            }\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationModified(annotation, element, ChangeTypes.LabelChange);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const point = data.handles.points[0];\n                styleSpecifier.annotationUID = annotationUID;\n                const canvasCoordinates = viewport.worldToCanvas(point);\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!data.label) {\n                    continue;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                const textBoxUID = '1';\n                drawTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, [data.label], canvasCoordinates, {\n                    ...options,\n                    padding: 0,\n                });\n            }\n            return renderStatus;\n        };\n    }\n    static { this.hydrate = (viewportId, position, label, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\n        const instance = new this();\n        const referencedImageId = instance.getReferencedImageId(viewport, position, viewPlaneNormal, viewUp);\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                label,\n                handles: {\n                    points: [position],\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...options,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(_evt, _annotation, _handle, _interactionType) { }\n    _doneChangingTextCallback(element, annotation, updatedLabel) {\n        annotation.data.label = updatedLabel;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        triggerAnnotationModified(annotation, element);\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction getTextCallback(doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nLabelTool.toolName = 'Label';\nexport default LabelTool;\n", "import { Events, ChangeTypes } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, utilities, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nconst { transformWorldToIndex } = csUtils;\nclass LengthTool extends AnnotationTool {\n    static { this.toolName = 'Length'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            actions: {\n                undo: {\n                    method: 'undo',\n                    bindings: [{ key: 'z' }],\n                },\n                redo: {\n                    method: 'redo',\n                    bindings: [{ key: 'y' }],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const annotation = (this.createAnnotation(evt, [\n                [...worldPos],\n                [...worldPos],\n            ]));\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const dataId = `${annotationUID}-line`;\n                const lineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId);\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(LengthTool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateLength(pos1, pos2) {\n        const dx = pos1[0] - pos2[0];\n        const dy = pos1[1] - pos2[1];\n        const dz = pos1[2] - pos2[2];\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[1];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { imageData, dimensions } = image;\n            const index1 = transformWorldToIndex(imageData, worldPos1);\n            const index2 = transformWorldToIndex(imageData, worldPos2);\n            const handles = [index1, index2];\n            const { scale, unit } = getCalibratedLengthUnitsAndScale(image, handles);\n            const length = this._calculateLength(worldPos1, worldPos2) / scale;\n            if (this._isInsideVolume(index1, index2, dimensions)) {\n                this.isHandleOutsideImage = false;\n            }\n            else {\n                this.isHandleOutsideImage = true;\n            }\n            cachedStats[targetId] = {\n                length,\n                unit,\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { length, unit } = cachedVolumeStats;\n    if (length === undefined || length === null || isNaN(length)) {\n        return;\n    }\n    const textLines = [`${csUtils.roundNumber(length)} ${unit}`];\n    return textLines;\n}\nexport default LengthTool;\n", "import { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawHeight as drawHeightSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nconst { transformWorldToIndex } = csUtils;\nclass HeightTool extends AnnotationTool {\n    static { this.toolName = 'Height'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const annotation = (this.createAnnotation(evt, [\n                [...worldPos],\n                [...worldPos],\n            ]));\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const enabledElement = getEnabledElement(element);\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                let activeHandleCanvasCoords;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const heightUID = '0';\n                drawHeightSvg(svgDrawingHelper, annotationUID, heightUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash: lineDash,\n                });\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateHeight(pos1, pos2) {\n        const dx = pos2[0] - pos1[0];\n        const dy = pos2[1] - pos1[1];\n        const dz = pos2[2] - pos1[2];\n        if (dx == 0) {\n            if (dy != 0) {\n                return Math.abs(dz);\n            }\n            else {\n                return 0;\n            }\n        }\n        else if (dy == 0) {\n            return Math.abs(dz);\n        }\n        else if (dz == 0) {\n            return Math.abs(dy);\n        }\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[1];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { imageData, dimensions } = image;\n            const index1 = transformWorldToIndex(imageData, worldPos1);\n            const index2 = transformWorldToIndex(imageData, worldPos2);\n            const handles = [index1, index2];\n            const { scale, unit } = getCalibratedLengthUnitsAndScale(image, handles);\n            const height = this._calculateHeight(worldPos1, worldPos2) / scale;\n            const outside = this._isInsideVolume(index1, index2, dimensions);\n            this.isHandleOutsideImage = outside;\n            cachedStats[targetId] = {\n                height,\n                unit,\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { height, unit } = cachedVolumeStats;\n    if (height === undefined || height === null || isNaN(height)) {\n        return;\n    }\n    const textLines = [`${csUtils.roundNumber(height)} ${unit}`];\n    return textLines;\n}\nexport default HeightTool;\n", "import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { getCalibratedProbeUnitsAndValue } from '../../utilities/getCalibratedUnits';\nimport { drawHandles as drawHandlesSvg, drawTextBox as drawTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nconst { transformWorldToIndex } = csUtils;\nclass ProbeTool extends AnnotationTool {\n    static { this.toolName = 'Probe'; }\n    static { this.probeDefaults = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            handleRadius: '6',\n            textCanvasOffset: {\n                x: 6,\n                y: -6,\n            },\n        },\n    }; }\n    constructor(toolProps = {}, defaultToolProps) {\n        super(toolProps, AnnotationTool.mergeDefaultProps(ProbeTool.probeDefaults, defaultToolProps));\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const annotation = (this.constructor).createAnnotationForViewport(viewport, {\n                data: {\n                    handles: { points: [[...worldPos]] },\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                newAnnotation: true,\n                viewportIdsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { viewportId, renderingEngine } = getEnabledElement(element);\n            this.eventDispatchDetail = {\n                viewportId,\n                renderingEngineId: renderingEngine.id,\n            };\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            if (newAnnotation) {\n                this.createMemo(element, annotation, { newAnnotation });\n            }\n            this.editData = null;\n            this.isDrawing = false;\n            this.doneEditMemo();\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            data.handles.points[0] = [...worldPos];\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const annotationUID = annotation.annotationUID;\n                const data = annotation.data;\n                const point = data.handles.points[0];\n                const canvasCoordinates = viewport.worldToCanvas(point);\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                if (!data.cachedStats) {\n                    data.cachedStats = {};\n                }\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].value === null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        index: null,\n                        value: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement, ChangeTypes.StatsUpdated);\n                }\n                else if (annotation.invalidated) {\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                const handleGroupUID = '0';\n                drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color, lineWidth, handleRadius: this.configuration.handleRadius });\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (textLines) {\n                    const textCanvasCoordinates = [\n                        canvasCoordinates[0] + this.configuration.textCanvasOffset.x,\n                        canvasCoordinates[1] + this.configuration.textCanvasOffset.y,\n                    ];\n                    const textUID = '0';\n                    drawTextBoxSvg(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], options);\n                }\n            }\n            return renderStatus;\n        };\n    }\n    isPointNearTool(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { data } = annotation;\n        const point = data.handles.points[0];\n        const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n        return vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n    }\n    toolSelectedCallback() { }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, viewUp, instance, viewport, } = this.hydrateBase(ProbeTool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { data } = annotation;\n        const point = data.handles.points[0];\n        const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n        const near = vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n        if (near === true) {\n            return point;\n        }\n    }\n    handleSelectedCallback(evt, annotation) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        annotation.highlighted = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement, changeType = ChangeTypes.StatsUpdated) {\n        const data = annotation.data;\n        const { renderingEngineId, viewport } = enabledElement;\n        const { element } = viewport;\n        const worldPos = data.handles.points[0];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const pixelUnitsOptions = {\n                isPreScaled: isViewportPreScaled(viewport, targetId),\n                isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n            };\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { dimensions, imageData, metadata, voxelManager } = image;\n            const modality = metadata.Modality;\n            let ijk = transformWorldToIndex(imageData, worldPos);\n            ijk = vec3.round(ijk, ijk);\n            if (csUtils.indexWithinDimensions(ijk, dimensions)) {\n                this.isHandleOutsideImage = false;\n                let value = voxelManager.getAtIJKPoint(ijk);\n                if (targetId.startsWith('imageId:')) {\n                    const imageId = targetId.split('imageId:')[1];\n                    const imageURI = csUtils.imageIdToURI(imageId);\n                    const viewports = csUtils.getViewportsWithImageURI(imageURI);\n                    const viewport = viewports[0];\n                    ijk[2] = viewport.getCurrentImageIdIndex();\n                }\n                let modalityUnit;\n                if (modality === 'US') {\n                    const calibratedResults = getCalibratedProbeUnitsAndValue(image, [\n                        ijk,\n                    ]);\n                    const hasEnhancedRegionValues = calibratedResults.values.every((value) => value !== null);\n                    value = (hasEnhancedRegionValues ? calibratedResults.values : value);\n                    modalityUnit = hasEnhancedRegionValues\n                        ? calibratedResults.units\n                        : 'raw';\n                }\n                else {\n                    modalityUnit = getPixelValueUnits(modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                }\n                cachedStats[targetId] = {\n                    index: ijk,\n                    value,\n                    Modality: modality,\n                    modalityUnit,\n                };\n                annotation.invalidated = true;\n            }\n            else {\n                this.isHandleOutsideImage = true;\n                cachedStats[targetId] = {\n                    index: ijk,\n                    Modality: modality,\n                };\n            }\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, changeType);\n        }\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { index, value, modalityUnit } = cachedVolumeStats;\n    if (value === undefined || !index) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n    if (value instanceof Array && modalityUnit instanceof Array) {\n        for (let i = 0; i < value.length; i++) {\n            textLines.push(`${csUtils.roundNumber(value[i])} ${modalityUnit[i]}`);\n        }\n    }\n    else {\n        textLines.push(`${csUtils.roundNumber(value)} ${modalityUnit}`);\n    }\n    return textLines;\n}\nexport default ProbeTool;\n", "import { getEnabledElement } from '@cornerstonejs/core';\nimport { drawHandles as drawHandlesSvg, drawTextBox as drawTextBoxSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport ProbeTool from './ProbeTool';\nclass DragProbeTool extends ProbeTool {\n    static { this.toolName = 'DragProbe'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.postMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                isVisible: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId,\n                },\n                data: {\n                    label: '',\n                    handles: { points: [[...worldPos]] },\n                    cachedStats: {},\n                },\n            };\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                newAnnotation: true,\n                viewportIdsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.postTouchStartCallback = (evt) => {\n            return this.postMouseDownCallback(evt);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const annotations = this.filterInteractableAnnotationsForElement(viewport.element, [this.editData.annotation]);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const annotation = this.editData.annotation;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const point = data.handles.points[0];\n            const canvasCoordinates = viewport.worldToCanvas(point);\n            styleSpecifier.annotationUID = annotationUID;\n            const { color } = this.getAnnotationStyle({\n                annotation,\n                styleSpecifier,\n            });\n            if (!data.cachedStats[targetId] ||\n                data.cachedStats[targetId].value === null) {\n                data.cachedStats[targetId] = {\n                    Modality: null,\n                    index: null,\n                    value: null,\n                };\n                this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n            }\n            else if (annotation.invalidated) {\n                this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n            }\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const handleGroupUID = '0';\n            drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color });\n            renderStatus = true;\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (textLines) {\n                const textCanvasCoordinates = [\n                    canvasCoordinates[0] + 6,\n                    canvasCoordinates[1] - 6,\n                ];\n                const textUID = '0';\n                drawTextBoxSvg(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n            }\n            return renderStatus;\n        };\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { index, value, modalityUnit } = cachedVolumeStats;\n    if (value === undefined) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n    textLines.push(`${value.toFixed(2)} ${modalityUnit}`);\n    return textLines;\n}\nexport default DragProbeTool;\n", "import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, EPSILON, } from '@cornerstonejs/core';\nimport { getCalibratedAspect, getCalibratedLengthUnitsAndScale, } from '../../utilities/getCalibratedUnits';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawEllipseByCoordinates as drawEllipseSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { pointInEllipse, getCanvasEllipseCorners, } from '../../utilities/math/ellipse';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport { vec2 } from 'gl-matrix';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nconst { transformWorldToIndex } = csUtils;\nclass EllipticalROITool extends AnnotationTool {\n    static { this.toolName = 'EllipticalROI'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            storePointData: false,\n            centerPointRadius: 0,\n            calculateStats: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            this.isDrawing = true;\n            const annotation = (this.createAnnotation(evt, [\n                [...worldPos],\n                [...worldPos],\n                [...worldPos],\n                [...worldPos],\n            ]));\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                centerWorld: worldPos,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const [bottom, top, left, right] = canvasCoordinates;\n            const w = Math.hypot(left[0] - right[0], left[1] - right[1]);\n            const h = Math.hypot(top[0] - bottom[0], top[1] - bottom[1]);\n            const angle = Math.atan2(left[1] - right[1], left[0] - right[0]);\n            const center = [(left[0] + right[0]) / 2, (top[1] + bottom[1]) / 2];\n            const minorEllipse = {\n                center,\n                xRadius: (w - proximity) / 2,\n                yRadius: (h - proximity) / 2,\n                angle,\n            };\n            const majorEllipse = {\n                center,\n                xRadius: (w + proximity) / 2,\n                yRadius: (h + proximity) / 2,\n                angle,\n            };\n            const pointInMinorEllipse = this._pointInEllipseCanvas(minorEllipse, canvasCoords);\n            const pointInMajorEllipse = this._pointInEllipseCanvas(majorEllipse, canvasCoords);\n            if (pointInMajorEllipse && !pointInMinorEllipse) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            let centerCanvas;\n            let centerWorld;\n            let canvasWidth;\n            let canvasHeight;\n            let originalHandleCanvas;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                const { viewport } = getEnabledElement(element);\n                const { worldToCanvas, canvasToWorld } = viewport;\n                handleIndex = points.findIndex((p) => p === handle);\n                const pointsCanvas = points.map(worldToCanvas);\n                originalHandleCanvas = pointsCanvas[handleIndex];\n                canvasWidth = Math.abs(pointsCanvas[2][0] - pointsCanvas[3][0]);\n                canvasHeight = Math.abs(pointsCanvas[0][1] - pointsCanvas[1][1]);\n                centerCanvas = [\n                    (pointsCanvas[2][0] + pointsCanvas[3][0]) / 2,\n                    (pointsCanvas[0][1] + pointsCanvas[1][1]) / 2,\n                ];\n                centerWorld = canvasToWorld(centerCanvas);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                canvasWidth,\n                canvasHeight,\n                centerWorld,\n                originalHandleCanvas,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, centerWorld, newAnnotation } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const centerCanvas = viewport.worldToCanvas(centerWorld);\n            const { data } = annotation;\n            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n            const bottomCanvas = [centerCanvas[0], centerCanvas[1] - dY];\n            const topCanvas = [centerCanvas[0], centerCanvas[1] + dY];\n            const leftCanvas = [centerCanvas[0] - dX, centerCanvas[1]];\n            const rightCanvas = [centerCanvas[0] + dX, centerCanvas[1]];\n            data.handles.points = [\n                canvasToWorld(bottomCanvas),\n                canvasToWorld(topCanvas),\n                canvasToWorld(leftCanvas),\n                canvasToWorld(rightCanvas),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragHandle(evt);\n                annotation.invalidated = true;\n            }\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { viewport } = getEnabledElement(element);\n            const { canvasToWorld, worldToCanvas } = viewport;\n            const { annotation, canvasWidth, canvasHeight, handleIndex, centerWorld, originalHandleCanvas, } = this.editData;\n            const centerCanvas = viewport.worldToCanvas(centerWorld);\n            const { data } = annotation;\n            const { points } = data.handles;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            if (handleIndex === 0 || handleIndex === 1) {\n                const dYCanvas = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n                const canvasBottom = [\n                    centerCanvas[0],\n                    centerCanvas[1] - dYCanvas,\n                ];\n                const canvasTop = [\n                    centerCanvas[0],\n                    centerCanvas[1] + dYCanvas,\n                ];\n                points[0] = canvasToWorld(canvasBottom);\n                points[1] = canvasToWorld(canvasTop);\n                const dXCanvas = currentCanvasPoints[0] - originalHandleCanvas[0];\n                const newHalfCanvasWidth = canvasWidth / 2 + dXCanvas;\n                const canvasLeft = [\n                    centerCanvas[0] - newHalfCanvasWidth,\n                    centerCanvas[1],\n                ];\n                const canvasRight = [\n                    centerCanvas[0] + newHalfCanvasWidth,\n                    centerCanvas[1],\n                ];\n                points[2] = canvasToWorld(canvasLeft);\n                points[3] = canvasToWorld(canvasRight);\n            }\n            else {\n                const dXCanvas = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n                const canvasLeft = [\n                    centerCanvas[0] - dXCanvas,\n                    centerCanvas[1],\n                ];\n                const canvasRight = [\n                    centerCanvas[0] + dXCanvas,\n                    centerCanvas[1],\n                ];\n                points[2] = canvasToWorld(canvasLeft);\n                points[3] = canvasToWorld(canvasRight);\n                const dYCanvas = currentCanvasPoints[1] - originalHandleCanvas[1];\n                const newHalfCanvasHeight = canvasHeight / 2 + dYCanvas;\n                const canvasBottom = [\n                    centerCanvas[0],\n                    centerCanvas[1] - newHalfCanvasHeight,\n                ];\n                const canvasTop = [\n                    centerCanvas[0],\n                    centerCanvas[1] + newHalfCanvasHeight,\n                ];\n                points[0] = canvasToWorld(canvasBottom);\n                points[1] = canvasToWorld(canvasTop);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const canvasCorners = (getCanvasEllipseCorners(canvasCoordinates));\n                const { centerPointRadius } = this.configuration;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit == null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                    };\n                    this._calculateCachedStats(annotation, viewport, renderingEngine);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, showHandlesAlways ? canvasCoordinates : activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-ellipse`;\n                const ellipseUID = '0';\n                drawEllipseSvg(svgDrawingHelper, annotationUID, ellipseUID, canvasCoordinates, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                if (centerPointRadius > 0) {\n                    const minRadius = Math.min(Math.abs(canvasCorners[0][0] - canvasCorners[1][0]) / 2, Math.abs(canvasCorners[0][1] - canvasCorners[1][1]) / 2);\n                    if (minRadius > 3 * centerPointRadius) {\n                        const centerPoint = this._getCanvasEllipseCenter(canvasCoordinates);\n                        drawCircleSvg(svgDrawingHelper, annotationUID, `${ellipseUID}-center`, centerPoint, centerPointRadius, {\n                            color,\n                            lineDash,\n                            lineWidth,\n                        });\n                    }\n                }\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const data = annotation.data;\n            const { element } = viewport;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const { viewPlaneNormal, viewUp } = viewport.getCamera();\n            const [topLeftCanvas, bottomRightCanvas] = (getCanvasEllipseCorners(canvasCoordinates));\n            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            const worldPos1 = topLeftWorld;\n            const worldPos2 = bottomRightWorld;\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, voxelManager } = image;\n                const pos1Index = transformWorldToIndex(imageData, worldPos1);\n                pos1Index[0] = Math.floor(pos1Index[0]);\n                pos1Index[1] = Math.floor(pos1Index[1]);\n                pos1Index[2] = Math.floor(pos1Index[2]);\n                const pos2Index = transformWorldToIndex(imageData, worldPos2);\n                pos2Index[0] = Math.floor(pos2Index[0]);\n                pos2Index[1] = Math.floor(pos2Index[1]);\n                pos2Index[2] = Math.floor(pos2Index[2]);\n                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {\n                    const iMin = Math.min(pos1Index[0], pos2Index[0]);\n                    const iMax = Math.max(pos1Index[0], pos2Index[0]);\n                    const jMin = Math.min(pos1Index[1], pos2Index[1]);\n                    const jMax = Math.max(pos1Index[1], pos2Index[1]);\n                    const kMin = Math.min(pos1Index[2], pos2Index[2]);\n                    const kMax = Math.max(pos1Index[2], pos2Index[2]);\n                    const boundsIJK = [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ];\n                    const center = [\n                        (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n                        (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n                        (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n                    ];\n                    const xRadius = Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2;\n                    const yRadius = Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2;\n                    const zRadius = Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2;\n                    const ellipseObj = {\n                        center,\n                        xRadius: xRadius < EPSILON / 2 ? 0 : xRadius,\n                        yRadius: yRadius < EPSILON / 2 ? 0 : yRadius,\n                        zRadius: zRadius < EPSILON / 2 ? 0 : zRadius,\n                    };\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n                    const handles = [pos1Index, pos2Index];\n                    const { scale, unit, areaUnit } = getCalibratedLengthUnitsAndScale(image, handles);\n                    const aspect = getCalibratedAspect(image);\n                    const area = Math.abs(Math.PI *\n                        (worldWidth / scale / 2) *\n                        (worldHeight / aspect / scale / 2));\n                    const pixelUnitsOptions = {\n                        isPreScaled: isViewportPreScaled(viewport, targetId),\n                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                    };\n                    const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                    let pointsInShape;\n                    if (voxelManager) {\n                        pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                            isInObject: (pointLPS) => pointInEllipse(ellipseObj, pointLPS, { fast: true }),\n                            boundsIJK,\n                            imageData,\n                            returnPoints: this.configuration.storePointData,\n                        });\n                    }\n                    const stats = this.configuration.statsCalculator.getStatistics();\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean: stats.mean?.value,\n                        max: stats.max?.value,\n                        min: stats.min?.value,\n                        stdDev: stats.stdDev?.value,\n                        statsArray: stats.array,\n                        pointsInShape,\n                        isEmptyArea,\n                        areaUnit,\n                        modalityUnit,\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(EllipticalROITool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    _pointInEllipseCanvas(ellipse, location) {\n        const { xRadius, yRadius, center, angle } = ellipse;\n        const rotLocation = vec2.rotate(vec2.create(), location, center, -angle);\n        if (xRadius <= 0.0 || yRadius <= 0.0) {\n            return false;\n        }\n        const normalized = [rotLocation[0] - center[0], rotLocation[1] - center[1]];\n        const inEllipse = (normalized[0] * normalized[0]) / (xRadius * xRadius) +\n            (normalized[1] * normalized[1]) / (yRadius * yRadius) <=\n            1.0;\n        return inEllipse;\n    }\n    _getCanvasEllipseCenter(ellipseCanvasPoints) {\n        const [bottom, top, left, right] = ellipseCanvasPoints;\n        const topLeft = [left[0], top[1]];\n        const bottomRight = [right[0], bottom[1]];\n        return [\n            (topLeft[0] + bottomRight[0]) / 2,\n            (topLeft[1] + bottomRight[1]) / 2,\n        ];\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit, min } = cachedVolumeStats;\n    const textLines = [];\n    if (csUtils.isNumber(area)) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    if (csUtils.isNumber(mean)) {\n        textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(max)) {\n        textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(min)) {\n        textLines.push(`Min: ${csUtils.roundNumber(min)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(stdDev)) {\n        textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    }\n    return textLines;\n}\nexport default EllipticalROITool;\n", "import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, EPSILON, } from '@cornerstonejs/core';\nimport { getCalibratedAspect, getCalibratedLengthUnitsAndScale, } from '../../utilities/getCalibratedUnits';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { getCanvasCircleCorners, getCanvasCircleRadius, } from '../../utilities/math/circle';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport { vec2, vec3 } from 'gl-matrix';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nconst { transformWorldToIndex } = csUtils;\nclass CircleROITool extends AnnotationTool {\n    static { this.toolName = 'CircleROI'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            storePointData: false,\n            centerPointRadius: 0,\n            calculateStats: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n            simplified: true,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            this.isDrawing = true;\n            let points;\n            if (this.configuration.simplified) {\n                points = [[...worldPos], [...worldPos]];\n            }\n            else {\n                points = [\n                    [...worldPos],\n                    [...worldPos],\n                    [...worldPos],\n                    [...worldPos],\n                    [...worldPos],\n                ];\n            }\n            const annotation = this.createAnnotation(evt, points);\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { points } = annotation.data.handles;\n            const canvasHandles = points.map((p) => viewport.worldToCanvas(p));\n            const canvasCenter = canvasHandles[0];\n            const radius = getCanvasCircleRadius([canvasCenter, canvasHandles[1]]);\n            const radiusPoint = getCanvasCircleRadius([canvasCenter, canvasCoords]);\n            return Math.abs(radiusPoint - radius) < proximity / 2;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                handleIndex = points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const { world: worldPos, canvas: currentCanvasPoints } = currentPoints;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            const centerWorld = data.handles.points[0];\n            const centerCanvas = viewport.worldToCanvas(centerWorld);\n            if (this.configuration.simplified) {\n                data.handles.points[1] = worldPos;\n            }\n            else {\n                const radiusCanvas = vec2.distance(centerCanvas, currentCanvasPoints);\n                data.handles.points[0] = [...centerWorld];\n                data.handles.points[1] = canvasToWorld([\n                    centerCanvas[0],\n                    centerCanvas[1] - radiusCanvas,\n                ]);\n                data.handles.points[2] = canvasToWorld([\n                    centerCanvas[0],\n                    centerCanvas[1] + radiusCanvas,\n                ]);\n                data.handles.points[3] = canvasToWorld([\n                    centerCanvas[0] - radiusCanvas,\n                    centerCanvas[1],\n                ]);\n                data.handles.points[4] = canvasToWorld([\n                    centerCanvas[0] + radiusCanvas,\n                    centerCanvas[1],\n                ]);\n            }\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragHandle(evt);\n                annotation.invalidated = true;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { canvasToWorld, worldToCanvas } = enabledElement.viewport;\n            const { annotation, handleIndex } = this.editData;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const { currentPoints, deltaPoints } = eventDetail;\n            if (handleIndex === 0) {\n                const worldPosDelta = deltaPoints.world;\n                points.forEach((point) => {\n                    vec3.add(point, point, worldPosDelta);\n                });\n            }\n            else {\n                const centerWorld = points[0];\n                const centerCanvas = worldToCanvas(centerWorld);\n                const currentCanvasPoint = currentPoints.canvas;\n                const newRadiusCanvas = vec2.distance(centerCanvas, currentCanvasPoint);\n                points[1] = canvasToWorld([\n                    centerCanvas[0],\n                    centerCanvas[1] - newRadiusCanvas,\n                ]);\n                points[2] = canvasToWorld([\n                    centerCanvas[0],\n                    centerCanvas[1] + newRadiusCanvas,\n                ]);\n                points[3] = canvasToWorld([\n                    centerCanvas[0] - newRadiusCanvas,\n                    centerCanvas[1],\n                ]);\n                points[4] = canvasToWorld([\n                    centerCanvas[0] + newRadiusCanvas,\n                    centerCanvas[1],\n                ]);\n            }\n            annotation.invalidated = true;\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                annotation.highlighted = false;\n                annotation.data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const center = canvasCoordinates[0];\n                const radius = getCanvasCircleRadius([center, canvasCoordinates[1]]);\n                const canvasCorners = getCanvasCircleCorners([\n                    center,\n                    canvasCoordinates[1],\n                ]);\n                const { centerPointRadius } = this.configuration;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit == null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                        radius: null,\n                        radiusUnit: null,\n                        perimeter: null,\n                    };\n                    this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    if (this.configuration.simplified) {\n                        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                    }\n                    else {\n                        activeHandleCanvasCoords = canvasCoordinates;\n                    }\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, showHandlesAlways ? canvasCoordinates : activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-circle`;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                if (centerPointRadius > 0) {\n                    if (radius > 3 * centerPointRadius) {\n                        drawCircleSvg(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {\n                            color,\n                            lineDash,\n                            lineWidth,\n                        });\n                    }\n                }\n                renderStatus = true;\n                if (this.configuration.calculateStats) {\n                    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                    if (!options.visibility) {\n                        data.handles.textBox = {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        };\n                        continue;\n                    }\n                    const textLines = this.configuration.getTextLines(data, targetId);\n                    if (!textLines || textLines.length === 0) {\n                        continue;\n                    }\n                    let canvasTextBoxCoords;\n                    if (!data.handles.textBox.hasMoved) {\n                        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n                        data.handles.textBox.worldPosition =\n                            viewport.canvasToWorld(canvasTextBoxCoords);\n                    }\n                    const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                    const textBoxUID = '1';\n                    const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, [center, canvasCoordinates[1]], {}, options);\n                    const { x: left, y: top, width, height } = boundingBox;\n                    data.handles.textBox.worldBoundingBox = {\n                        topLeft: viewport.canvasToWorld([left, top]),\n                        topRight: viewport.canvasToWorld([left + width, top]),\n                        bottomLeft: viewport.canvasToWorld([left, top + height]),\n                        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                    };\n                }\n            }\n            return renderStatus;\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const data = annotation.data;\n            const { element } = viewport;\n            const wasInvalidated = annotation.invalidated;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const canvasCenter = canvasCoordinates[0];\n            const canvasTop = canvasCoordinates[1];\n            const { viewPlaneNormal, viewUp } = viewport.getCamera();\n            const [topLeftCanvas, bottomRightCanvas] = (getCanvasCircleCorners([canvasCenter, canvasTop]));\n            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            const worldPos1 = topLeftWorld;\n            const worldPos2 = bottomRightWorld;\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, voxelManager } = image;\n                const pos1Index = transformWorldToIndex(imageData, worldPos1);\n                pos1Index[0] = Math.floor(pos1Index[0]);\n                pos1Index[1] = Math.floor(pos1Index[1]);\n                pos1Index[2] = Math.floor(pos1Index[2]);\n                const pos2Index = transformWorldToIndex(imageData, worldPos2);\n                pos2Index[0] = Math.floor(pos2Index[0]);\n                pos2Index[1] = Math.floor(pos2Index[1]);\n                pos2Index[2] = Math.floor(pos2Index[2]);\n                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {\n                    const iMin = Math.min(pos1Index[0], pos2Index[0]);\n                    const iMax = Math.max(pos1Index[0], pos2Index[0]);\n                    const jMin = Math.min(pos1Index[1], pos2Index[1]);\n                    const jMax = Math.max(pos1Index[1], pos2Index[1]);\n                    const kMin = Math.min(pos1Index[2], pos2Index[2]);\n                    const kMax = Math.max(pos1Index[2], pos2Index[2]);\n                    const boundsIJK = [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ];\n                    const center = points[0];\n                    const xRadius = Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2;\n                    const yRadius = Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2;\n                    const zRadius = Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2;\n                    const ellipseObj = {\n                        center,\n                        xRadius: xRadius < EPSILON / 2 ? 0 : xRadius,\n                        yRadius: yRadius < EPSILON / 2 ? 0 : yRadius,\n                        zRadius: zRadius < EPSILON / 2 ? 0 : zRadius,\n                    };\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n                    const handles = [pos1Index, pos2Index];\n                    const { scale, unit, areaUnit } = getCalibratedLengthUnitsAndScale(image, handles);\n                    const aspect = getCalibratedAspect(image);\n                    const area = Math.abs(Math.PI *\n                        (worldWidth / scale / 2) *\n                        (worldHeight / aspect / scale / 2));\n                    const pixelUnitsOptions = {\n                        isPreScaled: isViewportPreScaled(viewport, targetId),\n                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                    };\n                    const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                    let pointsInShape;\n                    if (voxelManager) {\n                        pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                            isInObject: (pointLPS) => pointInEllipse(ellipseObj, pointLPS, { fast: true }),\n                            boundsIJK,\n                            imageData,\n                            returnPoints: this.configuration.storePointData,\n                        });\n                    }\n                    const stats = this.configuration.statsCalculator.getStatistics();\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean: stats.mean?.value,\n                        max: stats.max?.value,\n                        min: stats.min?.value,\n                        pointsInShape,\n                        stdDev: stats.stdDev?.value,\n                        statsArray: stats.array,\n                        isEmptyArea,\n                        areaUnit,\n                        radius: worldWidth / 2 / scale,\n                        radiusUnit: unit,\n                        perimeter: (2 * Math.PI * (worldWidth / 2)) / scale,\n                        modalityUnit,\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            annotation.invalidated = false;\n            if (wasInvalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(CircleROITool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { radius, radiusUnit, area, mean, stdDev, max, min, isEmptyArea, areaUnit, modalityUnit, } = cachedVolumeStats;\n    const textLines = [];\n    if (csUtils.isNumber(radius)) {\n        const radiusLine = isEmptyArea\n            ? `Radius: Oblique not supported`\n            : `Radius: ${csUtils.roundNumber(radius)} ${radiusUnit}`;\n        textLines.push(radiusLine);\n    }\n    if (csUtils.isNumber(area)) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    if (csUtils.isNumber(mean)) {\n        textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(max)) {\n        textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(min)) {\n        textLines.push(`Min: ${csUtils.roundNumber(min)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(stdDev)) {\n        textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    }\n    return textLines;\n}\nexport default CircleROITool;\n", "import { AnnotationTool } from '../base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted } from '../../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawLine } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getCanvasCircleRadius } from '../../utilities/math/circle';\nimport { vec3 } from 'gl-matrix';\nconst CROSSHAIR_SIZE = 5;\nclass ETDRSGridTool extends AnnotationTool {\n    static { this.toolName = 'ETDRSGrid'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            degrees: [45, 135, 225, 315],\n            diameters: [10, 30, 60],\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        points: [[...worldPos]],\n                    },\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                newAnnotation: true,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const center = viewport.worldToCanvas(points[0]);\n            const radius = getCanvasCircleRadius([center, canvasCoords]);\n            if (Math.abs(radius) < proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const { renderingEngine } = getEnabledElement(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            data.handles.points = [\n                canvasToWorld(currentCanvasPoints),\n                canvasToWorld(currentCanvasPoints),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            const { deltaPoints } = eventDetail;\n            const worldPosDelta = deltaPoints.world;\n            const points = data.handles.points;\n            points.forEach((point) => {\n                point[0] += worldPosDelta[0];\n                point[1] += worldPosDelta[1];\n                point[2] += worldPosDelta[2];\n            });\n            annotation.invalidated = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { canvasToWorld, worldToCanvas } = enabledElement.viewport;\n            const { annotation } = this.editData;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => worldToCanvas(p));\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];\n            const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];\n            const canvasCenter = currentCanvasPoints;\n            const canvasEnd = [\n                canvasCoordinates[1][0] + dXCanvas,\n                canvasCoordinates[1][1] + dYCanvas,\n            ];\n            points[0] = canvasToWorld(canvasCenter);\n            points[1] = canvasToWorld(canvasEnd);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const { renderingEngine } = getEnabledElement(element);\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const center = canvasCoordinates[0];\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                let lineUID = `${annotationUID}-crosshair-vertical`;\n                let start = [center[0], center[1] + CROSSHAIR_SIZE];\n                let end = [center[0], center[1] - CROSSHAIR_SIZE];\n                drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                });\n                lineUID = `${annotationUID}-crosshair-horizontal`;\n                start = [center[0] + CROSSHAIR_SIZE, center[1]];\n                end = [center[0] - CROSSHAIR_SIZE, center[1]];\n                drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                });\n                const diametersCanvas = this.configuration.diameters.map((diameter) => this.worldMeasureToCanvas(diameter, viewport));\n                for (let i = 0; i < diametersCanvas.length; i++) {\n                    const dataId = `${annotationUID}-circle-${i}`;\n                    const circleUID = `${annotationUID}-circle-${i}`;\n                    drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, diametersCanvas[i] / 2, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    }, dataId);\n                }\n                const degreesRad = (x) => (x * Math.PI) / 180;\n                const angleRadians = this.configuration.degrees.map((degree) => degreesRad(degree));\n                for (let i = 0; i < angleRadians.length; i++) {\n                    const lineUID = `${annotationUID}-line-${i}`;\n                    const start = [\n                        (Math.cos(angleRadians[i]) * diametersCanvas[0]) / 2 + center[0],\n                        (Math.sin(angleRadians[i]) * diametersCanvas[0]) / 2 + center[1],\n                    ];\n                    const end = [\n                        (Math.cos(angleRadians[i]) * diametersCanvas[2]) / 2 + center[0],\n                        (Math.sin(angleRadians[i]) * diametersCanvas[2]) / 2 + center[1],\n                    ];\n                    drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n    }\n    worldMeasureToCanvas(measurement, viewport) {\n        const p1 = viewport.canvasToWorld([\n            viewport.canvas.width / 2,\n            viewport.canvas.height / 2,\n        ]);\n        const { viewUp } = viewport.getCamera();\n        const p2 = vec3.scaleAndAdd(vec3.create(), p1, viewUp, measurement);\n        const p1Canvas = viewport.worldToCanvas(p1);\n        const p2Canvas = viewport.worldToCanvas(p2);\n        const distance = Math.sqrt(Math.pow(p2Canvas[0] - p1Canvas[0], 2) +\n            Math.pow(p2Canvas[1] - p1Canvas[1], 2));\n        return distance;\n    }\n}\nexport default ETDRSGridTool;\n", "import { getEnabledElement, eventTarget, triggerEvent, utilities, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { addAnnotation, getChildAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { drawHandles as drawHandlesSvg, drawPolyline as drawPolylineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events, MouseBindings, KeyboardBindings, ChangeTypes, } from '../../enums';\nimport { resetElementCursor } from '../../cursors/elementCursor';\nimport * as math from '../../utilities/math';\nimport throttle from '../../utilities/throttle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport getMouseModifierKey from '../../eventDispatchers/shared/getMouseModifier';\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport { CardinalSpline } from './splines/CardinalSpline';\nimport { LinearSpline } from './splines/LinearSpline';\nimport { CatmullRomSpline } from './splines/CatmullRomSpline';\nimport { BSpline } from './splines/BSpline';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities';\nimport { convertContourSegmentationAnnotation } from '../../utilities/contourSegmentation';\nconst SPLINE_MIN_POINTS = 3;\nconst SPLINE_CLICK_CLOSE_CURVE_DIST = 10;\nconst DEFAULT_SPLINE_CONFIG = {\n    resolution: 20,\n    controlPointAdditionDistance: 6,\n    controlPointDeletionDistance: 6,\n    showControlPointsConnectors: false,\n    controlPointAdditionEnabled: true,\n    controlPointDeletionEnabled: true,\n};\nvar SplineTypesEnum;\n(function (SplineTypesEnum) {\n    SplineTypesEnum[\"Cardinal\"] = \"CARDINAL\";\n    SplineTypesEnum[\"Linear\"] = \"LINEAR\";\n    SplineTypesEnum[\"CatmullRom\"] = \"CATMULLROM\";\n    SplineTypesEnum[\"BSpline\"] = \"BSPLINE\";\n})(SplineTypesEnum || (SplineTypesEnum = {}));\nvar SplineToolActions;\n(function (SplineToolActions) {\n    SplineToolActions[\"AddControlPoint\"] = \"addControlPoint\";\n    SplineToolActions[\"DeleteControlPoint\"] = \"deleteControlPoint\";\n})(SplineToolActions || (SplineToolActions = {}));\nconst splineToolNames = [\n    'CatmullRomSplineROI',\n    'LinearSplineROI',\n    'BSplineROI',\n    'CardinalSplineROI',\n];\nclass SplineROITool extends ContourSegmentationBaseTool {\n    static { this.toolName = 'SplineROI'; }\n    static { this.SplineTypes = SplineTypesEnum; }\n    static { this.Actions = SplineToolActions; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            calculateStats: true,\n            simplifiedSpline: false,\n            getTextLines: defaultGetTextLines,\n            contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n            decimate: {\n                enabled: false,\n                epsilon: 0.1,\n            },\n            spline: {\n                configuration: {\n                    [SplineTypesEnum.Cardinal]: {\n                        Class: CardinalSpline,\n                        scale: 0.5,\n                    },\n                    [SplineTypesEnum.CatmullRom]: {\n                        Class: CatmullRomSpline,\n                    },\n                    [SplineTypesEnum.Linear]: {\n                        Class: LinearSpline,\n                    },\n                    [SplineTypesEnum.BSpline]: {\n                        Class: BSpline,\n                        controlPointAdditionEnabled: false,\n                        controlPointDeletionEnabled: false,\n                        showControlPointsConnectors: true,\n                    },\n                },\n                type: SplineTypesEnum.CatmullRom,\n                drawPreviewEnabled: true,\n                enableTwoPointPreview: false,\n                lastControlPointDeletionKeys: ['Backspace', 'Delete'],\n            },\n            actions: {\n                [SplineToolActions.AddControlPoint]: {\n                    method: 'addControlPointCallback',\n                    bindings: [\n                        {\n                            mouseButton: MouseBindings.Primary,\n                            modifierKey: KeyboardBindings.Shift,\n                        },\n                    ],\n                },\n                [SplineToolActions.DeleteControlPoint]: {\n                    method: 'deleteControlPointCallback',\n                    bindings: [\n                        {\n                            mouseButton: MouseBindings.Primary,\n                            modifierKey: KeyboardBindings.Ctrl,\n                        },\n                    ],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.splineToolNames = [\n            'CatmullRomSplineROI',\n            'LinearSplineROI',\n            'BSplineROI',\n            'CardinalSplineROI',\n        ];\n        this.isHandleOutsideImage = false;\n        this.fireChangeOnUpdate = null;\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const { instance: spline } = annotation.data.spline;\n            return spline.isPointNearCurve(canvasCoords, proximity);\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                handleIndex = points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, contourHoleProcessingEnabled, } = this.editData;\n            const { data } = annotation;\n            annotation.autoGenerated = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const image = this.getTargetImageData(this.getTargetId(enabledElement.viewport));\n            const { imageData, dimensions } = image;\n            this.isHandleOutsideImage = data.handles.points\n                .map((p) => utilities.transformWorldToIndex(imageData, p))\n                .some((index) => !utilities.indexWithinDimensions(index, dimensions));\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            const changeType = newAnnotation\n                ? ChangeTypes.Completed\n                : ChangeTypes.HandlesUpdated;\n            if (!this.fireChangeOnUpdate) {\n                this.fireChangeOnUpdate = {\n                    annotationUID: annotation.annotationUID,\n                    changeType,\n                    contourHoleProcessingEnabled,\n                };\n            }\n            else {\n                this.fireChangeOnUpdate.annotationUID = annotation.annotationUID;\n                this.fireChangeOnUpdate.changeType = changeType;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._keyDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const key = eventDetail.key ?? '';\n            const { lastControlPointDeletionKeys } = this.configuration.spline;\n            const deleteLastPoint = lastControlPointDeletionKeys.includes(key);\n            if (!deleteLastPoint) {\n                return;\n            }\n            const { annotation } = this.editData;\n            const { data } = annotation;\n            if (data.handles.points.length === SPLINE_MIN_POINTS) {\n                this.cancel(element);\n                return;\n            }\n            else {\n                const controlPointIndex = data.handles.points.length - 1;\n                this._deleteControlPointByIndex(element, annotation, controlPointIndex);\n            }\n            evt.preventDefault();\n        };\n        this._mouseMoveCallback = (evt) => {\n            const { drawPreviewEnabled } = this.configuration.spline;\n            if (!drawPreviewEnabled) {\n                return;\n            }\n            const { element } = evt.detail;\n            const { renderingEngine } = getEnabledElement(element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData.lastCanvasPoint = evt.detail.currentPoints.canvas;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._mouseDownCallback = (evt) => {\n            const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            if (data.contour.closed) {\n                return;\n            }\n            this.doneEditMemo();\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const { canvas: canvasPoint, world: worldPoint } = currentPoints;\n            let closeContour = data.handles.points.length >= 2 && doubleClick;\n            let addNewPoint = true;\n            if (data.handles.points.length) {\n                this.createMemo(element, annotation, {\n                    newAnnotation: data.handles.points.length === 1,\n                });\n            }\n            if (data.handles.points.length >= 3) {\n                this.createMemo(element, annotation);\n                const { instance: spline } = data.spline;\n                const closestControlPoint = spline.getClosestControlPointWithinDistance(canvasPoint, SPLINE_CLICK_CLOSE_CURVE_DIST);\n                if (closestControlPoint?.index === 0) {\n                    addNewPoint = false;\n                    closeContour = true;\n                }\n            }\n            if (addNewPoint) {\n                data.handles.points.push(worldPoint);\n            }\n            data.contour.closed = data.contour.closed || closeContour;\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (data.contour.closed) {\n                this._endCallback(evt);\n            }\n            evt.preventDefault();\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                this.moveAnnotation(annotation, worldPosDelta);\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.triggerAnnotationCompleted = (annotation, contourHoleProcessingEnabled) => {\n            const eventType = Events.ANNOTATION_COMPLETED;\n            const eventDetail = {\n                annotation,\n                changeType: ChangeTypes.Completed,\n                contourHoleProcessingEnabled,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n        };\n        this.triggerAnnotationModified = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated) => {\n            const { viewportId, renderingEngineId } = enabledElement;\n            const eventType = Events.ANNOTATION_MODIFIED;\n            const eventDetail = {\n                annotation,\n                viewportId,\n                renderingEngineId,\n                changeType,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n        };\n        this.triggerChangeEvent = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated, contourHoleProcessingEnabled) => {\n            if (changeType === ChangeTypes.Completed) {\n                this.triggerAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n            }\n            else {\n                this.triggerAnnotationModified(annotation, enabledElement, changeType);\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.KEY_DOWN, this._keyDownCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.addEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.KEY_DOWN, this._keyDownCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.removeEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._renderStats = (annotation, viewport, svgDrawingHelper, textboxStyle) => {\n            const data = annotation.data;\n            const targetId = this.getTargetId(viewport);\n            if (!data.spline.instance.closed || !textboxStyle.visibility) {\n                return;\n            }\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (!textLines || textLines.length === 0) {\n                return;\n            }\n            const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));\n            if (!data.handles.textBox.hasMoved) {\n                const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                data.handles.textBox.worldPosition =\n                    viewport.canvasToWorld(canvasTextBoxCoords);\n            }\n            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n            const textBoxUID = 'textBox';\n            const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, textboxStyle);\n            const { x: left, y: top, width, height } = boundingBox;\n            data.handles.textBox.worldBoundingBox = {\n                topLeft: viewport.canvasToWorld([left, top]),\n                topRight: viewport.canvasToWorld([left + width, top]),\n                bottomLeft: viewport.canvasToWorld([left, top + height]),\n                bottomRight: viewport.canvasToWorld([left + width, top + height]),\n            };\n        };\n        this.addControlPointCallback = (evt, annotation) => {\n            const { data } = annotation;\n            const splineType = data.spline.type;\n            const splineConfig = this._getSplineConfig(splineType);\n            const maxDist = splineConfig.controlPointAdditionDistance;\n            if (splineConfig.controlPointAdditionEnabled === false) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { instance: spline } = data.spline;\n            const canvasPos = evt.detail.currentPoints.canvas;\n            const closestPointInfo = spline.getClosestPoint(canvasPos);\n            if (closestPointInfo.distance > maxDist) {\n                return;\n            }\n            const { index, point: canvasPoint } = spline.addControlPointAtU(closestPointInfo.uValue);\n            data.handles.points.splice(index, 0, canvasToWorld(canvasPoint));\n            annotation.invalidated = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.deleteControlPointCallback = (evt, annotation) => {\n            const splineType = annotation.data.spline.type;\n            const splineConfig = this._getSplineConfig(splineType);\n            const maxDist = splineConfig.controlPointDeletionDistance;\n            if (splineConfig.controlPointDeletionEnabled === false) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const { canvas: canvasPos } = currentPoints;\n            const { instance: spline } = annotation.data.spline;\n            const closestControlPoint = spline.getClosestControlPointWithinDistance(canvasPos, maxDist);\n            if (!closestControlPoint) {\n                return;\n            }\n            this._deleteControlPointByIndex(element, annotation, closestControlPoint.index);\n        };\n        this._calculateCachedStats = (annotation, element) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const data = annotation.data;\n            if (!data.contour.closed) {\n                return;\n            }\n            const enabledElement = getEnabledElement(element);\n            if (!enabledElement) {\n                return;\n            }\n            const { viewport } = enabledElement;\n            const { cachedStats } = data;\n            const { polyline: points } = data.contour;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { metadata } = image;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const canvasPoint = canvasCoordinates[0];\n                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n                const deltaXPoint = viewport.canvasToWorld([\n                    canvasPoint[0] + 1,\n                    canvasPoint[1],\n                ]);\n                const deltaYPoint = viewport.canvasToWorld([\n                    canvasPoint[0],\n                    canvasPoint[1] + 1,\n                ]);\n                const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n                const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n                const { imageData } = image;\n                const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, () => {\n                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = math.polyline.getAABB(canvasCoordinates);\n                    const topLeftBBWorld = viewport.canvasToWorld([\n                        canvasMinX,\n                        canvasMinY,\n                    ]);\n                    const topLeftBBIndex = utilities.transformWorldToIndex(imageData, topLeftBBWorld);\n                    const bottomRightBBWorld = viewport.canvasToWorld([\n                        canvasMaxX,\n                        canvasMaxY,\n                    ]);\n                    const bottomRightBBIndex = utilities.transformWorldToIndex(imageData, bottomRightBBWorld);\n                    return [topLeftBBIndex, bottomRightBBIndex];\n                });\n                let area = math.polyline.getArea(canvasCoordinates) / scale / scale;\n                area *= deltaInX * deltaInY;\n                cachedStats[targetId] = {\n                    Modality: metadata.Modality,\n                    area,\n                    areaUnit,\n                };\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                this.triggerAnnotationModified(annotation, enabledElement, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n        this.annotationCompletedBinded = this.annotationCompleted.bind(this);\n    }\n    annotationCompleted(evt) {\n        const { sourceAnnotation: annotation } = evt.detail;\n        if (!this.splineToolNames.includes(annotation?.metadata?.toolName) ||\n            !this.configuration.simplifiedSpline ||\n            !this.isContourSegmentationTool()) {\n            return;\n        }\n        convertContourSegmentationAnnotation(annotation);\n    }\n    initializeListeners() {\n        eventTarget.addEventListener(Events.ANNOTATION_COMPLETED, this.annotationCompletedBinded);\n    }\n    removeListeners() {\n        eventTarget.removeEventListener(Events.ANNOTATION_COMPLETED, this.annotationCompletedBinded);\n    }\n    onSetToolEnabled() {\n        this.initializeListeners();\n    }\n    onSetToolActive() {\n        this.initializeListeners();\n    }\n    onSetToolDisabled() {\n        this.removeListeners();\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const { canvas: canvasPos } = currentPoints;\n        const contourHoleProcessingEnabled = getMouseModifierKey(evt.detail.event) ===\n            this.configuration.contourHoleAdditionModifierKey;\n        const annotation = this.createAnnotation(evt);\n        this.isDrawing = true;\n        this.addAnnotation(annotation, element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            movingTextBox: false,\n            newAnnotation: true,\n            hasMoved: false,\n            lastCanvasPoint: canvasPos,\n            contourHoleProcessingEnabled,\n        };\n        this._activateDraw(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        return annotation;\n    }\n    cancel(element) {\n        if (!this.isDrawing) {\n            return;\n        }\n        this.isDrawing = false;\n        this._deactivateDraw(element);\n        this._deactivateModify(element);\n        resetElementCursor(element);\n        const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n        if (newAnnotation) {\n            removeAnnotation(annotation.annotationUID);\n        }\n        super.cancelAnnotation(annotation);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        this.editData = null;\n        return annotation.annotationUID;\n    }\n    isContourSegmentationTool() {\n        return false;\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, targetId, svgDrawingHelper, annotationStyle } = renderContext;\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const { element } = viewport;\n        const annotation = renderContext.annotation;\n        const { annotationUID, data, highlighted } = annotation;\n        const { handles } = data;\n        const { points: controlPoints, activeHandleIndex } = handles;\n        const newAnnotation = this.editData?.newAnnotation;\n        const { lineWidth, lineDash, color, locked: annotationLocked, } = annotationStyle;\n        const canvasCoordinates = controlPoints.map((p) => worldToCanvas(p));\n        const { drawPreviewEnabled } = this.configuration.spline;\n        const splineType = annotation.data.spline.type;\n        const splineConfig = this._getSplineConfig(splineType);\n        const spline = annotation.data.spline.instance;\n        const childAnnotations = getChildAnnotations(annotation);\n        const missingAnnotation = childAnnotations.findIndex((it) => !it);\n        if (missingAnnotation !== -1) {\n            throw new Error(`Can't find annotation for child ${annotation.childAnnotationUIDs.join()}`);\n        }\n        const splineAnnotationsGroup = [annotation, ...childAnnotations].filter((annotation) => this._isSplineROIAnnotation(annotation));\n        splineAnnotationsGroup.forEach((annotation) => {\n            const spline = this._updateSplineInstance(element, annotation);\n            const splinePolylineCanvas = spline.getPolylinePoints();\n            this.updateContourPolyline(annotation, {\n                points: splinePolylineCanvas,\n                closed: data.contour.closed,\n                targetWindingDirection: ContourWindingDirection.Clockwise,\n            }, viewport, { updateWindingDirection: data.contour.closed });\n        });\n        super.renderAnnotationInstance(renderContext);\n        if (!data.cachedStats[targetId] ||\n            data.cachedStats[targetId].areaUnit == null) {\n            data.cachedStats[targetId] = {\n                Modality: null,\n                area: null,\n                areaUnit: null,\n            };\n            this._calculateCachedStats(annotation, element);\n        }\n        else if (annotation.invalidated) {\n            this._throttledCalculateCachedStats(annotation, element);\n        }\n        let activeHandleCanvasCoords;\n        if (!annotationLocked && !this.editData && activeHandleIndex !== null) {\n            activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n        }\n        if (activeHandleCanvasCoords || newAnnotation || highlighted) {\n            const handleGroupUID = '0';\n            drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                color,\n                lineWidth,\n                handleRadius: '3',\n            });\n        }\n        if (drawPreviewEnabled &&\n            spline.numControlPoints >= 1 &&\n            this.editData?.lastCanvasPoint &&\n            !spline.closed) {\n            const { lastCanvasPoint } = this.editData;\n            const { enableTwoPointPreview } = this.configuration.spline;\n            if (spline.numControlPoints === 1 && enableTwoPointPreview) {\n                const firstPoint = canvasCoordinates[0];\n                const previewPolylinePoints = [firstPoint, lastCanvasPoint];\n                drawPolylineSvg(svgDrawingHelper, annotationUID, 'previewSplineChange', previewPolylinePoints, {\n                    color: '#9EA0CA',\n                    lineDash: lineDash,\n                    lineWidth: 1,\n                });\n            }\n            else if (spline.numControlPoints > 1) {\n                const previewPolylinePoints = spline.getPreviewPolylinePoints(lastCanvasPoint, SPLINE_CLICK_CLOSE_CURVE_DIST);\n                drawPolylineSvg(svgDrawingHelper, annotationUID, 'previewSplineChange', previewPolylinePoints, {\n                    color: '#9EA0CA',\n                    lineDash: lineDash,\n                    lineWidth: 1,\n                });\n            }\n        }\n        if (splineConfig.showControlPointsConnectors) {\n            const controlPointsConnectors = [...canvasCoordinates];\n            if (spline.closed) {\n                controlPointsConnectors.push(canvasCoordinates[0]);\n            }\n            drawPolylineSvg(svgDrawingHelper, annotationUID, 'controlPointsConnectors', controlPointsConnectors, {\n                color: 'rgba(255, 255, 255, 0.5)',\n                lineWidth: 1,\n            });\n        }\n        this._renderStats(annotation, viewport, svgDrawingHelper, annotationStyle.textbox);\n        if (this.fireChangeOnUpdate?.annotationUID === annotationUID) {\n            this.triggerChangeEvent(annotation, enabledElement, this.fireChangeOnUpdate.changeType, this.fireChangeOnUpdate.contourHoleProcessingEnabled);\n            this.fireChangeOnUpdate = null;\n        }\n        annotation.invalidated = false;\n        return true;\n    }\n    createInterpolatedSplineControl(annotation) {\n        if (annotation.data.handles.points?.length) {\n            return;\n        }\n        const { polyline } = annotation.data.contour;\n        if (!polyline || !polyline.length) {\n            return;\n        }\n        annotation.data.handles.points = [];\n        const { points } = annotation.data.handles;\n        const increment = Math.max(10, Math.floor(polyline.length / 20));\n        for (let i = 0; i < polyline.length - increment; i += increment) {\n            points.push(polyline[i]);\n        }\n        points.push(polyline[polyline.length - 1]);\n    }\n    isSplineAnnotation(annotation) {\n        return splineToolNames.includes(annotation?.metadata?.toolName);\n    }\n    createSplineObjectFromType(annotation, splineType) {\n        const splineConfig = this._getSplineConfig(splineType);\n        const spline = new splineConfig.Class();\n        annotation.data.spline = {\n            type: splineConfig.type,\n            instance: spline,\n            resolution: splineConfig.resolution,\n        };\n    }\n    createAnnotation(evt) {\n        const contourAnnotation = super.createAnnotation(evt);\n        const { world: worldPos } = evt.detail.currentPoints;\n        const { type: splineType } = this.configuration.spline;\n        const splineConfig = this._getSplineConfig(splineType);\n        const spline = new splineConfig.Class();\n        const createSpline = () => ({\n            type: splineConfig.type,\n            instance: spline,\n            resolution: splineConfig.resolution,\n        });\n        let onInterpolationComplete;\n        if (this.configuration.interpolation?.enabled) {\n            onInterpolationComplete = (annotation) => {\n                annotation.data.spline ||= createSpline();\n                this.createInterpolatedSplineControl(annotation);\n            };\n        }\n        return utilities.deepMerge(contourAnnotation, {\n            data: {\n                handles: {\n                    points: [[...worldPos]],\n                },\n                spline: createSpline(),\n                cachedStats: {},\n            },\n            onInterpolationComplete,\n        });\n    }\n    _deleteControlPointByIndex(element, annotation, controlPointIndex) {\n        const enabledElement = getEnabledElement(element);\n        const { points: controlPoints } = annotation.data.handles;\n        if (controlPoints.length === 3) {\n            removeAnnotation(annotation.annotationUID);\n        }\n        else {\n            controlPoints.splice(controlPointIndex, 1);\n        }\n        const { renderingEngine } = enabledElement;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        annotation.invalidated = true;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    }\n    _isSplineROIAnnotation(annotation) {\n        return !!annotation.data?.spline;\n    }\n    _getSplineConfig(type) {\n        const { configuration: config } = this;\n        const splineConfigs = config.spline.configuration;\n        return Object.assign({ type }, DEFAULT_SPLINE_CONFIG, splineConfigs[type]);\n    }\n    _updateSplineInstance(element, annotation) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const { data } = annotation;\n        const { type: splineType, instance: spline } = annotation.data.spline;\n        const splineConfig = this._getSplineConfig(splineType);\n        const worldPoints = data.handles.points;\n        const canvasPoints = worldPoints.map(worldToCanvas);\n        const resolution = splineConfig.resolution !== undefined\n            ? parseInt(splineConfig.resolution)\n            : undefined;\n        const scale = splineConfig.scale !== undefined\n            ? parseFloat(splineConfig.scale)\n            : undefined;\n        spline.setControlPoints(canvasPoints);\n        spline.closed = !!data.contour.closed;\n        if (!spline.fixedResolution &&\n            resolution !== undefined &&\n            spline.resolution !== resolution) {\n            spline.resolution = resolution;\n            annotation.invalidated = true;\n        }\n        if (spline instanceof CardinalSpline &&\n            !spline.fixedScale &&\n            scale !== undefined &&\n            spline.scale !== scale) {\n            spline.scale = scale;\n            annotation.invalidated = true;\n        }\n        return spline;\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        if (points.length < SPLINE_MIN_POINTS) {\n            console.warn('Spline requires at least 3 control points');\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, viewUp, instance, viewport, } = this.hydrateBase(SplineROITool, enabledElement, points, options);\n        const splineType = options?.splineType || SplineTypesEnum.CatmullRom;\n        const splineConfig = instance._getSplineConfig(splineType);\n        const SplineClass = splineConfig.Class;\n        const splineInstance = new SplineClass();\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n                label: '',\n                cachedStats: {},\n                spline: {\n                    type: splineType,\n                    instance: splineInstance,\n                },\n                contour: {\n                    closed: true,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: true,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, isEmptyArea, areaUnit } = cachedVolumeStats;\n    const textLines = [];\n    if (area) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${utilities.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    return textLines;\n}\nexport default SplineROITool;\n", "import { eventTarget, utilities } from '@cornerstonejs/core';\nimport SplineROITool from './SplineROITool';\nimport { Events } from '../../enums';\nimport { convertContourSegmentationAnnotation } from '../../utilities/contourSegmentation';\nclass SplineContourSegmentationTool extends SplineROITool {\n    static { this.toolName = 'SplineContourSegmentationTool'; }\n    constructor(toolProps) {\n        const initialProps = utilities.deepMerge({\n            configuration: {\n                calculateStats: false,\n            },\n        }, toolProps);\n        super(initialProps);\n        this.annotationCutMergeCompletedBinded =\n            this.annotationCutMergeCompleted.bind(this);\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n    initializeListeners() {\n        eventTarget.addEventListener(Events.ANNOTATION_CUT_MERGE_PROCESS_COMPLETED, this.annotationCutMergeCompletedBinded);\n    }\n    removeListeners() {\n        eventTarget.removeEventListener(Events.ANNOTATION_CUT_MERGE_PROCESS_COMPLETED, this.annotationCutMergeCompletedBinded);\n    }\n    annotationCutMergeCompleted(evt) {\n        const { sourceAnnotation: annotation } = evt.detail;\n        if (this.toolName !== annotation?.metadata?.toolName ||\n            !this.splineToolNames.includes(annotation?.metadata?.toolName) ||\n            !this.configuration.simplifiedSpline) {\n            return;\n        }\n        convertContourSegmentationAnnotation(annotation);\n    }\n}\nexport default SplineContourSegmentationTool;\n", "export class BucketQueue {\n    constructor({ numBits, getPriority, areEqual, }) {\n        this._bucketCount = 1 << numBits;\n        this._mask = this._bucketCount - 1;\n        this._size = 0;\n        this._currentBucketIndex = 0;\n        this._buckets = this._buildArray(this._bucketCount);\n        this._getPriority =\n            typeof getPriority !== 'undefined'\n                ? getPriority\n                : (item) => item;\n        this._areEqual =\n            typeof areEqual === 'function'\n                ? areEqual\n                : (itemA, itemB) => itemA === itemB;\n    }\n    push(item) {\n        const bucketIndex = this._getBucketIndex(item);\n        const oldHead = this._buckets[bucketIndex];\n        const newHead = {\n            value: item,\n            next: oldHead,\n        };\n        this._buckets[bucketIndex] = newHead;\n        this._size++;\n    }\n    pop() {\n        if (this._size === 0) {\n            throw new Error('Cannot pop because the queue is empty.');\n        }\n        while (this._buckets[this._currentBucketIndex] === null) {\n            this._currentBucketIndex =\n                (this._currentBucketIndex + 1) % this._bucketCount;\n        }\n        const ret = this._buckets[this._currentBucketIndex];\n        this._buckets[this._currentBucketIndex] = ret.next;\n        this._size--;\n        return ret.value;\n    }\n    remove(item) {\n        if (!item) {\n            return false;\n        }\n        const bucketIndex = this._getBucketIndex(item);\n        const firstBucketNode = this._buckets[bucketIndex];\n        let node = firstBucketNode;\n        let prevNode;\n        while (node !== null) {\n            if (this._areEqual(item, node.value)) {\n                break;\n            }\n            prevNode = node;\n            node = node.next;\n        }\n        if (node === null) {\n            return false;\n        }\n        if (node === firstBucketNode) {\n            this._buckets[bucketIndex] = node.next;\n        }\n        else {\n            prevNode.next = node.next;\n        }\n        this._size--;\n        return true;\n    }\n    isEmpty() {\n        return this._size === 0;\n    }\n    _getBucketIndex(item) {\n        return this._getPriority(item) & this._mask;\n    }\n    _buildArray(size) {\n        const buckets = new Array(size);\n        buckets.fill(null);\n        return buckets;\n    }\n}\n", "import { utilities } from '@cornerstonejs/core';\nimport { BucketQueue } from '../BucketQueue';\nconst { isEqual } = utilities;\nconst MAX_UINT32 = 4294967295;\nconst TWO_THIRD_PI = 2 / (3 * Math.PI);\nexport class LivewireScissors {\n    constructor(grayscalePixelData, width, height) {\n        this._getPointIndex = (row, col) => {\n            const { width } = this;\n            return row * width + col;\n        };\n        this._getPointCoordinate = (index) => {\n            const x = index % this.width;\n            const y = Math.floor(index / this.width);\n            return [x, y];\n        };\n        this._getPointCost = (pointIndex) => {\n            return Math.round(this.searchGranularity * this.costs[pointIndex]);\n        };\n        const numPixels = grayscalePixelData.length;\n        this.searchGranularityBits = 8;\n        this.searchGranularity = 1 << this.searchGranularityBits;\n        this.width = width;\n        this.height = height;\n        this.grayscalePixelData = grayscalePixelData;\n        this.laplace = null;\n        this.gradXNew = null;\n        this.gradYNew = null;\n        this.laplace = this._computeLaplace();\n        this.gradMagnitude = this._computeGradient();\n        this.gradXNew = this._computeGradientX();\n        this.gradYNew = this._computeGradientY();\n        this.visited = new Array(numPixels);\n        this.parents = new Uint32Array(numPixels);\n        this.costs = new Float32Array(numPixels);\n    }\n    startSearch(startPoint) {\n        const startPointIndex = this._getPointIndex(startPoint[1], startPoint[0]);\n        this.startPoint = null;\n        this.visited.fill(false);\n        this.parents.fill(MAX_UINT32);\n        this.costs.fill(Infinity);\n        this.priorityQueueNew = new BucketQueue({\n            numBits: this.searchGranularityBits,\n            getPriority: this._getPointCost,\n        });\n        this.startPoint = startPoint;\n        this.costs[startPointIndex] = 0;\n        this.priorityQueueNew.push(startPointIndex);\n    }\n    findMinNearby(testPoint, delta = 2) {\n        const [x, y] = testPoint;\n        const { costs } = this;\n        const xRange = [\n            Math.max(0, x - delta),\n            Math.min(x + delta + 1, this.width),\n        ];\n        const yRange = [\n            Math.max(0, y - delta),\n            Math.min(y + delta + 1, this.height),\n        ];\n        let minValue = costs[this._getPointIndex(y, x)] * 0.8;\n        let minPoint = testPoint;\n        for (let xTest = xRange[0]; xTest < xRange[1]; xTest++) {\n            for (let yTest = yRange[0]; yTest < yRange[1]; yTest++) {\n                const distanceCost = 1 -\n                    (Math.abs(xTest - testPoint[0]) + Math.abs(yTest - testPoint[1])) /\n                        delta /\n                        2;\n                const weightCost = costs[this._getPointIndex(yTest, xTest)];\n                const weight = weightCost * 0.8 + distanceCost * 0.2;\n                if (weight < minValue) {\n                    minPoint = [xTest, yTest];\n                    minValue = weight;\n                }\n            }\n        }\n        return minPoint;\n    }\n    findPathToPoint(targetPoint) {\n        if (!this.startPoint) {\n            throw new Error('There is no search in progress');\n        }\n        const { startPoint, _getPointIndex: index, _getPointCoordinate: coord, } = this;\n        const startPointIndex = index(startPoint[1], startPoint[0]);\n        const targetPointIndex = index(targetPoint[1], targetPoint[0]);\n        const { visited: visited, parents: parents, costs: cost, priorityQueueNew: priorityQueue, } = this;\n        if (targetPointIndex === startPointIndex) {\n            return [];\n        }\n        while (!priorityQueue.isEmpty() &&\n            parents[targetPointIndex] === MAX_UINT32) {\n            const pointIndex = priorityQueue.pop();\n            if (visited[pointIndex]) {\n                continue;\n            }\n            const point = coord(pointIndex);\n            const neighborsPoints = this._getNeighborPoints(point);\n            visited[pointIndex] = true;\n            for (let i = 0, len = neighborsPoints.length; i < len; i++) {\n                const neighborPoint = neighborsPoints[i];\n                const neighborPointIndex = index(neighborPoint[1], neighborPoint[0]);\n                const dist = this._getWeightedDistance(point, neighborPoint);\n                const neighborCost = cost[pointIndex] + dist;\n                if (neighborCost < cost[neighborPointIndex]) {\n                    if (cost[neighborPointIndex] !== Infinity) {\n                        priorityQueue.remove(neighborPointIndex);\n                    }\n                    cost[neighborPointIndex] = neighborCost;\n                    parents[neighborPointIndex] = pointIndex;\n                    priorityQueue.push(neighborPointIndex);\n                }\n            }\n        }\n        const pathPoints = [];\n        let pathPointIndex = targetPointIndex;\n        while (pathPointIndex !== MAX_UINT32) {\n            pathPoints.push(coord(pathPointIndex));\n            pathPointIndex = parents[pathPointIndex];\n        }\n        return pathPoints.reverse();\n    }\n    _getDeltaX(x, y) {\n        const { grayscalePixelData: data, width } = this;\n        let index = this._getPointIndex(y, x);\n        if (x + 1 === width) {\n            index--;\n        }\n        return data[index + 1] - data[index];\n    }\n    _getDeltaY(x, y) {\n        const { grayscalePixelData: data, width, height } = this;\n        let index = this._getPointIndex(y, x);\n        if (y + 1 === height) {\n            index -= width;\n        }\n        return data[index] - data[index + width];\n    }\n    _getGradientMagnitude(x, y) {\n        const dx = this._getDeltaX(x, y);\n        const dy = this._getDeltaY(x, y);\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    _getLaplace(x, y) {\n        const { grayscalePixelData: data, _getPointIndex: index } = this;\n        const p02 = data[index(y - 2, x)];\n        const p11 = data[index(y - 1, x - 1)];\n        const p12 = data[index(y - 1, x)];\n        const p13 = data[index(y - 1, x + 1)];\n        const p20 = data[index(y, x - 2)];\n        const p21 = data[index(y, x - 1)];\n        const p22 = data[index(y, x)];\n        const p23 = data[index(y, x + 1)];\n        const p24 = data[index(y, x + 2)];\n        const p31 = data[index(y + 1, x - 1)];\n        const p32 = data[index(y + 1, x)];\n        const p33 = data[index(y + 1, x + 1)];\n        const p42 = data[index(y + 2, x)];\n        let lap = p02;\n        lap += p11 + 2 * p12 + p13;\n        lap += p20 + 2 * p21 - 16 * p22 + 2 * p23 + p24;\n        lap += p31 + 2 * p32 + p33;\n        lap += p42;\n        return lap;\n    }\n    _computeGradient() {\n        const { width, height } = this;\n        const gradient = new Float32Array(width * height);\n        let pixelIndex = 0;\n        let max = 0;\n        let x = 0;\n        let y = 0;\n        for (y = 0; y < height - 1; y++) {\n            for (x = 0; x < width - 1; x++) {\n                gradient[pixelIndex] = this._getGradientMagnitude(x, y);\n                max = Math.max(gradient[pixelIndex], max);\n                pixelIndex++;\n            }\n            gradient[pixelIndex] = gradient[pixelIndex - 1];\n            pixelIndex++;\n        }\n        for (let len = gradient.length; pixelIndex < len; pixelIndex++) {\n            gradient[pixelIndex] = gradient[pixelIndex - width];\n        }\n        for (let i = 0, len = gradient.length; i < len; i++) {\n            gradient[i] = 1 - gradient[i] / max;\n        }\n        return gradient;\n    }\n    _computeLaplace() {\n        const { width, height, _getPointIndex: index } = this;\n        const laplace = new Float32Array(width * height);\n        laplace.fill(1, 0, index(2, 0));\n        for (let y = 2; y < height - 2; y++) {\n            laplace[index(y, 0)] = 1;\n            laplace[index(y, 1)] = 1;\n            for (let x = 2; x < width - 2; x++) {\n                laplace[index(y, x)] = this._getLaplace(x, y) > 0.33 ? 0 : 1;\n            }\n            laplace[index(y, width - 2)] = 1;\n            laplace[index(y, width - 1)] = 1;\n        }\n        laplace.fill(1, index(height - 2, 0));\n        return laplace;\n    }\n    _computeGradientX() {\n        const { width, height } = this;\n        const gradX = new Float32Array(width * height);\n        let pixelIndex = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                gradX[pixelIndex++] = this._getDeltaX(x, y);\n            }\n        }\n        return gradX;\n    }\n    _computeGradientY() {\n        const { width, height } = this;\n        const gradY = new Float32Array(width * height);\n        let pixelIndex = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                gradY[pixelIndex++] = this._getDeltaY(x, y);\n            }\n        }\n        return gradY;\n    }\n    _getGradientUnitVector(px, py) {\n        const { gradXNew, gradYNew, _getPointIndex: index } = this;\n        const pointGradX = gradXNew[index(py, px)];\n        const pointGradY = gradYNew[index(py, px)];\n        let gradVecLen = Math.sqrt(pointGradX * pointGradX + pointGradY * pointGradY);\n        gradVecLen = Math.max(gradVecLen, 1e-100);\n        return [pointGradX / gradVecLen, pointGradY / gradVecLen];\n    }\n    _getGradientDirection(px, py, qx, qy) {\n        const dgpUnitVec = this._getGradientUnitVector(px, py);\n        const gdqUnitVec = this._getGradientUnitVector(qx, qy);\n        let dp = dgpUnitVec[1] * (qx - px) - dgpUnitVec[0] * (qy - py);\n        let dq = gdqUnitVec[1] * (qx - px) - gdqUnitVec[0] * (qy - py);\n        if (dp < 0) {\n            dp = -dp;\n            dq = -dq;\n        }\n        if (px !== qx && py !== qy) {\n            dp *= Math.SQRT1_2;\n            dq *= Math.SQRT1_2;\n        }\n        dq = Math.min(Math.max(dq, -1), 1);\n        const direction = TWO_THIRD_PI * (Math.acos(Math.min(dp, 1)) + Math.acos(dq));\n        if (isNaN(direction) || !isFinite(direction)) {\n            console.warn('Found non-direction:', px, py, qx, qy, dp, dq, direction);\n            return 1;\n        }\n        return direction;\n    }\n    getCost(pointA, pointB) {\n        return this._getWeightedDistance(pointA, pointB);\n    }\n    _getWeightedDistance(pointA, pointB) {\n        const { _getPointIndex: index, width, height } = this;\n        const [aX, aY] = pointA;\n        const [bX, bY] = pointB;\n        if (bX < 0 || bX >= width || bY < 0 || bY >= height) {\n            return 1;\n        }\n        if (aX < 0 || aY < 0 || aX >= width || aY >= height) {\n            return 0;\n        }\n        const bIndex = index(bY, bX);\n        let gradient = this.gradMagnitude[bIndex];\n        if (aX === bX || aY === bY) {\n            gradient *= Math.SQRT1_2;\n        }\n        const laplace = this.laplace[bIndex];\n        const direction = this._getGradientDirection(aX, aY, bX, bY);\n        return 0.43 * gradient + 0.43 * laplace + 0.11 * direction;\n    }\n    _getNeighborPoints(point) {\n        const { width, height } = this;\n        const list = [];\n        const sx = Math.max(point[0] - 1, 0);\n        const sy = Math.max(point[1] - 1, 0);\n        const ex = Math.min(point[0] + 1, width - 1);\n        const ey = Math.min(point[1] + 1, height - 1);\n        for (let y = sy; y <= ey; y++) {\n            for (let x = sx; x <= ex; x++) {\n                if (x !== point[0] || y !== point[1]) {\n                    list.push([x, y]);\n                }\n            }\n        }\n        return list;\n    }\n    static createInstanceFromRawPixelData(pixelData, width, height, voiRange) {\n        const numPixels = pixelData.length;\n        const grayscalePixelData = new Float32Array(numPixels);\n        const { lower: minPixelValue, upper: maxPixelValue } = voiRange;\n        const pixelRange = maxPixelValue - minPixelValue;\n        for (let i = 0, len = pixelData.length; i < len; i++) {\n            grayscalePixelData[i] = Math.max(0, Math.min(1, (pixelData[i] - minPixelValue) / pixelRange));\n        }\n        return new LivewireScissors(grayscalePixelData, width, height);\n    }\n}\n", "export class LivewirePath {\n    constructor(inputPointArray, inputControlPointIndexArray) {\n        this.pointArray = inputPointArray ? inputPointArray.slice() : [];\n        this._controlPointIndexes = inputControlPointIndexArray\n            ? inputControlPointIndexArray.slice()\n            : [];\n    }\n    getPoint(index) {\n        return this.pointArray[index];\n    }\n    getLastPoint() {\n        return this.pointArray[this.pointArray.length - 1];\n    }\n    isControlPoint(point) {\n        const index = this.pointArray.indexOf(point);\n        if (index !== -1) {\n            return this._controlPointIndexes.indexOf(index) !== -1;\n        }\n        else {\n            throw new Error('Error: isControlPoint called with not in list point.');\n        }\n    }\n    addPoint(point) {\n        this.pointArray.push(point);\n    }\n    addControlPoint(point) {\n        const index = this.pointArray.indexOf(point);\n        if (index !== -1) {\n            this._controlPointIndexes.push(index);\n        }\n        else {\n            throw new Error('Cannot mark a non registered point as control point.');\n        }\n    }\n    getControlPoints() {\n        return this._controlPointIndexes.map((i) => this.pointArray[i]);\n    }\n    getNumControlPoints() {\n        return this._controlPointIndexes.length;\n    }\n    removeLastControlPoint() {\n        if (this._controlPointIndexes.length) {\n            this._controlPointIndexes.pop();\n        }\n    }\n    getLastControlPoint() {\n        if (this._controlPointIndexes.length) {\n            return this.pointArray[this._controlPointIndexes[this._controlPointIndexes.length - 1]];\n        }\n    }\n    removeLastPoints(count) {\n        this.pointArray.splice(this.pointArray.length - count, count);\n    }\n    addPoints(newPointArray) {\n        this.pointArray = this.pointArray.concat(newPointArray);\n    }\n    prependPath(other) {\n        const otherSize = other.pointArray.length;\n        const shiftedIndexArray = [];\n        this.pointArray = other.pointArray.concat(this.pointArray);\n        for (let i = 0; i < this._controlPointIndexes.length; ++i) {\n            shiftedIndexArray[i] = this._controlPointIndexes[i] + otherSize;\n        }\n        this._controlPointIndexes =\n            other._controlPointIndexes.concat(shiftedIndexArray);\n    }\n    appendPath(other) {\n        this.addPoints(other.pointArray);\n        other._controlPointIndexes.forEach((point) => this._controlPointIndexes.push(point));\n    }\n}\n", "import { vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils, VolumeViewport, utilities, triggerEvent, eventTarget, } from '@cornerstonejs/core';\nimport { removeAnnotation } from '../../stateManagement/annotation/annotationState';\nimport { drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events, KeyboardBindings, ChangeTypes } from '../../enums';\nimport { resetElementCursor } from '../../cursors/elementCursor';\nimport getMouseModifierKey from '../../eventDispatchers/shared/getMouseModifier';\nimport * as math from '../../utilities/math';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport findHandlePolylineIndex from '../../utilities/contours/findHandlePolylineIndex';\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport { triggerAnnotationModified, triggerContourAnnotationCompleted, } from '../../stateManagement/annotation/helpers/state';\nimport { LivewireScissors } from '../../utilities/livewire/LivewireScissors';\nimport { LivewirePath } from '../../utilities/livewire/LiveWirePath';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { getCalibratedLengthUnitsAndScale, throttle } from '../../utilities';\nconst CLICK_CLOSE_CURVE_SQR_DIST = 10 ** 2;\nclass LivewireContourTool extends ContourSegmentationBaseTool {\n    static { this.toolName = 'LivewireContour'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            getTextLines: defaultGetTextLines,\n            calculateStats: true,\n            preventHandleOutsideImage: false,\n            contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n            snapHandleNearby: 2,\n            interpolation: {\n                enabled: false,\n                nearestEdge: 2,\n                showInterpolationPolyline: false,\n            },\n            decimate: {\n                enabled: false,\n                epsilon: 0.1,\n            },\n            actions: {\n                cancelInProgress: {\n                    method: 'cancelInProgress',\n                    bindings: [\n                        {\n                            key: 'Escape',\n                        },\n                    ],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const proximitySquared = proximity * proximity;\n            const canvasPoints = annotation.data.contour.polyline.map((p) => viewport.worldToCanvas(p));\n            let startPoint = canvasPoints[canvasPoints.length - 1];\n            for (let i = 0; i < canvasPoints.length; i++) {\n                const endPoint = canvasPoints[i];\n                const distanceToPointSquared = math.lineSegment.distanceToPointSquared(startPoint, endPoint, canvasCoords);\n                if (distanceToPointSquared <= proximitySquared) {\n                    return true;\n                }\n                startPoint = endPoint;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                handleIndex = points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt, clearAnnotation = false) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, contourHoleProcessingEnabled, } = this.editData;\n            const { data } = annotation;\n            this.doneEditMemo();\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            if ((this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) ||\n                clearAnnotation) {\n                removeAnnotation(annotation.annotationUID);\n                this.clearEditData();\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                return;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            const changeType = newAnnotation\n                ? ChangeTypes.Completed\n                : ChangeTypes.HandlesUpdated;\n            this.triggerChangeEvent(annotation, enabledElement, changeType, contourHoleProcessingEnabled);\n            this.clearEditData();\n        };\n        this.triggerChangeEvent = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated, contourHoleProcessingEnabled = false) => {\n            if (changeType === ChangeTypes.Completed) {\n                triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n            }\n            else {\n                triggerAnnotationModified(annotation, enabledElement.viewport.element, changeType);\n            }\n        };\n        this._mouseDownCallback = (evt) => {\n            const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;\n            const { annotation, viewportIdsToRender, worldToSlice, sliceToWorld, newAnnotation, } = this.editData;\n            if (this.editData.closed) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const { canvas: canvasPos, world: worldPosOriginal } = currentPoints;\n            let worldPos = worldPosOriginal;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            const controlPoints = this.editData.currentPath.getControlPoints();\n            let closePath = controlPoints.length >= 2 && doubleClick;\n            this.doneEditMemo();\n            this.createMemo(element, annotation, {\n                newAnnotation: newAnnotation && controlPoints.length === 1,\n            });\n            if (controlPoints.length >= 2) {\n                const closestHandlePoint = {\n                    index: -1,\n                    distSquared: Infinity,\n                };\n                for (let i = 0, len = controlPoints.length; i < len; i++) {\n                    const controlPoint = controlPoints[i];\n                    const worldControlPoint = sliceToWorld(controlPoint);\n                    const canvasControlPoint = viewport.worldToCanvas(worldControlPoint);\n                    const distSquared = math.point.distanceToPointSquared(canvasPos, canvasControlPoint);\n                    if (distSquared <= CLICK_CLOSE_CURVE_SQR_DIST &&\n                        distSquared < closestHandlePoint.distSquared) {\n                        closestHandlePoint.distSquared = distSquared;\n                        closestHandlePoint.index = i;\n                    }\n                }\n                if (closestHandlePoint.index === 0) {\n                    closePath = true;\n                }\n            }\n            const { snapHandleNearby } = this.configuration;\n            if (snapHandleNearby && !this.editData.closed) {\n                const currentPath = new LivewirePath();\n                const snapPoint = this.scissors.findMinNearby(worldToSlice(worldPosOriginal), 1);\n                const pathPoints = this.scissors.findPathToPoint(snapPoint);\n                currentPath.addPoints(pathPoints);\n                currentPath.prependPath(this.editData.confirmedPath);\n                worldPos = sliceToWorld(snapPoint);\n                this.editData.currentPath = currentPath;\n            }\n            this.editData.closed = this.editData.closed || closePath;\n            this.editData.confirmedPath = this.editData.currentPath;\n            const lastPoint = this.editData.currentPath.getLastPoint();\n            this.editData.confirmedPath.addControlPoint(lastPoint);\n            annotation.data.handles.points.push(sliceToWorld(lastPoint));\n            this.scissors.startSearch(worldToSlice(worldPos));\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (this.editData.closed) {\n                this.updateAnnotation(this.editData.confirmedPath);\n                this._endCallback(evt);\n            }\n            evt.preventDefault();\n        };\n        this._mouseMoveCallback = (evt) => {\n            const { element, currentPoints } = evt.detail;\n            const { world: worldPos, canvas: canvasPos } = currentPoints;\n            const { renderingEngine } = getEnabledElement(element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData.lastCanvasPoint = canvasPos;\n            const { width: imgWidth, height: imgHeight } = this.scissors;\n            const { worldToSlice } = this.editData;\n            const slicePoint = worldToSlice(worldPos);\n            if (slicePoint[0] < 0 ||\n                slicePoint[1] < 0 ||\n                slicePoint[0] >= imgWidth ||\n                slicePoint[1] >= imgHeight) {\n                return;\n            }\n            const pathPoints = this.scissors.findPathToPoint(slicePoint);\n            const currentPath = new LivewirePath();\n            currentPath.addPoints(pathPoints);\n            currentPath.prependPath(this.editData.confirmedPath);\n            this.editData.currentPath = currentPath;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, movingTextBox, handleIndex, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                console.warn('Drag annotation not implemented');\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                this.editHandle(worldPos, element, annotation, handleIndex);\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (!this.isDrawing) {\n                return;\n            }\n            this.isDrawing = false;\n            this._deactivateDraw(element);\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            if (newAnnotation) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            this.scissors = null;\n            return annotation.annotationUID;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.addEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.removeEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._calculateCachedStats = (annotation, element) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const data = annotation.data;\n            if (!data.contour.closed) {\n                return;\n            }\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            const { cachedStats } = data;\n            const { polyline: points } = data.contour;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { metadata } = image;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const canvasPoint = canvasCoordinates[0];\n                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n                const deltaXPoint = viewport.canvasToWorld([\n                    canvasPoint[0] + 1,\n                    canvasPoint[1],\n                ]);\n                const deltaYPoint = viewport.canvasToWorld([\n                    canvasPoint[0],\n                    canvasPoint[1] + 1,\n                ]);\n                const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n                const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n                const { imageData } = image;\n                const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, () => {\n                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = math.polyline.getAABB(canvasCoordinates);\n                    const topLeftBBWorld = viewport.canvasToWorld([\n                        canvasMinX,\n                        canvasMinY,\n                    ]);\n                    const topLeftBBIndex = utilities.transformWorldToIndex(imageData, topLeftBBWorld);\n                    const bottomRightBBWorld = viewport.canvasToWorld([\n                        canvasMaxX,\n                        canvasMaxY,\n                    ]);\n                    const bottomRightBBIndex = utilities.transformWorldToIndex(imageData, bottomRightBBWorld);\n                    return [topLeftBBIndex, bottomRightBBIndex];\n                });\n                let area = math.polyline.getArea(canvasCoordinates) / scale / scale;\n                area *= deltaInX * deltaInY;\n                cachedStats[targetId] = {\n                    Modality: metadata.Modality,\n                    area,\n                    areaUnit: areaUnit,\n                };\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                this.triggerAnnotationModified(annotation, enabledElement, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._renderStats = (annotation, viewport, svgDrawingHelper, textboxStyle) => {\n            const data = annotation.data;\n            const targetId = this.getTargetId(viewport);\n            if (!data.contour.closed || !textboxStyle.visibility) {\n                return;\n            }\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (!textLines || textLines.length === 0) {\n                return;\n            }\n            const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));\n            if (!data.handles.textBox.hasMoved) {\n                const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                data.handles.textBox.worldPosition =\n                    viewport.canvasToWorld(canvasTextBoxCoords);\n            }\n            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n            const textBoxUID = 'textBox';\n            const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, textboxStyle);\n            const { x: left, y: top, width, height } = boundingBox;\n            data.handles.textBox.worldBoundingBox = {\n                topLeft: viewport.canvasToWorld([left, top]),\n                topRight: viewport.canvasToWorld([left + width, top]),\n                bottomLeft: viewport.canvasToWorld([left, top + height]),\n                bottomRight: viewport.canvasToWorld([left + width, top + height]),\n            };\n        };\n        this.triggerAnnotationModified = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated) => {\n            const { viewportId, renderingEngineId } = enabledElement;\n            const eventType = Events.ANNOTATION_MODIFIED;\n            const eventDetail = {\n                annotation,\n                viewportId,\n                renderingEngineId,\n                changeType,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    setupBaseEditData(worldPos, element, annotation, nextPos, contourHoleProcessingEnabled) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        this.isDrawing = true;\n        const viewportImageData = viewport.getImageData();\n        const { imageData: vtkImageData } = viewportImageData;\n        let worldToSlice;\n        let sliceToWorld;\n        let width;\n        let height;\n        let scalarData;\n        if (!(viewport instanceof VolumeViewport)) {\n            width = viewportImageData.dimensions[0];\n            height = viewportImageData.dimensions[1];\n            worldToSlice = (point) => {\n                const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);\n                return [ijkPoint[0], ijkPoint[1]];\n            };\n            sliceToWorld = (point) => csUtils.transformIndexToWorld(vtkImageData, [point[0], point[1], 0]);\n            scalarData = viewportImageData.scalarData;\n        }\n        else if (viewport instanceof VolumeViewport) {\n            const sliceImageData = csUtils.getCurrentVolumeViewportSlice(viewport);\n            const { sliceToIndexMatrix, indexToSliceMatrix } = sliceImageData;\n            worldToSlice = (point) => {\n                const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);\n                const slicePoint = vec3.transformMat4([0, 0, 0], ijkPoint, indexToSliceMatrix);\n                return [slicePoint[0], slicePoint[1]];\n            };\n            sliceToWorld = (point) => {\n                const ijkPoint = vec3.transformMat4([0, 0, 0], [point[0], point[1], 0], sliceToIndexMatrix);\n                return csUtils.transformIndexToWorld(vtkImageData, ijkPoint);\n            };\n            scalarData = sliceImageData.scalarData;\n            width = sliceImageData.width;\n            height = sliceImageData.height;\n        }\n        else {\n            throw new Error('Viewport not supported');\n        }\n        scalarData = csUtils.convertToGrayscale(scalarData, width, height);\n        const { voiRange } = viewport.getProperties();\n        const startPos = worldToSlice(worldPos);\n        this.scissors = LivewireScissors.createInstanceFromRawPixelData(scalarData, width, height, voiRange);\n        if (nextPos) {\n            this.scissorsNext = LivewireScissors.createInstanceFromRawPixelData(scalarData, width, height, voiRange);\n            this.scissorsNext.startSearch(worldToSlice(nextPos));\n        }\n        this.scissors.startSearch(startPos);\n        const newAnnotation = !nextPos;\n        const confirmedPath = new LivewirePath();\n        const currentPath = new LivewirePath();\n        const currentPathNext = newAnnotation ? undefined : new LivewirePath();\n        confirmedPath.addPoint(startPos);\n        confirmedPath.addControlPoint(startPos);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        const lastCanvasPoint = viewport.worldToCanvas(worldPos);\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            newAnnotation,\n            hasMoved: false,\n            lastCanvasPoint,\n            confirmedPath,\n            currentPath,\n            confirmedPathNext: currentPathNext,\n            closed: false,\n            handleIndex: this.editData?.handleIndex ?? annotation.handles?.activeHandleIndex,\n            worldToSlice,\n            sliceToWorld,\n            contourHoleProcessingEnabled,\n        };\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const { world: worldPos } = currentPoints;\n        const annotation = this.createAnnotation(evt);\n        const contourHoleProcessingEnabled = getMouseModifierKey(evt.detail.event) ===\n            this.configuration.contourHoleAdditionModifierKey;\n        this.setupBaseEditData(worldPos, element, annotation, undefined, contourHoleProcessingEnabled);\n        this.addAnnotation(annotation, element);\n        this._activateDraw(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(this.editData.viewportIdsToRender);\n        return annotation;\n    }\n    clearEditData() {\n        this.editData = null;\n        this.scissors = null;\n        this.scissorsNext = null;\n        this.isDrawing = false;\n    }\n    editHandle(worldPos, element, annotation, handleIndex) {\n        const { data } = annotation;\n        const { points: handlePoints } = data.handles;\n        const { length: numHandles } = handlePoints;\n        const previousHandle = handlePoints[(handleIndex - 1 + numHandles) % numHandles];\n        const nextHandle = handlePoints[(handleIndex + 1) % numHandles];\n        if (!this.editData?.confirmedPathNext) {\n            this.setupBaseEditData(previousHandle, element, annotation, nextHandle);\n            const { polyline } = data.contour;\n            const confirmedPath = new LivewirePath();\n            const confirmedPathNext = new LivewirePath();\n            const { worldToSlice } = this.editData;\n            const previousIndex = findHandlePolylineIndex(annotation, handleIndex - 1);\n            const nextIndex = findHandlePolylineIndex(annotation, handleIndex + 1);\n            if (nextIndex === -1 || previousIndex === -1) {\n                throw new Error(`Can't find handle index ${nextIndex === -1 && nextHandle} ${previousIndex === -1 && previousHandle}`);\n            }\n            if (handleIndex === 0) {\n                confirmedPathNext.addPoints(polyline.slice(nextIndex + 1, previousIndex).map(worldToSlice));\n            }\n            else {\n                confirmedPath.addPoints(polyline.slice(0, previousIndex + 1).map(worldToSlice));\n                confirmedPathNext.addPoints(polyline.slice(nextIndex, polyline.length).map(worldToSlice));\n            }\n            this.editData.confirmedPath = confirmedPath;\n            this.editData.confirmedPathNext = confirmedPathNext;\n        }\n        const { editData, scissors } = this;\n        const { worldToSlice, sliceToWorld } = editData;\n        const { activeHandleIndex } = data.handles;\n        if (activeHandleIndex === null || activeHandleIndex === undefined) {\n            data.handles.activeHandleIndex = handleIndex;\n        }\n        else if (activeHandleIndex !== handleIndex) {\n            throw new Error(`Trying to edit a different handle than the one currently being edited ${handleIndex}!==${data.handles.activeHandleIndex}`);\n        }\n        const slicePos = worldToSlice(worldPos);\n        if (slicePos[0] < 0 ||\n            slicePos[0] >= scissors.width ||\n            slicePos[1] < 0 ||\n            slicePos[1] >= scissors.height) {\n            return;\n        }\n        handlePoints[handleIndex] = sliceToWorld(slicePos);\n        const pathPointsLeft = scissors.findPathToPoint(slicePos);\n        const pathPointsRight = this.scissorsNext.findPathToPoint(slicePos);\n        const currentPath = new LivewirePath();\n        currentPath.prependPath(editData.confirmedPath);\n        if (handleIndex !== 0) {\n            currentPath.addPoints(pathPointsLeft);\n        }\n        currentPath.addPoints(pathPointsRight.reverse());\n        currentPath.appendPath(editData.confirmedPathNext);\n        if (handleIndex === 0) {\n            currentPath.addPoints(pathPointsLeft);\n        }\n        editData.currentPath = currentPath;\n        annotation.invalidated = true;\n        editData.hasMoved = true;\n        editData.closed = true;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        this.updateAnnotation(this.editData?.currentPath);\n        return super.renderAnnotation(enabledElement, svgDrawingHelper);\n    }\n    isContourSegmentationTool() {\n        return false;\n    }\n    createAnnotation(evt) {\n        const contourSegmentationAnnotation = super.createAnnotation(evt);\n        const { world: worldPos } = evt.detail.currentPoints;\n        const annotation = csUtils.deepMerge(contourSegmentationAnnotation, {\n            data: {\n                handles: {\n                    points: [[...worldPos]],\n                },\n            },\n        });\n        return annotation;\n    }\n    cancelInProgress(element, config, evt) {\n        if (!this.editData) {\n            this.undo();\n            return;\n        }\n        this._endCallback(evt, true);\n    }\n    renderAnnotationInstance(renderContext) {\n        const { annotation, enabledElement, svgDrawingHelper, annotationStyle, targetId, } = renderContext;\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        const { worldToCanvas } = viewport;\n        const { annotationUID, data, highlighted } = annotation;\n        const { handles } = data;\n        const newAnnotation = this.editData?.newAnnotation;\n        const { lineWidth, lineDash, color } = annotationStyle;\n        if (highlighted ||\n            (newAnnotation &&\n                annotation.annotationUID === this.editData?.annotation?.annotationUID)) {\n            const handleGroupUID = '0';\n            const canvasHandles = handles.points.map(worldToCanvas);\n            drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasHandles, {\n                color,\n                lineDash,\n                lineWidth,\n            });\n        }\n        super.renderAnnotationInstance(renderContext);\n        if (!data.cachedStats[targetId] ||\n            data.cachedStats[targetId]?.areaUnit === null) {\n            data.cachedStats[targetId] = {\n                Modality: null,\n                area: null,\n                areaUnit: null,\n            };\n            this._calculateCachedStats(annotation, element);\n        }\n        else if (annotation.invalidated) {\n            this._throttledCalculateCachedStats(annotation, element);\n        }\n        this._renderStats(annotation, viewport, svgDrawingHelper, annotationStyle.textbox);\n        return true;\n    }\n    updateAnnotation(livewirePath) {\n        if (!this.editData || !livewirePath) {\n            return;\n        }\n        const { annotation, sliceToWorld, worldToSlice, closed, newAnnotation } = this.editData;\n        let { pointArray: imagePoints } = livewirePath;\n        if (imagePoints.length > 1) {\n            imagePoints = [...imagePoints, imagePoints[0]];\n        }\n        const targetWindingDirection = newAnnotation && closed ? ContourWindingDirection.Clockwise : undefined;\n        this.updateContourPolyline(annotation, {\n            points: imagePoints,\n            closed,\n            targetWindingDirection,\n        }, {\n            canvasToWorld: sliceToWorld,\n            worldToCanvas: worldToSlice,\n        });\n    }\n}\nexport default LivewireContourTool;\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, areaUnit } = cachedVolumeStats;\n    const textLines = [];\n    if (area) {\n        const areaLine = `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    return textLines;\n}\n", "import { utilities as csUtils } from '@cornerstonejs/core';\nimport LivewireContourTool from './LivewireContourTool';\nimport { LivewirePath } from '../../utilities/livewire/LiveWirePath';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport { ChangeTypes } from '../../enums';\nimport { drawPolyline as drawPolylineSvg } from '../../drawingSvg';\nclass LivewireContourSegmentationTool extends LivewireContourTool {\n    static { this.toolName = 'LivewireContourSegmentationTool'; }\n    updateInterpolatedAnnotation(annotation, enabledElement) {\n        if (this.editData ||\n            !annotation.invalidated ||\n            !annotation.data.handles.interpolationSources) {\n            return;\n        }\n        annotation.data.contour.originalPolyline = annotation.data.contour.polyline;\n        queueMicrotask(() => {\n            if (!annotation.data.handles.interpolationSources) {\n                return;\n            }\n            const { points } = annotation.data.handles;\n            const { element } = enabledElement.viewport;\n            this.setupBaseEditData(points[0], element, annotation);\n            const { length: count } = points;\n            const { scissors } = this;\n            const { nearestEdge, repeatInterpolation } = this.configuration.interpolation;\n            annotation.data.handles.originalPoints = points;\n            const { worldToSlice, sliceToWorld } = this.editData;\n            const handleSmoothing = [];\n            if (nearestEdge) {\n                let lastPoint = worldToSlice(points[points.length - 1]);\n                points.forEach((point, hIndex) => {\n                    const testPoint = worldToSlice(point);\n                    lastPoint = testPoint;\n                    handleSmoothing.push(testPoint);\n                    scissors.startSearch(lastPoint);\n                    scissors.findPathToPoint(testPoint);\n                    scissors.findPathToPoint(worldToSlice(points[(hIndex + 3) % points.length]));\n                    const minPoint = scissors.findMinNearby(testPoint, nearestEdge);\n                    if (!csUtils.isEqual(testPoint, minPoint)) {\n                        handleSmoothing[hIndex] = minPoint;\n                        lastPoint = minPoint;\n                        points[hIndex] = sliceToWorld(minPoint);\n                    }\n                });\n            }\n            const acceptedPath = new LivewirePath();\n            for (let i = 0; i < count; i++) {\n                scissors.startSearch(worldToSlice(points[i]));\n                const path = scissors.findPathToPoint(worldToSlice(points[(i + 1) % count]));\n                acceptedPath.addPoints(path);\n            }\n            this.updateAnnotation(acceptedPath);\n            this.scissors = null;\n            this.scissorsNext = null;\n            this.editData = null;\n            annotation.data.handles.interpolationSources = null;\n            if (repeatInterpolation) {\n                triggerAnnotationModified(annotation, enabledElement.viewport.element, ChangeTypes.InterpolationUpdated);\n            }\n        });\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, svgDrawingHelper } = renderContext;\n        const annotation = renderContext.annotation;\n        const { annotationUID } = annotation;\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const { showInterpolationPolyline } = this.configuration.interpolation || {};\n        this.updateInterpolatedAnnotation?.(annotation, enabledElement);\n        const { originalPolyline } = annotation.data.contour;\n        const rendered = super.renderAnnotationInstance(renderContext);\n        if (showInterpolationPolyline &&\n            originalPolyline &&\n            annotation.autoGenerated) {\n            const polylineCanvasPoints = originalPolyline.map(worldToCanvas);\n            polylineCanvasPoints.push(polylineCanvasPoints[0]);\n            drawPolylineSvg(svgDrawingHelper, annotationUID, 'interpolationContour-0', polylineCanvasPoints, {\n                color: '#70ffff',\n                lineWidth: 1,\n                fillOpacity: 0,\n            });\n        }\n        return rendered;\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n}\nexport default LivewireContourSegmentationTool;\n", "import { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawArrow as drawArrowSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { setAnnotationLabel } from '../../utilities';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nclass ArrowAnnotateTool extends AnnotationTool {\n    static { this.toolName = 'ArrowAnnotate'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            getTextCallback,\n            changeTextCallback,\n            preventHandleOutsideImage: false,\n            arrowFirst: true,\n            arrowHeadStyle: 'legacy',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const { arrowFirst } = this.configuration;\n            const annotation = this.createAnnotation(evt, [[...worldPos], [...worldPos]], {\n                data: {\n                    handles: {\n                        arrowFirst,\n                    },\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved, movingTextBox, } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            if (newAnnotation) {\n                this.configuration.getTextCallback((label) => {\n                    if (!label) {\n                        removeAnnotation(annotation.annotationUID);\n                        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                        this.editData = null;\n                        this.isDrawing = false;\n                        return;\n                    }\n                    annotation.data.label = label;\n                    triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n                    triggerAnnotationCompleted(annotation);\n                    this.createMemo(element, annotation, { newAnnotation: !!this.memo });\n                    setAnnotationLabel(annotation, element, label);\n                    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                });\n            }\n            else if (!movingTextBox) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n            this.doneEditMemo();\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.touchTapCallback = (evt) => {\n            if (evt.detail.taps == 2) {\n                this.doubleClickCallback(evt);\n            }\n        };\n        this.doubleClickCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            let annotations = getAnnotations(this.getToolName(), element);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return;\n            }\n            const clickedAnnotation = annotations.find((annotation) => this.isPointNearTool(element, annotation, eventDetail.currentPoints.canvas, 6));\n            if (!clickedAnnotation) {\n                return;\n            }\n            const annotation = clickedAnnotation;\n            this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));\n            this.editData = null;\n            this.isDrawing = false;\n            evt.stopImmediatePropagation();\n            evt.preventDefault();\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles, label } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, markerSize } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineWidth,\n                    });\n                }\n                const arrowUID = '1';\n                if (this.configuration.arrowFirst) {\n                    drawArrowSvg(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[1], canvasCoordinates[0], {\n                        color,\n                        width: lineWidth,\n                        lineDash: lineDash,\n                        viaMarker: this.configuration.arrowHeadStyle !== 'legacy',\n                        markerSize,\n                    });\n                }\n                else {\n                    drawArrowSvg(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[0], canvasCoordinates[1], {\n                        color,\n                        width: lineWidth,\n                        lineDash: lineDash,\n                        viaMarker: this.configuration.arrowHeadStyle !== 'legacy',\n                        markerSize,\n                    });\n                }\n                renderStatus = true;\n                if (!label) {\n                    continue;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = canvasCoordinates[1];\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, [label], textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n    }\n    static { this.hydrate = (viewportId, points, label, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(ArrowAnnotateTool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = this.createAnnotation({\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                label: label || '',\n                handles: {\n                    points,\n                },\n            },\n            autoGenerated: false,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        });\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _doneChangingTextCallback(element, annotation, updatedLabel) {\n        annotation.data.label = updatedLabel;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        triggerAnnotationModified(annotation, element);\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction getTextCallback(doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nexport default ArrowAnnotateTool;\n", "import { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, drawPath as drawPathSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nclass AngleTool extends AnnotationTool {\n    static { this.toolName = 'Angle'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            showAngleArc: false,\n            arcOffset: 5,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            if (this.angleStartedNotYetCompleted) {\n                return;\n            }\n            this.angleStartedNotYetCompleted = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const annotation = (this.createAnnotation(evt, [\n                [...worldPos],\n                [...worldPos],\n            ]));\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2, point3] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line1 = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            if (!point3) {\n                return false;\n            }\n            const canvasPoint3 = viewport.worldToCanvas(point3);\n            const line2 = {\n                start: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n                end: {\n                    x: canvasPoint3[0],\n                    y: canvasPoint3[1],\n                },\n            };\n            const distanceToPoint2 = lineSegment.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint2 <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            if (this.angleStartedNotYetCompleted && data.handles.points.length === 2) {\n                this.editData.handleIndex = 2;\n                return;\n            }\n            this.angleStartedNotYetCompleted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                this.angleStartedNotYetCompleted = false;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, angleArcLineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].angle == null) {\n                    data.cachedStats[targetId] = {\n                        angle: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotation.annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                let lineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                renderStatus = true;\n                if (canvasCoordinates.length !== 3) {\n                    return renderStatus;\n                }\n                lineUID = '2';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], canvasCoordinates[2], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                if (this.configuration.showAngleArc) {\n                    const center = canvasCoordinates[1];\n                    const offset = this.configuration.arcOffset;\n                    const radius = Math.min(lineSegment.distanceToPoint([center[0], center[1]], [canvasCoordinates[0][0], canvasCoordinates[0][1]], [canvasCoordinates[2][0], canvasCoordinates[2][1]]), lineSegment.distanceToPoint([center[0], center[1]], [canvasCoordinates[2][0], canvasCoordinates[2][1]], [canvasCoordinates[0][0], canvasCoordinates[0][1]])) / offset;\n                    const anglePoints = [];\n                    let startAngle = Math.atan2(canvasCoordinates[0][1] - center[1], canvasCoordinates[0][0] - center[0]);\n                    let endAngle = Math.atan2(canvasCoordinates[2][1] - center[1], canvasCoordinates[2][0] - center[0]);\n                    if (endAngle < startAngle) {\n                        endAngle += 2 * Math.PI;\n                    }\n                    const angleDifference = endAngle - startAngle;\n                    if (angleDifference > Math.PI) {\n                        const temp = startAngle;\n                        startAngle = endAngle;\n                        endAngle = temp + 2 * Math.PI;\n                    }\n                    const segments = 32;\n                    for (let i = 0; i <= segments; i++) {\n                        const angle = startAngle + (i / segments) * (endAngle - startAngle);\n                        anglePoints.push([\n                            center[0] + radius * Math.cos(angle),\n                            center[1] + radius * Math.sin(angle),\n                        ]);\n                    }\n                    drawPathSvg(svgDrawingHelper, annotationUID, '3', anglePoints, {\n                        color: color,\n                        width: lineWidth,\n                        lineDash: angleArcLineDash,\n                    });\n                }\n                if (!data.cachedStats[targetId]?.angle) {\n                    continue;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = canvasCoordinates[1];\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(AngleTool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        if (data.handles.points.length !== 3) {\n            return;\n        }\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[1];\n        const worldPos3 = data.handles.points[2];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const angle = angleBetweenLines([worldPos1, worldPos2], [worldPos2, worldPos3]);\n            const { dimensions, imageData } = this.getTargetImageData(targetId);\n            this.isHandleOutsideImage = [worldPos1, worldPos2, worldPos3]\n                .map((worldPos) => csUtils.transformWorldToIndex(imageData, worldPos))\n                .some((index) => !csUtils.indexWithinDimensions(index, dimensions));\n            cachedStats[targetId] = {\n                angle: isNaN(angle) ? 'Incomplete Angle' : angle,\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { angle } = cachedVolumeStats;\n    if (angle === undefined) {\n        return;\n    }\n    if (isNaN(angle)) {\n        return [`${angle}`];\n    }\n    const textLines = [\n        `${csUtils.roundNumber(angle)} ${String.fromCharCode(176)}`,\n    ];\n    return textLines;\n}\nexport default AngleTool;\n", "const midPoint = (...args) => {\n    const ret = args[0].length === 2 ? [0, 0] : [0, 0, 0];\n    const len = args.length;\n    for (const arg of args) {\n        ret[0] += arg[0] / len;\n        ret[1] += arg[1] / len;\n        if (ret.length === 3) {\n            ret[2] += arg[2] / len;\n        }\n    }\n    return ret;\n};\nconst midPoint2 = midPoint;\nexport default midPoint;\nexport { midPoint2 };\n", "import { vec3 } from 'gl-matrix';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { midPoint2 } from '../../utilities/math/midPoint';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, drawTextBox as drawTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nclass CobbAngleTool extends AnnotationTool {\n    static { this.toolName = 'CobbAngle'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            showArcLines: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            if (this.angleStartedNotYetCompleted) {\n                return;\n            }\n            this.angleStartedNotYetCompleted = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const annotation = (this.createAnnotation(evt, [\n                [...worldPos],\n                [...worldPos],\n            ]));\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { distanceToPoint, distanceToPoint2 } = this.distanceToLines({\n                viewport,\n                points: data.handles.points,\n                canvasCoords,\n                proximity,\n            });\n            if (distanceToPoint <= proximity || distanceToPoint2 <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType, canvasCoords, proximity = 6) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { isNearFirstLine, isNearSecondLine } = this.distanceToLines({\n                viewport,\n                points: annotation.data.handles.points,\n                canvasCoords,\n                proximity,\n            });\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n                isNearFirstLine,\n                isNearSecondLine,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            if (this.angleStartedNotYetCompleted && data.handles.points.length < 4) {\n                resetElementCursor(element);\n                this.editData.handleIndex = data.handles.points.length;\n                return;\n            }\n            this.angleStartedNotYetCompleted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._mouseDownCallback = (evt) => {\n            const { annotation, handleIndex } = this.editData;\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { data } = annotation;\n            if (handleIndex === 1) {\n                data.handles.points[1] = worldPos;\n                this.editData.hasMoved =\n                    data.handles.points[1][0] !== data.handles.points[0][0] ||\n                        data.handles.points[1][1] !== data.handles.points[0][0];\n                return;\n            }\n            if (handleIndex === 3) {\n                data.handles.points[3] = worldPos;\n                this.editData.hasMoved =\n                    data.handles.points[3][0] !== data.handles.points[2][0] ||\n                        data.handles.points[3][1] !== data.handles.points[2][0];\n                this.angleStartedNotYetCompleted = false;\n                return;\n            }\n            this.editData.hasMoved = false;\n            hideElementCursor(element);\n            data.handles.points[2] = data.handles.points[3] = worldPos;\n            this.editData.handleIndex = data.handles.points.length - 1;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, isNearFirstLine, isNearSecondLine, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined &&\n                (isNearFirstLine || isNearSecondLine)) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                if (isNearFirstLine) {\n                    const firstLinePoints = [points[0], points[1]];\n                    firstLinePoints.forEach((point) => {\n                        point[0] += worldPosDelta[0];\n                        point[1] += worldPosDelta[1];\n                        point[2] += worldPosDelta[2];\n                    });\n                }\n                else if (isNearSecondLine) {\n                    const secondLinePoints = [points[2], points[3]];\n                    secondLinePoints.forEach((point) => {\n                        point[0] += worldPosDelta[0];\n                        point[1] += worldPosDelta[1];\n                        point[2] += worldPosDelta[2];\n                    });\n                }\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (!this.isDrawing) {\n                return;\n            }\n            this.isDrawing = false;\n            this._deactivateDraw(element);\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            if (data.handles.points.length < 4) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.angleStartedNotYetCompleted = false;\n            return annotation.annotationUID;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_START, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_START, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_START, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_START, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].angle == null) {\n                    data.cachedStats[targetId] = {\n                        angle: null,\n                        arc1Angle: null,\n                        arc2Angle: null,\n                        points: {\n                            world: {\n                                arc1Start: null,\n                                arc1End: null,\n                                arc2Start: null,\n                                arc2End: null,\n                                arc1Angle: null,\n                                arc2Angle: null,\n                            },\n                            canvas: {\n                                arc1Start: null,\n                                arc1End: null,\n                                arc2Start: null,\n                                arc2End: null,\n                                arc1Angle: null,\n                                arc2Angle: null,\n                            },\n                        },\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const firstLine = [canvasCoordinates[0], canvasCoordinates[1]];\n                const secondLine = [canvasCoordinates[2], canvasCoordinates[3]];\n                let lineUID = 'line1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, firstLine[0], firstLine[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                renderStatus = true;\n                if (canvasCoordinates.length < 4) {\n                    return renderStatus;\n                }\n                lineUID = 'line2';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, secondLine[0], secondLine[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                lineUID = 'linkLine';\n                const mid1 = midPoint2(firstLine[0], firstLine[1]);\n                const mid2 = midPoint2(secondLine[0], secondLine[1]);\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, mid1, mid2, {\n                    color,\n                    lineWidth: '1',\n                    lineDash: '1,4',\n                });\n                const { arc1Start, arc1End, arc2End, arc2Start } = data.cachedStats[targetId].points.canvas;\n                const { arc1Angle, arc2Angle } = data.cachedStats[targetId];\n                if (this.configuration.showArcLines) {\n                    lineUID = 'arc1';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, arc1Start, arc1End, {\n                        color,\n                        lineWidth: '1',\n                    });\n                    lineUID = 'arc2';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, arc2Start, arc2End, {\n                        color,\n                        lineWidth: '1',\n                    });\n                }\n                if (!data.cachedStats[targetId]?.angle) {\n                    continue;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = 'cobbAngleText';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n                if (this.configuration.showArcLines) {\n                    const arc1TextBoxUID = 'arcAngle1';\n                    const arc1TextLine = [\n                        `${arc1Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n                    ];\n                    const arch1TextPosCanvas = midPoint2(arc1Start, arc1End);\n                    drawTextBoxSvg(svgDrawingHelper, annotationUID, arc1TextBoxUID, arc1TextLine, arch1TextPosCanvas, {\n                        ...options,\n                        padding: 3,\n                    });\n                    const arc2TextBoxUID = 'arcAngle2';\n                    const arc2TextLine = [\n                        `${arc2Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n                    ];\n                    const arch2TextPosCanvas = midPoint2(arc2Start, arc2End);\n                    drawTextBoxSvg(svgDrawingHelper, annotationUID, arc2TextBoxUID, arc2TextLine, arch2TextPosCanvas, {\n                        ...options,\n                        padding: 3,\n                    });\n                }\n            }\n            return renderStatus;\n        };\n        this.distanceToLines = ({ viewport, points, canvasCoords, proximity }) => {\n            const [point1, point2, point3, point4] = points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const canvasPoint3 = viewport.worldToCanvas(point3);\n            const canvasPoint4 = viewport.worldToCanvas(point4);\n            const line1 = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const line2 = {\n                start: {\n                    x: canvasPoint3[0],\n                    y: canvasPoint3[1],\n                },\n                end: {\n                    x: canvasPoint4[0],\n                    y: canvasPoint4[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const distanceToPoint2 = lineSegment.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            let isNearFirstLine = false;\n            let isNearSecondLine = false;\n            if (distanceToPoint <= proximity) {\n                isNearFirstLine = true;\n            }\n            else if (distanceToPoint2 <= proximity) {\n                isNearSecondLine = true;\n            }\n            return {\n                distanceToPoint,\n                distanceToPoint2,\n                isNearFirstLine,\n                isNearSecondLine,\n            };\n        };\n        this.getArcsStartEndPoints = ({ firstLine, secondLine, mid1, mid2, }) => {\n            const linkLine = [mid1, mid2];\n            const arc1Angle = angleBetweenLines(firstLine, linkLine);\n            const arc2Angle = angleBetweenLines(secondLine, linkLine);\n            const arc1Side = arc1Angle > 90 ? 1 : 0;\n            const arc2Side = arc2Angle > 90 ? 0 : 1;\n            const midLinkLine = midPoint2(linkLine[0], linkLine[1]);\n            const linkLineLength = Math.sqrt((linkLine[1][0] - linkLine[0][0]) ** 2 +\n                (linkLine[1][1] - linkLine[0][1]) ** 2);\n            const ratio = 0.1;\n            const midFirstLine = midPoint2(firstLine[0], firstLine[1]);\n            const midSecondLine = midPoint2(secondLine[0], secondLine[1]);\n            const directionVectorStartArc1 = [\n                firstLine[arc1Side][0] - midFirstLine[0],\n                firstLine[arc1Side][1] - midFirstLine[1],\n            ];\n            const magnitudeStartArc1 = Math.sqrt(directionVectorStartArc1[0] ** 2 + directionVectorStartArc1[1] ** 2);\n            const normalizedDirectionStartArc1 = [\n                directionVectorStartArc1[0] / magnitudeStartArc1,\n                directionVectorStartArc1[1] / magnitudeStartArc1,\n            ];\n            const arc1Start = [\n                midFirstLine[0] +\n                    normalizedDirectionStartArc1[0] * linkLineLength * ratio,\n                midFirstLine[1] +\n                    normalizedDirectionStartArc1[1] * linkLineLength * ratio,\n            ];\n            const directionVectorEndArc1 = [\n                midLinkLine[0] - mid1[0],\n                midLinkLine[1] - mid1[1],\n            ];\n            const magnitudeEndArc1 = Math.sqrt(directionVectorEndArc1[0] ** 2 + directionVectorEndArc1[1] ** 2);\n            const normalizedDirectionEndArc1 = [\n                directionVectorEndArc1[0] / magnitudeEndArc1,\n                directionVectorEndArc1[1] / magnitudeEndArc1,\n            ];\n            const arc1End = [\n                mid1[0] + normalizedDirectionEndArc1[0] * linkLineLength * ratio,\n                mid1[1] + normalizedDirectionEndArc1[1] * linkLineLength * ratio,\n            ];\n            const directionVectorStartArc2 = [\n                secondLine[arc2Side][0] - midSecondLine[0],\n                secondLine[arc2Side][1] - midSecondLine[1],\n            ];\n            const magnitudeStartArc2 = Math.sqrt(directionVectorStartArc2[0] ** 2 + directionVectorStartArc2[1] ** 2);\n            const normalizedDirectionStartArc2 = [\n                directionVectorStartArc2[0] / magnitudeStartArc2,\n                directionVectorStartArc2[1] / magnitudeStartArc2,\n            ];\n            const arc2Start = [\n                midSecondLine[0] +\n                    normalizedDirectionStartArc2[0] * linkLineLength * ratio,\n                midSecondLine[1] +\n                    normalizedDirectionStartArc2[1] * linkLineLength * ratio,\n            ];\n            const directionVectorEndArc2 = [\n                midLinkLine[0] - mid2[0],\n                midLinkLine[1] - mid2[1],\n            ];\n            const magnitudeEndArc2 = Math.sqrt(directionVectorEndArc2[0] ** 2 + directionVectorEndArc2[1] ** 2);\n            const normalizedDirectionEndArc2 = [\n                directionVectorEndArc2[0] / magnitudeEndArc2,\n                directionVectorEndArc2[1] / magnitudeEndArc2,\n            ];\n            const arc2End = [\n                mid2[0] + normalizedDirectionEndArc2[0] * linkLineLength * ratio,\n                mid2[1] + normalizedDirectionEndArc2[1] * linkLineLength * ratio,\n            ];\n            return {\n                arc1Start,\n                arc1End,\n                arc2Start,\n                arc2End,\n                arc1Angle: arc1Angle > 90 ? 180 - arc1Angle : arc1Angle,\n                arc2Angle: arc2Angle > 90 ? 180 - arc2Angle : arc2Angle,\n            };\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 25, { trailing: true });\n    }\n    handleSelectedCallback(evt, annotation, handle, interactionType = 'mouse') {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        if (data.handles.points.length !== 4) {\n            return;\n        }\n        const seg1 = [null, null];\n        const seg2 = [null, null];\n        let minDist = Number.MAX_VALUE;\n        for (let i = 0; i < 2; i += 1) {\n            for (let j = 2; j < 4; j += 1) {\n                const dist = vec3.distance(data.handles.points[i], data.handles.points[j]);\n                if (dist < minDist) {\n                    minDist = dist;\n                    seg1[1] = data.handles.points[i];\n                    seg1[0] = data.handles.points[(i + 1) % 2];\n                    seg2[0] = data.handles.points[j];\n                    seg2[1] = data.handles.points[2 + ((j - 1) % 2)];\n                }\n            }\n        }\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        const canvasPoints = data.handles.points.map((p) => viewport.worldToCanvas(p));\n        const firstLine = [canvasPoints[0], canvasPoints[1]];\n        const secondLine = [canvasPoints[2], canvasPoints[3]];\n        const mid1 = midPoint2(firstLine[0], firstLine[1]);\n        const mid2 = midPoint2(secondLine[0], secondLine[1]);\n        const { arc1Start, arc1End, arc2End, arc2Start, arc1Angle, arc2Angle } = this.getArcsStartEndPoints({\n            firstLine,\n            secondLine,\n            mid1,\n            mid2,\n        });\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            cachedStats[targetId] = {\n                angle: angleBetweenLines(seg1, seg2),\n                arc1Angle,\n                arc2Angle,\n                points: {\n                    canvas: {\n                        arc1Start,\n                        arc1End,\n                        arc2End,\n                        arc2Start,\n                    },\n                    world: {\n                        arc1Start: viewport.canvasToWorld(arc1Start),\n                        arc1End: viewport.canvasToWorld(arc1End),\n                        arc2End: viewport.canvasToWorld(arc2End),\n                        arc2Start: viewport.canvasToWorld(arc2Start),\n                    },\n                },\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { angle } = cachedVolumeStats;\n    if (angle === undefined) {\n        return;\n    }\n    const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];\n    return textLines;\n}\nexport default CobbAngleTool;\n", "import { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, StackViewport, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawHandle as drawHandleSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { distanceToPoint } from '../../utilities/math/point';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { getCalibratedProbeUnitsAndValue } from '../../utilities/getCalibratedUnits';\nimport { lineSegment } from '../../utilities/math';\nconst { transformWorldToIndex } = csUtils;\nclass UltrasoundDirectionalTool extends AnnotationTool {\n    static { this.toolName = 'UltrasoundDirectionalTool'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            displayBothAxesDistances: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            if (this.startedDrawing) {\n                return;\n            }\n            this.startedDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            if (!(viewport instanceof StackViewport)) {\n                throw new Error('UltrasoundDirectionalTool can only be used on a StackViewport');\n            }\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const annotation = (this.createAnnotation(evt, [\n                [...worldPos],\n                [...worldPos],\n            ]));\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            if (this.startedDrawing && data.handles.points.length === 1) {\n                this.editData.handleIndex = 1;\n                return;\n            }\n            this.startedDrawing = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                this.startedDrawing = false;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].xValues == null) {\n                    data.cachedStats[targetId] = {\n                        xValues: [0, 0],\n                        yValues: [0, 0],\n                        isHorizontal: false,\n                        units: [''],\n                        isUnitless: false,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let handleGroupUID = '0';\n                drawHandleSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates[0], {\n                    color,\n                }, 0);\n                renderStatus = true;\n                if (canvasCoordinates.length !== 2) {\n                    return renderStatus;\n                }\n                handleGroupUID = '1';\n                drawHandleSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates[1], {\n                    color,\n                }, 1);\n                const isUnitless = data.cachedStats[targetId].isUnitless;\n                if (!isUnitless) {\n                    const canvasPoint1 = canvasCoordinates[0];\n                    const canvasPoint2 = canvasCoordinates[1];\n                    const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];\n                    const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];\n                    const isHorizontal = data.cachedStats[targetId].isHorizontal;\n                    let projectedPointCanvas = [0, 0];\n                    if (isHorizontal) {\n                        projectedPointCanvas = [\n                            canvasPoint1[0] + canvasDeltaX,\n                            canvasPoint1[1],\n                        ];\n                    }\n                    else {\n                        projectedPointCanvas = [\n                            canvasPoint1[0],\n                            canvasPoint1[1] + canvasDeltaY,\n                        ];\n                    }\n                    let dataId = `${annotationUID}-line-1`;\n                    let lineUID = '1';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], projectedPointCanvas, {\n                        color,\n                        width: 1,\n                        shadow: this.configuration.shadow,\n                    }, dataId);\n                    dataId = `${annotationUID}-line-2`;\n                    lineUID = '2';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], projectedPointCanvas, {\n                        color,\n                        width: 1,\n                        lineDash: [1, 1],\n                        shadow: this.configuration.shadow,\n                    }, dataId);\n                }\n                else {\n                    const dataId = `${annotationUID}-line-1`;\n                    const lineUID = '1';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                        color,\n                        width: 1,\n                        shadow: this.configuration.shadow,\n                    }, dataId);\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId, this.configuration);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = canvasCoordinates[1];\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    toolSelectedCallback(evt, annotation, interactionType, canvasCoords) {\n        return;\n    }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        this.editData = {\n            handleIndex,\n            annotation,\n            viewportIdsToRender,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        if (data.handles.points.length !== 2) {\n            return;\n        }\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { imageData } = image;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[1];\n            const imageIndex1 = transformWorldToIndex(imageData, worldPos1);\n            const imageIndex2 = transformWorldToIndex(imageData, worldPos2);\n            const { values: values1, units: units1 } = getCalibratedProbeUnitsAndValue(image, [imageIndex1]);\n            const { values: values2, units: units2 } = getCalibratedProbeUnitsAndValue(image, [imageIndex2]);\n            let xValues, yValues, units, isHorizontal;\n            let isUnitless = false;\n            if (units1[0] !== units2[0] ||\n                units1[1] !== units2[1] ||\n                (units1[0] === 'raw' && units2[0] === 'raw')) {\n                const value = distanceToPoint(worldPos1, worldPos2);\n                xValues = [value, 0];\n                yValues = [value, 0];\n                units = ['px'];\n                isUnitless = true;\n            }\n            else {\n                const canvasPoint1 = enabledElement.viewport.worldToCanvas(worldPos1);\n                const canvasPoint2 = enabledElement.viewport.worldToCanvas(worldPos2);\n                const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];\n                const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];\n                isHorizontal = Math.abs(canvasDeltaX) > Math.abs(canvasDeltaY);\n                xValues = [values1[0], values2[0]];\n                yValues = [values1[1], values2[1]];\n                units = [units1[0], units1[1]];\n            }\n            cachedStats[targetId] = {\n                xValues,\n                yValues,\n                isHorizontal,\n                units,\n                isUnitless,\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId, configuration) {\n    const cachedStats = data.cachedStats[targetId];\n    const { xValues, yValues, units, isUnitless, isHorizontal } = cachedStats;\n    if (isUnitless) {\n        return [`${csUtils.roundNumber(xValues[0])} px`];\n    }\n    if (configuration.displayBothAxesDistances) {\n        const dist1 = Math.abs(xValues[1] - xValues[0]);\n        const dist2 = Math.abs(yValues[1] - yValues[0]);\n        return [\n            `${csUtils.roundNumber(dist1)} ${units[0]}`,\n            `${csUtils.roundNumber(dist2)} ${units[1]}`,\n        ];\n    }\n    if (isHorizontal) {\n        const dist = Math.abs(xValues[1] - xValues[0]);\n        return [`${csUtils.roundNumber(dist)} ${units[0]}`];\n    }\n    else {\n        const dist = Math.abs(yValues[1] - yValues[0]);\n        return [`${csUtils.roundNumber(dist)} ${units[1]}`];\n    }\n}\nexport default UltrasoundDirectionalTool;\n", "function normalizeAngle(angle) {\n    return ((angle % 360) + 360) % 360;\n}\nexport function angleFromCenter(center, point) {\n    const dx = point[0] - center[0];\n    const dy = point[1] - center[1];\n    const angle = Math.atan2(dy, dx) * (180 / Math.PI);\n    return normalizeAngle(angle);\n}\nexport function intervalFromPoints(center, pair) {\n    const start = angleFromCenter(center, pair[0]);\n    const end = angleFromCenter(center, pair[1]);\n    return start < end ? [start, end] : [end, start];\n}\nexport function mergeIntervals(intervals) {\n    if (!intervals.length) {\n        return [];\n    }\n    intervals.sort((a, b) => a[0] - b[0]);\n    const merged = [intervals[0].slice()];\n    for (let i = 1; i < intervals.length; i++) {\n        const last = merged[merged.length - 1];\n        const current = intervals[i];\n        if (current[0] <= last[1]) {\n            last[1] = Math.max(last[1], current[1]);\n        }\n        else {\n            merged.push(current.slice());\n        }\n    }\n    return merged;\n}\nexport function subtractIntervals(blocked, target) {\n    const [T0, T1] = target;\n    if (T1 <= T0) {\n        return [];\n    }\n    const overlaps = blocked\n        .map(([a, b]) => [Math.max(a, T0), Math.min(b, T1)])\n        .filter(([a, b]) => b > a);\n    if (overlaps.length === 0) {\n        return [[T0, T1]];\n    }\n    overlaps.sort((p, q) => p[0] - q[0]);\n    const merged = [];\n    let [curA, curB] = overlaps[0];\n    for (let i = 1; i < overlaps.length; i++) {\n        const [a, b] = overlaps[i];\n        if (a <= curB) {\n            curB = Math.max(curB, b);\n        }\n        else {\n            merged.push([curA, curB]);\n            [curA, curB] = [a, b];\n        }\n    }\n    merged.push([curA, curB]);\n    const gaps = [];\n    let cursor = T0;\n    for (const [a, b] of merged) {\n        if (a > cursor) {\n            gaps.push([cursor, a]);\n        }\n        cursor = Math.max(cursor, b);\n    }\n    if (cursor < T1) {\n        gaps.push([cursor, T1]);\n    }\n    return gaps;\n}\nexport function clipInterval(inner, outerMerged) {\n    const result = [];\n    for (const out of outerMerged) {\n        const start = Math.max(inner[0], out[0]);\n        const end = Math.min(inner[1], out[1]);\n        if (start < end) {\n            result.push([start, end]);\n        }\n    }\n    return result;\n}\nexport function calculateInnerFanPercentage(center, outerFanPairs, innerFanPairs) {\n    const outerIntervals = outerFanPairs.map((pair) => intervalFromPoints(center, pair));\n    const mergedOuter = mergeIntervals(outerIntervals);\n    const outerTotal = mergedOuter.reduce((sum, [a, b]) => sum + (b - a), 0);\n    if (outerTotal === 0) {\n        return 0;\n    }\n    const clippedInnerIntervals = [];\n    for (const pair of innerFanPairs) {\n        const innerInterval = intervalFromPoints(center, pair);\n        const clipped = clipInterval(innerInterval, mergedOuter);\n        clippedInnerIntervals.push(...clipped);\n    }\n    const mergedInner = mergeIntervals(clippedInnerIntervals);\n    const innerTotal = mergedInner.reduce((sum, [a, b]) => sum + (b - a), 0);\n    const percentage = (innerTotal / outerTotal) * 100;\n    return Math.min(100, Math.max(0, percentage));\n}\n", "import { Events, ChangeTypes } from '../../../enums';\nimport { getEnabledElement, utilities, metaData, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawFan as drawFanSvg, } from '../../../drawingSvg';\nimport { state } from '../../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { angleFromCenter, calculateInnerFanPercentage, clipInterval, intervalFromPoints, mergeIntervals, subtractIntervals, } from '../../../utilities/math/fan/fanUtils';\nimport { calculateFanGeometry } from './utils/fanExtraction';\nconst { transformIndexToWorld } = utilities;\nclass UltrasoundPleuraBLineTool extends AnnotationTool {\n    static { this.toolName = 'UltrasoundPleuraBLineTool'; }\n    static { this.USPleuraBLineAnnotationType = {\n        BLINE: 'bLine',\n        PLEURA: 'pleura',\n    }; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            center: null,\n            innerRadius: null,\n            outerRadius: null,\n            startAngle: null,\n            endAngle: null,\n            bLineColor: 'rgb(60, 255, 60)',\n            pleuraColor: 'rgb(0, 4, 255)',\n            drawDepthGuide: true,\n            depth_ratio: 0.5,\n            depthGuideColor: 'rgb(0, 255, 255)',\n            depthGuideThickness: 4,\n            depthGuideDashLength: 20,\n            depthGuideDashGap: 16,\n            depthGuideOpacity: 0.2,\n            fanOpacity: 0.1,\n            showFanAnnotations: true,\n            updatePercentageCallback: null,\n            actions: {\n                undo: {\n                    method: 'undo',\n                    bindings: [{ key: 'z' }],\n                },\n                redo: {\n                    method: 'redo',\n                    bindings: [{ key: 'y' }],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.pleuraAnnotations = [];\n        this.bLineAnnotations = [];\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const { viewPlaneNormal, viewUp, position: cameraPosition, } = viewport.getCamera();\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                    toolName: this.getToolName(),\n                    referencedImageId,\n                    viewUp,\n                    cameraPosition,\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                    },\n                    annotationType: this.getActiveAnnotationType(),\n                    label: '',\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { viewport } = getEnabledElement(element) || {};\n            if (!viewport) {\n                return;\n            }\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                const allPointsInsideShape = points.every((point) => {\n                    const newPoint = [\n                        point[0] + worldPosDelta[0],\n                        point[1] + worldPosDelta[1],\n                        point[2] + worldPosDelta[2],\n                    ];\n                    return this.isInsideFanShape(viewport, newPoint);\n                });\n                if (allPointsInsideShape) {\n                    points.forEach((point) => {\n                        point[0] += worldPosDelta[0];\n                        point[1] += worldPosDelta[1];\n                        point[2] += worldPosDelta[2];\n                    });\n                    annotation.invalidated = true;\n                }\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                if (this.isInsideFanShape(viewport, worldPos)) {\n                    data.handles.points[handleIndex] = [...worldPos];\n                    annotation.invalidated = true;\n                }\n            }\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            if (!this.getFanShapeGeometryParameters(viewport)) {\n                return;\n            }\n            const { imageData } = viewport.getImageData() || {};\n            if (!imageData) {\n                return renderStatus;\n            }\n            if (this.configuration.drawDepthGuide) {\n                this.drawDepthGuide(svgDrawingHelper, viewport);\n            }\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const fanCenter = viewport.worldToCanvas(transformIndexToWorld(imageData, this.configuration.center));\n            const indexToCanvasRatio = this.getIndexToCanvasRatio(viewport);\n            const innerRadius = this.configuration.innerRadius * indexToCanvasRatio;\n            const outerRadius = this.configuration.outerRadius * indexToCanvasRatio;\n            const currentImageId = viewport.getCurrentImageId();\n            const unMergedPleuraIntervals = annotations\n                .filter((annotation) => annotation.data.annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA &&\n                annotation.metadata.referencedImageId === currentImageId)\n                .map((annotation) => {\n                const canvasCoordinates = annotation.data.handles.points.map((p) => viewport.worldToCanvas(p));\n                const interval = intervalFromPoints(fanCenter, canvasCoordinates);\n                return interval;\n            });\n            const mergedPleuraIntervals = mergeIntervals(unMergedPleuraIntervals);\n            const pleuraIntervalsDisplayed = [];\n            const bLineIntervalsDisplayed = [];\n            const drawAnnotation = (annotation) => {\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    return;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color: this.getColorForLineType(annotation),\n                        fill: this.getColorForLineType(annotation),\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const dataId = `${annotationUID}-line`;\n                const lineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color: this.getColorForLineType(annotation),\n                    width: lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId);\n                if (this.configuration.showFanAnnotations) {\n                    const lineInterval = intervalFromPoints(fanCenter, canvasCoordinates);\n                    let fanNumber = 0;\n                    if (annotation.data.annotationType ===\n                        UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE) {\n                        const uncoveredIntervals = subtractIntervals(bLineIntervalsDisplayed, lineInterval);\n                        uncoveredIntervals.forEach((interval) => {\n                            const clippedIntervals = clipInterval(interval, mergedPleuraIntervals);\n                            clippedIntervals.forEach((clippedInterval) => {\n                                fanNumber++;\n                                const fanIndex = fanNumber;\n                                const fanDataId = `${annotationUID}-fan-${fanIndex}`;\n                                const fanUID = `2-${fanIndex}`;\n                                drawFanSvg(svgDrawingHelper, annotationUID, fanUID, fanCenter, innerRadius, outerRadius, clippedInterval[0], clippedInterval[1], {\n                                    color: 'transparent',\n                                    fill: this.getColorForLineType(annotation),\n                                    fillOpacity: this.configuration.fanOpacity,\n                                    width: lineWidth,\n                                    lineDash,\n                                    shadow,\n                                }, fanDataId, 10);\n                                bLineIntervalsDisplayed.push(clippedInterval);\n                            });\n                        });\n                    }\n                    else if (annotation.data.annotationType ===\n                        UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA) {\n                        const uncoveredIntervals = subtractIntervals(pleuraIntervalsDisplayed, lineInterval);\n                        uncoveredIntervals.forEach((interval, index) => {\n                            fanNumber++;\n                            const fanIndex = fanNumber;\n                            const fanDataId = `${annotationUID}-fan-${fanIndex}`;\n                            const fanUID = `2-${fanIndex}`;\n                            drawFanSvg(svgDrawingHelper, annotationUID, fanUID, fanCenter, innerRadius, outerRadius, interval[0], interval[1], {\n                                color: 'transparent',\n                                fill: this.getColorForLineType(annotation),\n                                fillOpacity: this.configuration.fanOpacity,\n                                width: lineWidth,\n                                lineDash,\n                                shadow,\n                            }, fanDataId, 5);\n                            pleuraIntervalsDisplayed.push(interval);\n                        });\n                    }\n                }\n            };\n            const pleuraAnnotationsToDraw = annotations.filter((annotation) => annotation.data.annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA &&\n                annotation.metadata.referencedImageId === currentImageId);\n            pleuraAnnotationsToDraw.forEach((annotation) => {\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                drawAnnotation(annotation);\n            });\n            const bLineAnnotationsToDraw = annotations.filter((annotation) => annotation.data.annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE &&\n                annotation.metadata.referencedImageId === currentImageId);\n            bLineAnnotationsToDraw.forEach((annotation) => {\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                drawAnnotation(annotation);\n            });\n            renderStatus = true;\n            if (this.configuration.updatePercentageCallback && viewport) {\n                this.configuration.updatePercentageCallback(this.calculateBLinePleuraPercentage(viewport));\n            }\n            return renderStatus;\n        };\n        this.activeAnnotationType =\n            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE;\n    }\n    static filterAnnotations(element, filterFunction = () => true) {\n        const annotations = getAnnotations(UltrasoundPleuraBLineTool.toolName, element);\n        if (!annotations?.length) {\n            return [];\n        }\n        const filteredAnnotations = annotations.filter((annotation) => {\n            const currentImageId = annotation.metadata.referencedImageId;\n            return filterFunction(currentImageId);\n        });\n        return filteredAnnotations;\n    }\n    static countAnnotations(element, filterFunction = () => true) {\n        const annotations = getAnnotations(UltrasoundPleuraBLineTool.toolName, element);\n        const { viewport } = getEnabledElement(element);\n        const imageIds = viewport.getImageIds();\n        const getImageIdIndex = (imageId) => {\n            const index = imageIds.findIndex((id) => id === imageId);\n            if (index === -1) {\n                return 0;\n            }\n            return index;\n        };\n        if (!annotations?.length) {\n            return;\n        }\n        const annotationMapping = new Map();\n        annotations.forEach((annotation) => {\n            const currentImageId = annotation.metadata.referencedImageId;\n            if (!filterFunction(currentImageId)) {\n                return;\n            }\n            const { annotationType } = annotation.data;\n            let counts;\n            if (annotationMapping.has(currentImageId)) {\n                counts = annotationMapping.get(currentImageId);\n            }\n            else {\n                counts = {\n                    frame: getImageIdIndex(currentImageId),\n                    bLine: 0,\n                    pleura: 0,\n                };\n            }\n            if (annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA) {\n                counts.pleura++;\n            }\n            else if (annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE) {\n                counts.bLine++;\n            }\n            annotationMapping.set(currentImageId, counts);\n        });\n        return annotationMapping;\n    }\n    static deleteAnnotations(element, filterFunction = () => false) {\n        const annotations = getAnnotations(UltrasoundPleuraBLineTool.toolName, element);\n        if (!annotations?.length) {\n            return;\n        }\n        annotations.forEach((annotation) => {\n            if (!filterFunction(annotation.metadata.referencedImageId)) {\n                return;\n            }\n            removeAnnotation(annotation.annotationUID);\n        });\n    }\n    setActiveAnnotationType(type) {\n        this.activeAnnotationType = type;\n    }\n    getActiveAnnotationType() {\n        return this.activeAnnotationType;\n    }\n    deleteLastAnnotationType(element, type) {\n        let annotationList;\n        const annotations = getAnnotations(UltrasoundPleuraBLineTool.toolName, element);\n        if (type === UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA) {\n            annotationList = annotations.filter((annotation) => annotation.data.annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA);\n        }\n        else if (type === UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE) {\n            annotationList = annotations.filter((annotation) => annotation.data.annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE);\n        }\n        if (annotationList?.length > 0) {\n            const annotation = annotationList.pop();\n            removeAnnotation(annotation.annotationUID);\n        }\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(UltrasoundPleuraBLineTool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    isInsideFanShape(viewport, point) {\n        if (!this.getFanShapeGeometryParameters(viewport)) {\n            return false;\n        }\n        const { imageData } = viewport.getImageData() || {};\n        if (imageData) {\n            const fanCenter = viewport.worldToCanvas(imageData.indexToWorld(this.configuration.center));\n            const canvasCoordinates = viewport.worldToCanvas(point);\n            const angle = angleFromCenter(fanCenter, canvasCoordinates);\n            return (angle >= this.configuration.startAngle &&\n                angle <= this.configuration.endAngle);\n        }\n    }\n    updateFanGeometryConfiguration(fanGeometry) {\n        if (!fanGeometry) {\n            return;\n        }\n        if (this.isFanShapeGeometryParametersValid(fanGeometry)) {\n            this.configuration.center = [\n                fanGeometry.center[0],\n                fanGeometry.center[1],\n                0,\n            ];\n        }\n        this.configuration.innerRadius = fanGeometry.innerRadius;\n        this.configuration.outerRadius = fanGeometry.outerRadius;\n        this.configuration.startAngle = fanGeometry.startAngle;\n        this.configuration.endAngle = fanGeometry.endAngle;\n    }\n    deriveFanGeometryFromViewport(viewport) {\n        const imageId = viewport.getCurrentImageId();\n        const { fanGeometry } = calculateFanGeometry(imageId) || {};\n        if (fanGeometry) {\n            this.updateFanGeometryConfiguration(fanGeometry);\n        }\n    }\n    isFanShapeGeometryParametersValid(fanGeometry) {\n        if (!fanGeometry) {\n            fanGeometry = this.configuration;\n        }\n        return (fanGeometry?.center &&\n            fanGeometry?.innerRadius > 0 &&\n            fanGeometry?.outerRadius &&\n            fanGeometry?.startAngle > 0 &&\n            fanGeometry?.startAngle < 360 &&\n            fanGeometry?.endAngle > 0 &&\n            fanGeometry?.endAngle < 360);\n    }\n    getFanShapeGeometryParameters(viewport) {\n        if (this.isFanShapeGeometryParametersValid()) {\n            return true;\n        }\n        if (!this.isFanShapeGeometryParametersValid()) {\n            const imageId = viewport.getCurrentImageId();\n            const fanGeometry = metaData.get('ultrasoundFanShapeGeometry', imageId);\n            this.updateFanGeometryConfiguration(fanGeometry);\n        }\n        if (!this.isFanShapeGeometryParametersValid()) {\n            this.deriveFanGeometryFromViewport(viewport);\n        }\n        return this.isFanShapeGeometryParametersValid();\n    }\n    calculateBLinePleuraPercentage(viewport) {\n        if (!this.getFanShapeGeometryParameters(viewport)) {\n            return;\n        }\n        const { imageData } = viewport.getImageData() || {};\n        if (!imageData) {\n            return;\n        }\n        const { element } = viewport;\n        const fanCenter = viewport.worldToCanvas(imageData.indexToWorld(this.configuration.center));\n        const currentImageId = viewport.getCurrentImageId();\n        const annotations = getAnnotations(this.getToolName(), element) || [];\n        const pleuraIntervals = annotations\n            .filter((annotation) => annotation.data.annotationType ===\n            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA &&\n            annotation.metadata.referencedImageId === currentImageId)\n            .map((annotation) => {\n            const canvasCoordinates = annotation.data.handles.points.map((p) => viewport.worldToCanvas(p));\n            return canvasCoordinates;\n        });\n        const bLineIntervals = annotations\n            .filter((annotation) => annotation.data.annotationType ===\n            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE &&\n            annotation.metadata.referencedImageId === currentImageId)\n            .map((annotation) => {\n            const canvasCoordinates = annotation.data.handles.points.map((p) => viewport.worldToCanvas(p));\n            return canvasCoordinates;\n        });\n        return calculateInnerFanPercentage(fanCenter, pleuraIntervals, bLineIntervals);\n    }\n    getColorForLineType(annotation) {\n        const { annotationType } = annotation.data;\n        const { bLineColor, pleuraColor } = this.configuration;\n        if (annotationType ===\n            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE) {\n            return bLineColor;\n        }\n        if (annotationType ===\n            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA) {\n            return pleuraColor;\n        }\n        return bLineColor;\n    }\n    getIndexToCanvasRatio(viewport) {\n        const { imageData } = viewport.getImageData() || {};\n        const v1 = viewport.worldToCanvas(imageData.indexToWorld([1, 0, 0]));\n        const v2 = viewport.worldToCanvas(imageData.indexToWorld([2, 0, 0]));\n        const diffVector = [v2[0] - v1[0], v2[1] - v1[1]];\n        const vectorSize = Math.sqrt(diffVector[0] * diffVector[0] + diffVector[1] * diffVector[1]);\n        return vectorSize;\n    }\n    drawDepthGuide(svgDrawingHelper, viewport) {\n        if (!this.getFanShapeGeometryParameters(viewport)) {\n            return;\n        }\n        const { imageData } = viewport.getImageData() || {};\n        if (!imageData) {\n            return;\n        }\n        const radToDegree = (rad) => (rad * 180) / Math.PI;\n        const degreeToRad = (degree) => (degree * Math.PI) / 180;\n        const indexToCanvas = (point) => {\n            return viewport.worldToCanvas(transformIndexToWorld(imageData, point));\n        };\n        const depth_radius = this.configuration.innerRadius +\n            this.configuration.depth_ratio *\n                (this.configuration.outerRadius - this.configuration.innerRadius);\n        const theta_start = this.configuration.startAngle;\n        const theta_end = this.configuration.endAngle;\n        const theta_range = theta_end - theta_start;\n        const arc_length = degreeToRad(theta_range) * depth_radius;\n        let num_dashes = Math.round(arc_length /\n            (this.configuration.depthGuideDashLength +\n                this.configuration.depthGuideDashGap));\n        if (num_dashes <= 0) {\n            num_dashes = Math.max(15, Math.round(theta_range / 5));\n        }\n        const theta_step = theta_range / num_dashes;\n        for (let i = 0; i < num_dashes; i++) {\n            const theta1 = degreeToRad(theta_start + i * theta_step);\n            const theta2 = degreeToRad(theta_start +\n                i * theta_step +\n                radToDegree(this.configuration.depthGuideDashLength) / depth_radius);\n            const start_point = [\n                this.configuration.center[0] + depth_radius * Math.cos(theta1),\n                this.configuration.center[1] + depth_radius * Math.sin(theta1),\n                0,\n            ];\n            const end_point = [\n                this.configuration.center[0] + depth_radius * Math.cos(theta2),\n                this.configuration.center[1] + depth_radius * Math.sin(theta2),\n                0,\n            ];\n            drawLineSvg(svgDrawingHelper, viewport.id, `depthGuide-${i}`, indexToCanvas(start_point), indexToCanvas(end_point), {\n                color: this.configuration.depthGuideColor,\n                lineWidth: this.configuration.depthGuideThickness,\n                strokeOpacity: this.configuration.depthGuideOpacity,\n            });\n        }\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (utilities.indexWithinDimensions(index1, dimensions) &&\n            utilities.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    return [''];\n}\nexport default UltrasoundPleuraBLineTool;\n", "import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawArrow as drawArrowSvg, drawHandles as drawHandlesSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nclass KeyImageTool extends AnnotationTool {\n    static { this.toolName = 'KeyImage'; }\n    static { this.dataSeries = {\n        data: {\n            seriesLevel: true,\n        },\n    }; }\n    static { this.dataPoint = {\n        data: {\n            isPoint: true,\n        },\n    }; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            getTextCallback,\n            changeTextCallback,\n            canvasPosition: [10, 10],\n            canvasSize: 10,\n            handleRadius: '6',\n            seriesLevel: false,\n            isPoint: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const worldPos = currentPoints.world;\n            const annotation = (this.constructor).createAnnotationForViewport(viewport, {\n                data: {\n                    handles: { points: [[...worldPos]] },\n                    seriesLevel: this.configuration.seriesLevel,\n                    isPoint: this.configuration.isPoint,\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.configuration.getTextCallback((label) => {\n                if (!label) {\n                    removeAnnotation(annotation.annotationUID);\n                    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                    this.isDrawing = false;\n                    return;\n                }\n                annotation.data.label = label;\n                triggerAnnotationCompleted(annotation);\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            });\n            this.createMemo(element, annotation, { newAnnotation: true });\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            if (!data?.isPoint) {\n                return false;\n            }\n            const { canvasPosition, canvasSize } = this.configuration;\n            if (!canvasPosition?.length) {\n                return false;\n            }\n            if (Math.abs(canvasCoords[0] - canvasPosition[0] + canvasSize / 2) <=\n                canvasSize / 2 &&\n                Math.abs(canvasCoords[1] - canvasPosition[1] + canvasSize / 2) <=\n                    canvasSize / 2) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            annotation.highlighted = true;\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { viewportId, renderingEngine } = getEnabledElement(element);\n            this.eventDispatchDetail = {\n                viewportId,\n                renderingEngineId: renderingEngine.id,\n            };\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            if (newAnnotation) {\n                this.createMemo(element, annotation, { newAnnotation });\n            }\n            this.editData = null;\n            this.isDrawing = false;\n            this.doneEditMemo();\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this.doubleClickCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            let annotations = getAnnotations(this.getToolName(), element);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return;\n            }\n            const clickedAnnotation = annotations.find((annotation) => this.isPointNearTool(element, annotation, eventDetail.currentPoints.canvas, 6));\n            if (!clickedAnnotation) {\n                return;\n            }\n            const annotation = clickedAnnotation;\n            this.createMemo(element, annotation);\n            this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));\n            this.isDrawing = false;\n            this.doneEditMemo();\n            evt.stopImmediatePropagation();\n            evt.preventDefault();\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            data.handles.points[0] = [...worldPos];\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const { canvasPosition, canvasSize } = this.configuration;\n                const arrowUID = '1';\n                if (data?.isPoint) {\n                    const point = data.handles.points[0];\n                    const canvasCoordinates = viewport.worldToCanvas(point);\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, arrowUID, [canvasCoordinates], {\n                        color,\n                        lineWidth,\n                        handleRadius: this.configuration.handleRadius,\n                    });\n                }\n                else if (canvasPosition?.length) {\n                    drawArrowSvg(svgDrawingHelper, annotationUID, arrowUID, canvasPosition.map((it) => it + canvasSize), canvasPosition, {\n                        color,\n                        width: 1,\n                    });\n                }\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n            }\n            return renderStatus;\n        };\n    }\n    handleSelectedCallback(evt, annotation) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        annotation.highlighted = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    static setPoint(annotation, isPoint = !annotation.data.isPoint, element) {\n        annotation.data.isPoint = isPoint;\n        triggerAnnotationModified(annotation, element);\n    }\n    _doneChangingTextCallback(element, annotation, updatedText) {\n        annotation.data.label = updatedText;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        triggerAnnotationModified(annotation, element);\n    }\n    cancel(element) {\n        if (this.isDrawing) {\n            this.isDrawing = false;\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            return annotation.annotationUID;\n        }\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction getTextCallback(doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nexport default KeyImageTool;\n", "import { BaseTool, AnnotationTool } from './base';\nimport { getAnnotations, getAnnotation, removeAnnotation, } from '../stateManagement/annotation/annotationState';\nimport { setAnnotationSelected } from '../stateManagement/annotation/annotationSelection';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nclass AnnotationEraserTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            return this._deleteNearbyAnnotations(evt, 'mouse');\n        };\n        this.preTouchStartCallback = (evt) => {\n            return this._deleteNearbyAnnotations(evt, 'touch');\n        };\n    }\n    _deleteNearbyAnnotations(evt, interactionType) {\n        const { renderingEngineId, viewportId, element, currentPoints } = evt.detail;\n        const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n        if (!toolGroup) {\n            return false;\n        }\n        const tools = toolGroup._toolInstances;\n        const annotationsToRemove = [];\n        for (const toolName in tools) {\n            const toolInstance = tools[toolName];\n            if (typeof toolInstance.isPointNearTool !== 'function' ||\n                typeof toolInstance.filterInteractableAnnotationsForElement !==\n                    'function') {\n                continue;\n            }\n            const annotations = getAnnotations(toolName, element);\n            const interactableAnnotations = toolInstance.filterInteractableAnnotationsForElement(element, annotations);\n            if (!interactableAnnotations) {\n                continue;\n            }\n            for (const annotation of interactableAnnotations) {\n                if (toolInstance.isPointNearTool(element, annotation, currentPoints.canvas, 10, interactionType)) {\n                    annotationsToRemove.push(annotation.annotationUID);\n                }\n            }\n        }\n        for (const annotationUID of annotationsToRemove) {\n            setAnnotationSelected(annotationUID);\n            const annotation = getAnnotation(annotationUID);\n            AnnotationTool.createAnnotationMemo(element, annotation, {\n                deleting: true,\n            });\n            removeAnnotation(annotationUID);\n        }\n        evt.preventDefault();\n        return true;\n    }\n}\nAnnotationEraserTool.toolName = 'Eraser';\nexport default AnnotationEraserTool;\n", "import { getEnabledElement, utilities as csUtils, cache, getRenderingEngine, volumeLoader, imageLoader, ImageVolume, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { SegmentationRepresentations } from '../../enums';\nimport { segmentIndex as segmentIndexController, state as segmentationState, activeSegmentation, } from '../../stateManagement/segmentation';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { DEFAULT_POSITIVE_STD_DEV_MULTIPLIER, DEFAULT_NEGATIVE_SEED_MARGIN, } from '../../utilities/segmentation/growCut/constants';\nimport { getSVGStyleForSegment } from '../../utilities/segmentation/getSVGStyleForSegment';\nimport IslandRemoval from '../../utilities/segmentation/islandRemoval';\nimport { getOrCreateSegmentationVolume } from '../../utilities/segmentation';\nimport { getCurrentLabelmapImageIdForViewport } from '../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nconst { transformWorldToIndex, transformIndexToWorld } = csUtils;\nclass GrowCutBaseTool extends BaseTool {\n    static { this.lastGrowCutCommand = null; }\n    constructor(toolProps, defaultToolProps) {\n        const baseToolProps = csUtils.deepMerge({\n            configuration: {\n                positiveStdDevMultiplier: DEFAULT_POSITIVE_STD_DEV_MULTIPLIER,\n                shrinkExpandIncrement: 0.1,\n                islandRemoval: {\n                    enabled: false,\n                },\n            },\n        }, defaultToolProps);\n        super(toolProps, baseToolProps);\n    }\n    async preMouseDownCallback(evt) {\n        const eventData = evt.detail;\n        const { element, currentPoints } = eventData;\n        const { world: worldPoint } = currentPoints;\n        const enabledElement = getEnabledElement(element);\n        const { viewport, renderingEngine } = enabledElement;\n        const { viewUp } = viewport.getCamera();\n        const { segmentationId, segmentIndex, labelmapVolumeId, referencedVolumeId, } = await this.getLabelmapSegmentationData(viewport);\n        if (!this._isOrthogonalView(viewport, referencedVolumeId)) {\n            throw new Error('Oblique view is not supported yet');\n        }\n        this.growCutData = {\n            metadata: {\n                ...viewport.getViewReference({ points: [worldPoint] }),\n                viewUp,\n            },\n            segmentation: {\n                segmentationId,\n                segmentIndex,\n                labelmapVolumeId,\n                referencedVolumeId,\n            },\n            viewportId: viewport.id,\n            renderingEngineId: renderingEngine.id,\n        };\n        evt.preventDefault();\n        return true;\n    }\n    shrink() {\n        this._runLastCommand({\n            shrinkExpandAmount: -this.configuration.shrinkExpandIncrement,\n        });\n    }\n    expand() {\n        this._runLastCommand({\n            shrinkExpandAmount: this.configuration.shrinkExpandIncrement,\n        });\n    }\n    refresh() {\n        this._runLastCommand();\n    }\n    async getGrowCutLabelmap(_growCutData) {\n        throw new Error('Not implemented');\n    }\n    async runGrowCut() {\n        const { growCutData, configuration: config } = this;\n        const { segmentation: { segmentationId, segmentIndex, labelmapVolumeId }, } = growCutData;\n        const labelmap = cache.getVolume(labelmapVolumeId);\n        let shrinkExpandAccumulator = 0;\n        const growCutCommand = async ({ shrinkExpandAmount = 0 } = {}) => {\n            if (shrinkExpandAmount !== 0) {\n                this.seeds = null;\n            }\n            shrinkExpandAccumulator += shrinkExpandAmount;\n            const newPositiveStdDevMultiplier = Math.max(0.1, config.positiveStdDevMultiplier + shrinkExpandAccumulator);\n            const negativeSeedMargin = shrinkExpandAmount < 0\n                ? Math.max(1, DEFAULT_NEGATIVE_SEED_MARGIN -\n                    Math.abs(shrinkExpandAccumulator) * 3)\n                : DEFAULT_NEGATIVE_SEED_MARGIN + shrinkExpandAccumulator * 3;\n            const updatedGrowCutData = {\n                ...growCutData,\n                options: {\n                    ...(growCutData.options || {}),\n                    positiveSeedValue: segmentIndex,\n                    negativeSeedValue: 255,\n                    positiveStdDevMultiplier: newPositiveStdDevMultiplier,\n                    negativeSeedMargin,\n                },\n            };\n            const growcutLabelmap = await this.getGrowCutLabelmap(updatedGrowCutData);\n            const { isPartialVolume } = config;\n            const fn = isPartialVolume\n                ? this.applyPartialGrowCutLabelmap\n                : this.applyGrowCutLabelmap;\n            fn(segmentationId, segmentIndex, labelmap, growcutLabelmap);\n            this._removeIslands(updatedGrowCutData);\n        };\n        await growCutCommand();\n        GrowCutBaseTool.lastGrowCutCommand = growCutCommand;\n        this.growCutData = null;\n    }\n    applyPartialGrowCutLabelmap(segmentationId, segmentIndex, targetLabelmap, sourceLabelmap) {\n        const srcLabelmapData = sourceLabelmap.voxelManager.getCompleteScalarDataArray();\n        const tgtVoxelManager = targetLabelmap.voxelManager;\n        const [srcColumns, srcRows, srcNumSlices] = sourceLabelmap.dimensions;\n        const [tgtColumns, tgtRows] = targetLabelmap.dimensions;\n        const srcPixelsPerSlice = srcColumns * srcRows;\n        const tgtPixelsPerSlice = tgtColumns * tgtRows;\n        for (let srcSlice = 0; srcSlice < srcNumSlices; srcSlice++) {\n            for (let srcRow = 0; srcRow < srcRows; srcRow++) {\n                const srcRowIJK = [0, srcRow, srcSlice];\n                const rowVoxelWorld = transformIndexToWorld(sourceLabelmap.imageData, srcRowIJK);\n                const tgtRowIJK = transformWorldToIndex(targetLabelmap.imageData, rowVoxelWorld);\n                const [tgtColumn, tgtRow, tgtSlice] = tgtRowIJK;\n                const srcOffset = srcRow * srcColumns + srcSlice * srcPixelsPerSlice;\n                const tgtOffset = tgtColumn + tgtRow * tgtColumns + tgtSlice * tgtPixelsPerSlice;\n                for (let column = 0; column < srcColumns; column++) {\n                    const labelmapValue = srcLabelmapData[srcOffset + column] === segmentIndex\n                        ? segmentIndex\n                        : 0;\n                    tgtVoxelManager.setAtIndex(tgtOffset + column, labelmapValue);\n                }\n            }\n        }\n        triggerSegmentationDataModified(segmentationId);\n    }\n    applyGrowCutLabelmap(segmentationId, segmentIndex, targetLabelmap, sourceLabelmap) {\n        const tgtVoxelManager = targetLabelmap.voxelManager;\n        const srcVoxelManager = sourceLabelmap.voxelManager;\n        srcVoxelManager.forEach(({ value, index }) => {\n            if (value === segmentIndex) {\n                tgtVoxelManager.setAtIndex(index, value);\n            }\n        });\n        triggerSegmentationDataModified(segmentationId);\n    }\n    _runLastCommand({ shrinkExpandAmount = 0 } = {}) {\n        const cmd = GrowCutBaseTool.lastGrowCutCommand;\n        if (cmd) {\n            cmd({ shrinkExpandAmount });\n        }\n    }\n    async getLabelmapSegmentationData(viewport) {\n        const activeSeg = activeSegmentation.getActiveSegmentation(viewport.id);\n        if (!activeSeg) {\n            throw new Error('No active segmentation found');\n        }\n        const { segmentationId } = activeSeg;\n        const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n        const { representationData } = segmentationState.getSegmentation(segmentationId);\n        const labelmapData = representationData[SegmentationRepresentations.Labelmap];\n        let { volumeId: labelmapVolumeId, referencedVolumeId } = labelmapData;\n        if (!labelmapVolumeId) {\n            const referencedImageIds = viewport.getImageIds();\n            if (!csUtils.isValidVolume(referencedImageIds)) {\n                const currentImageId = viewport.getCurrentImageId();\n                const currentImage = cache.getImage(currentImageId);\n                const fakeImage = imageLoader.createAndCacheDerivedImage(currentImageId);\n                const fakeVolume = this._createFakeVolume([\n                    currentImage.imageId,\n                    fakeImage.imageId,\n                ]);\n                referencedVolumeId = fakeVolume.volumeId;\n                const currentLabelmapImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n                const fakeDerivedImage = imageLoader.createAndCacheDerivedImage(currentLabelmapImageId);\n                const fakeLabelmapVolume = this._createFakeVolume([\n                    currentLabelmapImageId,\n                    fakeDerivedImage.imageId,\n                ]);\n                labelmapVolumeId = fakeLabelmapVolume.volumeId;\n            }\n            else {\n                const segVolume = getOrCreateSegmentationVolume(segmentationId);\n                labelmapVolumeId = segVolume.volumeId;\n            }\n        }\n        if (!referencedVolumeId) {\n            const { imageIds: segImageIds } = labelmapData;\n            const referencedImageIds = segImageIds.map((imageId) => cache.getImage(imageId).referencedImageId);\n            const volumeId = cache.generateVolumeId(referencedImageIds);\n            const imageVolume = cache.getVolume(volumeId);\n            referencedVolumeId = imageVolume\n                ? imageVolume.volumeId\n                : (await volumeLoader.createAndCacheVolumeFromImagesSync(volumeId, referencedImageIds)).volumeId;\n        }\n        return {\n            segmentationId,\n            segmentIndex,\n            labelmapVolumeId,\n            referencedVolumeId,\n        };\n    }\n    _createFakeVolume(imageIds) {\n        const volumeId = cache.generateVolumeId(imageIds);\n        const cachedVolume = cache.getVolume(volumeId);\n        if (cachedVolume) {\n            return cachedVolume;\n        }\n        const volumeProps = csUtils.generateVolumePropsFromImageIds(imageIds, volumeId);\n        const spacing = volumeProps.spacing;\n        if (spacing[2] === 0) {\n            spacing[2] = 1;\n        }\n        const derivedVolume = new ImageVolume({\n            volumeId,\n            dataType: volumeProps.dataType,\n            metadata: structuredClone(volumeProps.metadata),\n            dimensions: volumeProps.dimensions,\n            spacing: volumeProps.spacing,\n            origin: volumeProps.origin,\n            direction: volumeProps.direction,\n            referencedVolumeId: volumeProps.referencedVolumeId,\n            imageIds: volumeProps.imageIds,\n            referencedImageIds: volumeProps.referencedImageIds,\n        });\n        cache.putVolumeSync(volumeId, derivedVolume);\n        return derivedVolume;\n    }\n    _isOrthogonalView(viewport, referencedVolumeId) {\n        const volume = cache.getVolume(referencedVolumeId);\n        const volumeImageData = volume.imageData;\n        const camera = viewport.getCamera();\n        const { ijkVecColDir, ijkVecSliceDir } = csUtils.getVolumeDirectionVectors(volumeImageData, camera);\n        return [ijkVecColDir, ijkVecSliceDir].every((vec) => csUtils.isEqual(Math.abs(vec[0]), 1) ||\n            csUtils.isEqual(Math.abs(vec[1]), 1) ||\n            csUtils.isEqual(Math.abs(vec[2]), 1));\n    }\n    getRemoveIslandData(_growCutData) {\n        return;\n    }\n    _removeIslands(growCutData) {\n        const { islandRemoval: config } = this.configuration;\n        if (!config.enabled) {\n            return;\n        }\n        const { segmentation: { segmentIndex, labelmapVolumeId }, renderingEngineId, viewportId, } = growCutData;\n        const labelmap = cache.getVolume(labelmapVolumeId);\n        const removeIslandData = this.getRemoveIslandData(growCutData);\n        if (!removeIslandData) {\n            return;\n        }\n        const [width, height] = labelmap.dimensions;\n        const numPixelsPerSlice = width * height;\n        const { worldIslandPoints = [], islandPointIndexes = [] } = removeIslandData;\n        let ijkIslandPoints = [...(removeIslandData?.ijkIslandPoints ?? [])];\n        const renderingEngine = getRenderingEngine(renderingEngineId);\n        const viewport = renderingEngine.getViewport(viewportId);\n        const { voxelManager } = labelmap;\n        const islandRemoval = new IslandRemoval();\n        ijkIslandPoints = ijkIslandPoints.concat(worldIslandPoints.map((worldPoint) => transformWorldToIndex(labelmap.imageData, worldPoint)));\n        ijkIslandPoints = ijkIslandPoints.concat(islandPointIndexes.map((pointIndex) => {\n            const x = pointIndex % width;\n            const y = Math.floor(pointIndex / width) % height;\n            const z = Math.floor(pointIndex / numPixelsPerSlice);\n            return [x, y, z];\n        }));\n        islandRemoval.initialize(viewport, voxelManager, {\n            points: ijkIslandPoints,\n            previewSegmentIndex: segmentIndex,\n            segmentIndex,\n        });\n        islandRemoval.floodFillSegmentIsland();\n        islandRemoval.removeExternalIslands();\n        islandRemoval.removeInternalIslands();\n    }\n    getSegmentStyle({ segmentationId, viewportId, segmentIndex }) {\n        return getSVGStyleForSegment({\n            segmentationId,\n            segmentIndex,\n            viewportId,\n        });\n    }\n}\nGrowCutBaseTool.toolName = 'GrowCutBaseTool';\nexport default GrowCutBaseTool;\n", "import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils, getRenderingEngine, } from '@cornerstonejs/core';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { Events } from '../../enums';\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { growCut } from '../../utilities/segmentation';\nimport GrowCutBaseTool from '../base/GrowCutBaseTool';\nclass RegionSegmentTool extends GrowCutBaseTool {\n    static { this.toolName = 'RegionSegment'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            isPartialVolume: true,\n            positiveSeedVariance: 0.5,\n            negativeSeedVariance: 0.9,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const { world: currentWorldPoint } = currentPoints;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.growCutData.circleBorderPoint = currentWorldPoint;\n            triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        };\n        this._endCallback = async (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.runGrowCut();\n            this._deactivateDraw(element);\n            this.growCutData = null;\n            resetElementCursor(element);\n            triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n    }\n    async preMouseDownCallback(evt) {\n        const eventData = evt.detail;\n        const { element, currentPoints } = eventData;\n        const { world: worldPoint } = currentPoints;\n        const enabledElement = getEnabledElement(element);\n        const { viewport, renderingEngine } = enabledElement;\n        await super.preMouseDownCallback(evt);\n        Object.assign(this.growCutData, {\n            circleCenterPoint: worldPoint,\n            circleBorderPoint: worldPoint,\n        });\n        this._activateDraw(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        return true;\n    }\n    async getGrowCutLabelmap(growCutData) {\n        const { segmentation: { referencedVolumeId }, renderingEngineId, viewportId, circleCenterPoint, circleBorderPoint, options, } = growCutData;\n        const renderingEngine = getRenderingEngine(renderingEngineId);\n        const viewport = renderingEngine.getViewport(viewportId);\n        const worldCircleRadius = vec3.len(vec3.sub(vec3.create(), circleCenterPoint, circleBorderPoint));\n        const sphereInfo = {\n            center: circleCenterPoint,\n            radius: worldCircleRadius,\n        };\n        return growCut.runGrowCutForSphere(referencedVolumeId, sphereInfo, viewport, options);\n    }\n    _activateDraw(element) {\n        element.addEventListener(Events.MOUSE_UP, this._endCallback);\n        element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n        element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this.growCutData) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const { segmentation: segmentationData, circleCenterPoint, circleBorderPoint, } = this.growCutData;\n        const canvasCenterPoint = viewport.worldToCanvas(circleCenterPoint);\n        const canvasBorderPoint = viewport.worldToCanvas(circleBorderPoint);\n        const vecCenterToBorder = vec2.sub(vec2.create(), canvasBorderPoint, canvasCenterPoint);\n        const circleRadius = vec2.len(vecCenterToBorder);\n        if (csUtils.isEqual(circleRadius, 0)) {\n            return;\n        }\n        const annotationUID = 'growcut';\n        const circleUID = '0';\n        const { color } = this.getSegmentStyle({\n            segmentationId: segmentationData.segmentationId,\n            segmentIndex: segmentationData.segmentIndex,\n            viewportId: viewport.id,\n        });\n        drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, canvasCenterPoint, circleRadius, {\n            color,\n        });\n    }\n}\nexport default RegionSegmentTool;\n", "import { cache, utilities as csUtils, getEnabledElement, } from '@cornerstonejs/core';\nimport { growCut } from '../../utilities/segmentation';\nimport GrowCutBaseTool from '../base/GrowCutBaseTool';\nimport { calculateGrowCutSeeds } from '../../utilities/segmentation/growCut/runOneClickGrowCut';\nimport { ToolModes } from '../../enums';\nclass RegionSegmentPlusTool extends GrowCutBaseTool {\n    static { this.toolName = 'RegionSegmentPlus'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            isPartialVolume: false,\n            positiveSeedVariance: 0.4,\n            negativeSeedVariance: 0.9,\n            subVolumePaddingPercentage: 0.1,\n            islandRemoval: {\n                enabled: false,\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.mouseTimer = null;\n        this.allowedToProceed = false;\n    }\n    mouseMoveCallback(evt) {\n        if (this.mode !== ToolModes.Active) {\n            return;\n        }\n        const eventData = evt.detail;\n        const { currentPoints, element } = eventData;\n        const { world: worldPoint } = currentPoints;\n        element.style.cursor = 'default';\n        if (this.mouseTimer !== null) {\n            window.clearTimeout(this.mouseTimer);\n            this.mouseTimer = null;\n        }\n        this.mouseTimer = window.setTimeout(() => {\n            this.onMouseStable(evt, worldPoint, element);\n        }, this.configuration.mouseStabilityDelay || 500);\n    }\n    async onMouseStable(evt, worldPoint, element) {\n        await super.preMouseDownCallback(evt);\n        const refVolume = cache.getVolume(this.growCutData.segmentation.referencedVolumeId);\n        const seeds = calculateGrowCutSeeds(refVolume, worldPoint, {}) || {\n            positiveSeedIndices: new Set(),\n            negativeSeedIndices: new Set(),\n        };\n        const { positiveSeedIndices, negativeSeedIndices } = seeds;\n        let cursor;\n        if (positiveSeedIndices.size / negativeSeedIndices.size > 20 ||\n            negativeSeedIndices.size < 30) {\n            cursor = 'not-allowed';\n            this.allowedToProceed = false;\n        }\n        else {\n            cursor = 'copy';\n            this.allowedToProceed = true;\n        }\n        const enabledElement = getEnabledElement(element);\n        if (element) {\n            element.style.cursor = cursor;\n            requestAnimationFrame(() => {\n                if (element.style.cursor !== cursor) {\n                    element.style.cursor = cursor;\n                }\n            });\n        }\n        if (this.allowedToProceed) {\n            this.seeds = seeds;\n        }\n        if (enabledElement && enabledElement.viewport) {\n            enabledElement.viewport.render();\n        }\n    }\n    async preMouseDownCallback(evt) {\n        if (!this.allowedToProceed) {\n            return false;\n        }\n        const eventData = evt.detail;\n        const { currentPoints, element } = eventData;\n        const enabledElement = getEnabledElement(element);\n        if (enabledElement) {\n            element.style.cursor = 'wait';\n            requestAnimationFrame(() => {\n                if (element.style.cursor !== 'wait') {\n                    element.style.cursor = 'wait';\n                }\n            });\n        }\n        const { world: worldPoint } = currentPoints;\n        await super.preMouseDownCallback(evt);\n        this.growCutData = csUtils.deepMerge(this.growCutData, {\n            worldPoint,\n            islandRemoval: {\n                worldIslandPoints: [worldPoint],\n            },\n        });\n        this.growCutData.worldPoint = worldPoint;\n        this.growCutData.islandRemoval = {\n            worldIslandPoints: [worldPoint],\n        };\n        await this.runGrowCut();\n        if (element) {\n            element.style.cursor = 'default';\n        }\n        return true;\n    }\n    getRemoveIslandData(growCutData) {\n        const { worldPoint } = growCutData;\n        return {\n            worldIslandPoints: [worldPoint],\n        };\n    }\n    async getGrowCutLabelmap(growCutData) {\n        const { segmentation: { referencedVolumeId }, worldPoint, options, } = growCutData;\n        const { subVolumePaddingPercentage } = this.configuration;\n        const mergedOptions = {\n            ...options,\n            subVolumePaddingPercentage,\n            seeds: this.seeds,\n        };\n        return growCut.runOneClickGrowCut({\n            referencedVolumeId,\n            worldPosition: worldPoint,\n            options: mergedOptions,\n        });\n    }\n}\nexport default RegionSegmentPlusTool;\n", "import { vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils, cache, getRenderingEngine, BaseVolumeViewport, } from '@cornerstonejs/core';\nimport { drawPolyline as drawPolylineSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { Events } from '../../enums';\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { growCut } from '../../utilities/segmentation';\nimport GrowCutBaseTool from '../base/GrowCutBaseTool';\nconst NEGATIVE_PIXEL_RANGE = [-Infinity, -995];\nconst POSITIVE_PIXEL_RANGE = [0, 1900];\nconst ISLAND_PIXEL_RANGE = [1000, 1900];\nconst { transformWorldToIndex, transformIndexToWorld } = csUtils;\nclass WholeBodySegmentTool extends GrowCutBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            isPartialVolume: true,\n            positivePixelRange: POSITIVE_PIXEL_RANGE,\n            negativePixelRange: NEGATIVE_PIXEL_RANGE,\n            islandRemoval: {\n                enabled: true,\n                islandPixelRange: ISLAND_PIXEL_RANGE,\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const { world: currentWorldPoint } = currentPoints;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const linePoints = this._getHorizontalLineWorldPoints(enabledElement, currentWorldPoint);\n            this.growCutData.horizontalLines[1] = linePoints;\n            triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        };\n        this._endCallback = async (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            await this.runGrowCut();\n            this._deactivateDraw(element);\n            this.growCutData = null;\n            resetElementCursor(element);\n            triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n    }\n    async preMouseDownCallback(evt) {\n        const eventData = evt.detail;\n        const { element, currentPoints } = eventData;\n        const { world: worldPoint } = currentPoints;\n        const enabledElement = getEnabledElement(element);\n        const { viewport, renderingEngine } = enabledElement;\n        const linePoints = this._getHorizontalLineWorldPoints(enabledElement, worldPoint);\n        await super.preMouseDownCallback(evt);\n        this.growCutData.horizontalLines = [linePoints, linePoints];\n        this._activateDraw(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        return true;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this.growCutData) {\n            return;\n        }\n        const { segmentation: segmentationData, horizontalLines } = this.growCutData;\n        if (horizontalLines.length !== 2) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const { segmentationId, segmentIndex } = segmentationData;\n        const [line1, line2] = horizontalLines;\n        const [worldLine1P1, worldLine1P2] = line1;\n        const [worldLine2P1, worldLine2P2] = line2;\n        const canvasPoints = [\n            worldLine1P1,\n            worldLine1P2,\n            worldLine2P2,\n            worldLine2P1,\n        ].map((worldPoint) => viewport.worldToCanvas(worldPoint));\n        const annotationUID = 'growCutRect';\n        const squareGroupUID = '0';\n        const { color, fillColor, lineWidth, fillOpacity, lineDash } = this.getSegmentStyle({\n            segmentationId,\n            segmentIndex,\n            viewportId: viewport.id,\n        });\n        drawPolylineSvg(svgDrawingHelper, annotationUID, squareGroupUID, canvasPoints, {\n            color,\n            fillColor,\n            fillOpacity,\n            lineWidth,\n            lineDash,\n            closePath: true,\n        });\n    }\n    async getGrowCutLabelmap(growCutData) {\n        const { segmentation: { segmentIndex, referencedVolumeId }, renderingEngineId, viewportId, horizontalLines, } = growCutData;\n        const renderingEngine = getRenderingEngine(renderingEngineId);\n        const viewport = renderingEngine.getViewport(viewportId);\n        const [line1, line2] = horizontalLines;\n        const worldSquarePoints = [line1[0], line1[1], line2[1], line2[0]];\n        const referencedVolume = cache.getVolume(referencedVolumeId);\n        const { topLeft: worldTopLeft, bottomRight: worldBottomRight } = this._getWorldBoundingBoxFromProjectedSquare(viewport, worldSquarePoints);\n        const ijkTopLeft = transformWorldToIndex(referencedVolume.imageData, worldTopLeft);\n        const ijkBottomRight = transformWorldToIndex(referencedVolume.imageData, worldBottomRight);\n        const boundingBoxInfo = {\n            boundingBox: {\n                ijkTopLeft,\n                ijkBottomRight,\n            },\n        };\n        const config = this.configuration;\n        const options = {\n            positiveSeedValue: segmentIndex,\n            negativeSeedValue: 255,\n            negativePixelRange: config.negativePixelRange,\n            positivePixelRange: config.positivePixelRange,\n        };\n        return growCut.runGrowCutForBoundingBox(referencedVolumeId, boundingBoxInfo, options);\n    }\n    getRemoveIslandData() {\n        const { segmentation: { segmentIndex, referencedVolumeId, labelmapVolumeId }, } = this.growCutData;\n        const referencedVolume = cache.getVolume(referencedVolumeId);\n        const labelmapVolume = cache.getVolume(labelmapVolumeId);\n        const referencedVolumeData = referencedVolume.voxelManager.getCompleteScalarDataArray();\n        const labelmapData = labelmapVolume.voxelManager.getCompleteScalarDataArray();\n        const { islandPixelRange } = this.configuration.islandRemoval;\n        const islandPointIndexes = [];\n        for (let i = 0, len = labelmapData.length; i < len; i++) {\n            if (labelmapData[i] !== segmentIndex) {\n                continue;\n            }\n            const pixelValue = referencedVolumeData[i];\n            if (pixelValue >= islandPixelRange[0] &&\n                pixelValue <= islandPixelRange[1]) {\n                islandPointIndexes.push(i);\n            }\n        }\n        return {\n            islandPointIndexes,\n        };\n    }\n    _activateDraw(element) {\n        element.addEventListener(Events.MOUSE_UP, this._endCallback);\n        element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n        element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n    }\n    _projectWorldPointAcrossSlices(viewport, worldEdgePoint, vecDirection) {\n        const volume = this._getViewportVolume(viewport);\n        const { dimensions } = volume;\n        const ijkPoint = transformWorldToIndex(volume.imageData, worldEdgePoint);\n        const axis = vecDirection.findIndex((n) => csUtils.isEqual(Math.abs(n), 1));\n        if (axis === -1) {\n            throw new Error('Non-orthogonal direction vector');\n        }\n        const ijkLineP1 = [...ijkPoint];\n        const ijkLineP2 = [...ijkPoint];\n        ijkLineP1[axis] = 0;\n        ijkLineP2[axis] = dimensions[axis] - 1;\n        return [ijkLineP1, ijkLineP2];\n    }\n    _getCuboidIJKEdgePointsFromProjectedWorldPoint(viewport, worldEdgePoint) {\n        const { viewPlaneNormal } = viewport.getCamera();\n        return this._projectWorldPointAcrossSlices(viewport, worldEdgePoint, viewPlaneNormal);\n    }\n    _getWorldCuboidCornerPoints(viewport, worldSquarePoints) {\n        const cuboidPoints = [];\n        const volume = this._getViewportVolume(viewport);\n        worldSquarePoints.forEach((worldSquarePoint) => {\n            const ijkEdgePoints = this._getCuboidIJKEdgePointsFromProjectedWorldPoint(viewport, worldSquarePoint);\n            const worldEdgePoints = ijkEdgePoints.map((ijkPoint) => transformIndexToWorld(volume.imageData, ijkPoint));\n            cuboidPoints.push(...worldEdgePoints);\n        });\n        return cuboidPoints;\n    }\n    _getWorldBoundingBoxFromProjectedSquare(viewport, worldSquarePoints) {\n        const worldCuboidPoints = this._getWorldCuboidCornerPoints(viewport, worldSquarePoints);\n        const topLeft = [...worldCuboidPoints[0]];\n        const bottomRight = [...worldCuboidPoints[0]];\n        worldCuboidPoints.forEach((worldPoint) => {\n            vec3.min(topLeft, topLeft, worldPoint);\n            vec3.max(bottomRight, bottomRight, worldPoint);\n        });\n        return { topLeft, bottomRight };\n    }\n    _getViewportVolume(viewport) {\n        if (!(viewport instanceof BaseVolumeViewport)) {\n            throw new Error('Viewport is not a BaseVolumeViewport');\n        }\n        const volumeId = viewport.getAllVolumeIds()[0];\n        return cache.getVolume(volumeId);\n    }\n    _getHorizontalLineIJKPoints(enabledElement, worldPoint) {\n        const { viewport } = enabledElement;\n        const volume = this._getViewportVolume(viewport);\n        const { dimensions } = volume;\n        const ijkPoint = transformWorldToIndex(volume.imageData, worldPoint);\n        const { viewUp, viewPlaneNormal } = viewport.getCamera();\n        const vecRow = vec3.cross(vec3.create(), viewUp, viewPlaneNormal);\n        const axis = vecRow.findIndex((n) => csUtils.isEqual(Math.abs(n), 1));\n        const ijkLineP1 = [...ijkPoint];\n        const ijkLineP2 = [...ijkPoint];\n        ijkLineP1[axis] = 0;\n        ijkLineP2[axis] = dimensions[axis] - 1;\n        return [ijkLineP1, ijkLineP2];\n    }\n    _getHorizontalLineWorldPoints(enabledElement, worldPoint) {\n        const { viewport } = enabledElement;\n        const volume = this._getViewportVolume(viewport);\n        const [ijkPoint1, ijkPoint2] = this._getHorizontalLineIJKPoints(enabledElement, worldPoint);\n        const worldPoint1 = transformIndexToWorld(volume.imageData, ijkPoint1);\n        const worldPoint2 = transformIndexToWorld(volume.imageData, ijkPoint2);\n        return [worldPoint1, worldPoint2];\n    }\n}\nWholeBodySegmentTool.toolName = 'WholeBodySegment';\nexport default WholeBodySegmentTool;\n", "import { fillInsideRectangle } from './fillRectangle';\nfunction eraseRectangle(enabledElement, operationData, inside = true) {\n    const eraseOperationData = Object.assign({}, operationData, {\n        segmentIndex: 0,\n    });\n    fillInsideRectangle(enabledElement, eraseOperationData);\n}\nexport function eraseInsideRectangle(enabledElement, operationData) {\n    eraseRectangle(enabledElement, operationData, true);\n}\nexport function eraseOutsideRectangle(enabledElement, operationData) {\n    eraseRectangle(enabledElement, operationData, false);\n}\n", "import { BaseVolumeViewport, cache, getEnabledElement, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { fillInsideRectangle } from './strategies/fillRectangle';\nimport { eraseInsideRectangle } from './strategies/eraseRectangle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { drawRect as drawRectSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { config as segmentationConfig, segmentLocking, segmentIndex as segmentIndexController, activeSegmentation, } from '../../stateManagement/segmentation';\nimport { getCurrentLabelmapImageIdForViewport, getSegmentation, } from '../../stateManagement/segmentation/segmentationState';\nimport LabelmapBaseTool from './LabelmapBaseTool';\nclass RectangleScissorsTool extends LabelmapBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE: fillInsideRectangle,\n                ERASE_INSIDE: eraseInsideRectangle,\n            },\n            defaultStrategy: 'FILL_INSIDE',\n            activeStrategy: 'FILL_INSIDE',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            if (this.isDrawing === true) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const activeLabelmapSegmentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeLabelmapSegmentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeLabelmapSegmentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const segmentColor = segmentationConfig.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n            const { representationData } = getSegmentation(segmentationId);\n            const labelmapData = representationData[SegmentationRepresentations.Labelmap];\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId: '',\n                    toolName: this.getToolName(),\n                    segmentColor,\n                },\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                },\n            };\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                segmentIndex,\n                segmentationId,\n                segmentsLocked,\n                segmentColor,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n                volumeId: null,\n                referencedVolumeId: null,\n                imageId: null,\n            };\n            if (viewport instanceof BaseVolumeViewport) {\n                const { volumeId } = labelmapData;\n                const segmentation = cache.getVolume(volumeId);\n                this.editData = {\n                    ...this.editData,\n                    volumeId,\n                    referencedVolumeId: segmentation.referencedVolumeId,\n                };\n            }\n            else {\n                const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n                this.editData = {\n                    ...this.editData,\n                    imageId: segmentationImageId,\n                };\n            }\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n            const { data } = annotation;\n            const { currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n            const worldPos = currentPoints.world;\n            const { points } = data.handles;\n            points[handleIndex] = [...worldPos];\n            let bottomLeftCanvas;\n            let bottomRightCanvas;\n            let topLeftCanvas;\n            let topRightCanvas;\n            let bottomLeftWorld;\n            let bottomRightWorld;\n            let topLeftWorld;\n            let topRightWorld;\n            switch (handleIndex) {\n                case 0:\n                case 3:\n                    bottomLeftCanvas = worldToCanvas(points[0]);\n                    topRightCanvas = worldToCanvas(points[3]);\n                    bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n                    topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n                    bottomRightWorld = canvasToWorld(bottomRightCanvas);\n                    topLeftWorld = canvasToWorld(topLeftCanvas);\n                    points[1] = bottomRightWorld;\n                    points[2] = topLeftWorld;\n                    break;\n                case 1:\n                case 2:\n                    bottomRightCanvas = worldToCanvas(points[1]);\n                    topLeftCanvas = worldToCanvas(points[2]);\n                    bottomLeftCanvas = [\n                        topLeftCanvas[0],\n                        bottomRightCanvas[1],\n                    ];\n                    topRightCanvas = [bottomRightCanvas[0], topLeftCanvas[1]];\n                    bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n                    topRightWorld = canvasToWorld(topRightCanvas);\n                    points[0] = bottomLeftWorld;\n                    points[3] = topRightWorld;\n                    break;\n            }\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const operationData = {\n                ...this.editData,\n                points: data.handles.points,\n                createMemo: this.createMemo.bind(this),\n            };\n            this.editData = null;\n            this.isDrawing = false;\n            this.applyActiveStrategy(enabledElement, operationData);\n            this.doneEditMemo();\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const { viewport } = enabledElement;\n            const { annotation } = this.editData;\n            const toolMetadata = annotation.metadata;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const rectangleUID = '0';\n            drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                color,\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nRectangleScissorsTool.toolName = 'RectangleScissor';\nexport default RectangleScissorsTool;\n", "import { BaseVolumeViewport, cache, getEnabledElement, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { fillInsideCircle } from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport { Events } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { segmentLocking, activeSegmentation, segmentIndex as segmentIndexController, config as segmentationConfig, } from '../../stateManagement/segmentation';\nimport { getCurrentLabelmapImageIdForViewport, getSegmentation, } from '../../stateManagement/segmentation/segmentationState';\nimport LabelmapBaseTool from './LabelmapBaseTool';\nclass CircleScissorsTool extends LabelmapBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE: fillInsideCircle,\n                ERASE_INSIDE: eraseInsideCircle,\n            },\n            defaultStrategy: 'FILL_INSIDE',\n            activeStrategy: 'FILL_INSIDE',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            if (this.isDrawing === true) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const activeLabelmapSegmentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeLabelmapSegmentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeLabelmapSegmentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const segmentColor = segmentationConfig.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n            const { representationData } = getSegmentation(segmentationId);\n            const labelmapData = representationData.Labelmap;\n            if (!labelmapData) {\n                throw new Error('No labelmap data found for the active segmentation, create one before using scissors tool');\n            }\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId: '',\n                    toolName: this.getToolName(),\n                    segmentColor,\n                },\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    isDrawing: true,\n                    cachedStats: {},\n                },\n            };\n            const viewportIdsToRender = [viewport.id];\n            this.editData = {\n                annotation,\n                centerCanvas: canvasPos,\n                segmentIndex,\n                segmentationId,\n                segmentsLocked,\n                segmentColor,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n                volumeId: null,\n                referencedVolumeId: null,\n                imageId: null,\n            };\n            if (viewport instanceof BaseVolumeViewport) {\n                const { volumeId } = labelmapData;\n                const segmentation = cache.getVolume(volumeId);\n                this.editData = {\n                    ...this.editData,\n                    volumeId,\n                    referencedVolumeId: segmentation.referencedVolumeId,\n                };\n            }\n            else {\n                const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n                this.editData = {\n                    ...this.editData,\n                    imageId: segmentationImageId,\n                };\n            }\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n            const { data } = annotation;\n            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n            const radius = Math.sqrt(dX * dX + dY * dY);\n            const bottomCanvas = [\n                centerCanvas[0],\n                centerCanvas[1] + radius,\n            ];\n            const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];\n            const leftCanvas = [\n                centerCanvas[0] - radius,\n                centerCanvas[1],\n            ];\n            const rightCanvas = [\n                centerCanvas[0] + radius,\n                centerCanvas[1],\n            ];\n            data.handles.points = [\n                canvasToWorld(bottomCanvas),\n                canvasToWorld(topCanvas),\n                canvasToWorld(leftCanvas),\n                canvasToWorld(rightCanvas),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            const { viewPlaneNormal, viewUp } = annotation.metadata;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const operationData = {\n                ...this.editData,\n                points: data.handles.points,\n                viewPlaneNormal,\n                viewUp,\n                createMemo: this.createMemo.bind(this),\n            };\n            this.editData = null;\n            this.isDrawing = false;\n            this.applyActiveStrategy(enabledElement, operationData);\n            this.doneEditMemo();\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const { viewport } = enabledElement;\n            const { viewportIdsToRender } = this.editData;\n            if (!viewportIdsToRender.includes(viewport.id)) {\n                return renderStatus;\n            }\n            const { annotation } = this.editData;\n            const toolMetadata = annotation.metadata;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const bottom = canvasCoordinates[0];\n            const top = canvasCoordinates[1];\n            const center = [\n                Math.floor((bottom[0] + top[0]) / 2),\n                Math.floor((bottom[1] + top[1]) / 2),\n            ];\n            const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const circleUID = '0';\n            drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                color,\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nCircleScissorsTool.toolName = 'CircleScissor';\nexport default CircleScissorsTool;\n", "import { getEnabledElement } from '@cornerstonejs/core';\nimport { fillInsideSphere } from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { config as segmentationConfig, segmentLocking, segmentIndex as segmentIndexController, activeSegmentation, } from '../../stateManagement/segmentation';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport LabelmapBaseTool from './LabelmapBaseTool';\nclass SphereScissorsTool extends LabelmapBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE: fillInsideSphere,\n                ERASE_INSIDE: eraseInsideSphere,\n            },\n            defaultStrategy: 'FILL_INSIDE',\n            activeStrategy: 'FILL_INSIDE',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            if (this.isDrawing === true) {\n                return;\n            }\n            this.doneEditMemo();\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const activeSegmentationRepresentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeSegmentationRepresentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeSegmentationRepresentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const segmentColor = segmentationConfig.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n            this.isDrawing = true;\n            const annotation = {\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId: '',\n                    toolName: this.getToolName(),\n                    segmentColor,\n                },\n                data: {\n                    invalidated: true,\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {},\n                    highlighted: true,\n                },\n            };\n            const viewportIdsToRender = [viewport.id];\n            this.editData = {\n                annotation,\n                centerCanvas: canvasPos,\n                segmentIndex,\n                segmentationId,\n                segmentsLocked,\n                segmentColor,\n                toolGroupId: this.toolGroupId,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n                volumeId: null,\n                referencedVolumeId: null,\n                imageId: null,\n            };\n            const { representationData } = getSegmentation(segmentationId);\n            const editData = this.getEditData({\n                viewport,\n                representationData,\n                segmentsLocked,\n                segmentationId,\n            });\n            this.editData = {\n                ...this.editData,\n                ...editData,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n            const { data } = annotation;\n            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n            const radius = Math.sqrt(dX * dX + dY * dY);\n            const bottomCanvas = [\n                centerCanvas[0],\n                centerCanvas[1] + radius,\n            ];\n            const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];\n            const leftCanvas = [\n                centerCanvas[0] - radius,\n                centerCanvas[1],\n            ];\n            const rightCanvas = [\n                centerCanvas[0] + radius,\n                centerCanvas[1],\n            ];\n            data.handles.points = [\n                canvasToWorld(bottomCanvas),\n                canvasToWorld(topCanvas),\n                canvasToWorld(leftCanvas),\n                canvasToWorld(rightCanvas),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, newAnnotation, hasMoved, segmentIndex, segmentsLocked, } = this.editData;\n            const { data } = annotation;\n            const { viewPlaneNormal, viewUp } = annotation.metadata;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const operationData = {\n                ...this.editData,\n                points: data.handles.points,\n                segmentIndex,\n                segmentsLocked,\n                viewPlaneNormal,\n                viewUp,\n                createMemo: this.createMemo.bind(this),\n            };\n            this.editData = null;\n            this.isDrawing = false;\n            this.applyActiveStrategy(enabledElement, operationData);\n            this.doneEditMemo();\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const { viewport } = enabledElement;\n            const { viewportIdsToRender } = this.editData;\n            if (!viewportIdsToRender.includes(viewport.id)) {\n                return renderStatus;\n            }\n            const { annotation } = this.editData;\n            const toolMetadata = annotation.metadata;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const bottom = canvasCoordinates[0];\n            const top = canvasCoordinates[1];\n            const center = [\n                Math.floor((bottom[0] + top[0]) / 2),\n                Math.floor((bottom[1] + top[1]) / 2),\n            ];\n            const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const circleUID = '0';\n            drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                color,\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nSphereScissorsTool.toolName = 'SphereScissor';\nexport default SphereScissorsTool;\n", "import { StackViewport, cache, getEnabledElement, utilities as csUtils, utilities as coreUtils, } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { addAnnotation, removeAnnotation, getAnnotations, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport throttle from '../../utilities/throttle';\nimport debounce from '../../utilities/debounce';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { hideElementCursor, resetElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport CircleROITool from '../annotation/CircleROITool';\nimport { getCanvasCircleCorners, getCanvasCircleRadius, } from '../../utilities/math/circle';\nimport { getCalibratedLengthUnitsAndScale, getCalibratedAspect, } from '../../utilities/getCalibratedUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport { filterAnnotationsWithinSamePlane } from '../../utilities/planar';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nconst { transformWorldToIndex } = csUtils;\nclass CircleROIStartEndThresholdTool extends CircleROITool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            simplified: true,\n            storePointData: false,\n            numSlicesToPropagate: 10,\n            calculatePointsInsideVolume: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n            showTextBox: false,\n            throttleTimeout: 100,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            let referencedImageId, imageVolume, volumeId;\n            if (viewport instanceof StackViewport) {\n                throw new Error('Stack Viewport Not implemented');\n            }\n            else {\n                const targetId = this.getTargetId(viewport);\n                volumeId = csUtils.getVolumeId(targetId);\n                imageVolume = cache.getVolume(volumeId);\n                referencedImageId = csUtils.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n            }\n            const spacingInNormal = csUtils.getSpacingInNormalDirection(imageVolume, viewPlaneNormal);\n            const startCoord = this._getStartCoordinate(worldPos, spacingInNormal, viewPlaneNormal);\n            const endCoord = this._getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            let points;\n            if (this.configuration.simplified) {\n                points = [[...worldPos], [...worldPos]];\n            }\n            else {\n                points = [\n                    [...worldPos],\n                    [...worldPos],\n                    [...worldPos],\n                    [...worldPos],\n                    [...worldPos],\n                ];\n            }\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    volumeId,\n                    spacingInNormal,\n                    enabledElement,\n                },\n                data: {\n                    label: '',\n                    startCoordinate: startCoord,\n                    endCoordinate: endCoord,\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                        points,\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {\n                        pointsInVolume: [],\n                        projectionPoints: [],\n                        statistics: [],\n                    },\n                    labelmapUID: null,\n                },\n            };\n            this._computeProjectionPoints(annotation, imageVolume);\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const { metadata } = annotation;\n            const { enabledElement } = metadata;\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            const targetId = this.getTargetId(enabledElement.viewport);\n            const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n            this._computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            else {\n                triggerAnnotationModified(annotation, element);\n            }\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            let annotations = getAnnotations(this.getToolName(), viewport.element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = filterAnnotationsWithinSamePlane(annotations, viewport.getCamera());\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data, metadata } = annotation;\n                const { startCoordinate, endCoordinate } = data;\n                const { points, activeHandleIndex } = data.handles;\n                const { enabledElement: annotationEnabledElement } = metadata;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const center = canvasCoordinates[0];\n                const radius = getCanvasCircleRadius([\n                    canvasCoordinates[0],\n                    canvasCoordinates[1],\n                ]);\n                const { centerPointRadius } = this.configuration;\n                const canvasCorners = getCanvasCircleCorners([\n                    canvasCoordinates[0],\n                    canvasCoordinates[1],\n                ]);\n                const focalPoint = viewport.getCamera().focalPoint;\n                const viewplaneNormal = viewport.getCamera().viewPlaneNormal;\n                let tempStartCoordinate = startCoordinate;\n                let tempEndCoordinate = endCoordinate;\n                if (Array.isArray(startCoordinate)) {\n                    tempStartCoordinate = this._getCoordinateForViewplaneNormal(tempStartCoordinate, viewplaneNormal);\n                    data.startCoordinate = tempStartCoordinate;\n                }\n                if (Array.isArray(endCoordinate)) {\n                    tempEndCoordinate = this._getCoordinateForViewplaneNormal(tempEndCoordinate, viewplaneNormal);\n                    data.endCoordinate = tempEndCoordinate;\n                }\n                const roundedStartCoordinate = coreUtils.roundToPrecision(data.startCoordinate);\n                const roundedEndCoordinate = coreUtils.roundToPrecision(data.endCoordinate);\n                const cameraCoordinate = this._getCoordinateForViewplaneNormal(focalPoint, viewplaneNormal);\n                const roundedCameraCoordinate = coreUtils.roundToPrecision(cameraCoordinate);\n                if (roundedCameraCoordinate <\n                    Math.min(roundedStartCoordinate, roundedEndCoordinate) ||\n                    roundedCameraCoordinate >\n                        Math.max(roundedStartCoordinate, roundedEndCoordinate)) {\n                    continue;\n                }\n                const middleCoordinate = coreUtils.roundToPrecision((data.startCoordinate + data.endCoordinate) / 2);\n                let isMiddleSlice = false;\n                if (roundedCameraCoordinate === middleCoordinate) {\n                    isMiddleSlice = true;\n                }\n                data.handles.points[0][this._getIndexOfCoordinatesForViewplaneNormal(viewplaneNormal)] = middleCoordinate;\n                const iteratorVolumeIDs = annotationEnabledElement.viewport?.volumeIds.values();\n                for (const volumeId of iteratorVolumeIDs) {\n                    if (annotation.invalidated &&\n                        annotation.metadata.volumeId === volumeId) {\n                        this._throttledCalculateCachedStats(annotation, annotationEnabledElement);\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null &&\n                    isMiddleSlice) {\n                    if (this.configuration.simplified) {\n                        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                    }\n                    else {\n                        activeHandleCanvasCoords = canvasCoordinates;\n                    }\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                let lineWidthToUse = lineWidth;\n                let lineDashToUse = lineDash;\n                if (isMiddleSlice) {\n                    lineWidthToUse = lineWidth;\n                    lineDashToUse = [];\n                }\n                else {\n                    lineDashToUse = [5, 5];\n                }\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                    color,\n                    lineDash: lineDashToUse,\n                    lineWidth: lineWidthToUse,\n                });\n                if (centerPointRadius > 0) {\n                    if (radius > 3 * centerPointRadius) {\n                        drawCircleSvg(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {\n                            color,\n                            lineDash,\n                            lineWidth,\n                        });\n                    }\n                }\n                renderStatus = true;\n                if (this.configuration.showTextBox) {\n                    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                    if (!options.visibility) {\n                        data.handles.textBox = {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        };\n                        continue;\n                    }\n                    const textLines = this.configuration.getTextLines(data, { metadata });\n                    if (!textLines || textLines.length === 0) {\n                        continue;\n                    }\n                    let canvasTextBoxCoords;\n                    if (!data.handles.textBox.hasMoved) {\n                        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n                        data.handles.textBox.worldPosition =\n                            viewport.canvasToWorld(canvasTextBoxCoords);\n                    }\n                    const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                    const textBoxUID = '1';\n                    const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, [canvasCoordinates[0], canvasCoordinates[1]], {}, options);\n                    const { x: left, y: top, width, height } = boundingBox;\n                    data.handles.textBox.worldBoundingBox = {\n                        topLeft: viewport.canvasToWorld([left, top]),\n                        topRight: viewport.canvasToWorld([left + width, top]),\n                        bottomLeft: viewport.canvasToWorld([left, top + height]),\n                        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                    };\n                }\n            }\n            return renderStatus;\n        };\n        if (this.configuration.calculatePointsInsideVolume) {\n            this._throttledCalculateCachedStats = throttle(this._calculateCachedStatsTool, this.configuration.throttleTimeout, { trailing: true });\n        }\n        else {\n            this._throttledCalculateCachedStats = debounce(this._calculateCachedStatsTool, this.configuration.throttleTimeout);\n        }\n    }\n    _computeProjectionPoints(annotation, imageVolume) {\n        const { data, metadata } = annotation;\n        const { viewPlaneNormal, spacingInNormal } = metadata;\n        const { startCoordinate, endCoordinate } = data;\n        const { points } = data.handles;\n        const projectionAxisIndex = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n        const startWorld = vec3.clone(points[0]);\n        startWorld[projectionAxisIndex] = startCoordinate;\n        const endWorld = vec3.clone(points[0]);\n        endWorld[projectionAxisIndex] = endCoordinate;\n        const direction = vec3.create();\n        vec3.subtract(direction, endWorld, startWorld);\n        const distance = vec3.length(direction);\n        if (distance === 0) {\n            const handlesOnStartPlane = points.map((p) => {\n                const newPoint = vec3.clone(p);\n                newPoint[projectionAxisIndex] = startCoordinate;\n                return Array.from(newPoint);\n            });\n            data.cachedStats.projectionPoints = [handlesOnStartPlane];\n            return;\n        }\n        vec3.normalize(direction, direction);\n        const handlesToStart = csUtils.deepClone(points);\n        handlesToStart[0][projectionAxisIndex] = startCoordinate;\n        handlesToStart[1][projectionAxisIndex] = startCoordinate;\n        const newProjectionPoints = [];\n        for (let dist = 0; dist <= distance + 1e-6; dist += spacingInNormal) {\n            newProjectionPoints.push(handlesToStart.map((point) => {\n                const newPoint = vec3.create();\n                vec3.scaleAndAdd(newPoint, point, direction, dist);\n                return Array.from(newPoint);\n            }));\n        }\n        data.cachedStats.projectionPoints = newProjectionPoints;\n    }\n    _computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement) {\n        const { data, metadata } = annotation;\n        const { viewPlaneNormal, viewUp } = metadata;\n        const { viewport } = enabledElement;\n        const projectionPoints = data.cachedStats.projectionPoints;\n        const pointsInsideVolume = [[]];\n        const image = this.getTargetImageData(targetId);\n        const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));\n        const baseTopLeftCanvas = getCanvasCircleCorners([\n            canvasCoordinates[0],\n            canvasCoordinates[1],\n        ])[0];\n        const baseBottomRightCanvas = getCanvasCircleCorners([\n            canvasCoordinates[0],\n            canvasCoordinates[1],\n        ])[1];\n        const basePos1 = viewport.canvasToWorld(baseTopLeftCanvas);\n        const basePos2 = viewport.canvasToWorld(baseBottomRightCanvas);\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, basePos1, basePos2);\n        const measureInfo = getCalibratedLengthUnitsAndScale(image, data.handles.points);\n        const aspect = getCalibratedAspect(image);\n        const area = Math.abs(Math.PI *\n            (worldWidth / measureInfo.scale / 2) *\n            (worldHeight / aspect / measureInfo.scale / 2));\n        const modalityUnitOptions = {\n            isPreScaled: isViewportPreScaled(viewport, targetId),\n            isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n        };\n        const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);\n        for (let i = 0; i < projectionPoints.length; i++) {\n            if (!imageVolume) {\n                continue;\n            }\n            const centerWorld = projectionPoints[i][0];\n            const currentCanvasCoordinates = projectionPoints[i].map((p) => viewport.worldToCanvas(p));\n            const [topLeftCanvas, bottomRightCanvas] = (getCanvasCircleCorners([\n                currentCanvasCoordinates[0],\n                currentCanvasCoordinates[1],\n            ]));\n            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n            const worldPos1 = topLeftWorld;\n            const worldPos2 = bottomRightWorld;\n            const { dimensions, imageData, voxelManager } = imageVolume;\n            const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n            const worldProjectionPointIndex = transformWorldToIndex(imageData, centerWorld);\n            const indexOfProjection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n            worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n            worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n            worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n            worldPos1Index[indexOfProjection] =\n                worldProjectionPointIndex[indexOfProjection];\n            const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n            worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n            worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n            worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n            worldPos2Index[indexOfProjection] =\n                worldProjectionPointIndex[indexOfProjection];\n            if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n                const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n                const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n                const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n                const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n                const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n                const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n                const boundsIJK = [\n                    [iMin, iMax],\n                    [jMin, jMax],\n                    [kMin, kMax],\n                ];\n                const center = centerWorld;\n                const ellipseObj = {\n                    center,\n                    xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n                    yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n                    zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n                };\n                const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                    isInObject: (pointLPS) => pointInEllipse(ellipseObj, pointLPS),\n                    boundsIJK,\n                    imageData,\n                    returnPoints: this.configuration.storePointData,\n                });\n                pointsInsideVolume.push(pointsInShape);\n            }\n        }\n        const stats = this.configuration.statsCalculator.getStatistics();\n        data.cachedStats.pointsInVolume = pointsInsideVolume;\n        data.cachedStats.statistics = {\n            Modality: metadata.Modality,\n            area,\n            mean: stats.mean?.value,\n            stdDev: stats.stdDev?.value,\n            max: stats.max?.value,\n            statsArray: stats.array,\n            areaUnit: measureInfo.areaUnit,\n            modalityUnit,\n        };\n    }\n    _calculateCachedStatsTool(annotation, enabledElement) {\n        const data = annotation.data;\n        const { viewport } = enabledElement;\n        const { cachedStats } = data;\n        const targetId = this.getTargetId(viewport);\n        const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n        this._computeProjectionPoints(annotation, imageVolume);\n        this._computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement);\n        annotation.invalidated = false;\n        triggerAnnotationModified(annotation, viewport.element);\n        return cachedStats;\n    }\n    _getStartCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {\n        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n        const numSlicesToPropagateFromStart = Math.round(numSlicesToPropagate / 2);\n        const startPos = vec3.create();\n        vec3.scaleAndAdd(startPos, worldPos, viewPlaneNormal, numSlicesToPropagateFromStart * -spacingInNormal);\n        const startCoord = this._getCoordinateForViewplaneNormal(startPos, viewPlaneNormal);\n        return startCoord;\n    }\n    _getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {\n        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n        const numSlicesToPropagateToEnd = numSlicesToPropagate - Math.round(numSlicesToPropagate / 2);\n        const endPos = vec3.create();\n        vec3.scaleAndAdd(endPos, worldPos, viewPlaneNormal, numSlicesToPropagateToEnd * spacingInNormal);\n        const endCoord = this._getCoordinateForViewplaneNormal(endPos, viewPlaneNormal);\n        return endCoord;\n    }\n    _getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) {\n        const viewplaneNormalAbs = [\n            Math.abs(viewPlaneNormal[0]),\n            Math.abs(viewPlaneNormal[1]),\n            Math.abs(viewPlaneNormal[2]),\n        ];\n        const indexOfDirection = viewplaneNormalAbs.indexOf(Math.max(...viewplaneNormalAbs));\n        return indexOfDirection;\n    }\n    _getCoordinateForViewplaneNormal(pos, viewPlaneNormal) {\n        const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n        return pos[indexOfDirection];\n    }\n}\nfunction defaultGetTextLines(data, _context = {}) {\n    const cachedVolumeStats = data.cachedStats.statistics;\n    const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;\n    if (mean === undefined) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`Area: ${csUtils.roundNumber(area)} ${areaUnit}`);\n    textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    return textLines;\n}\nCircleROIStartEndThresholdTool.toolName = 'CircleROIStartEndThreshold';\nexport default CircleROIStartEndThresholdTool;\n", "import { cache, getEnabledElement, utilities as csUtils, BaseVolumeViewport, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { SegmentationRepresentations } from '../../enums';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { segmentLocking, activeSegmentation, segmentIndex as segmentIndexController, } from '../../stateManagement/segmentation';\nimport floodFill from '../../utilities/segmentation/floodFill';\nimport { getCurrentLabelmapImageIdForViewport, getSegmentation, } from '../../stateManagement/segmentation/segmentationState';\nconst { transformWorldToIndex, isEqual } = csUtils;\nclass PaintFillTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal } = camera;\n            const activeSegmentationRepresentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeSegmentationRepresentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeSegmentationRepresentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const { representationData } = getSegmentation(segmentationId);\n            let dimensions;\n            let direction;\n            let index;\n            let voxelManager;\n            this.doneEditMemo();\n            if (viewport instanceof BaseVolumeViewport) {\n                const { volumeId } = representationData[SegmentationRepresentations.Labelmap];\n                const segmentation = cache.getVolume(volumeId);\n                ({ dimensions, direction } = segmentation);\n                voxelManager = segmentation.voxelManager;\n                index = transformWorldToIndex(segmentation.imageData, worldPos);\n            }\n            else {\n                const currentSegmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n                if (!currentSegmentationImageId) {\n                    throw new Error('No active segmentation imageId detected, create one before using scissors tool');\n                }\n                const { imageData } = viewport.getImageData();\n                dimensions = imageData.getDimensions();\n                direction = imageData.getDirection();\n                const image = cache.getImage(currentSegmentationImageId);\n                voxelManager = image.voxelManager;\n                index = transformWorldToIndex(imageData, worldPos);\n            }\n            const fixedDimension = this.getFixedDimension(viewPlaneNormal, direction);\n            if (fixedDimension === undefined) {\n                console.warn('Oblique paint fill not yet supported');\n                return;\n            }\n            const { floodFillGetter, getLabelValue, getScalarDataPositionFromPlane, inPlaneSeedPoint, fixedDimensionValue, } = this.generateHelpers(voxelManager, dimensions, index, fixedDimension);\n            if (index[0] < 0 ||\n                index[0] >= dimensions[0] ||\n                index[1] < 0 ||\n                index[1] >= dimensions[1] ||\n                index[2] < 0 ||\n                index[2] >= dimensions[2]) {\n                return;\n            }\n            const clickedLabelValue = getLabelValue(index[0], index[1], index[2]);\n            if (segmentsLocked.includes(clickedLabelValue)) {\n                return;\n            }\n            const floodFillResult = floodFill(floodFillGetter, inPlaneSeedPoint);\n            const { flooded } = floodFillResult;\n            flooded.forEach((index) => {\n                const scalarDataIndex = getScalarDataPositionFromPlane(index[0], index[1]);\n                voxelManager.setAtIndex(scalarDataIndex, segmentIndex);\n            });\n            const framesModified = this.getFramesModified(fixedDimension, fixedDimensionValue, floodFillResult);\n            triggerSegmentationDataModified(segmentationId, framesModified);\n            return true;\n        };\n        this.getFramesModified = (fixedDimension, fixedDimensionValue, floodFillResult) => {\n            const { flooded: boundaries } = floodFillResult;\n            if (fixedDimension === 2) {\n                return [fixedDimensionValue];\n            }\n            let minJ = Infinity;\n            let maxJ = -Infinity;\n            for (let b = 0; b < boundaries.length; b++) {\n                const j = boundaries[b][1];\n                if (j < minJ) {\n                    minJ = j;\n                }\n                if (j > maxJ) {\n                    maxJ = j;\n                }\n            }\n            const framesModified = [];\n            for (let frame = minJ; frame <= maxJ; frame++) {\n                framesModified.push(frame);\n            }\n            return framesModified;\n        };\n        this.generateHelpers = (voxelManager, dimensions, seedIndex3D, fixedDimension = 2) => {\n            let fixedDimensionValue;\n            let inPlaneSeedPoint;\n            switch (fixedDimension) {\n                case 0:\n                    fixedDimensionValue = seedIndex3D[0];\n                    inPlaneSeedPoint = [seedIndex3D[1], seedIndex3D[2]];\n                    break;\n                case 1:\n                    fixedDimensionValue = seedIndex3D[1];\n                    inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[2]];\n                    break;\n                case 2:\n                    fixedDimensionValue = seedIndex3D[2];\n                    inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[1]];\n                    break;\n                default:\n                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n            }\n            const getScalarDataPosition = (x, y, z) => {\n                return voxelManager.toIndex([x, y, z]);\n            };\n            const getLabelValue = (x, y, z) => {\n                return voxelManager.getAtIJK(x, y, z);\n            };\n            const floodFillGetter = this.generateFloodFillGetter(dimensions, fixedDimension, fixedDimensionValue, getLabelValue);\n            const getScalarDataPositionFromPlane = this.generateGetScalarDataPositionFromPlane(getScalarDataPosition, fixedDimension, fixedDimensionValue);\n            return {\n                getScalarDataPositionFromPlane,\n                getLabelValue,\n                floodFillGetter,\n                inPlaneSeedPoint,\n                fixedDimensionValue,\n            };\n        };\n        this.generateFloodFillGetter = (dimensions, fixedDimension, fixedDimensionValue, getLabelValue) => {\n            let floodFillGetter;\n            switch (fixedDimension) {\n                case 0:\n                    floodFillGetter = (y, z) => {\n                        if (y >= dimensions[1] || y < 0 || z >= dimensions[2] || z < 0) {\n                            return;\n                        }\n                        return getLabelValue(fixedDimensionValue, y, z);\n                    };\n                    break;\n                case 1:\n                    floodFillGetter = (x, z) => {\n                        if (x >= dimensions[0] || x < 0 || z >= dimensions[2] || z < 0) {\n                            return;\n                        }\n                        return getLabelValue(x, fixedDimensionValue, z);\n                    };\n                    break;\n                case 2:\n                    floodFillGetter = (x, y) => {\n                        if (x >= dimensions[0] || x < 0 || y >= dimensions[1] || y < 0) {\n                            return;\n                        }\n                        return getLabelValue(x, y, fixedDimensionValue);\n                    };\n                    break;\n                default:\n                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n            }\n            return floodFillGetter;\n        };\n        this.generateGetScalarDataPositionFromPlane = (getScalarDataPosition, fixedDimension, fixedDimensionValue) => {\n            let getScalarDataPositionFromPlane;\n            switch (fixedDimension) {\n                case 0:\n                    getScalarDataPositionFromPlane = (y, z) => {\n                        return getScalarDataPosition(fixedDimensionValue, y, z);\n                    };\n                    break;\n                case 1:\n                    getScalarDataPositionFromPlane = (x, z) => {\n                        return getScalarDataPosition(x, fixedDimensionValue, z);\n                    };\n                    break;\n                case 2:\n                    getScalarDataPositionFromPlane = (x, y) => {\n                        return getScalarDataPosition(x, y, fixedDimensionValue);\n                    };\n                    break;\n                default:\n                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n            }\n            return getScalarDataPositionFromPlane;\n        };\n    }\n    getFixedDimension(viewPlaneNormal, direction) {\n        const xDirection = direction.slice(0, 3);\n        const yDirection = direction.slice(3, 6);\n        const zDirection = direction.slice(6, 9);\n        const absoluteOfViewPlaneNormal = [\n            Math.abs(viewPlaneNormal[0]),\n            Math.abs(viewPlaneNormal[1]),\n            Math.abs(viewPlaneNormal[2]),\n        ];\n        const absoluteOfXDirection = [\n            Math.abs(xDirection[0]),\n            Math.abs(xDirection[1]),\n            Math.abs(xDirection[2]),\n        ];\n        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfXDirection)) {\n            return 0;\n        }\n        const absoluteOfYDirection = [\n            Math.abs(yDirection[0]),\n            Math.abs(yDirection[1]),\n            Math.abs(yDirection[2]),\n        ];\n        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfYDirection)) {\n            return 1;\n        }\n        const absoluteOfZDirection = [\n            Math.abs(zDirection[0]),\n            Math.abs(zDirection[1]),\n            Math.abs(zDirection[2]),\n        ];\n        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfZDirection)) {\n            return 2;\n        }\n    }\n}\nPaintFillTool.toolName = 'PaintFill';\nexport default PaintFillTool;\n", "const Corners = {\n  TOP_LEFT: 'TOP_LEFT',\n  TOP_RIGHT: 'TOP_RIGHT',\n  BOTTOM_LEFT: 'BOTTOM_LEFT',\n  BOTTOM_RIGHT: 'BOTTOM_RIGHT'\n};\nvar Constants = {\n  Corners\n};\n\nexport { Corners, Constants as default };\n", "import { m as macro } from '../../macros2.js';\nimport vtkRenderer from '../../Rendering/Core/Renderer.js';\nimport Constants from './OrientationMarkerWidget/Constants.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\nconst {\n  Corners\n} = Constants;\n\n// ----------------------------------------------------------------------------\n// vtkOrientationMarkerWidget\n// ----------------------------------------------------------------------------\n\nfunction vtkOrientationMarkerWidget(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOrientationMarkerWidget');\n  const superClass = {\n    ...publicAPI\n  };\n\n  // Private variables\n\n  const previousCameraInput = [];\n  const selfRenderer = vtkRenderer.newInstance();\n  const resizeObserver = new ResizeObserver(entries => {\n    publicAPI.updateViewport();\n  });\n  let onCameraChangedSub = null;\n  let onCameraModifiedSub = null;\n  let onAnimationSub = null;\n  let onEndAnimationSub = null;\n  let selfSubscription = null;\n  function onCameraModified() {\n    // If animating, marker will be updated on Animation event\n    if (!model._interactor.isAnimating()) {\n      publicAPI.updateMarkerOrientation();\n    }\n  }\n  model._onParentRendererChanged = () => publicAPI.updateViewport();\n  publicAPI.computeViewport = () => {\n    const parentRen = model.parentRenderer || model._interactor.getCurrentRenderer();\n    const [xMin, yMin, xMax, yMax] = parentRen.getViewport();\n    const view = model._interactor.getView();\n    const canvasSize = view.getSize();\n    const [viewXSize, viewYSize] = view.getViewportSize(parentRen);\n    const minViewSize = Math.min(viewXSize, viewYSize);\n    let pixelSize = model.viewportSize * minViewSize;\n    // clamp pixel size\n    pixelSize = Math.max(Math.min(model.minPixelSize, minViewSize), Math.min(model.maxPixelSize, pixelSize));\n    const xFrac = pixelSize / canvasSize[0];\n    const yFrac = pixelSize / canvasSize[1];\n    // [left bottom right top]\n    switch (model.viewportCorner) {\n      case Corners.TOP_LEFT:\n        return [xMin, yMax - yFrac, xMin + xFrac, yMax];\n      case Corners.TOP_RIGHT:\n        return [xMax - xFrac, yMax - yFrac, xMax, yMax];\n      case Corners.BOTTOM_LEFT:\n        return [xMin, yMin, xMin + xFrac, yMin + yFrac];\n      case Corners.BOTTOM_RIGHT:\n        return [xMax - xFrac, yMin, xMax, yMin + yFrac];\n      default:\n        vtkErrorMacro('Invalid widget corner');\n        return null;\n    }\n  };\n  publicAPI.updateViewport = () => {\n    if (model.enabled) {\n      selfRenderer.setViewport(...publicAPI.computeViewport());\n      model._interactor.render();\n    }\n  };\n  publicAPI.updateMarkerOrientation = () => {\n    const ren = model.parentRenderer || model._interactor.getCurrentRenderer();\n    const currentCamera = ren.getActiveCamera();\n    if (!currentCamera) {\n      return;\n    }\n    const position = currentCamera.getReferenceByName('position');\n    const focalPoint = currentCamera.getReferenceByName('focalPoint');\n    const viewUp = currentCamera.getReferenceByName('viewUp');\n    if (previousCameraInput[0] !== position[0] || previousCameraInput[1] !== position[1] || previousCameraInput[2] !== position[2] || previousCameraInput[3] !== focalPoint[0] || previousCameraInput[4] !== focalPoint[1] || previousCameraInput[5] !== focalPoint[2] || previousCameraInput[6] !== viewUp[0] || previousCameraInput[7] !== viewUp[1] || previousCameraInput[8] !== viewUp[2]) {\n      previousCameraInput[0] = position[0];\n      previousCameraInput[1] = position[1];\n      previousCameraInput[2] = position[2];\n      previousCameraInput[3] = focalPoint[0];\n      previousCameraInput[4] = focalPoint[1];\n      previousCameraInput[5] = focalPoint[2];\n      previousCameraInput[6] = viewUp[0];\n      previousCameraInput[7] = viewUp[1];\n      previousCameraInput[8] = viewUp[2];\n      const activeCamera = selfRenderer.getActiveCamera();\n      activeCamera.setPosition(position[0], position[1], position[2]);\n      activeCamera.setFocalPoint(focalPoint[0], focalPoint[1], focalPoint[2]);\n      activeCamera.setViewUp(viewUp[0], viewUp[1], viewUp[2]);\n      selfRenderer.resetCamera();\n    }\n  };\n\n  /**\n   * Enables/Disables the orientation marker.\n   */\n  publicAPI.setEnabled = enabling => {\n    if (enabling) {\n      if (model.enabled) {\n        return;\n      }\n      if (!model.actor) {\n        vtkErrorMacro('Must set actor before enabling orientation marker.');\n        return;\n      }\n      if (!model._interactor) {\n        vtkErrorMacro('Must set interactor before enabling orientation marker.');\n        return;\n      }\n      const ren = model.parentRenderer || model._interactor.getCurrentRenderer();\n      const renderWindow = ren.getRenderWindow();\n      renderWindow.addRenderer(selfRenderer);\n      if (renderWindow.getNumberOfLayers() < 2) {\n        renderWindow.setNumberOfLayers(2);\n      }\n      // Highest number is foreground\n      selfRenderer.setLayer(renderWindow.getNumberOfLayers() - 1);\n      selfRenderer.setInteractive(model.interactiveRenderer);\n      selfRenderer.addViewProp(model.actor);\n      model.actor.setVisibility(true);\n      onCameraChangedSub = ren.onEvent(event => {\n        if (event.type === 'ActiveCameraEvent') {\n          if (onCameraModifiedSub) {\n            onCameraModifiedSub.unsubscribe();\n          }\n          onCameraModifiedSub = event.camera.onModified(onCameraModified);\n        }\n      });\n      onCameraModifiedSub = ren.getActiveCamera().onModified(onCameraModified);\n      onAnimationSub = model._interactor.onAnimation(publicAPI.updateMarkerOrientation);\n      onEndAnimationSub = model._interactor.onEndAnimation(publicAPI.updateMarkerOrientation);\n      resizeObserver.observe(model._interactor.getView().getCanvas());\n      publicAPI.updateViewport();\n      publicAPI.updateMarkerOrientation();\n      model.enabled = true;\n    } else {\n      if (!model.enabled) {\n        return;\n      }\n      model.enabled = false;\n      resizeObserver.disconnect();\n      onCameraChangedSub.unsubscribe();\n      onCameraChangedSub = null;\n      onCameraModifiedSub.unsubscribe();\n      onCameraModifiedSub = null;\n      onAnimationSub.unsubscribe();\n      onAnimationSub = null;\n      onEndAnimationSub.unsubscribe();\n      onEndAnimationSub = null;\n      model.actor.setVisibility(false);\n      selfRenderer.removeViewProp(model.actor);\n      const renderWindow = model._interactor?.findPokedRenderer()?.getRenderWindow();\n      if (renderWindow) {\n        renderWindow.removeRenderer(selfRenderer);\n      }\n    }\n    publicAPI.modified();\n  };\n\n  /**\n   * Sets the viewport corner.\n   */\n  publicAPI.setViewportCorner = corner => {\n    if (corner === model.viewportCorner) {\n      return;\n    }\n    model.viewportCorner = corner;\n    publicAPI.updateViewport();\n  };\n\n  /**\n   * Sets the viewport size.\n   */\n  publicAPI.setViewportSize = sizeFactor => {\n    const viewportSize = Math.min(1, Math.max(0, sizeFactor));\n    if (viewportSize === model.viewportSize) {\n      return;\n    }\n    model.viewportSize = viewportSize;\n    publicAPI.updateViewport();\n  };\n  publicAPI.setActor = actor => {\n    const previousState = model.enabled;\n    publicAPI.setEnabled(false);\n    model.actor = actor;\n    publicAPI.setEnabled(previousState);\n  };\n  publicAPI.getRenderer = () => selfRenderer;\n  publicAPI.delete = () => {\n    superClass.delete();\n    if (selfSubscription) {\n      selfSubscription.unsubscribe();\n      selfSubscription = null;\n    }\n    if (onCameraChangedSub) {\n      onCameraChangedSub.unsubscribe();\n      onCameraChangedSub = null;\n    }\n    if (onCameraModifiedSub) {\n      onCameraModifiedSub.unsubscribe();\n      onCameraModifiedSub = null;\n    }\n    if (onAnimationSub) {\n      onAnimationSub.unsubscribe();\n      onAnimationSub = null;\n    }\n    if (onEndAnimationSub) {\n      onEndAnimationSub.unsubscribe();\n      onEndAnimationSub = null;\n    }\n    resizeObserver.disconnect();\n  };\n\n  // --------------------------------------------------------------------------\n\n  // update viewport whenever we are updated\n  selfSubscription = publicAPI.onModified(publicAPI.updateViewport);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // actor: null,\n  // _interactor: null,\n  viewportCorner: Constants.Corners.BOTTOM_LEFT,\n  viewportSize: 0.2,\n  minPixelSize: 50,\n  maxPixelSize: 200,\n  parentRenderer: null,\n  interactiveRenderer: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['enabled', 'viewportCorner', 'viewportSize', 'interactiveRenderer']);\n\n  // NOTE: setting these while the widget is enabled will\n  // not update the widget.\n  macro.setGet(publicAPI, model, ['_interactor', 'minPixelSize', 'maxPixelSize', 'parentRenderer']);\n  macro.get(publicAPI, model, ['actor']);\n  macro.moveToProtected(publicAPI, model, ['interactor']);\n\n  // Object methods\n  vtkOrientationMarkerWidget(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkOrientationMarkerWidget');\n\n// ----------------------------------------------------------------------------\n\nvar vtkOrientationMarkerWidget$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\nexport { DEFAULT_VALUES, vtkOrientationMarkerWidget$1 as default, extend, newInstance };\n", "import vtkImageData from '../DataModel/ImageData.js';\nimport vtkDataArray from './DataArray.js';\n\n/**\n * Takes a canvas and converts it to a vtkImageData.\n *\n * Optionally supply a bounding box to get a particular subset of the canvas.\n *\n * @param canvas       The HTML canvas to convert\n * @param boundingBox  A bounding box of type [top, left, width, height]\n */\nfunction canvasToImageData(canvas) {\n  let boundingBox = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0, 0];\n  const [top, left, width, height] = boundingBox;\n  const ctxt = canvas.getContext('2d');\n  const idata = ctxt.getImageData(top, left, width || canvas.width, height || canvas.height);\n  const imageData = vtkImageData.newInstance({\n    type: 'vtkImageData'\n  });\n  imageData.setOrigin(0, 0, 0);\n  imageData.setSpacing(1, 1, 1);\n  imageData.setExtent(0, (width || canvas.width) - 1, 0, (height || canvas.height) - 1, 0, 0);\n  const scalars = vtkDataArray.newInstance({\n    numberOfComponents: 4,\n    values: new Uint8Array(idata.data.buffer)\n  });\n  scalars.setName('scalars');\n  imageData.getPointData().setScalars(scalars);\n  return imageData;\n}\n\n/**\n * Converts an Image object to a vtkImageData.\n */\nfunction imageToImageData(image) {\n  let transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    flipX: false,\n    flipY: false,\n    rotate: 0\n  };\n  const canvas = document.createElement('canvas');\n  canvas.width = image.width;\n  canvas.height = image.height;\n  const ctx = canvas.getContext('2d');\n  const {\n    flipX,\n    flipY,\n    rotate\n  } = transform;\n  ctx.translate(canvas.width / 2, canvas.height / 2);\n  ctx.scale(flipX ? -1 : 1, flipY ? -1 : 1);\n  ctx.rotate(rotate * Math.PI / 180);\n  ctx.drawImage(image, -image.width / 2, -image.height / 2);\n  return canvasToImageData(canvas);\n}\nvar ImageHelper = {\n  canvasToImageData,\n  imageToImageData\n};\n\nexport { ImageHelper as default };\n", "const STYLES = {\n  default: {\n    defaultStyle: {\n      fontStyle: 'bold',\n      fontFamily: 'Arial',\n      fontColor: 'black',\n      fontSizeScale: res => res / 2,\n      faceColor: 'white',\n      edgeThickness: 0.1,\n      edgeColor: 'black',\n      resolution: 400\n    },\n    xMinusFaceProperty: {\n      text: 'X-',\n      faceColor: 'yellow'\n    },\n    xPlusFaceProperty: {\n      text: 'X+',\n      faceColor: 'yellow'\n    },\n    yMinusFaceProperty: {\n      text: 'Y-',\n      faceColor: 'red'\n    },\n    yPlusFaceProperty: {\n      text: 'Y+',\n      faceColor: 'red'\n    },\n    zMinusFaceProperty: {\n      text: 'Z-',\n      faceColor: '#008000'\n    },\n    zPlusFaceProperty: {\n      text: 'Z+',\n      faceColor: '#008000'\n    }\n  },\n  lps: {\n    xMinusFaceProperty: {\n      text: 'R',\n      faceRotation: -90\n    },\n    xPlusFaceProperty: {\n      text: 'L',\n      faceRotation: 90\n    },\n    yMinusFaceProperty: {\n      text: 'A',\n      faceRotation: 0\n    },\n    yPlusFaceProperty: {\n      text: 'P',\n      faceRotation: 180\n    },\n    zMinusFaceProperty: {\n      text: 'I',\n      faceRotation: 180\n    },\n    zPlusFaceProperty: {\n      text: 'S',\n      faceRotation: 0\n    }\n  }\n};\nfunction applyDefinitions(definitions, cubeActor) {\n  cubeActor.set(definitions);\n}\nfunction applyPreset(name, cubeActor) {\n  return applyDefinitions(STYLES[name], cubeActor);\n}\nfunction registerStylePreset(name, definitions) {\n  STYLES[name] = definitions;\n}\nvar AnnotatedCubePresets = {\n  applyDefinitions,\n  applyPreset,\n  registerStylePreset\n};\n\nexport { AnnotatedCubePresets as default };\n", "import { m as macro } from '../../macros2.js';\nimport vtkActor from './Actor.js';\nimport vtkMapper from './Mapper.js';\nimport vtkTexture from './Texture.js';\nimport vtkCubeSource from '../../Filters/Sources/CubeSource.js';\nimport ImageHelper from '../../Common/Core/ImageHelper.js';\nimport AnnotatedCubePresets from './AnnotatedCubeActor/Presets.js';\n\nconst FACE_TO_INDEX = {\n  xPlus: 0,\n  xMinus: 1,\n  yPlus: 2,\n  yMinus: 3,\n  zPlus: 4,\n  zMinus: 5\n};\n\n// ----------------------------------------------------------------------------\n// vtkAnnotatedCubeActor\n// ----------------------------------------------------------------------------\n\nfunction vtkAnnotatedCubeActor(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkAnnotatedCubeActor');\n\n  // Make sure face properties are not references to the default value\n  model.xPlusFaceProperty = {\n    ...model.xPlusFaceProperty\n  };\n  model.xMinusFaceProperty = {\n    ...model.xMinusFaceProperty\n  };\n  model.yPlusFaceProperty = {\n    ...model.yPlusFaceProperty\n  };\n  model.yMinusFaceProperty = {\n    ...model.yMinusFaceProperty\n  };\n  model.zPlusFaceProperty = {\n    ...model.zPlusFaceProperty\n  };\n  model.zMinusFaceProperty = {\n    ...model.zMinusFaceProperty\n  };\n\n  // private variables\n\n  let cubeSource = null;\n  const canvas = document.createElement('canvas');\n  const mapper = vtkMapper.newInstance();\n  const texture = vtkTexture.newInstance();\n  texture.setInterpolate(true);\n\n  // private methods\n\n  function updateFaceTexture(faceName) {\n    let newProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (newProp) {\n      Object.assign(model[`${faceName}FaceProperty`], newProp);\n    }\n    const prop = {\n      ...model.defaultStyle,\n      ...model[`${faceName}FaceProperty`]\n    };\n\n    // set canvas resolution\n    canvas.width = prop.resolution;\n    canvas.height = prop.resolution;\n    const ctxt = canvas.getContext('2d');\n\n    // set background color\n    ctxt.fillStyle = prop.faceColor;\n    ctxt.fillRect(0, 0, canvas.width, canvas.height);\n\n    // draw edge\n    if (prop.edgeThickness > 0) {\n      ctxt.strokeStyle = prop.edgeColor;\n      ctxt.lineWidth = prop.edgeThickness * canvas.width;\n      ctxt.strokeRect(0, 0, canvas.width, canvas.height);\n    }\n\n    // set face rotation\n    ctxt.save();\n\n    // vertical flip\n    ctxt.translate(0, canvas.height);\n    ctxt.scale(1, -1);\n    ctxt.translate(canvas.width / 2, canvas.height / 2);\n    ctxt.rotate(-Math.PI * (prop.faceRotation / 180.0));\n\n    // set foreground text\n    const textSize = prop.fontSizeScale(prop.resolution);\n    ctxt.fillStyle = prop.fontColor;\n    ctxt.textAlign = 'center';\n    ctxt.textBaseline = 'middle';\n    ctxt.font = `${prop.fontStyle} ${textSize}px \"${prop.fontFamily}\"`;\n    ctxt.fillText(prop.text, 0, 0);\n    ctxt.restore();\n    const vtkImage = ImageHelper.canvasToImageData(canvas);\n    texture.setInputData(vtkImage, FACE_TO_INDEX[faceName]);\n    publicAPI.modified();\n  }\n  function updateAllFaceTextures() {\n    cubeSource = vtkCubeSource.newInstance({\n      generate3DTextureCoordinates: true\n    });\n    mapper.setInputConnection(cubeSource.getOutputPort());\n    updateFaceTexture('xPlus');\n    updateFaceTexture('xMinus');\n    updateFaceTexture('yPlus');\n    updateFaceTexture('yMinus');\n    updateFaceTexture('zPlus');\n    updateFaceTexture('zMinus');\n  }\n\n  // public methods\n\n  publicAPI.setDefaultStyle = style => {\n    model.defaultStyle = {\n      ...model.defaultStyle,\n      ...style\n    };\n    updateAllFaceTextures();\n  };\n  publicAPI.setXPlusFaceProperty = prop => updateFaceTexture('xPlus', prop);\n  publicAPI.setXMinusFaceProperty = prop => updateFaceTexture('xMinus', prop);\n  publicAPI.setYPlusFaceProperty = prop => updateFaceTexture('yPlus', prop);\n  publicAPI.setYMinusFaceProperty = prop => updateFaceTexture('yMinus', prop);\n  publicAPI.setZPlusFaceProperty = prop => updateFaceTexture('zPlus', prop);\n  publicAPI.setZMinusFaceProperty = prop => updateFaceTexture('zMinus', prop);\n\n  // constructor\n\n  updateAllFaceTextures();\n\n  // set mapper\n  mapper.setInputConnection(cubeSource.getOutputPort());\n  publicAPI.setMapper(mapper);\n\n  // set texture\n  publicAPI.addTexture(texture);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  defaultStyle: {\n    text: '',\n    faceColor: 'white',\n    faceRotation: 0,\n    fontFamily: 'Arial',\n    fontColor: 'black',\n    fontStyle: 'normal',\n    fontSizeScale: resolution => resolution / 1.8,\n    edgeThickness: 0.1,\n    edgeColor: 'black',\n    resolution: 200\n  }\n  // xPlusFaceProperty: null,\n  // xMinusFaceProperty: null,\n  // yPlusFaceProperty: null,\n  // yMinusFaceProperty: null,\n  // zPlusFaceProperty: null,\n  // zMinusFaceProperty: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkActor.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['defaultStyle', 'xPlusFaceProperty', 'xMinusFaceProperty', 'yPlusFaceProperty', 'yMinusFaceProperty', 'zPlusFaceProperty', 'zMinusFaceProperty']);\n\n  // Object methods\n  vtkAnnotatedCubeActor(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkAnnotatedCubeActor');\n\n// ----------------------------------------------------------------------------\n\nvar vtkAnnotatedCubeActor$1 = {\n  newInstance,\n  extend,\n  Presets: AnnotatedCubePresets\n};\n\nexport { DEFAULT_VALUES, vtkAnnotatedCubeActor$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkPoints from '../../Common/Core/Points.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport { DesiredOutputPrecision } from '../../Common/DataModel/DataSetAttributes/Constants.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\nfunction offsetCellArray(typedArray, offset) {\n  let currentIdx = 0;\n  return typedArray.map((value, index) => {\n    if (index === currentIdx) {\n      currentIdx += value + 1;\n      return value;\n    }\n    return value + offset;\n  });\n}\nfunction appendCellData(dest, src, ptOffset, cellOffset) {\n  dest.set(offsetCellArray(src, ptOffset), cellOffset);\n}\n\n// ----------------------------------------------------------------------------\n// vtkAppendPolyData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkAppendPolyData(publicAPI, model) {\n  // Set our classname\n  model.classHierarchy.push('vtkAppendPolyData');\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const numberOfInputs = publicAPI.getNumberOfInputPorts();\n    if (!numberOfInputs) {\n      vtkErrorMacro('No input specified.');\n      return;\n    }\n    if (numberOfInputs === 1) {\n      // pass through filter\n      outData[0] = inData[0];\n      return;\n    }\n\n    // Allocate output\n    const output = vtkPolyData.newInstance();\n    let numPts = 0;\n    let pointType = 0;\n    let ttype = 1;\n    let firstType = 1;\n    let numVerts = 0;\n    let numLines = 0;\n    let numStrips = 0;\n    let numPolys = 0;\n\n    // Field data is propagated to output only if present in all inputs\n    let hasPtNormals = true; // assume present by default\n    let hasPtTCoords = true;\n    let hasPtScalars = true;\n    for (let i = 0; i < numberOfInputs; i++) {\n      const ds = inData[i];\n      if (!ds) {\n        // eslint-disable-next-line\n        continue;\n      }\n      const dsNumPts = ds.getPoints().getNumberOfPoints();\n      numPts += dsNumPts;\n      numVerts += ds.getVerts().getNumberOfValues();\n      numLines += ds.getLines().getNumberOfValues();\n      numStrips += ds.getStrips().getNumberOfValues();\n      numPolys += ds.getPolys().getNumberOfValues();\n      if (dsNumPts) {\n        if (firstType) {\n          firstType = 0;\n          pointType = ds.getPoints().getDataType();\n        }\n        ttype = ds.getPoints().getDataType();\n        pointType = pointType > ttype ? pointType : ttype;\n      }\n      const ptD = ds.getPointData();\n      if (ptD) {\n        hasPtNormals = hasPtNormals && ptD.getNormals() !== null;\n        hasPtTCoords = hasPtTCoords && ptD.getTCoords() !== null;\n        hasPtScalars = hasPtScalars && ptD.getScalars() !== null;\n      } else {\n        hasPtNormals = false;\n        hasPtTCoords = false;\n        hasPtScalars = false;\n      }\n    }\n    if (model.outputPointsPrecision === DesiredOutputPrecision.SINGLE) {\n      pointType = VtkDataTypes.FLOAT;\n    } else if (model.outputPointsPrecision === DesiredOutputPrecision.DOUBLE) {\n      pointType = VtkDataTypes.DOUBLE;\n    }\n    const points = vtkPoints.newInstance({\n      dataType: pointType\n    });\n    points.setNumberOfPoints(numPts);\n    const pointData = points.getData();\n    const vertData = new Uint32Array(numVerts);\n    const lineData = new Uint32Array(numLines);\n    const stripData = new Uint32Array(numStrips);\n    const polyData = new Uint32Array(numPolys);\n    let newPtNormals = null;\n    let newPtTCoords = null;\n    let newPtScalars = null;\n    const lds = inData[numberOfInputs - 1];\n    if (hasPtNormals) {\n      const dsNormals = lds.getPointData().getNormals();\n      newPtNormals = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        numberOfTuples: numPts,\n        size: 3 * numPts,\n        dataType: dsNormals.getDataType(),\n        name: dsNormals.getName()\n      });\n    }\n    if (hasPtTCoords) {\n      const dsTCoords = lds.getPointData().getTCoords();\n      newPtTCoords = vtkDataArray.newInstance({\n        numberOfComponents: 2,\n        numberOfTuples: numPts,\n        size: 2 * numPts,\n        dataType: dsTCoords.getDataType(),\n        name: dsTCoords.getName()\n      });\n    }\n    if (hasPtScalars) {\n      const dsScalars = lds.getPointData().getScalars();\n      newPtScalars = vtkDataArray.newInstance({\n        numberOfComponents: dsScalars.getNumberOfComponents(),\n        numberOfTuples: numPts,\n        size: numPts * dsScalars.getNumberOfComponents(),\n        dataType: dsScalars.getDataType(),\n        name: dsScalars.getName()\n      });\n    }\n    numPts = 0;\n    numVerts = 0;\n    numLines = 0;\n    numStrips = 0;\n    numPolys = 0;\n    for (let i = 0; i < numberOfInputs; i++) {\n      const ds = inData[i];\n      pointData.set(ds.getPoints().getData(), numPts * 3);\n      appendCellData(vertData, ds.getVerts().getData(), numPts, numVerts);\n      numVerts += ds.getVerts().getNumberOfValues();\n      appendCellData(lineData, ds.getLines().getData(), numPts, numLines);\n      numLines += ds.getLines().getNumberOfValues();\n      appendCellData(stripData, ds.getStrips().getData(), numPts, numStrips);\n      numStrips += ds.getStrips().getNumberOfValues();\n      appendCellData(polyData, ds.getPolys().getData(), numPts, numPolys);\n      numPolys += ds.getPolys().getNumberOfValues();\n      const dsPD = ds.getPointData();\n      if (hasPtNormals) {\n        const ptNorms = dsPD.getNormals();\n        newPtNormals.getData().set(ptNorms.getData(), numPts * 3);\n      }\n      if (hasPtTCoords) {\n        const ptTCoords = dsPD.getTCoords();\n        newPtTCoords.getData().set(ptTCoords.getData(), numPts * 2);\n      }\n      if (hasPtScalars) {\n        const ptScalars = dsPD.getScalars();\n        newPtScalars.getData().set(ptScalars.getData(), numPts * newPtScalars.getNumberOfComponents());\n      }\n      numPts += ds.getPoints().getNumberOfPoints();\n    }\n    output.setPoints(points);\n    output.getVerts().setData(vertData);\n    output.getLines().setData(lineData);\n    output.getStrips().setData(stripData);\n    output.getPolys().setData(polyData);\n    if (newPtNormals) {\n      output.getPointData().setNormals(newPtNormals);\n    }\n    if (newPtTCoords) {\n      output.getPointData().setTCoords(newPtTCoords);\n    }\n    if (newPtScalars) {\n      output.getPointData().setScalars(newPtScalars);\n    }\n    outData[0] = output;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  outputPointsPrecision: DesiredOutputPrecision.DEFAULT\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.setGet(publicAPI, model, ['outputPointsPrecision']);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n\n  // Object specific methods\n  vtkAppendPolyData(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkAppendPolyData');\n\n// ----------------------------------------------------------------------------\n\nvar vtkAppendPolyData$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkAppendPolyData$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkMatrixBuilder from '../../Common/Core/MatrixBuilder.js';\n\n// ----------------------------------------------------------------------------\n// vtkConeSource methods\n// ----------------------------------------------------------------------------\n\nfunction vtkConeSource(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkConeSource');\n  function requestData(inData, outData) {\n    if (model.deleted) {\n      return;\n    }\n    let dataset = outData[0];\n    const angle = 2 * Math.PI / model.resolution;\n    const xbot = -model.height / 2.0;\n    const numberOfPoints = model.resolution + 1;\n    const cellArraySize = 4 * model.resolution + 1 + model.resolution;\n\n    // Points\n    let pointIdx = 0;\n    const points = macro.newTypedArray(model.pointType, numberOfPoints * 3);\n\n    // Cells\n    let cellLocation = 0;\n    const polys = new Uint32Array(cellArraySize);\n\n    // Add summit point\n    points[0] = model.height / 2.0;\n    points[1] = 0.0;\n    points[2] = 0.0;\n\n    // Create bottom cell\n    if (model.capping) {\n      polys[cellLocation++] = model.resolution;\n    }\n\n    // Add all points\n    for (let i = 0; i < model.resolution; i++) {\n      pointIdx++;\n      points[pointIdx * 3 + 0] = xbot;\n      points[pointIdx * 3 + 1] = model.radius * Math.cos(i * angle);\n      points[pointIdx * 3 + 2] = model.radius * Math.sin(i * angle);\n\n      // Add points to bottom cell in reverse order\n      if (model.capping) {\n        polys[model.resolution - cellLocation++ + 1] = pointIdx;\n      }\n    }\n\n    // Add all triangle cells\n    for (let i = 0; i < model.resolution; i++) {\n      polys[cellLocation++] = 3;\n      polys[cellLocation++] = 0;\n      polys[cellLocation++] = i + 1;\n      polys[cellLocation++] = i + 2 > model.resolution ? 1 : i + 2;\n    }\n\n    // Apply transformation to the points coordinates\n    vtkMatrixBuilder.buildFromRadian().translate(...model.center).rotateFromDirections([1, 0, 0], model.direction).apply(points);\n    dataset = vtkPolyData.newInstance();\n    dataset.getPoints().setData(points, 3);\n    dataset.getPolys().setData(polys, 1);\n\n    // Update output\n    outData[0] = dataset;\n  }\n\n  // Expose methods\n  publicAPI.requestData = requestData;\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  height: 1.0,\n  radius: 0.5,\n  resolution: 6,\n  center: [0, 0, 0],\n  direction: [1.0, 0.0, 0.0],\n  capping: true,\n  pointType: 'Float64Array'\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['height', 'radius', 'resolution', 'capping']);\n  macro.setGetArray(publicAPI, model, ['center', 'direction'], 3);\n  macro.algo(publicAPI, model, 0, 1);\n  vtkConeSource(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkConeSource');\n\n// ----------------------------------------------------------------------------\n\nvar vtkConeSource$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkConeSource$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkMatrixBuilder from '../../Common/Core/MatrixBuilder.js';\n\n// ----------------------------------------------------------------------------\n// vtkCylinderSource methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCylinderSource(publicAPI, model) {\n  // Set our classname\n  model.classHierarchy.push('vtkCylinderSource');\n  function requestData(inData, outData) {\n    if (model.deleted) {\n      return;\n    }\n    let dataset = outData[0];\n    const angle = 2.0 * Math.PI / model.resolution;\n    let numberOfPoints = 2 * model.resolution;\n    let numberOfPolys = 5 * model.resolution;\n    if (model.capping) {\n      numberOfPoints = 4 * model.resolution;\n      numberOfPolys = 7 * model.resolution + 2;\n    }\n\n    // Points\n    const points = macro.newTypedArray(model.pointType, numberOfPoints * 3);\n\n    // Cells\n    let cellLocation = 0;\n    const polys = new Uint32Array(numberOfPolys);\n\n    // Normals\n    const normalsData = new Float32Array(numberOfPoints * 3);\n    const normals = vtkDataArray.newInstance({\n      numberOfComponents: 3,\n      values: normalsData,\n      name: 'Normals'\n    });\n\n    // Texture coords\n    const tcData = new Float32Array(numberOfPoints * 2);\n    const tcoords = vtkDataArray.newInstance({\n      numberOfComponents: 2,\n      values: tcData,\n      name: 'TCoords'\n    });\n\n    // Generate points for all sides\n    const nbot = [0.0, 0.0, 0.0];\n    const ntop = [0.0, 0.0, 0.0];\n    const xbot = [0.0, 0.0, 0.0];\n    const xtop = [0.0, 0.0, 0.0];\n    const tcbot = [0.0, 0.0];\n    const tctop = [0.0, 0.0];\n    const otherRadius = model.otherRadius == null ? model.radius : model.otherRadius;\n    for (let i = 0; i < model.resolution; i++) {\n      // x coordinate\n      nbot[0] = Math.cos(i * angle + model.initAngle);\n      ntop[0] = nbot[0];\n      xbot[0] = model.radius * nbot[0] + model.center[0];\n      xtop[0] = xbot[0];\n      tcbot[0] = Math.abs(2.0 * i / model.resolution - 1.0);\n      tctop[0] = tcbot[0];\n\n      // y coordinate\n      xbot[1] = 0.5 * model.height + model.center[1];\n      xtop[1] = -0.5 * model.height + model.center[1];\n      tcbot[1] = 0.0;\n      tctop[1] = 1.0;\n\n      // z coordinate\n      nbot[2] = -Math.sin(i * angle + model.initAngle);\n      ntop[2] = nbot[2];\n      xbot[2] = otherRadius * nbot[2] + model.center[2];\n      xtop[2] = xbot[2];\n      const pointIdx = 2 * i;\n      for (let j = 0; j < 3; j++) {\n        normalsData[pointIdx * 3 + j] = nbot[j];\n        normalsData[(pointIdx + 1) * 3 + j] = ntop[j];\n        points[pointIdx * 3 + j] = xbot[j];\n        points[(pointIdx + 1) * 3 + j] = xtop[j];\n        if (j < 2) {\n          tcData[pointIdx * 2 + j] = tcbot[j];\n          tcData[(pointIdx + 1) * 2 + j] = tctop[j];\n        }\n      }\n    }\n\n    // Generate polygons for sides\n    for (let i = 0; i < model.resolution; i++) {\n      polys[cellLocation++] = 4;\n      polys[cellLocation++] = 2 * i;\n      polys[cellLocation++] = 2 * i + 1;\n      const pt = (2 * i + 3) % (2 * model.resolution);\n      polys[cellLocation++] = pt;\n      polys[cellLocation++] = pt - 1;\n    }\n    if (model.capping) {\n      // Generate points for top/bottom polygons\n      for (let i = 0; i < model.resolution; i++) {\n        // x coordinate\n        xbot[0] = model.radius * Math.cos(i * angle + model.initAngle);\n        xtop[0] = xbot[0];\n        tcbot[0] = xbot[0];\n        tctop[0] = xbot[0];\n        xbot[0] += model.center[0];\n        xtop[0] += model.center[0];\n\n        // y coordinate\n        nbot[1] = 1.0;\n        ntop[1] = -1.0;\n        xbot[1] = 0.5 * model.height + model.center[1];\n        xtop[1] = -0.5 * model.height + model.center[1];\n\n        // z coordinate\n        xbot[2] = -otherRadius * Math.sin(i * angle + model.initAngle);\n        xtop[2] = xbot[2];\n        tcbot[1] = xbot[2];\n        tctop[1] = xbot[2];\n        xbot[2] += model.center[2];\n        xtop[2] += model.center[2];\n        const botIdx = 2 * model.resolution + i;\n        const topIdx = 3 * model.resolution + model.resolution - i - 1;\n        for (let j = 0; j < 3; j++) {\n          normalsData[3 * botIdx + j] = nbot[j];\n          normalsData[3 * topIdx + j] = ntop[j];\n          points[3 * botIdx + j] = xbot[j];\n          points[3 * topIdx + j] = xtop[j];\n          if (j < 2) {\n            tcData[2 * botIdx + j] = tcbot[j];\n            tcData[2 * topIdx + j] = tctop[j];\n          }\n        }\n      }\n\n      // Generate polygons for top/bottom\n      polys[cellLocation++] = model.resolution;\n      for (let i = 0; i < model.resolution; i++) {\n        polys[cellLocation++] = 2 * model.resolution + i;\n      }\n      polys[cellLocation++] = model.resolution;\n      for (let i = 0; i < model.resolution; i++) {\n        polys[cellLocation++] = 3 * model.resolution + i;\n      }\n    }\n\n    // Apply transformation to the points coordinates\n    vtkMatrixBuilder.buildFromRadian().translate(...model.center).rotateFromDirections([0, 1, 0], model.direction).translate(...model.center.map(c => c * -1)).apply(points);\n    dataset = vtkPolyData.newInstance();\n    dataset.getPoints().setData(points, 3);\n    dataset.getPolys().setData(polys, 1);\n    dataset.getPointData().setNormals(normals);\n    dataset.getPointData().setTCoords(tcoords);\n\n    // Update output\n    outData[0] = dataset;\n  }\n\n  // Expose methods\n  publicAPI.requestData = requestData;\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  height: 1.0,\n  initAngle: 0,\n  radius: 1.0,\n  resolution: 6,\n  center: [0, 0, 0],\n  direction: [0.0, 1.0, 0.0],\n  capping: true,\n  pointType: 'Float64Array'\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['height', 'initAngle', 'otherRadius', 'radius', 'resolution', 'capping']);\n  macro.setGetArray(publicAPI, model, ['center', 'direction'], 3);\n  macro.algo(publicAPI, model, 0, 1);\n  vtkCylinderSource(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCylinderSource');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCylinderSource$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkCylinderSource$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkAppendPolyData from '../General/AppendPolyData.js';\nimport vtkConeSource from './ConeSource.js';\nimport vtkCylinderSource from './CylinderSource.js';\nimport vtkMatrixBuilder from '../../Common/Core/MatrixBuilder.js';\n\n// ----------------------------------------------------------------------------\n// vtkArrowSource methods\n// ----------------------------------------------------------------------------\n\nfunction vtkArrowSource(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkArrowSource');\n  function requestData(inData, outData) {\n    if (model.deleted) {\n      return;\n    }\n    const cylinder = vtkCylinderSource.newInstance({\n      capping: true\n    });\n    cylinder.setResolution(model.shaftResolution);\n    cylinder.setRadius(model.shaftRadius);\n    cylinder.setHeight(1.0 - model.tipLength);\n    cylinder.setCenter(0, (1.0 - model.tipLength) * 0.5, 0.0);\n    const cylinderPD = cylinder.getOutputData();\n    const cylinderPts = cylinderPD.getPoints().getData();\n    const cylinderNormals = cylinderPD.getPointData().getNormals().getData();\n\n    // Apply transformation to the cylinder\n    vtkMatrixBuilder.buildFromDegree().rotateZ(-90).apply(cylinderPts).apply(cylinderNormals);\n    const cone = vtkConeSource.newInstance();\n    cone.setResolution(model.tipResolution);\n    cone.setHeight(model.tipLength);\n    cone.setRadius(model.tipRadius);\n    const conePD = cone.getOutputData();\n    const conePts = conePD.getPoints().getData();\n\n    // Apply transformation to the cone\n    vtkMatrixBuilder.buildFromRadian().translate(1.0 - model.tipLength * 0.5, 0.0, 0.0).apply(conePts);\n    const append = vtkAppendPolyData.newInstance();\n    append.setInputData(cylinderPD);\n    append.addInputData(conePD);\n    const appendPD = append.getOutputData();\n    const appendPts = appendPD.getPoints().getData();\n    // Center the arrow about [0, 0, 0]\n    vtkMatrixBuilder.buildFromRadian().translate(-0.5 + model.tipLength * 0.5, 0.0, 0.0).apply(appendPts);\n    if (model.invert) {\n      // Apply transformation to the arrow\n      vtkMatrixBuilder.buildFromRadian().rotateFromDirections([1, 0, 0], model.direction).scale(-1, -1, -1).apply(appendPts);\n\n      // Update output\n      outData[0] = appendPD;\n    } else {\n      // Apply transformation to the arrow\n      vtkMatrixBuilder.buildFromRadian().rotateFromDirections([1, 0, 0], model.direction).scale(1, 1, 1).apply(appendPts);\n\n      // Update output\n      outData[0] = append.getOutputData();\n    }\n  }\n\n  // Expose methods\n  publicAPI.requestData = requestData;\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  tipResolution: 6,\n  tipRadius: 0.1,\n  tipLength: 0.35,\n  shaftResolution: 6,\n  shaftRadius: 0.03,\n  invert: false,\n  direction: [1.0, 0.0, 0.0],\n  pointType: 'Float64Array'\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['tipResolution', 'tipRadius', 'tipLength', 'shaftResolution', 'shaftRadius', 'invert']);\n  macro.setGetArray(publicAPI, model, ['direction'], 3);\n  macro.algo(publicAPI, model, 0, 1);\n  vtkArrowSource(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkArrowSource');\n\n// ----------------------------------------------------------------------------\n\nvar vtkArrowSource$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkArrowSource$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkMatrixBuilder from '../../Common/Core/MatrixBuilder.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkActor from './Actor.js';\nimport vtkMapper from './Mapper.js';\nimport vtkArrowSource from '../../Filters/Sources/ArrowSource.js';\nimport vtkAppendPolyData from '../../Filters/General/AppendPolyData.js';\n\n// ----------------------------------------------------------------------------\n\nfunction centerDataSet(ds) {\n  const bounds = ds.getPoints().getBounds();\n  const center = [-(bounds[0] + bounds[1]) * 0.5, -(bounds[2] + bounds[3]) * 0.5, -(bounds[4] + bounds[5]) * 0.5];\n  vtkMatrixBuilder.buildFromDegree().translate(...center).apply(ds.getPoints().getData());\n}\nfunction shiftDataset(ds, axis) {\n  let invert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const bounds = ds.getPoints().getBounds();\n  const center = [0, 0, 0];\n  if (invert) {\n    center[axis] = -bounds[axis * 2 + 1];\n  } else {\n    center[axis] = -bounds[axis * 2];\n  }\n  vtkMatrixBuilder.buildFromDegree().translate(...center).apply(ds.getPoints().getData());\n}\n\n// ----------------------------------------------------------------------------\n\nfunction addColor(ds, r, g, b) {\n  const size = ds.getPoints().getData().length;\n  const rgbArray = new Uint8ClampedArray(size);\n  let offset = 0;\n  while (offset < size) {\n    rgbArray[offset++] = r;\n    rgbArray[offset++] = g;\n    rgbArray[offset++] = b;\n  }\n  ds.getPointData().setScalars(vtkDataArray.newInstance({\n    name: 'color',\n    numberOfComponents: 3,\n    values: rgbArray\n  }));\n}\n\n// ----------------------------------------------------------------------------\n// vtkAxesActor\n// ----------------------------------------------------------------------------\n\nfunction vtkAxesActor(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkAxesActor');\n  const _mapper = vtkMapper.newInstance();\n  publicAPI.setMapper(_mapper);\n  publicAPI.update = () => {\n    let currentConfig = {\n      ...model.config,\n      ...model.xConfig\n    };\n    const xAxis = vtkArrowSource.newInstance({\n      direction: [1, 0, 0],\n      ...currentConfig\n    }).getOutputData();\n    if (model.config.recenter) {\n      centerDataSet(xAxis);\n    } else {\n      shiftDataset(xAxis, 0, currentConfig.invert);\n    }\n    addColor(xAxis, ...currentConfig.color);\n    currentConfig = {\n      ...model.config,\n      ...model.yConfig\n    };\n    const yAxis = vtkArrowSource.newInstance({\n      direction: [0, 1, 0],\n      ...currentConfig\n    }).getOutputData();\n    if (model.config.recenter) {\n      centerDataSet(yAxis);\n    } else {\n      shiftDataset(yAxis, 1, currentConfig.invert);\n    }\n    addColor(yAxis, ...currentConfig.color);\n    currentConfig = {\n      ...model.config,\n      ...model.zConfig\n    };\n    const zAxis = vtkArrowSource.newInstance({\n      direction: [0, 0, 1],\n      ...currentConfig\n    }).getOutputData();\n    if (model.config.recenter) {\n      centerDataSet(zAxis);\n    } else {\n      shiftDataset(zAxis, 2, currentConfig.invert);\n    }\n    addColor(zAxis, ...currentConfig.color);\n    const source = vtkAppendPolyData.newInstance();\n    source.setInputData(xAxis);\n    source.addInputData(yAxis);\n    source.addInputData(zAxis);\n    _mapper.setInputConnection(source.getOutputPort());\n  };\n  publicAPI.update();\n  const _debouncedUpdate = macro.debounce(publicAPI.update, 0);\n  publicAPI.setXAxisColor = color => publicAPI.setXConfig({\n    ...publicAPI.getXConfig(),\n    color\n  });\n  publicAPI.setYAxisColor = color => publicAPI.setYConfig({\n    ...publicAPI.getYConfig(),\n    color\n  });\n  publicAPI.setZAxisColor = color => publicAPI.setZConfig({\n    ...publicAPI.getZConfig(),\n    color\n  });\n  publicAPI.getXAxisColor = () => model.getXConfig().color;\n  publicAPI.getYAxisColor = () => model.getYConfig().color;\n  publicAPI.getZAxisColor = () => model.getZConfig().color;\n  model._onConfigChanged = _debouncedUpdate;\n  model._onXConfigChanged = _debouncedUpdate;\n  model._onYConfigChanged = _debouncedUpdate;\n  model._onZConfigChanged = _debouncedUpdate;\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nfunction defaultValues(initialValues) {\n  return {\n    config: {\n      recenter: true,\n      tipResolution: 60,\n      tipRadius: 0.1,\n      tipLength: 0.2,\n      shaftResolution: 60,\n      shaftRadius: 0.03,\n      invert: false,\n      ...initialValues?.config\n    },\n    xConfig: {\n      color: [255, 0, 0],\n      invert: false,\n      ...initialValues?.xConfig\n    },\n    yConfig: {\n      color: [255, 255, 0],\n      invert: false,\n      ...initialValues?.yConfig\n    },\n    zConfig: {\n      color: [0, 128, 0],\n      invert: false,\n      ...initialValues?.zConfig\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // Inheritance\n  vtkActor.extend(publicAPI, model, defaultValues(initialValues));\n  macro.setGet(publicAPI, model, ['config', 'xConfig', 'yConfig', 'zConfig']);\n\n  // Object methods\n  vtkAxesActor(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkAxesActor');\n\n// ----------------------------------------------------------------------------\n\nvar vtkAxesActor$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkAxesActor$1 as default, extend, newInstance };\n", "import vtkOrientationMarkerWidget from '@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget';\nimport vtkAnnotatedCubeActor from '@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor';\nimport vtkAxesActor from '@kitware/vtk.js/Rendering/Core/AxesActor';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkXMLPolyDataReader from '@kitware/vtk.js/IO/XML/XMLPolyDataReader';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport { BaseTool } from './base';\nimport { Enums, eventTarget, getEnabledElementByIds, getRenderingEngines, } from '@cornerstonejs/core';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport { Events } from '../enums';\nvar OverlayMarkerType;\n(function (OverlayMarkerType) {\n    OverlayMarkerType[OverlayMarkerType[\"ANNOTATED_CUBE\"] = 1] = \"ANNOTATED_CUBE\";\n    OverlayMarkerType[OverlayMarkerType[\"AXES\"] = 2] = \"AXES\";\n    OverlayMarkerType[OverlayMarkerType[\"CUSTOM\"] = 3] = \"CUSTOM\";\n})(OverlayMarkerType || (OverlayMarkerType = {}));\nclass OrientationMarkerTool extends BaseTool {\n    static { this.CUBE = 1; }\n    static { this.AXIS = 2; }\n    static { this.VTPFILE = 3; }\n    static { this.OVERLAY_MARKER_TYPES = OverlayMarkerType; }\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            orientationWidget: {\n                enabled: true,\n                viewportCorner: vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT,\n                viewportSize: 0.15,\n                minPixelSize: 100,\n                maxPixelSize: 300,\n            },\n            overlayMarkerType: OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE,\n            overlayConfiguration: {\n                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE]: {\n                    faceProperties: {\n                        xPlus: { text: 'L', faceColor: '#ffff00', faceRotation: 90 },\n                        xMinus: { text: 'R', faceColor: '#ffff00', faceRotation: 270 },\n                        yPlus: {\n                            text: 'P',\n                            faceColor: '#00ffff',\n                            fontColor: 'white',\n                            faceRotation: 180,\n                        },\n                        yMinus: { text: 'A', faceColor: '#00ffff', fontColor: 'white' },\n                        zPlus: { text: 'S' },\n                        zMinus: { text: 'I' },\n                    },\n                    defaultStyle: {\n                        fontStyle: 'bold',\n                        fontFamily: 'Arial',\n                        fontColor: 'black',\n                        fontSizeScale: (res) => res / 2,\n                        faceColor: '#0000ff',\n                        edgeThickness: 0.1,\n                        edgeColor: 'black',\n                        resolution: 400,\n                    },\n                },\n                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.AXES]: {},\n                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.CUSTOM]: {\n                    polyDataURL: 'https://raw.githubusercontent.com/Slicer/Slicer/80ad0a04dacf134754459557bf2638c63f3d1d1b/Base/Logic/Resources/OrientationMarkers/Human.vtp',\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._resizeObservers = new Map();\n        this.onSetToolEnabled = () => {\n            this.initViewports();\n            this._subscribeToViewportEvents();\n        };\n        this.onSetToolActive = () => {\n            this.initViewports();\n            this._subscribeToViewportEvents();\n        };\n        this.onSetToolDisabled = () => {\n            this.cleanUpData();\n            this._unsubscribeToViewportNewVolumeSet();\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this.resize = (viewportId) => {\n            const orientationMarker = this.orientationMarkers[viewportId];\n            if (!orientationMarker) {\n                return;\n            }\n            const { orientationWidget } = orientationMarker;\n            orientationWidget.updateViewport();\n        };\n        this.orientationMarkers = {};\n        this.updatingOrientationMarker = {};\n    }\n    _unsubscribeToViewportNewVolumeSet() {\n        const unsubscribe = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n                const { element } = viewport;\n                element.removeEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this.initViewports.bind(this));\n                const resizeObserver = this._resizeObservers.get(viewportId);\n                resizeObserver.unobserve(element);\n            });\n        };\n        eventTarget.removeEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {\n            if (evt.detail.toolGroupId !== this.toolGroupId) {\n                return;\n            }\n            unsubscribe();\n            this.initViewports();\n        });\n    }\n    _subscribeToViewportEvents() {\n        const subscribeToElementResize = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n                const { element } = viewport;\n                this.initViewports();\n                element.addEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this.initViewports.bind(this));\n                const resizeObserver = new ResizeObserver(() => {\n                    setTimeout(() => {\n                        const element = getEnabledElementByIds(viewportId, renderingEngineId);\n                        if (!element) {\n                            return;\n                        }\n                        const { viewport } = element;\n                        this.resize(viewportId);\n                        viewport.render();\n                    }, 100);\n                });\n                resizeObserver.observe(element);\n                this._resizeObservers.set(viewportId, resizeObserver);\n            });\n        };\n        subscribeToElementResize();\n        eventTarget.addEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {\n            if (evt.detail.toolGroupId !== this.toolGroupId) {\n                return;\n            }\n            subscribeToElementResize();\n            this.initViewports();\n        });\n    }\n    cleanUpData() {\n        const renderingEngines = getRenderingEngines();\n        const renderingEngine = renderingEngines[0];\n        const viewports = renderingEngine.getViewports();\n        viewports.forEach((viewport) => {\n            const orientationMarker = this.orientationMarkers[viewport.id];\n            if (!orientationMarker) {\n                return;\n            }\n            const { actor, orientationWidget } = orientationMarker;\n            orientationWidget?.setEnabled(false);\n            orientationWidget?.delete();\n            actor?.delete();\n            const renderWindow = viewport\n                .getRenderingEngine()\n                .getOffscreenMultiRenderWindow(viewport.id)\n                .getRenderWindow();\n            renderWindow.render();\n            viewport.getRenderingEngine().render();\n            delete this.orientationMarkers[viewport.id];\n        });\n    }\n    initViewports() {\n        const renderingEngines = getRenderingEngines();\n        const renderingEngine = renderingEngines[0];\n        if (!renderingEngine) {\n            return;\n        }\n        let viewports = renderingEngine.getViewports();\n        viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n        viewports.forEach((viewport) => {\n            const widget = viewport.getWidget(this.getToolName());\n            if (!widget || widget.isDeleted()) {\n                this.addAxisActorInViewport(viewport);\n            }\n        });\n    }\n    async addAxisActorInViewport(viewport) {\n        const viewportId = viewport.id;\n        if (!this.updatingOrientationMarker[viewportId]) {\n            this.updatingOrientationMarker[viewportId] = true;\n            const type = this.configuration.overlayMarkerType;\n            const overlayConfiguration = this.configuration.overlayConfiguration[type];\n            if (this.orientationMarkers[viewportId]) {\n                const { actor, orientationWidget } = this.orientationMarkers[viewportId];\n                viewport.getRenderer().removeActor(actor);\n                orientationWidget.setEnabled(false);\n            }\n            let actor;\n            if (type === 1) {\n                actor = this.createAnnotationCube(overlayConfiguration);\n            }\n            else if (type === 2) {\n                actor = vtkAxesActor.newInstance();\n            }\n            else if (type === 3) {\n                actor = await this.createCustomActor();\n            }\n            const renderer = viewport.getRenderer();\n            const renderWindow = viewport\n                .getRenderingEngine()\n                .getOffscreenMultiRenderWindow(viewportId)\n                .getRenderWindow();\n            const { enabled, viewportCorner, viewportSize, minPixelSize, maxPixelSize, } = this.configuration.orientationWidget;\n            const orientationWidget = vtkOrientationMarkerWidget.newInstance({\n                actor,\n                interactor: renderWindow.getInteractor(),\n                parentRenderer: renderer,\n            });\n            orientationWidget.setEnabled(enabled);\n            orientationWidget.setViewportCorner(viewportCorner);\n            orientationWidget.setViewportSize(viewportSize);\n            orientationWidget.setMinPixelSize(minPixelSize);\n            orientationWidget.setMaxPixelSize(maxPixelSize);\n            orientationWidget.updateMarkerOrientation();\n            this.orientationMarkers[viewportId] = {\n                orientationWidget,\n                actor,\n            };\n            viewport.addWidget(this.getToolName(), orientationWidget);\n            renderWindow.render();\n            viewport.getRenderingEngine().render();\n            this.updatingOrientationMarker[viewportId] = false;\n        }\n    }\n    async createCustomActor() {\n        const url = this.configuration.overlayConfiguration[OverlayMarkerType.CUSTOM]\n            .polyDataURL;\n        const response = await fetch(url);\n        const arrayBuffer = await response.arrayBuffer();\n        const vtpReader = vtkXMLPolyDataReader.newInstance();\n        vtpReader.parseAsArrayBuffer(arrayBuffer);\n        vtpReader.update();\n        const polyData = vtkPolyData.newInstance();\n        polyData.shallowCopy(vtpReader.getOutputData());\n        polyData.getPointData().setActiveScalars('Color');\n        const mapper = vtkMapper.newInstance();\n        mapper.setInputData(polyData);\n        mapper.setColorModeToDirectScalars();\n        const actor = vtkActor.newInstance();\n        actor.setMapper(mapper);\n        actor.rotateZ(180);\n        return actor;\n    }\n    createAnnotationCube(overlayConfiguration) {\n        const actor = vtkAnnotatedCubeActor.newInstance();\n        actor.setDefaultStyle({ ...overlayConfiguration.defaultStyle });\n        actor.setXPlusFaceProperty({\n            ...overlayConfiguration.faceProperties.xPlus,\n        });\n        actor.setXMinusFaceProperty({\n            ...overlayConfiguration.faceProperties.xMinus,\n        });\n        actor.setYPlusFaceProperty({\n            ...overlayConfiguration.faceProperties.yPlus,\n        });\n        actor.setYMinusFaceProperty({\n            ...overlayConfiguration.faceProperties.yMinus,\n        });\n        actor.setZPlusFaceProperty({\n            ...overlayConfiguration.faceProperties.zPlus,\n        });\n        actor.setZMinusFaceProperty({\n            ...overlayConfiguration.faceProperties.zMinus,\n        });\n        return actor;\n    }\n    async createAnnotatedCubeActor() {\n        const axes = vtkAnnotatedCubeActor.newInstance();\n        const { faceProperties, defaultStyle } = this.configuration.annotatedCube;\n        axes.setDefaultStyle(defaultStyle);\n        Object.keys(faceProperties).forEach((key) => {\n            const methodName = `set${key.charAt(0).toUpperCase() + key.slice(1)}FaceProperty`;\n            axes[methodName](faceProperties[key]);\n        });\n        return axes;\n    }\n}\nOrientationMarkerTool.toolName = 'OrientationMarker';\nexport default OrientationMarkerTool;\n", "import { getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { triggerSegmentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/activeSegmentation';\nimport { setActiveSegmentIndex } from '../../stateManagement/segmentation/segmentIndex';\nimport { getHoveredContourSegmentationAnnotation, getSegmentIndexAtLabelmapBorder, getSegmentIndexAtWorldPoint, } from '../../utilities/segmentation';\nimport { state } from '../../store/state';\nimport { ToolModes } from '../../enums';\nclass SegmentSelectTool extends BaseTool {\n    static { this.SelectMode = {\n        Inside: 'Inside',\n        Border: 'Border',\n    }; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            hoverTimeout: 100,\n            mode: SegmentSelectTool.SelectMode.Border,\n            searchRadius: 6,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.mouseMoveCallback = (evt) => {\n            if (this.mode !== ToolModes.Active) {\n                return;\n            }\n            if (this.hoverTimer) {\n                clearTimeout(this.hoverTimer);\n            }\n            this.hoverTimer = setTimeout(() => {\n                this._setActiveSegment(evt);\n                this.hoverTimer = null;\n            }, this.configuration.hoverTimeout);\n            return true;\n        };\n        this.onSetToolEnabled = () => {\n            this.onSetToolActive();\n        };\n        this.onSetToolActive = () => {\n            this.hoverTimer = null;\n        };\n        this.onSetToolDisabled = () => {\n            this.hoverTimer = null;\n        };\n        this.hoverTimer = null;\n    }\n    _setActiveSegment(evt = {}) {\n        if (state.isInteractingWithTool) {\n            return;\n        }\n        const { element, currentPoints } = evt.detail;\n        const worldPoint = currentPoints.world;\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const activeSegmentation = getActiveSegmentation(viewport.id);\n        if (!activeSegmentation) {\n            return;\n        }\n        this._setActiveSegmentForType(activeSegmentation, worldPoint, viewport);\n    }\n    _setActiveSegmentForType(activeSegmentation, worldPoint, viewport) {\n        const imageDataInfo = viewport.getImageData();\n        if (!imageDataInfo) {\n            return;\n        }\n        const { segmentationId, representationData } = activeSegmentation;\n        let hoveredSegmentIndex;\n        if (this.configuration.mode === SegmentSelectTool.SelectMode.Inside) {\n            hoveredSegmentIndex = getSegmentIndexAtWorldPoint(segmentationId, worldPoint, {\n                viewport,\n            });\n        }\n        else {\n            if (representationData.Labelmap) {\n                hoveredSegmentIndex = getSegmentIndexAtLabelmapBorder(segmentationId, worldPoint, {\n                    viewport,\n                    searchRadius: this.configuration.searchRadius,\n                });\n            }\n            else if (representationData.Contour) {\n                hoveredSegmentIndex =\n                    getHoveredContourSegmentationAnnotation(segmentationId);\n            }\n            else if (representationData.Surface) {\n            }\n        }\n        if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {\n            return;\n        }\n        setActiveSegmentIndex(segmentationId, hoveredSegmentIndex);\n        const renderingEngine = viewport.getRenderingEngine();\n        const viewportIds = renderingEngine.getViewports().map((v) => v.id);\n        triggerSegmentationModified(segmentationId);\n        triggerAnnotationRenderForViewportIds(viewportIds);\n    }\n}\nSegmentSelectTool.toolName = 'SegmentSelectTool';\nexport default SegmentSelectTool;\n", "import { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, utilities, } from '@cornerstonejs/core';\nimport { addAnnotation, getAllAnnotations, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { drawLine as drawLineSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport BidirectionalTool from '../annotation/BidirectionalTool';\nimport { getSegmentIndexColor } from '../../stateManagement/segmentation/config/segmentationColor';\nclass SegmentBidirectionalTool extends BidirectionalTool {\n    static { this.toolName = 'SegmentBidirectional'; }\n    constructor(toolProps = {}) {\n        super(toolProps);\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = true;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            const viewportId = viewport.id;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { segmentIndex, segmentationId } = annotation.metadata;\n                const { lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const colorArray = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n                const color = `rgb(${colorArray.slice(0, 3).join(',')})`;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        width: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId1 = `${annotationUID}-line-1`;\n                const dataId2 = `${annotationUID}-line-2`;\n                const lineUID = '0';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId1);\n                const secondLineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, secondLineUID, canvasCoordinates[2], canvasCoordinates[3], {\n                    color,\n                    lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId2);\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                options.color = color;\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const worldPos = currentPoints.world;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        this.isDrawing = true;\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, viewUp } = camera;\n        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const annotation = {\n            highlighted: true,\n            invalidated: true,\n            metadata: {\n                toolName: this.getToolName(),\n                viewPlaneNormal: [...viewPlaneNormal],\n                viewUp: [...viewUp],\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...viewport.getViewReference({ points: [worldPos] }),\n            },\n            data: {\n                handles: {\n                    points: [\n                        [...worldPos],\n                        [...worldPos],\n                        [...worldPos],\n                        [...worldPos],\n                    ],\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n        };\n        addAnnotation(annotation, element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex: 1,\n            movingTextBox: false,\n            newAnnotation: true,\n            hasMoved: false,\n        };\n        this._activateDraw(element);\n        hideElementCursor(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        return annotation;\n    }\n    static { this.hydrate = (viewportId, axis, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const existingAnnotations = getAllAnnotations();\n        const toolAnnotations = existingAnnotations.filter((annotation) => annotation.metadata.toolName === 'SegmentBidirectional');\n        const existingAnnotation = toolAnnotations.find((annotation) => {\n            const { metadata } = annotation;\n            if (metadata.segmentIndex === options?.segmentIndex &&\n                metadata.segmentationId === options?.segmentationId) {\n                return true;\n            }\n            return false;\n        });\n        if (existingAnnotation) {\n            removeAnnotation(existingAnnotation.annotationUID);\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, } = this.hydrateBase(SegmentBidirectionalTool, enabledElement, axis[0], options);\n        const [majorAxis, minorAxis] = axis;\n        const [major0, major1] = majorAxis;\n        const [minor0, minor1] = minorAxis;\n        const points = [major0, major1, minor0, minor1];\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    activeHandleIndex: null,\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                },\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                segmentIndex: options?.segmentIndex,\n                segmentationId: options?.segmentationId,\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n        return annotation;\n    }; }\n}\nexport default SegmentBidirectionalTool;\n", "import { getEnabledElement } from '@cornerstonejs/core';\nimport { config as segmentationConfig } from '../../stateManagement/segmentation';\nimport { BaseTool } from '../base';\nimport { triggerSegmentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/activeSegmentation';\nimport { getSegmentIndexAtWorldPoint } from '../../utilities/segmentation';\nimport { state } from '../../store/state';\nimport { drawTextBox as drawTextBoxSvg } from '../../drawingSvg';\nclass SegmentLabelTool extends BaseTool {\n    constructor(toolProps = {\n        data: {\n            handles: {\n                textBox: {\n                    worldPosition: [0, 0, 0],\n                    worldBoundingBox: {\n                        topLeft: [0, 0, 0],\n                        topRight: [0, 0, 0],\n                        bottomLeft: [0, 0, 0],\n                        bottomRight: [0, 0, 0],\n                    },\n                },\n            },\n        },\n    }, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            hoverTimeout: 100,\n            searchRadius: 6,\n            color: null,\n            background: null,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.mouseMoveCallback = (evt) => {\n            if (this.hoverTimer) {\n                clearTimeout(this.hoverTimer);\n            }\n            this.hoverTimer = setTimeout(() => {\n                this._setHoveredSegment(evt);\n                this.hoverTimer = null;\n            }, this.configuration.hoverTimeout);\n            return true;\n        };\n        this.onSetToolEnabled = () => {\n            this.onSetToolActive();\n        };\n        this.onSetToolActive = () => {\n            this.hoverTimer = null;\n        };\n        this.onSetToolDisabled = () => {\n            this.hoverTimer = null;\n        };\n        this.data = toolProps.data ?? {\n            handles: {\n                textBox: {\n                    worldPosition: [0, 0, 0],\n                    worldBoundingBox: {\n                        topLeft: [0, 0, 0],\n                        topRight: [0, 0, 0],\n                        bottomLeft: [0, 0, 0],\n                        bottomRight: [0, 0, 0],\n                    },\n                },\n            },\n        };\n        this.hoverTimer = null;\n    }\n    _setHoveredSegment(evt = {}) {\n        if (state.isInteractingWithTool) {\n            return;\n        }\n        const { element, currentPoints } = evt.detail;\n        const worldPoint = currentPoints.world;\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const activeSegmentation = getActiveSegmentation(viewport.id);\n        if (!activeSegmentation) {\n            return;\n        }\n        this._setHoveredSegmentForType(activeSegmentation, worldPoint, viewport);\n    }\n    _setHoveredSegmentForType(activeSegmentation, worldPoint, viewport) {\n        const imageDataInfo = viewport.getImageData();\n        if (!imageDataInfo) {\n            return;\n        }\n        const { segmentationId } = activeSegmentation;\n        const hoveredSegmentIndex = getSegmentIndexAtWorldPoint(segmentationId, worldPoint, {\n            viewport,\n        });\n        const segment = activeSegmentation.segments[hoveredSegmentIndex];\n        const color = this.configuration.color ??\n            segmentationConfig.color.getSegmentIndexColor(viewport.id, segmentationId, hoveredSegmentIndex);\n        const label = segment?.label;\n        const canvasCoordinates = viewport.worldToCanvas(worldPoint);\n        this._editData = {\n            hoveredSegmentIndex,\n            hoveredSegmentLabel: label,\n            canvasCoordinates,\n            color,\n        };\n        if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {\n            return;\n        }\n        const renderingEngine = viewport.getRenderingEngine();\n        const viewportIds = renderingEngine.getViewports().map((v) => v.id);\n        triggerSegmentationModified(segmentationId);\n        triggerAnnotationRenderForViewportIds(viewportIds);\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this._editData) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const { hoveredSegmentIndex, hoveredSegmentLabel, canvasCoordinates, color, } = this._editData;\n        if (!hoveredSegmentIndex) {\n            return;\n        }\n        const offset = -15;\n        const textBoxPosition = [\n            canvasCoordinates[0] + offset,\n            canvasCoordinates[1] + offset,\n        ];\n        const boundingBox = drawTextBoxSvg(svgDrawingHelper, 'segmentSelectLabelAnnotation', 'segmentSelectLabelTextBox', [hoveredSegmentLabel ?? '(unnamed segment)'], textBoxPosition, {\n            color: `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3]})`,\n            background: this.configuration.background ?? undefined,\n        });\n        const left = canvasCoordinates[0];\n        const top = canvasCoordinates[1];\n        const { width, height } = boundingBox;\n        this.data.handles.textBox.worldBoundingBox = {\n            topLeft: viewport.canvasToWorld([left, top]),\n            topRight: viewport.canvasToWorld([left + width, top]),\n            bottomLeft: viewport.canvasToWorld([left, top + height]),\n            bottomRight: viewport.canvasToWorld([left + width, top + height]),\n        };\n    }\n}\nSegmentLabelTool.toolName = 'SegmentLabelTool';\nexport default SegmentLabelTool;\n", "import { Events, SegmentationRepresentations } from '../../enums';\nimport { eventTarget, utilities, getRenderingEngine, } from '@cornerstonejs/core';\nimport PlanarFreehandContourSegmentationTool from '../annotation/PlanarFreehandContourSegmentationTool';\nimport BrushTool from './BrushTool';\nimport * as segmentation from '../../stateManagement/segmentation';\nimport { getSegmentationRepresentationsBySegmentationId } from '../../stateManagement/segmentation/getSegmentationRepresentation';\nclass LabelMapEditWithContourTool extends PlanarFreehandContourSegmentationTool {\n    static { this.toolName = 'LabelMapEditWithContour'; }\n    static { this.annotationsToViewportMap = new Map(); }\n    static { this.viewportIdsChecked = []; }\n    constructor(toolProps = {}) {\n        const initialProps = utilities.deepMerge({\n            configuration: {\n                calculateStats: false,\n                allowOpenContours: false,\n            },\n        }, toolProps);\n        super(initialProps);\n        this.onViewportAddedToToolGroupBinded =\n            this.onViewportAddedToToolGroup.bind(this);\n        this.onSegmentationModifiedBinded = this.onSegmentationModified.bind(this);\n    }\n    initializeListeners() {\n        LabelMapEditWithContourTool.annotationsToViewportMap.clear();\n        LabelMapEditWithContourTool.viewportIdsChecked = [];\n        eventTarget.addEventListener(Events.ANNOTATION_MODIFIED, this.annotationModified);\n        eventTarget.addEventListener(Events.ANNOTATION_COMPLETED, this.annotationCompleted);\n        eventTarget.addEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this.onViewportAddedToToolGroupBinded);\n        eventTarget.addEventListener(Events.SEGMENTATION_MODIFIED, this.onSegmentationModifiedBinded);\n        eventTarget.addEventListener(Events.SEGMENTATION_REPRESENTATION_MODIFIED, this.onSegmentationModifiedBinded);\n    }\n    cleanUpListeners() {\n        LabelMapEditWithContourTool.annotationsToViewportMap.clear();\n        LabelMapEditWithContourTool.viewportIdsChecked = [];\n        eventTarget.removeEventListener(Events.ANNOTATION_MODIFIED, this.annotationModified);\n        eventTarget.removeEventListener(Events.ANNOTATION_COMPLETED, this.annotationCompleted);\n        eventTarget.removeEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this.onViewportAddedToToolGroup.bind(this));\n        eventTarget.removeEventListener(Events.SEGMENTATION_MODIFIED, this.onSegmentationModified.bind(this));\n        eventTarget.removeEventListener(Events.SEGMENTATION_REPRESENTATION_MODIFIED, this.onSegmentationModified.bind(this));\n    }\n    async checkContourSegmentation(viewportId) {\n        if (LabelMapEditWithContourTool.viewportIdsChecked.includes(viewportId)) {\n            return;\n        }\n        const activeSeg = segmentation.getActiveSegmentation(viewportId);\n        if (!activeSeg) {\n            console.log('No active segmentation detected');\n            return false;\n        }\n        const segmentationId = activeSeg.segmentationId;\n        if (!activeSeg.representationData.Contour) {\n            LabelMapEditWithContourTool.viewportIdsChecked.push(viewportId);\n            await segmentation.addContourRepresentationToViewport(viewportId, [\n                {\n                    segmentationId,\n                    type: SegmentationRepresentations.Contour,\n                },\n            ]);\n            segmentation.addRepresentationData({\n                segmentationId,\n                type: SegmentationRepresentations.Contour,\n                data: {},\n            });\n        }\n        else {\n            LabelMapEditWithContourTool.viewportIdsChecked.push(viewportId);\n        }\n        return true;\n    }\n    onViewportAddedToToolGroup(evt) {\n        const { toolGroupId, viewportId } = evt.detail;\n        if (toolGroupId !== this.toolGroupId) {\n            return;\n        }\n        this.checkContourSegmentation(viewportId);\n    }\n    onSegmentationModified(evt) {\n        const { segmentationId } = evt.detail || {};\n        if (!segmentationId) {\n            return;\n        }\n        const representations = getSegmentationRepresentationsBySegmentationId(segmentationId);\n        if (!representations) {\n            return;\n        }\n        representations.forEach(async ({ viewportId }) => await this.checkContourSegmentation(viewportId));\n    }\n    onSetToolEnabled() {\n        this.initializeListeners();\n    }\n    onSetToolActive() {\n        this.initializeListeners();\n    }\n    onSetToolDisabled() {\n        this.cleanUpListeners();\n    }\n    annotationModified(evt) {\n        const { annotation, renderingEngineId, viewportId } = evt.detail;\n        const viewport = getRenderingEngine(renderingEngineId)?.getViewport(viewportId);\n        if (!viewport) {\n            return;\n        }\n        LabelMapEditWithContourTool.annotationsToViewportMap.set(annotation.annotationUID, viewport);\n    }\n    annotationCompleted(evt) {\n        const { annotation } = evt.detail;\n        const { polyline } = annotation.data?.contour || {};\n        if (annotation?.metadata?.toolName !== LabelMapEditWithContourTool.toolName) {\n            return;\n        }\n        if (!polyline) {\n            return;\n        }\n        if (LabelMapEditWithContourTool.annotationsToViewportMap.has(annotation.annotationUID)) {\n            const viewport = LabelMapEditWithContourTool.annotationsToViewportMap.get(annotation.annotationUID);\n            if (polyline.length > 3) {\n                BrushTool.viewportContoursToLabelmap(viewport);\n            }\n        }\n    }\n}\nexport default LabelMapEditWithContourTool;\n", "import { vec3, vec2 } from 'gl-matrix';\nimport { getEnabledElement, triggerEvent, eventTarget, utilities as csUtils, cache, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement';\nimport { drawHandles as drawHandlesSvg, drawRedactionRect as drawRedactionRectSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nclass VideoRedactionTool extends AnnotationTool {\n    static { this.toolName = 'VideoRedaction'; }\n    constructor(toolConfiguration = {}) {\n        super(toolConfiguration, {\n            supportedInteractionTypes: ['Mouse', 'Touch'],\n            configuration: { shadow: true, preventHandleOutsideImage: false },\n        });\n        this.addNewAnnotation = (evt) => {\n            const eventData = evt.detail;\n            const { currentPoints, element } = eventData;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const annotation = (this.constructor).createAnnotationForViewport(viewport, {\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                    },\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportUIDsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            this.editData = {\n                annotation,\n                viewportUIDsToRender,\n                handleIndex: 3,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n            return annotation;\n        };\n        this.getHandleNearImagePoint = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            for (let i = 0; i < points.length; i++) {\n                const point = points[i];\n                const toolDataCanvasCoordinate = viewport.worldToCanvas(point);\n                const near = vec2.distance(canvasCoords, toolDataCanvasCoordinate) < proximity;\n                if (near === true) {\n                    data.handles.activeHandleIndex = i;\n                    return point;\n                }\n            }\n            data.handles.activeHandleIndex = null;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasPoint1 = viewport.worldToCanvas(points[0]);\n            const canvasPoint2 = viewport.worldToCanvas(points[3]);\n            const rect = this._getRectangleImageCoordinates([\n                canvasPoint1,\n                canvasPoint2,\n            ]);\n            const point = [canvasCoords[0], canvasCoords[1]];\n            const { left, top, width, height } = rect;\n            const distanceToPoint = rectangle.distanceToPoint([left, top, width, height], point);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType = 'mouse') => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { data } = annotation;\n            data.active = true;\n            const viewportUIDsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            this.editData = {\n                annotation,\n                viewportUIDsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle, interactionType = 'mouse') => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { data } = annotation;\n            data.active = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                handleIndex = data.handles.points.findIndex((p) => p === handle);\n            }\n            const viewportUIDsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            this.editData = {\n                annotation,\n                viewportUIDsToRender,\n                handleIndex,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { annotation, viewportUIDsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            data.active = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { annotation, viewportUIDsToRender, handleIndex, newAnnotation } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (handleIndex === undefined) {\n                const { deltaPoints } = eventData;\n                const worldPosDelta = deltaPoints.world;\n                const { points } = data.handles;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                data.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventData;\n                const enabledElement = getEnabledElement(element);\n                const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n                const worldPos = currentPoints.world;\n                const { points } = data.handles;\n                points[handleIndex] = [...worldPos];\n                let bottomLeftCanvas;\n                let bottomRightCanvas;\n                let topLeftCanvas;\n                let topRightCanvas;\n                let bottomLeftWorld;\n                let bottomRightWorld;\n                let topLeftWorld;\n                let topRightWorld;\n                switch (handleIndex) {\n                    case 0:\n                    case 3:\n                        bottomLeftCanvas = worldToCanvas(points[0]);\n                        topRightCanvas = worldToCanvas(points[3]);\n                        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n                        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n                        bottomRightWorld = canvasToWorld(bottomRightCanvas);\n                        topLeftWorld = canvasToWorld(topLeftCanvas);\n                        points[1] = bottomRightWorld;\n                        points[2] = topLeftWorld;\n                        break;\n                    case 1:\n                    case 2:\n                        bottomRightCanvas = worldToCanvas(points[1]);\n                        topLeftCanvas = worldToCanvas(points[2]);\n                        bottomLeftCanvas = [\n                            topLeftCanvas[0],\n                            bottomRightCanvas[1],\n                        ];\n                        topRightCanvas = [\n                            bottomRightCanvas[0],\n                            topLeftCanvas[1],\n                        ];\n                        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n                        topRightWorld = canvasToWorld(topRightCanvas);\n                        points[0] = bottomLeftWorld;\n                        points[3] = topRightWorld;\n                        break;\n                }\n                data.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID } = annotation;\n                const data = annotation.data;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return;\n                }\n                let activeHandleCanvasCoords;\n                if (!this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const rectangleUID = '0';\n                drawRedactionRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                    color: 'black',\n                    lineDash,\n                    lineWidth,\n                });\n            }\n        };\n        this._getRectangleImageCoordinates = (points) => {\n            const [point0, point1] = points;\n            return {\n                left: Math.min(point0[0], point1[0]),\n                top: Math.min(point0[1], point1[1]),\n                width: Math.abs(point0[0] - point1[0]),\n                height: Math.abs(point0[1] - point1[1]),\n            };\n        };\n        this._calculateCachedStats = (annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { viewportUID, renderingEngineUID, sceneUID } = enabledElement;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[3];\n            const { cachedStats } = data;\n            const targetUIDs = Object.keys(cachedStats);\n            for (let i = 0; i < targetUIDs.length; i++) {\n                const targetUID = targetUIDs[i];\n                const { imageVolume } = this._getImageVolumeFromTargetUID(targetUID, renderingEngine);\n                const { dimensions, scalarData, vtkImageData: imageData, metadata, } = imageVolume;\n                const worldPos1Index = vec3.fromValues(0, 0, 0);\n                const worldPos2Index = vec3.fromValues(0, 0, 0);\n                imageData.worldToIndexVec3(worldPos1, worldPos1Index);\n                worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n                worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n                worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n                imageData.worldToIndexVec3(worldPos2, worldPos2Index);\n                worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n                worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n                worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n                if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n                    this.isHandleOutsideImage = false;\n                    const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n                    const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n                    const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n                    const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n                    const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n                    const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const area = worldWidth * worldHeight;\n                    let count = 0;\n                    let mean = 0;\n                    let stdDev = 0;\n                    const yMultiple = dimensions[0];\n                    const zMultiple = dimensions[0] * dimensions[1];\n                    for (let k = kMin; k <= kMax; k++) {\n                        for (let j = jMin; j <= jMax; j++) {\n                            for (let i = iMin; i <= iMax; i++) {\n                                const value = scalarData[k * zMultiple + j * yMultiple + i];\n                                count++;\n                                mean += value;\n                            }\n                        }\n                    }\n                    mean /= count;\n                    for (let k = kMin; k <= kMax; k++) {\n                        for (let j = jMin; j <= jMax; j++) {\n                            for (let i = iMin; i <= iMax; i++) {\n                                const value = scalarData[k * zMultiple + j * yMultiple + i];\n                                const valueMinusMean = value - mean;\n                                stdDev += valueMinusMean * valueMinusMean;\n                            }\n                        }\n                    }\n                    stdDev /= count;\n                    stdDev = Math.sqrt(stdDev);\n                    cachedStats[targetUID] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean,\n                        stdDev,\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetUID] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                const eventType = Events.ANNOTATION_MODIFIED;\n                const eventDetail = {\n                    annotation,\n                    viewportUID,\n                    renderingEngineUID,\n                    sceneUID: sceneUID,\n                    changeType: ChangeTypes.StatsUpdated,\n                };\n                triggerEvent(eventTarget, eventType, eventDetail);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._getTargetVolumeUID = (scene) => {\n            if (this.configuration.volumeUID) {\n                return this.configuration.volumeUID;\n            }\n            const volumeActors = scene.getVolumeActors();\n            if (!volumeActors && !volumeActors.length) {\n                return;\n            }\n            return volumeActors[0].uid;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    cancel(element) {\n        if (!this.isDrawing) {\n            return;\n        }\n        this.isDrawing = false;\n        this._deactivateDraw(element);\n        this._deactivateModify(element);\n        resetElementCursor(element);\n        const { annotation, viewportUIDsToRender } = this.editData;\n        const { data } = annotation;\n        data.active = false;\n        data.handles.activeHandleIndex = null;\n        triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n        this.editData = null;\n        return annotation.annotationUID;\n    }\n    _getImageVolumeFromTargetUID(targetUID, renderingEngine) {\n        let imageVolume, viewport;\n        if (targetUID.startsWith('stackTarget')) {\n            const coloneIndex = targetUID.indexOf(':');\n            const viewportUID = targetUID.substring(coloneIndex + 1);\n            const viewport = renderingEngine.getViewport(viewportUID);\n            imageVolume = viewport.getImageData();\n        }\n        else {\n            imageVolume = cache.getVolume(targetUID);\n        }\n        return { imageVolume, viewport };\n    }\n    _getTargetStackUID(viewport) {\n        return `stackTarget:${viewport.uid}`;\n    }\n}\nexport default VideoRedactionTool;\n"],
  "mappings": "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G;AAAA,EAClB,CAAC,IAAI,IAAI,KAAK,GAAG;AAAA,EACjB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,IAAI,KAAK,GAAG;AAAA,EACjB,CAAC,KAAK,IAAI,IAAI,GAAG;AAAA,EACjB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,IAAI,GAAG;AAAA,EACjB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,IAAI,GAAG;AAAA,EACjB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,IAAI,KAAK,GAAG;AAAA,EACjB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,IAAI,GAAG;AAAA,EACjB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,IAAI,GAAG;AAAA,EACjB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,IAAI,GAAG;AAAA,EACjB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,IAAI,GAAG;AAAA,EACjB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,IAAI,KAAK,GAAG;AAAA,EACjB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,IAAI,GAAG;AAAA,EACjB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,KAAK,GAAG;AAAA,EACnB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB,CAAC,IAAI,KAAK,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,IAAI,KAAK,GAAG;AAAA,EAClB,CAAC,KAAK,KAAK,IAAI,GAAG;AAAA,EAClB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",
  "names": ["Symbol", "Map", "isObject", "string", "get", "enums_exports", "MouseBindings", "KeyboardBindings", "ToolModes", "AnnotationStyleStates", "Events", "SegmentationRepresentations", "Swipe", "StrategyCallbacks", "ChangeTypes", "ChangeTypes", "toolStyle", "config", "state", "scale", "configuration", "runtimeSettings", "get", "defaultState", "state", "eventName", "eventName", "disable", "enable", "_clientToPoint", "_pageToPoint", "_pagePointsToCanvasPoints", "_subtractPoints2D", "_subtractPoints3D", "defaultState", "state", "disable", "enable", "enable", "disable", "defaultState", "state", "enable", "disable", "EPSILON", "segmentation", "state", "stackViewport", "segmentationId", "labelmapImageIds", "triangles", "wait", "debounced", "dot", "add", "toolName", "state", "preprocessingFn", "makeEventDetail", "publish", "makeEventDetail", "publish", "defaultManager", "state", "ContourWindingDirection", "vec2_exports", "state", "distanceToPoint", "distanceToPointSquared", "distanceToPointSquared", "distanceToPoint", "distanceToPointSquared", "distanceToPoint", "distanceToPoint", "distanceToPoint", "distanceToPointSquared", "distanceToPointSquared", "distanceToPointSquared", "distanceToPoint", "distanceToPointSquared", "x", "y", "orientation", "distanceToPointSquared", "closed", "EPSILON", "t", "PolylineNodeType", "IntersectionDirection", "EPSILON", "EPSILON", "closed", "closed", "PolylinePointType", "PolylinePointPosition", "PolylinePointDirection", "distanceToPointSquared", "epsilon", "distanceToPointSquared", "closed", "closed", "EPSILON", "dot", "distanceToPoint", "distanceToPoint", "vec2_exports", "EPSILON", "dot", "closed", "svgns", "svgns", "svgns", "svgns", "svgns", "svgns", "points", "svgns", "svgns", "svgns", "svgns", "Active", "Passive", "Enabled", "Active", "Passive", "Enabled", "hasTool", "EPS", "DEFAULT_CONTOUR_SEG_TOOL_NAME", "mergePolylines", "LogicalOperation", "removeAnnotations", "add", "convertContourPolylineToCanvasSpace", "DEFAULT_CONTOUR_SEG_TOOL_NAME", "createPolylineHole", "updateViewportsForAnnotations", "getContourHolesData", "createNewAnnotationFromPolyline", "convertContourPolylineToCanvasSpace", "handleContourSegmentation", "removeRepresentation", "render", "onSegmentationDataModified", "segmentationId", "segVoxelManager", "baseData", "newComp", "dims", "actor", "config", "getActiveSegmentation", "setActiveSegmentation", "getActiveSegmentation", "setActiveSegmentation", "removeRepresentation", "render", "config", "getActiveSegmentation", "outlineWidth", "renderOutline", "configuration", "state", "isEqual", "EPSILON", "dot", "state", "DefaultHistoryMemo", "PointsManager", "getStyle", "state", "scale", "region", "EPSILON", "PARALLEL_THRESHOLD", "configuration", "shouldSmooth", "isEqual", "addCanvasPointsToArray", "pointsAreWithinCloseContourProximity", "getFirstLineSegmentIntersectionIndexes", "getSubPixelSpacingAndXYDirections", "addCanvasPointsToArray", "getFirstLineSegmentIntersectionIndexes", "lastEditCanvasPoint", "getSubPixelSpacingAndXYDirections", "addCanvasPointsToArray", "getArea", "addCanvasPointsToArray", "getSubPixelSpacingAndXYDirections", "getSubPixelSpacingAndXYDirections", "pointsAreWithinCloseContourProximity", "closed", "state", "state", "DEFAULT_CONTOUR_SEG_TOOLNAME", "annotation", "PointsManager", "interval", "dot", "state", "PointsManager", "state", "PointsManager", "node", "annotation", "state", "viewport", "uuidv4", "state", "annotation", "addColorLUT", "addColorLUT", "pointCanProjectOnLine", "EPSILON", "PARALLEL_THRESHOLD", "closed", "i", "dot", "annotation", "scale", "worldPosIndex", "renderingEngine", "viewportId", "element", "enable", "disable", "enable", "disable", "enable", "disable", "Active", "Active", "action", "Active", "Passive", "Active", "Passive", "Active", "Passive", "enable", "disable", "Active", "action", "enable", "disable", "Active", "Passive", "Enabled", "enable", "disable", "Active", "Passive", "Enabled", "enable", "disable", "Active", "Active", "Passive", "getAnnotationForSelection", "toggleAnnotationSelection", "enable", "disable", "enable", "disable", "Active", "Passive", "Enabled", "enable", "disable", "svgns", "VIEWPORT_ELEMENT", "VIEWPORT_ELEMENT", "eventName", "destroy_default", "eventName", "destroy", "destroy_default", "destroy", "constants_exports", "createPresentationViewSynchronizer", "CAMERA_MODIFIED", "range", "CAMERA_MODIFIED", "CAMERA_MODIFIED", "createPresentationViewSynchronizer", "utilities_exports", "range", "dot", "intersect", "contourIndex", "config", "destroy", "state", "config", "state", "state", "destroy", "Labelmap", "isEqual", "range", "voxelManager", "transformWorldToIndex", "defaultGetTextLines", "distanceToPoint", "enabledElement", "targetId", "scale", "transformWorldToIndex", "defaultGetTextLines", "boundsIJK", "state", "labelmap", "get", "permutations", "configuration", "configuration", "isEqual", "SegmentationEnum", "configuration", "configuration", "state", "func", "transformWorldToIndex", "isEqual", "dx", "dy", "dz", "dot", "transformWorldToIndex", "VoxelManager", "RLEVoxelMap", "state", "transformWorldToIndex", "EPS", "timer", "config", "calculator", "range", "EPSILON", "dot", "transformWorldToIndex", "defaultGetTextLines", "distanceToPoint", "configuration", "state", "segment", "segmentIndex", "segmentationId", "segmentIndex", "voxelManager", "imageData", "indexIJK", "segmentIndex", "onEdge", "commandEncoder", "transformWorldToIndex", "_getSphereBoundsInfo", "POSITIVE_SEED_VALUE", "NEGATIVE_SEED_VALUE", "_setNegativeSeedValues", "_setPositiveSeedValues", "transformWorldToIndex", "config", "index", "orientation", "Events", "state", "triggerEvent", "viewport", "volumeId", "dot", "closed", "isEqual", "state", "addToolState", "getToolState", "getToolState", "getToolState", "stackPrefetch", "imageId", "enable", "addToolState", "disable", "getConfiguration", "config", "imageRetrieveMetadataProvider", "configuration", "resetPrefetchTimeout", "resetPrefetchDelay", "enable", "priority", "prefetch", "onImageUpdated", "getToolState", "stackPrefetch", "addToolState", "disable", "getConfiguration", "setConfiguration", "config", "dataInTime", "enums_exports", "enums_exports", "ColorbarRangeTextPosition", "range", "range", "i", "color", "range", "DEFAULTS", "evt", "Events", "volumeId", "element", "voiRange", "transformWorldToIndex", "epsilon", "segmentation_exports", "config_exports", "utilities_exports", "config_exports", "getSegmentationRepresentationVisibility", "setSegmentationRepresentationVisibility", "setSegmentationRepresentationVisibility", "getSegmentationRepresentationVisibility", "utilities_exports", "closed", "closed", "i", "closed", "scale", "TRANSFORM_MATRIX", "element", "viewport", "dot", "extend", "viewport", "state", "state2", "element", "dot", "orientation", "viewportsInfo", "data", "clientWidth", "clientHeight", "color", "viewportId", "distanceToPoint", "DEFAULT_MULTIPLIER", "range", "viewport", "RENDERING_DEFAULTS", "defaultReferenceLineColor", "defaultReferenceLineControllable", "OPERATION", "data", "clientWidth", "clientHeight", "viewportColor", "color", "handleRadius", "viewportId", "annotation", "distanceToPoint", "distanceToPoint2", "AdvancedMagnifyToolActions", "PARALLEL_THRESHOLD", "config", "eventName", "distanceToPoint", "EPSILON", "dot", "EPSILON", "dot", "viewport", "distanceToPoint", "midPoint", "config", "transformWorldToIndex", "defaultGetTextLines", "distanceToPoint", "scale", "transformWorldToIndex", "defaultGetTextLines", "distanceToPoint", "scale", "transformWorldToIndex", "targetId", "viewport", "value", "defaultGetTextLines", "defaultGetTextLines", "transformWorldToIndex", "defaultGetTextLines", "targetId", "scale", "transformWorldToIndex", "defaultGetTextLines", "targetId", "scale", "i", "lineUID", "start", "end", "SplineTypesEnum", "SplineToolActions", "defaultGetTextLines", "scale", "annotation", "spline", "config", "isEqual", "width", "defaultGetTextLines", "distanceToPointSquared", "scale", "worldToSlice", "config", "closed", "getTextCallback", "changeTextCallback", "distanceToPoint", "annotation", "defaultGetTextLines", "distanceToPoint", "distanceToPoint2", "i", "defaultGetTextLines", "distanceToPoint", "distanceToPoint2", "transformWorldToIndex", "defaultGetTextLines", "distanceToPoint", "configuration", "transformIndexToWorld", "defaultGetTextLines", "distanceToPoint", "getTextCallback", "changeTextCallback", "annotation", "transformWorldToIndex", "transformIndexToWorld", "config", "NEGATIVE_PIXEL_RANGE", "POSITIVE_PIXEL_RANGE", "transformWorldToIndex", "transformIndexToWorld", "config", "config_exports", "config_exports", "config_exports", "transformWorldToIndex", "defaultGetTextLines", "transformWorldToIndex", "isEqual", "index", "Corners", "onCameraModified", "DEFAULT_VALUES", "extend", "newInstance", "rotate", "DEFAULT_VALUES", "extend", "newInstance", "vtkErrorMacro", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "extend", "newInstance", "OverlayMarkerType", "element", "viewport", "actor", "orientationWidget", "getActiveSegmentation", "annotation", "getActiveSegmentation", "config_exports", "distanceToPoint", "enabledElement", "i", "viewport"]
}
